{  "type" : "TestResult","map" : { "type" : "Map","entries" : [ [ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/MC\/MISSING_TYPE_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject MISSING_TYPE_Impl {\n  def empty(): MC.MISSING_TYPE_Impl = {\n    return MC.MISSING_TYPE_Impl(Base_Types.Integer_32_empty())\n  }\n}\n\n@datatype class MISSING_TYPE_Impl(\n  MISSING : Base_Types.Integer_32) {\n}\n\nobject MISSING_TYPE_Impl_Payload {\n  def empty(): MISSING_TYPE_Impl_Payload = {\n    return MISSING_TYPE_Impl_Payload(MC.MISSING_TYPE_Impl.empty())\n  }\n}\n\n@datatype class MISSING_TYPE_Impl_Payload(value: MC.MISSING_TYPE_Impl) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/Coordinate_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Coordinate_Impl {\n  def empty(): SW.Coordinate_Impl = {\n    return SW.Coordinate_Impl(Base_Types.Integer_32_empty(), Base_Types.Integer_32_empty(), Base_Types.Integer_32_empty())\n  }\n}\n\n@datatype class Coordinate_Impl(\n  lat : Base_Types.Integer_32,\n  longitude : Base_Types.Integer_32,\n  alt : Base_Types.Integer_32) {\n}\n\nobject Coordinate_Impl_Payload {\n  def empty(): Coordinate_Impl_Payload = {\n    return Coordinate_Impl_Payload(SW.Coordinate_Impl.empty())\n  }\n}\n\n@datatype class Coordinate_Impl_Payload(value: SW.Coordinate_Impl) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/Map.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Map {\n  def empty(): SW.Map = {\n    return SW.Map(ISZ.create(4, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class Map(\n  value : ISZ[SW.Coordinate_Impl]) {\n  \/\/{  assert (value.size == 4) }\n}\n\nobject Map_Payload {\n  def empty(): Map_Payload = {\n    return Map_Payload(SW.Map.empty())\n  }\n}\n\n@datatype class Map_Payload(value: SW.Map) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/FlightPattern.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FlightPattern {\n  'ZigZag\n  'StraightLine\n  'Perimeter\n}\n\nobject FlightPattern_Payload {\n  def empty(): FlightPattern_Payload = {\n    return FlightPattern_Payload(SW.FlightPattern.byOrdinal(0).get)\n  }\n}\n\n@datatype class FlightPattern_Payload(value: SW.FlightPattern.Type) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/Command_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Command_Impl {\n  def empty(): SW.Command_Impl = {\n    return SW.Command_Impl(SW.Map.empty(), SW.FlightPattern.byOrdinal(0).get, Base_Types.Boolean_empty())\n  }\n}\n\n@datatype class Command_Impl(\n  Map : SW.Map,\n  Pattern : SW.FlightPattern.Type,\n  HMAC : Base_Types.Boolean) {\n}\n\nobject Command_Impl_Payload {\n  def empty(): Command_Impl_Payload = {\n    return Command_Impl_Payload(SW.Command_Impl.empty())\n  }\n}\n\n@datatype class Command_Impl_Payload(value: SW.Command_Impl) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/Mission.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Mission {\n  def empty(): SW.Mission = {\n    return SW.Mission(ISZ.create(10, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class Mission(\n  value : ISZ[SW.Coordinate_Impl]) {\n  \/\/{  assert (value.size == 10) }\n}\n\nobject Mission_Payload {\n  def empty(): Mission_Payload = {\n    return Mission_Payload(SW.Mission.empty())\n  }\n}\n\n@datatype class Mission_Payload(value: SW.Mission) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/SW\/MissionWindow.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject MissionWindow {\n  def empty(): SW.MissionWindow = {\n    return SW.MissionWindow(ISZ.create(4, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class MissionWindow(\n  value : ISZ[SW.Coordinate_Impl]) {\n  \/\/{  assert (value.size == 4) }\n}\n\nobject MissionWindow_Payload {\n  def empty(): MissionWindow_Payload = {\n    return MissionWindow_Payload(SW.MissionWindow.empty())\n  }\n}\n\n@datatype class MissionWindow_Payload(value: SW.MissionWindow) extends art.DataContent\n"}],[ "uav_alt--JVM\/src\/main\/data\/uav_alt__JVM\/Base_Types.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = org.sireum.B\n\n  type Integer = org.sireum.Z\n\n  type Integer_8 = org.sireum.S8\n  type Integer_16 = org.sireum.S16\n  type Integer_32 = org.sireum.S32\n  type Integer_64 = org.sireum.S64\n\n  type Unsigned_8 = org.sireum.U8\n  type Unsigned_16 = org.sireum.U16\n  type Unsigned_32 = org.sireum.U32\n  type Unsigned_64 = org.sireum.U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = org.sireum.R\n  type Float_32 = org.sireum.F32\n  type Float_64 = org.sireum.F64\n\n  type Character = org.sireum.C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[org.sireum.B]\n\n  @datatype class Boolean_Payload(value: Boolean) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Integer) extends art.DataContent\n  @datatype class Integer_8_Payload(value: Integer_8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: Integer_16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: Integer_32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: Integer_64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: Unsigned_8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: Unsigned_16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: Unsigned_32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: Unsigned_64) extends art.DataContent\n\n  @datatype class Float_Payload(value: Float) extends art.DataContent\n  @datatype class Float_32_Payload(value: Float_32) extends art.DataContent\n  @datatype class Float_64_Payload(value: Float_64) extends art.DataContent\n\n  @datatype class Character_Payload(value: Character) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: Bits) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}"}],[ "uav_alt--JVM\/src\/main\/architecture\/uav_alt__JVM\/Arch.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val UAV_Impl_Instance_MCMP_RADIO_HW : uav_alt__JVM.MC.Radio_Impl_Bridge = {\n    val recv_map_inn = Port[MC.MISSING_TYPE_Impl] (id = 0, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_recv_map_inn\", mode = EventIn)\n    val recv_map_out = Port[SW.Command_Impl] (id = 1, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_recv_map_out\", mode = EventOut)\n    val send_status_inn = Port[SW.Coordinate_Impl] (id = 2, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_send_status_inn\", mode = EventIn)\n    val send_status_out = Port[MC.MISSING_TYPE_Impl] (id = 3, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_send_status_out\", mode = EventOut)\n\n    uav_alt__JVM.MC.Radio_Impl_Bridge(\n      id = 0,\n      name = \"UAV_Impl_Instance_MCMP_RADIO_HW\",\n      dispatchProtocol = Periodic(period = 1),\n      dispatchTriggers = None(),\n\n      recv_map_inn = recv_map_inn,\n      recv_map_out = recv_map_out,\n      send_status_inn = send_status_inn,\n      send_status_out = send_status_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_UART_HW : uav_alt__JVM.MC.UART_Impl_Bridge = {\n    val waypoint_out = Port[MC.MISSING_TYPE_Impl] (id = 4, name = \"UAV_Impl_Instance_MCMP_UART_HW_waypoint_out\", mode = EventOut)\n    val position_status_inn = Port[MC.MISSING_TYPE_Impl] (id = 5, name = \"UAV_Impl_Instance_MCMP_UART_HW_position_status_inn\", mode = EventIn)\n    val position_status_out = Port[SW.Coordinate_Impl] (id = 6, name = \"UAV_Impl_Instance_MCMP_UART_HW_position_status_out\", mode = EventOut)\n\n    uav_alt__JVM.MC.UART_Impl_Bridge(\n      id = 1,\n      name = \"UAV_Impl_Instance_MCMP_UART_HW\",\n      dispatchProtocol = Periodic(period = 1),\n      dispatchTriggers = None(),\n\n      waypoint_out = waypoint_out,\n      position_status_inn = position_status_inn,\n      position_status_out = position_status_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_RADIO : uav_alt__JVM.SW.RadioDriver_Impl_Bridge = {\n    val recv_map_out = Port[SW.Command_Impl] (id = 7, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out\", mode = EventOut)\n\n    uav_alt__JVM.SW.RadioDriver_Impl_Bridge(\n      id = 2,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO\",\n      dispatchProtocol = Sporadic(min = 1),\n      dispatchTriggers = None(),\n\n      recv_map_out = recv_map_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_FPLN : uav_alt__JVM.SW.FlightPlanner_Impl_Bridge = {\n    val flight_plan = Port[SW.Mission] (id = 8, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan\", mode = EventOut)\n    val mission_rcv = Port[Base_Types.Boolean] (id = 9, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv\", mode = EventIn)\n    val recv_map = Port[SW.Command_Impl] (id = 10, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map\", mode = EventIn)\n\n    uav_alt__JVM.SW.FlightPlanner_Impl_Bridge(\n      id = 3,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN\",\n      dispatchProtocol = Sporadic(min = 1),\n      dispatchTriggers = None(),\n\n      flight_plan = flight_plan,\n      mission_rcv = mission_rcv,\n      recv_map = recv_map\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_WPM : uav_alt__JVM.SW.WaypointManager_Impl_Bridge = {\n    val flight_plan = Port[SW.Mission] (id = 11, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan\", mode = EventIn)\n    val mission_rcv = Port[Base_Types.Boolean] (id = 12, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv\", mode = EventOut)\n    val mission_window = Port[SW.MissionWindow] (id = 13, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window\", mode = EventOut)\n    val tracking_id = Port[Base_Types.Integer_64] (id = 14, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id\", mode = EventIn)\n\n    uav_alt__JVM.SW.WaypointManager_Impl_Bridge(\n      id = 4,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM\",\n      dispatchProtocol = Sporadic(min = 1),\n      dispatchTriggers = None(),\n\n      flight_plan = flight_plan,\n      mission_rcv = mission_rcv,\n      mission_window = mission_window,\n      tracking_id = tracking_id\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_UART : uav_alt__JVM.SW.UARTDriver_Impl_Bridge = {\n    val mission_window = Port[SW.MissionWindow] (id = 15, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window\", mode = EventIn)\n    val tracking_id = Port[Base_Types.Integer_64] (id = 16, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id\", mode = EventOut)\n\n    uav_alt__JVM.SW.UARTDriver_Impl_Bridge(\n      id = 5,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART\",\n      dispatchProtocol = Sporadic(min = 1),\n      dispatchTriggers = None(),\n\n      mission_window = mission_window,\n      tracking_id = tracking_id\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (UAV_Impl_Instance_MCMP_RADIO_HW, UAV_Impl_Instance_MCMP_UART_HW, UAV_Impl_Instance_MCMP_PROC_SW_RADIO, UAV_Impl_Instance_MCMP_PROC_SW_FPLN, UAV_Impl_Instance_MCMP_PROC_SW_WPM, UAV_Impl_Instance_MCMP_PROC_SW_UART),\n\n      connections = ISZ (Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO.recv_map_out, to = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.recv_map),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.flight_plan, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM.flight_plan),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_rcv, to = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.mission_rcv),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_window, to = UAV_Impl_Instance_MCMP_PROC_SW_UART.mission_window),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UART.tracking_id, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM.tracking_id))\n    )\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/architecture\/uav_alt__JVM\/Demo.scala", { "type" : "Resource","content" : "\/\/ This file was auto-generated.  Do not edit\npackage uav_alt__JVM\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/MC\/UAV_Impl_Instance_MCMP_RADIO_HW_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.MC\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_RADIO_HW_Test extends BridgeTestSuite[Radio_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_RADIO_HW) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_recv_map_inn(value : MC.MISSING_TYPE_Impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.recv_map_inn_Id, MC.MISSING_TYPE_Impl_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_send_status_inn(value : SW.Coordinate_Impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.send_status_inn_Id, SW.Coordinate_Impl_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_recv_map_out(): Option[SW.Command_Impl] = {\n    val value: Option[SW.Command_Impl] = get_recv_map_out_payload() match {\n      case Some(SW.Command_Impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port recv_map_out.  Expecting 'SW.Command_Impl_Payload' but received ${v}\") \n      case _ => None[SW.Command_Impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_recv_map_out_payload(): Option[SW.Command_Impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.recv_map_out_Id).asInstanceOf[Option[SW.Command_Impl_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_send_status_out(): Option[MC.MISSING_TYPE_Impl] = {\n    val value: Option[MC.MISSING_TYPE_Impl] = get_send_status_out_payload() match {\n      case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port send_status_out.  Expecting 'MC.MISSING_TYPE_Impl_Payload' but received ${v}\") \n      case _ => None[MC.MISSING_TYPE_Impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_send_status_out_payload(): Option[MC.MISSING_TYPE_Impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.send_status_out_Id).asInstanceOf[Option[MC.MISSING_TYPE_Impl_Payload]]\n  }\n\n  def getComponent(): Radio_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[Radio_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/MC\/Radio_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Radio_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_map_inn: Port[MC.MISSING_TYPE_Impl],\n  recv_map_out: Port[SW.Command_Impl],\n  send_status_inn: Port[SW.Coordinate_Impl],\n  send_status_out: Port[MC.MISSING_TYPE_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_map_inn,\n              recv_map_out,\n              send_status_inn,\n              send_status_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(recv_map_inn,\n                   send_status_inn),\n\n    eventOuts = ISZ(recv_map_out,\n                    send_status_out)\n  )\n\n  val api : Radio_Impl_Bridge.Api =\n    Radio_Impl_Bridge.Api(\n      id,\n      recv_map_inn.id,\n      recv_map_out.id,\n      send_status_inn.id,\n      send_status_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    Radio_Impl_Bridge.EntryPoints(\n      id,\n\n      recv_map_inn.id,\n      recv_map_out.id,\n      send_status_inn.id,\n      send_status_out.id,\n\n      dispatchTriggers,\n\n      Radio_Impl_Impl(api)\n    )\n}\n\nobject Radio_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    recv_map_inn_Id : Art.PortId,\n    recv_map_out_Id : Art.PortId,\n    send_status_inn_Id : Art.PortId,\n    send_status_out_Id : Art.PortId) {\n\n    def getrecv_map_inn() : Option[MC.MISSING_TYPE_Impl] = {\n      val value : Option[MC.MISSING_TYPE_Impl] = Art.getValue(recv_map_inn_Id) match {\n        case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port recv_map_inn.  Expecting 'MC.MISSING_TYPE_Impl_Payload' but received ${v}\")\n          None[MC.MISSING_TYPE_Impl]() \n        case _ => None[MC.MISSING_TYPE_Impl]()\n      }\n      return value\n    }\n\n    def sendrecv_map_out(value : SW.Command_Impl) : Unit = {\n      Art.putValue(recv_map_out_Id, SW.Command_Impl_Payload(value))\n    }\n\n    def getsend_status_inn() : Option[SW.Coordinate_Impl] = {\n      val value : Option[SW.Coordinate_Impl] = Art.getValue(send_status_inn_Id) match {\n        case Some(SW.Coordinate_Impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port send_status_inn.  Expecting 'SW.Coordinate_Impl_Payload' but received ${v}\")\n          None[SW.Coordinate_Impl]() \n        case _ => None[SW.Coordinate_Impl]()\n      }\n      return value\n    }\n\n    def sendsend_status_out(value : MC.MISSING_TYPE_Impl) : Unit = {\n      Art.putValue(send_status_out_Id, MC.MISSING_TYPE_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    Radio_Impl_BridgeId : Art.BridgeId,\n\n    recv_map_inn_Id : Art.PortId,\n    recv_map_out_Id : Art.PortId,\n    send_status_inn_Id : Art.PortId,\n    send_status_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : Radio_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(recv_map_inn_Id,\n                                              send_status_inn_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(recv_map_out_Id,\n                                               send_status_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/MC\/Radio_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait Radio_Impl {\n\n  def api : Radio_Impl_Bridge.Api\n\n  def timeTriggered() : Unit = {}\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/MC\/Radio_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class Radio_Impl_Impl (val api : Radio_Impl_Bridge.Api) extends Radio_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_recv_map_inn: Option[MC.MISSING_TYPE_Impl] = api.getrecv_map_inn()\n    api.sendrecv_map_out(SW.Command_Impl.empty())\n    val apiUsage_send_status_inn: Option[SW.Coordinate_Impl] = api.getsend_status_inn()\n    api.sendsend_status_out(MC.MISSING_TYPE_Impl.empty())\n  }\n\n  override def timeTriggered(): Unit = {\n    \/\/ example override of timeTriggered\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/MC\/BridgeTestSuite.scala", { "type" : "Resource","content" : "package uav_alt__JVM.MC\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[uav_alt__JVM.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/MC\/UAV_Impl_Instance_MCMP_UART_HW_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.MC\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_UART_HW_Test extends BridgeTestSuite[UART_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_UART_HW) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_position_status_inn(value : MC.MISSING_TYPE_Impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.position_status_inn_Id, MC.MISSING_TYPE_Impl_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_waypoint_out(): Option[MC.MISSING_TYPE_Impl] = {\n    val value: Option[MC.MISSING_TYPE_Impl] = get_waypoint_out_payload() match {\n      case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port waypoint_out.  Expecting 'MC.MISSING_TYPE_Impl_Payload' but received ${v}\") \n      case _ => None[MC.MISSING_TYPE_Impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_waypoint_out_payload(): Option[MC.MISSING_TYPE_Impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.waypoint_out_Id).asInstanceOf[Option[MC.MISSING_TYPE_Impl_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_position_status_out(): Option[SW.Coordinate_Impl] = {\n    val value: Option[SW.Coordinate_Impl] = get_position_status_out_payload() match {\n      case Some(SW.Coordinate_Impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port position_status_out.  Expecting 'SW.Coordinate_Impl_Payload' but received ${v}\") \n      case _ => None[SW.Coordinate_Impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_position_status_out_payload(): Option[SW.Coordinate_Impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.position_status_out_Id).asInstanceOf[Option[SW.Coordinate_Impl_Payload]]\n  }\n\n  def getComponent(): UART_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[UART_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/MC\/UART_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class UART_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  waypoint_out: Port[MC.MISSING_TYPE_Impl],\n  position_status_inn: Port[MC.MISSING_TYPE_Impl],\n  position_status_out: Port[SW.Coordinate_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(waypoint_out,\n              position_status_inn,\n              position_status_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(position_status_inn),\n\n    eventOuts = ISZ(waypoint_out,\n                    position_status_out)\n  )\n\n  val api : UART_Impl_Bridge.Api =\n    UART_Impl_Bridge.Api(\n      id,\n      waypoint_out.id,\n      position_status_inn.id,\n      position_status_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    UART_Impl_Bridge.EntryPoints(\n      id,\n\n      waypoint_out.id,\n      position_status_inn.id,\n      position_status_out.id,\n\n      dispatchTriggers,\n\n      UART_Impl_Impl(api)\n    )\n}\n\nobject UART_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    waypoint_out_Id : Art.PortId,\n    position_status_inn_Id : Art.PortId,\n    position_status_out_Id : Art.PortId) {\n\n    def sendwaypoint_out(value : MC.MISSING_TYPE_Impl) : Unit = {\n      Art.putValue(waypoint_out_Id, MC.MISSING_TYPE_Impl_Payload(value))\n    }\n\n    def getposition_status_inn() : Option[MC.MISSING_TYPE_Impl] = {\n      val value : Option[MC.MISSING_TYPE_Impl] = Art.getValue(position_status_inn_Id) match {\n        case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port position_status_inn.  Expecting 'MC.MISSING_TYPE_Impl_Payload' but received ${v}\")\n          None[MC.MISSING_TYPE_Impl]() \n        case _ => None[MC.MISSING_TYPE_Impl]()\n      }\n      return value\n    }\n\n    def sendposition_status_out(value : SW.Coordinate_Impl) : Unit = {\n      Art.putValue(position_status_out_Id, SW.Coordinate_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    UART_Impl_BridgeId : Art.BridgeId,\n\n    waypoint_out_Id : Art.PortId,\n    position_status_inn_Id : Art.PortId,\n    position_status_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : UART_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(position_status_inn_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(waypoint_out_Id,\n                                               position_status_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/MC\/UART_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait UART_Impl {\n\n  def api : UART_Impl_Bridge.Api\n\n  def timeTriggered() : Unit = {}\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/MC\/UART_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.MC\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class UART_Impl_Impl (val api : UART_Impl_Bridge.Api) extends UART_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendwaypoint_out(MC.MISSING_TYPE_Impl.empty())\n    val apiUsage_position_status_inn: Option[MC.MISSING_TYPE_Impl] = api.getposition_status_inn()\n    api.sendposition_status_out(SW.Coordinate_Impl.empty())\n  }\n\n  override def timeTriggered(): Unit = {\n    \/\/ example override of timeTriggered\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/SW\/UAV_Impl_Instance_MCMP_PROC_SW_RADIO_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.SW\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_PROC_SW_RADIO_Test extends BridgeTestSuite[RadioDriver_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ getter for out EventDataPort\n  def get_recv_map_out(): Option[SW.Command_Impl] = {\n    val value: Option[SW.Command_Impl] = get_recv_map_out_payload() match {\n      case Some(SW.Command_Impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port recv_map_out.  Expecting 'SW.Command_Impl_Payload' but received ${v}\") \n      case _ => None[SW.Command_Impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_recv_map_out_payload(): Option[SW.Command_Impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.recv_map_out_Id).asInstanceOf[Option[SW.Command_Impl_Payload]]\n  }\n\n  def getComponent(): RadioDriver_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[RadioDriver_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/SW\/RadioDriver_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class RadioDriver_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_map_out: Port[SW.Command_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_map_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(recv_map_out)\n  )\n\n  val api : RadioDriver_Impl_Bridge.Api =\n    RadioDriver_Impl_Bridge.Api(\n      id,\n      recv_map_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    RadioDriver_Impl_Bridge.EntryPoints(\n      id,\n\n      recv_map_out.id,\n\n      dispatchTriggers,\n\n      RadioDriver_Impl_Impl(api)\n    )\n}\n\nobject RadioDriver_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    recv_map_out_Id : Art.PortId) {\n\n    def sendrecv_map_out(value : SW.Command_Impl) : Unit = {\n      Art.putValue(recv_map_out_Id, SW.Command_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    RadioDriver_Impl_BridgeId : Art.BridgeId,\n\n    recv_map_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : RadioDriver_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(recv_map_out_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(RadioDriver_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(RadioDriver_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/RadioDriver_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait RadioDriver_Impl {\n\n  def api : RadioDriver_Impl_Bridge.Api\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/RadioDriver_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class RadioDriver_Impl_Impl (val api : RadioDriver_Impl_Bridge.Api) extends RadioDriver_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendrecv_map_out(SW.Command_Impl.empty())\n  }\n\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/SW\/BridgeTestSuite.scala", { "type" : "Resource","content" : "package uav_alt__JVM.SW\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[uav_alt__JVM.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/SW\/UAV_Impl_Instance_MCMP_PROC_SW_FPLN_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.SW\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_PROC_SW_FPLN_Test extends BridgeTestSuite[FlightPlanner_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_mission_rcv(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.mission_rcv_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_recv_map(value : SW.Command_Impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.recv_map_Id, SW.Command_Impl_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_flight_plan(): Option[SW.Mission] = {\n    val value: Option[SW.Mission] = get_flight_plan_payload() match {\n      case Some(SW.Mission_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port flight_plan.  Expecting 'SW.Mission_Payload' but received ${v}\") \n      case _ => None[SW.Mission]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_flight_plan_payload(): Option[SW.Mission_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.flight_plan_Id).asInstanceOf[Option[SW.Mission_Payload]]\n  }\n\n  def getComponent(): FlightPlanner_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[FlightPlanner_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/SW\/FlightPlanner_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class FlightPlanner_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  flight_plan: Port[SW.Mission],\n  mission_rcv: Port[Base_Types.Boolean],\n  recv_map: Port[SW.Command_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(flight_plan,\n              mission_rcv,\n              recv_map),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(mission_rcv,\n                   recv_map),\n\n    eventOuts = ISZ(flight_plan)\n  )\n\n  val api : FlightPlanner_Impl_Bridge.Api =\n    FlightPlanner_Impl_Bridge.Api(\n      id,\n      flight_plan.id,\n      mission_rcv.id,\n      recv_map.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    FlightPlanner_Impl_Bridge.EntryPoints(\n      id,\n\n      flight_plan.id,\n      mission_rcv.id,\n      recv_map.id,\n\n      dispatchTriggers,\n\n      FlightPlanner_Impl_Impl(api)\n    )\n}\n\nobject FlightPlanner_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    flight_plan_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    recv_map_Id : Art.PortId) {\n\n    def sendflight_plan(value : SW.Mission) : Unit = {\n      Art.putValue(flight_plan_Id, SW.Mission_Payload(value))\n    }\n\n    def getmission_rcv() : Option[Base_Types.Boolean] = {\n      val value : Option[Base_Types.Boolean] = Art.getValue(mission_rcv_Id) match {\n        case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port mission_rcv.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n          None[Base_Types.Boolean]() \n        case _ => None[Base_Types.Boolean]()\n      }\n      return value\n    }\n\n    def getrecv_map() : Option[SW.Command_Impl] = {\n      val value : Option[SW.Command_Impl] = Art.getValue(recv_map_Id) match {\n        case Some(SW.Command_Impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port recv_map.  Expecting 'SW.Command_Impl_Payload' but received ${v}\")\n          None[SW.Command_Impl]() \n        case _ => None[SW.Command_Impl]()\n      }\n      return value\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    FlightPlanner_Impl_BridgeId : Art.BridgeId,\n\n    flight_plan_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    recv_map_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : FlightPlanner_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(mission_rcv_Id,\n                                              recv_map_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(flight_plan_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(FlightPlanner_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == mission_rcv_Id){\n          val Some(Base_Types.Boolean_Payload(value)) = Art.getValue(mission_rcv_Id)\n          component.handlemission_rcv(value)\n        }\n        else if(portId == recv_map_Id){\n          val Some(SW.Command_Impl_Payload(value)) = Art.getValue(recv_map_Id)\n          component.handlerecv_map(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(FlightPlanner_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == mission_rcv_Id){\n          val Some(Base_Types.Boolean_Payload(value)) = Art.getValue(mission_rcv_Id)\n          component.handlemission_rcv(value)\n        }\n        else if(portId == recv_map_Id){\n          val Some(SW.Command_Impl_Payload(value)) = Art.getValue(recv_map_Id)\n          component.handlerecv_map(value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/FlightPlanner_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait FlightPlanner_Impl {\n\n  def api : FlightPlanner_Impl_Bridge.Api\n\n  def handlemission_rcv(value : Base_Types.Boolean): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlemission_rcv implementation\")\n  }\n\n  def handlerecv_map(value : SW.Command_Impl): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlerecv_map implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/FlightPlanner_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class FlightPlanner_Impl_Impl (val api : FlightPlanner_Impl_Bridge.Api) extends FlightPlanner_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendflight_plan(SW.Mission.empty())\n    val apiUsage_mission_rcv: Option[Base_Types.Boolean] = api.getmission_rcv()\n    val apiUsage_recv_map: Option[SW.Command_Impl] = api.getrecv_map()\n  }\n\n  override def handlemission_rcv(value : Base_Types.Boolean): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlemission_rcv implementation\")\n  }\n\n  override def handlerecv_map(value : SW.Command_Impl): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlerecv_map implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/SW\/UAV_Impl_Instance_MCMP_PROC_SW_WPM_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.SW\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_PROC_SW_WPM_Test extends BridgeTestSuite[WaypointManager_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_flight_plan(value : SW.Mission): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.flight_plan_Id, SW.Mission_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_tracking_id(value : Base_Types.Integer_64): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.tracking_id_Id, Base_Types.Integer_64_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_mission_rcv(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_mission_rcv_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port mission_rcv.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\") \n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_mission_rcv_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.mission_rcv_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_mission_window(): Option[SW.MissionWindow] = {\n    val value: Option[SW.MissionWindow] = get_mission_window_payload() match {\n      case Some(SW.MissionWindow_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port mission_window.  Expecting 'SW.MissionWindow_Payload' but received ${v}\") \n      case _ => None[SW.MissionWindow]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_mission_window_payload(): Option[SW.MissionWindow_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.mission_window_Id).asInstanceOf[Option[SW.MissionWindow_Payload]]\n  }\n\n  def getComponent(): WaypointManager_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[WaypointManager_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/SW\/WaypointManager_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class WaypointManager_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  flight_plan: Port[SW.Mission],\n  mission_rcv: Port[Base_Types.Boolean],\n  mission_window: Port[SW.MissionWindow],\n  tracking_id: Port[Base_Types.Integer_64]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(flight_plan,\n              mission_rcv,\n              mission_window,\n              tracking_id),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(flight_plan,\n                   tracking_id),\n\n    eventOuts = ISZ(mission_rcv,\n                    mission_window)\n  )\n\n  val api : WaypointManager_Impl_Bridge.Api =\n    WaypointManager_Impl_Bridge.Api(\n      id,\n      flight_plan.id,\n      mission_rcv.id,\n      mission_window.id,\n      tracking_id.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    WaypointManager_Impl_Bridge.EntryPoints(\n      id,\n\n      flight_plan.id,\n      mission_rcv.id,\n      mission_window.id,\n      tracking_id.id,\n\n      dispatchTriggers,\n\n      WaypointManager_Impl_Impl(api)\n    )\n}\n\nobject WaypointManager_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    flight_plan_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId) {\n\n    def getflight_plan() : Option[SW.Mission] = {\n      val value : Option[SW.Mission] = Art.getValue(flight_plan_Id) match {\n        case Some(SW.Mission_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port flight_plan.  Expecting 'SW.Mission_Payload' but received ${v}\")\n          None[SW.Mission]() \n        case _ => None[SW.Mission]()\n      }\n      return value\n    }\n\n    def sendmission_rcv(value : Base_Types.Boolean) : Unit = {\n      Art.putValue(mission_rcv_Id, Base_Types.Boolean_Payload(value))\n    }\n\n    def sendmission_window(value : SW.MissionWindow) : Unit = {\n      Art.putValue(mission_window_Id, SW.MissionWindow_Payload(value))\n    }\n\n    def gettracking_id() : Option[Base_Types.Integer_64] = {\n      val value : Option[Base_Types.Integer_64] = Art.getValue(tracking_id_Id) match {\n        case Some(Base_Types.Integer_64_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port tracking_id.  Expecting 'Base_Types.Integer_64_Payload' but received ${v}\")\n          None[Base_Types.Integer_64]() \n        case _ => None[Base_Types.Integer_64]()\n      }\n      return value\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    WaypointManager_Impl_BridgeId : Art.BridgeId,\n\n    flight_plan_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : WaypointManager_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(flight_plan_Id,\n                                              tracking_id_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(mission_rcv_Id,\n                                               mission_window_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(WaypointManager_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == flight_plan_Id){\n          val Some(SW.Mission_Payload(value)) = Art.getValue(flight_plan_Id)\n          component.handleflight_plan(value)\n        }\n        else if(portId == tracking_id_Id){\n          val Some(Base_Types.Integer_64_Payload(value)) = Art.getValue(tracking_id_Id)\n          component.handletracking_id(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(WaypointManager_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == flight_plan_Id){\n          val Some(SW.Mission_Payload(value)) = Art.getValue(flight_plan_Id)\n          component.handleflight_plan(value)\n        }\n        else if(portId == tracking_id_Id){\n          val Some(Base_Types.Integer_64_Payload(value)) = Art.getValue(tracking_id_Id)\n          component.handletracking_id(value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/WaypointManager_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait WaypointManager_Impl {\n\n  def api : WaypointManager_Impl_Bridge.Api\n\n  def handleflight_plan(value : SW.Mission): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handleflight_plan implementation\")\n  }\n\n  def handletracking_id(value : Base_Types.Integer_64): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handletracking_id implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/WaypointManager_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class WaypointManager_Impl_Impl (val api : WaypointManager_Impl_Bridge.Api) extends WaypointManager_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_flight_plan: Option[SW.Mission] = api.getflight_plan()\n    api.sendmission_rcv(Base_Types.Boolean_empty())\n    api.sendmission_window(SW.MissionWindow.empty())\n    val apiUsage_tracking_id: Option[Base_Types.Integer_64] = api.gettracking_id()\n  }\n\n  override def handleflight_plan(value : SW.Mission): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handleflight_plan implementation\")\n  }\n\n  override def handletracking_id(value : Base_Types.Integer_64): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handletracking_id implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/test\/bridge\/uav_alt__JVM\/SW\/UAV_Impl_Instance_MCMP_PROC_SW_UART_Test.scala", { "type" : "Resource","content" : "package uav_alt__JVM.SW\n\nimport art.{ArtNative_Ext, Empty}\nimport uav_alt__JVM._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass UAV_Impl_Instance_MCMP_PROC_SW_UART_Test extends BridgeTestSuite[UARTDriver_Impl_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_mission_window(value : SW.MissionWindow): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.mission_window_Id, SW.MissionWindow_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_tracking_id(): Option[Base_Types.Integer_64] = {\n    val value: Option[Base_Types.Integer_64] = get_tracking_id_payload() match {\n      case Some(Base_Types.Integer_64_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port tracking_id.  Expecting 'Base_Types.Integer_64_Payload' but received ${v}\") \n      case _ => None[Base_Types.Integer_64]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_tracking_id_payload(): Option[Base_Types.Integer_64_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.tracking_id_Id).asInstanceOf[Option[Base_Types.Integer_64_Payload]]\n  }\n\n  def getComponent(): UARTDriver_Impl_Impl = {\n    return bridge.entryPoints.asInstanceOf[UARTDriver_Impl_Bridge.EntryPoints].component\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/bridge\/uav_alt__JVM\/SW\/UARTDriver_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport art._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class UARTDriver_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  mission_window: Port[SW.MissionWindow],\n  tracking_id: Port[Base_Types.Integer_64]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(mission_window,\n              tracking_id),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(mission_window),\n\n    eventOuts = ISZ(tracking_id)\n  )\n\n  val api : UARTDriver_Impl_Bridge.Api =\n    UARTDriver_Impl_Bridge.Api(\n      id,\n      mission_window.id,\n      tracking_id.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    UARTDriver_Impl_Bridge.EntryPoints(\n      id,\n\n      mission_window.id,\n      tracking_id.id,\n\n      dispatchTriggers,\n\n      UARTDriver_Impl_Impl(api)\n    )\n}\n\nobject UARTDriver_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId) {\n\n    def getmission_window() : Option[SW.MissionWindow] = {\n      val value : Option[SW.MissionWindow] = Art.getValue(mission_window_Id) match {\n        case Some(SW.MissionWindow_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port mission_window.  Expecting 'SW.MissionWindow_Payload' but received ${v}\")\n          None[SW.MissionWindow]() \n        case _ => None[SW.MissionWindow]()\n      }\n      return value\n    }\n\n    def sendtracking_id(value : Base_Types.Integer_64) : Unit = {\n      Art.putValue(tracking_id_Id, Base_Types.Integer_64_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    UARTDriver_Impl_BridgeId : Art.BridgeId,\n\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : UARTDriver_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(mission_window_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(tracking_id_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(UARTDriver_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == mission_window_Id){\n          val Some(SW.MissionWindow_Payload(value)) = Art.getValue(mission_window_Id)\n          component.handlemission_window(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(UARTDriver_Impl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == mission_window_Id){\n          val Some(SW.MissionWindow_Payload(value)) = Art.getValue(mission_window_Id)\n          component.handlemission_window(value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/UARTDriver_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait UARTDriver_Impl {\n\n  def api : UARTDriver_Impl_Bridge.Api\n\n  def handlemission_window(value : SW.MissionWindow): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlemission_window implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt--JVM\/src\/main\/component\/uav_alt__JVM\/SW\/UARTDriver_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage uav_alt__JVM.SW\n\nimport org.sireum._\nimport uav_alt__JVM._\n\n\/\/ the contents of this file will not be overwritten\n@record class UARTDriver_Impl_Impl (val api : UARTDriver_Impl_Bridge.Api) extends UARTDriver_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_mission_window: Option[SW.MissionWindow] = api.getmission_window()\n    api.sendtracking_id(Base_Types.Integer_64_empty())\n  }\n\n  override def handlemission_window(value : SW.MissionWindow): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlemission_window implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/art\/ArchitectureDescription.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus"}],[ "uav_alt--JVM\/src\/main\/art\/Art.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 6\n  val maxPorts: PortId = 17\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/art\/ArtDebug_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import scala.collection.JavaConverters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/art\/ArtTimer.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n"}],[ "uav_alt--JVM\/src\/main\/art\/ArtTimer_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}"}],[ "uav_alt--JVM\/src\/main\/art\/DataContent.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent"}],[ "uav_alt--JVM\/src\/main\/art\/ArtNative_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtDebug_Ext.start()\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import scala.collection.JavaConverters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]\n    }\n  }\n}\n"}],[ "uav_alt--JVM\/src\/main\/art\/ArtDebug.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}"}],[ "uav_alt--JVM\/src\/main\/art\/ArtNative.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n"}],[ "uav_alt--JVM\/build.sbt", { "type" : "Resource","content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ To open the following project in Sireum IVE select 'File > Open ...' and then\n\/\/ navigate to the directory containing this file then click 'OK'.  To install\n\/\/ Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\nlazy val UAV_Impl_Instance = slangEmbeddedTestProject(\"UAV_Impl_Instance\", \".\")\n\n\nval scalaVer = \"2.12.10\"\n\nval sireumScalacVersion = \"4.20200212.6edf3e0\" \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20200212.6edf3e0\n\nval runtimeVersion = \"716ec0e\" \/\/ https:\/\/github.com\/sireum\/runtime\/tree\/716ec0e\n\nval scalaTestVersion = \"3.1.0\"\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.runtime\" %% \"library\" % runtimeVersion withSources() withJavadoc()\n  )\n)\n\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\"\n)\n\ndef standardProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).settings(commonSettings)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedTestProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++\n      Seq(\n        Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n        libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\")\n    )        \n"}]]}}