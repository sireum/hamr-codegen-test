{  "type" : "TestResult","map" : { "type" : "Map","entries" : [ [ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/MC\/MISSING_TYPE_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject MISSING_TYPE_Impl {\n  def empty(): MC.MISSING_TYPE_Impl = {\n    return MC.MISSING_TYPE_Impl(Base_Types.Integer_32_empty())\n  }\n}\n\n@datatype class MISSING_TYPE_Impl(\n  MISSING : Base_Types.Integer_32) {\n}\n\nobject MISSING_TYPE_Impl_Payload {\n  def empty(): MISSING_TYPE_Impl_Payload = {\n    return MISSING_TYPE_Impl_Payload(MC.MISSING_TYPE_Impl.empty())\n  }\n}\n\n@datatype class MISSING_TYPE_Impl_Payload(value: MC.MISSING_TYPE_Impl) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/Coordinate_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Coordinate_Impl {\n  def empty(): SW.Coordinate_Impl = {\n    return SW.Coordinate_Impl(Base_Types.Integer_32_empty(), Base_Types.Integer_32_empty(), Base_Types.Integer_32_empty())\n  }\n}\n\n@datatype class Coordinate_Impl(\n  lat : Base_Types.Integer_32,\n  longitude : Base_Types.Integer_32,\n  alt : Base_Types.Integer_32) {\n}\n\nobject Coordinate_Impl_Payload {\n  def empty(): Coordinate_Impl_Payload = {\n    return Coordinate_Impl_Payload(SW.Coordinate_Impl.empty())\n  }\n}\n\n@datatype class Coordinate_Impl_Payload(value: SW.Coordinate_Impl) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/Map.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Map {\n  def empty(): SW.Map = {\n    return SW.Map(ISZ.create(4, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class Map(\n  value : ISZ[SW.Coordinate_Impl]) {\n  { assert (value.size == 4) }\n}\n\nobject Map_Payload {\n  def empty(): Map_Payload = {\n    return Map_Payload(SW.Map.empty())\n  }\n}\n\n@datatype class Map_Payload(value: SW.Map) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/FlightPattern.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FlightPattern {\n  'ZigZag\n  'StraightLine\n  'Perimeter\n}\n\nobject FlightPattern_Payload {\n  def empty(): FlightPattern_Payload = {\n    return FlightPattern_Payload(SW.FlightPattern.byOrdinal(0).get)\n  }\n}\n\n@datatype class FlightPattern_Payload(value: SW.FlightPattern.Type) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/Command_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Command_Impl {\n  def empty(): SW.Command_Impl = {\n    return SW.Command_Impl(SW.Map.empty(), SW.FlightPattern.byOrdinal(0).get, Base_Types.Boolean_empty())\n  }\n}\n\n@datatype class Command_Impl(\n  Map : SW.Map,\n  Pattern : SW.FlightPattern.Type,\n  HMAC : Base_Types.Boolean) {\n}\n\nobject Command_Impl_Payload {\n  def empty(): Command_Impl_Payload = {\n    return Command_Impl_Payload(SW.Command_Impl.empty())\n  }\n}\n\n@datatype class Command_Impl_Payload(value: SW.Command_Impl) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/Mission.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Mission {\n  def empty(): SW.Mission = {\n    return SW.Mission(ISZ.create(10, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class Mission(\n  value : ISZ[SW.Coordinate_Impl]) {\n  { assert (value.size == 10) }\n}\n\nobject Mission_Payload {\n  def empty(): Mission_Payload = {\n    return Mission_Payload(SW.Mission.empty())\n  }\n}\n\n@datatype class Mission_Payload(value: SW.Mission) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/SW\/MissionWindow.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject MissionWindow {\n  def empty(): SW.MissionWindow = {\n    return SW.MissionWindow(ISZ.create(4, SW.Coordinate_Impl.empty()))\n  }\n}\n\n@datatype class MissionWindow(\n  value : ISZ[SW.Coordinate_Impl]) {\n  { assert (value.size == 4) }\n}\n\nobject MissionWindow_Payload {\n  def empty(): MissionWindow_Payload = {\n    return MissionWindow_Payload(SW.MissionWindow.empty())\n  }\n}\n\n@datatype class MissionWindow_Payload(value: SW.MissionWindow) extends art.DataContent\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = org.sireum.B\n\n  type Integer = org.sireum.Z\n\n  type Integer_8 = org.sireum.S8\n  type Integer_16 = org.sireum.S16\n  type Integer_32 = org.sireum.S32\n  type Integer_64 = org.sireum.S64\n\n  type Unsigned_8 = org.sireum.U8\n  type Unsigned_16 = org.sireum.U16\n  type Unsigned_32 = org.sireum.U32\n  type Unsigned_64 = org.sireum.U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = org.sireum.R\n  type Float_32 = org.sireum.F32\n  type Float_64 = org.sireum.F64\n\n  type Character = org.sireum.C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[org.sireum.B]\n\n  @datatype class Boolean_Payload(value: Boolean) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Integer) extends art.DataContent\n  @datatype class Integer_8_Payload(value: Integer_8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: Integer_16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: Integer_32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: Integer_64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: Unsigned_8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: Unsigned_16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: Unsigned_32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: Unsigned_64) extends art.DataContent\n\n  @datatype class Float_Payload(value: Float) extends art.DataContent\n  @datatype class Float_32_Payload(value: Float_32) extends art.DataContent\n  @datatype class Float_64_Payload(value: Float_64) extends art.DataContent\n\n  @datatype class Character_Payload(value: Character) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: Bits) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val UAV_Impl_Instance_MCMP_RADIO_HW : slang_embedded.MC.Radio_Impl_Bridge = slang_embedded.MC.Radio_Impl_Bridge(\n    id = 0,\n    name = \"UAV_Impl_Instance_MCMP_RADIO_HW\",\n    dispatchProtocol = Periodic(period = 1),\n\n    recv_map_inn = Port[MC.MISSING_TYPE_Impl] (id = 0, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_recv_map_inn\", mode = EventIn),\n    recv_map_out = Port[SW.Command_Impl] (id = 1, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_recv_map_out\", mode = EventOut),\n    send_status_inn = Port[SW.Coordinate_Impl] (id = 2, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_send_status_inn\", mode = EventIn),\n    send_status_out = Port[MC.MISSING_TYPE_Impl] (id = 3, name = \"UAV_Impl_Instance_MCMP_RADIO_HW_send_status_out\", mode = EventOut)\n  )\n  val UAV_Impl_Instance_MCMP_UART_HW : slang_embedded.MC.UART_Impl_Bridge = slang_embedded.MC.UART_Impl_Bridge(\n    id = 1,\n    name = \"UAV_Impl_Instance_MCMP_UART_HW\",\n    dispatchProtocol = Periodic(period = 1),\n\n    waypoint_out = Port[MC.MISSING_TYPE_Impl] (id = 4, name = \"UAV_Impl_Instance_MCMP_UART_HW_waypoint_out\", mode = EventOut),\n    position_status_inn = Port[MC.MISSING_TYPE_Impl] (id = 5, name = \"UAV_Impl_Instance_MCMP_UART_HW_position_status_inn\", mode = EventIn),\n    position_status_out = Port[SW.Coordinate_Impl] (id = 6, name = \"UAV_Impl_Instance_MCMP_UART_HW_position_status_out\", mode = EventOut)\n  )\n  val UAV_Impl_Instance_MCMP_PROC_SW_RADIO : slang_embedded.SW.RadioDriver_Impl_Bridge = slang_embedded.SW.RadioDriver_Impl_Bridge(\n    id = 2,\n    name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO\",\n    dispatchProtocol = Sporadic(min = 1),\n\n    recv_map_out = Port[SW.Command_Impl] (id = 7, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out\", mode = EventOut)\n  )\n  val UAV_Impl_Instance_MCMP_PROC_SW_FPLN : slang_embedded.SW.FlightPlanner_Impl_Bridge = slang_embedded.SW.FlightPlanner_Impl_Bridge(\n    id = 3,\n    name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN\",\n    dispatchProtocol = Sporadic(min = 1),\n\n    mission_rcv = Port[Base_Types.Boolean] (id = 8, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv\", mode = EventIn),\n    recv_map = Port[SW.Command_Impl] (id = 9, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map\", mode = EventIn),\n    flight_plan = Port[SW.Mission] (id = 10, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan\", mode = EventOut)\n  )\n  val UAV_Impl_Instance_MCMP_PROC_SW_WPM : slang_embedded.SW.WaypointManager_Impl_Bridge = slang_embedded.SW.WaypointManager_Impl_Bridge(\n    id = 4,\n    name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM\",\n    dispatchProtocol = Sporadic(min = 1),\n\n    flight_plan = Port[SW.Mission] (id = 11, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan\", mode = EventIn),\n    tracking_id = Port[Base_Types.Integer_64] (id = 12, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id\", mode = EventIn),\n    mission_rcv = Port[Base_Types.Boolean] (id = 13, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv\", mode = EventOut),\n    mission_window = Port[SW.MissionWindow] (id = 14, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window\", mode = EventOut)\n  )\n  val UAV_Impl_Instance_MCMP_PROC_SW_UART : slang_embedded.SW.UARTDriver_Impl_Bridge = slang_embedded.SW.UARTDriver_Impl_Bridge(\n    id = 5,\n    name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART\",\n    dispatchProtocol = Sporadic(min = 1),\n\n    mission_window = Port[SW.MissionWindow] (id = 15, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window\", mode = EventIn),\n    tracking_id = Port[Base_Types.Integer_64] (id = 16, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id\", mode = EventOut)\n  )\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (UAV_Impl_Instance_MCMP_RADIO_HW, UAV_Impl_Instance_MCMP_UART_HW, UAV_Impl_Instance_MCMP_PROC_SW_RADIO, UAV_Impl_Instance_MCMP_PROC_SW_FPLN, UAV_Impl_Instance_MCMP_PROC_SW_WPM, UAV_Impl_Instance_MCMP_PROC_SW_UART),\n\n      connections = ISZ (Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO.recv_map_out, to = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.recv_map),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.flight_plan, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM.flight_plan),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_rcv, to = UAV_Impl_Instance_MCMP_PROC_SW_FPLN.mission_rcv),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_window, to = UAV_Impl_Instance_MCMP_PROC_SW_UART.mission_window),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UART.tracking_id, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM.tracking_id))\n    )\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala", { "type" : "Resource","content" : "\/\/ This file was auto-generated.  Do not edit\npackage slang_embedded\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/MC\/Radio_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Radio_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  recv_map_inn: Port[MC.MISSING_TYPE_Impl],\n  recv_map_out: Port[SW.Command_Impl],\n  send_status_inn: Port[SW.Coordinate_Impl],\n  send_status_out: Port[MC.MISSING_TYPE_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_map_inn,\n              recv_map_out,\n              send_status_inn,\n              send_status_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(recv_map_inn,\n                   send_status_inn),\n\n    eventOuts = ISZ(recv_map_out,\n                    send_status_out)\n  )\n\n  val api : Radio_Impl_Bridge.Api =\n    Radio_Impl_Bridge.Api(\n      id,\n      recv_map_inn.id,\n      recv_map_out.id,\n      send_status_inn.id,\n      send_status_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    Radio_Impl_Bridge.EntryPoints(\n      id,\n\n      recv_map_inn.id,\n      recv_map_out.id,\n      send_status_inn.id,\n      send_status_out.id,\n\n      Radio_Impl_Impl(api)\n    )\n}\n\nobject Radio_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    recv_map_inn_Id : Art.PortId,\n    recv_map_out_Id : Art.PortId,\n    send_status_inn_Id : Art.PortId,\n    send_status_out_Id : Art.PortId) {\n\n    def getrecv_map_inn() : Option[MC.MISSING_TYPE_Impl] = {\n      val value : Option[MC.MISSING_TYPE_Impl] = Art.getValue(recv_map_inn_Id) match {\n        case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n        case _ => None[MC.MISSING_TYPE_Impl]()\n      }\n      return value\n    }\n\n    def sendrecv_map_out(value : SW.Command_Impl) : Unit = {\n      Art.putValue(recv_map_out_Id, SW.Command_Impl_Payload(value))\n    }\n\n    def getsend_status_inn() : Option[SW.Coordinate_Impl] = {\n      val value : Option[SW.Coordinate_Impl] = Art.getValue(send_status_inn_Id) match {\n        case Some(SW.Coordinate_Impl_Payload(v)) => Some(v)\n        case _ => None[SW.Coordinate_Impl]()\n      }\n      return value\n    }\n\n    def sendsend_status_out(value : MC.MISSING_TYPE_Impl) : Unit = {\n      Art.putValue(send_status_out_Id, MC.MISSING_TYPE_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    Radio_Impl_BridgeId : Art.BridgeId,\n\n    recv_map_inn_Id : Art.PortId,\n    recv_map_out_Id : Art.PortId,\n    send_status_inn_Id : Art.PortId,\n    send_status_out_Id : Art.PortId,\n\n    component : Radio_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(recv_map_inn_Id,\n                                              send_status_inn_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(recv_map_out_Id,\n                                               send_status_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/MC\/Radio_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait Radio_Impl {\n\n  def api : Radio_Impl_Bridge.Api\n\n  def timeTriggered() : Unit = {}\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/MC\/Radio_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class Radio_Impl_Impl (val api : Radio_Impl_Bridge.Api) extends Radio_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_recv_map_inn: Option[MC.MISSING_TYPE_Impl] = api.getrecv_map_inn()\n    api.sendrecv_map_out(SW.Command_Impl.empty())\n    val apiUsage_send_status_inn: Option[SW.Coordinate_Impl] = api.getsend_status_inn()\n    api.sendsend_status_out(MC.MISSING_TYPE_Impl.empty())\n  }\n\n  override def timeTriggered(): Unit = {\n    \/\/ example override of timeTriggered\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/MC\/UART_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class UART_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  waypoint_out: Port[MC.MISSING_TYPE_Impl],\n  position_status_inn: Port[MC.MISSING_TYPE_Impl],\n  position_status_out: Port[SW.Coordinate_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(waypoint_out,\n              position_status_inn,\n              position_status_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(position_status_inn),\n\n    eventOuts = ISZ(waypoint_out,\n                    position_status_out)\n  )\n\n  val api : UART_Impl_Bridge.Api =\n    UART_Impl_Bridge.Api(\n      id,\n      waypoint_out.id,\n      position_status_inn.id,\n      position_status_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    UART_Impl_Bridge.EntryPoints(\n      id,\n\n      waypoint_out.id,\n      position_status_inn.id,\n      position_status_out.id,\n\n      UART_Impl_Impl(api)\n    )\n}\n\nobject UART_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    waypoint_out_Id : Art.PortId,\n    position_status_inn_Id : Art.PortId,\n    position_status_out_Id : Art.PortId) {\n\n    def sendwaypoint_out(value : MC.MISSING_TYPE_Impl) : Unit = {\n      Art.putValue(waypoint_out_Id, MC.MISSING_TYPE_Impl_Payload(value))\n    }\n\n    def getposition_status_inn() : Option[MC.MISSING_TYPE_Impl] = {\n      val value : Option[MC.MISSING_TYPE_Impl] = Art.getValue(position_status_inn_Id) match {\n        case Some(MC.MISSING_TYPE_Impl_Payload(v)) => Some(v)\n        case _ => None[MC.MISSING_TYPE_Impl]()\n      }\n      return value\n    }\n\n    def sendposition_status_out(value : SW.Coordinate_Impl) : Unit = {\n      Art.putValue(position_status_out_Id, SW.Coordinate_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    UART_Impl_BridgeId : Art.BridgeId,\n\n    waypoint_out_Id : Art.PortId,\n    position_status_inn_Id : Art.PortId,\n    position_status_out_Id : Art.PortId,\n\n    component : UART_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(position_status_inn_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(waypoint_out_Id,\n                                               position_status_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/MC\/UART_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait UART_Impl {\n\n  def api : UART_Impl_Bridge.Api\n\n  def timeTriggered() : Unit = {}\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/MC\/UART_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.MC\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class UART_Impl_Impl (val api : UART_Impl_Bridge.Api) extends UART_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendwaypoint_out(MC.MISSING_TYPE_Impl.empty())\n    val apiUsage_position_status_inn: Option[MC.MISSING_TYPE_Impl] = api.getposition_status_inn()\n    api.sendposition_status_out(SW.Coordinate_Impl.empty())\n  }\n\n  override def timeTriggered(): Unit = {\n    \/\/ example override of timeTriggered\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/SW\/RadioDriver_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class RadioDriver_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  recv_map_out: Port[SW.Command_Impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_map_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(recv_map_out)\n  )\n\n  val api : RadioDriver_Impl_Bridge.Api =\n    RadioDriver_Impl_Bridge.Api(\n      id,\n      recv_map_out.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    RadioDriver_Impl_Bridge.EntryPoints(\n      id,\n\n      recv_map_out.id,\n\n      RadioDriver_Impl_Impl(api)\n    )\n}\n\nobject RadioDriver_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    recv_map_out_Id : Art.PortId) {\n\n    def sendrecv_map_out(value : SW.Command_Impl) : Unit = {\n      Art.putValue(recv_map_out_Id, SW.Command_Impl_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    RadioDriver_Impl_BridgeId : Art.BridgeId,\n\n    recv_map_out_Id : Art.PortId,\n\n    component : RadioDriver_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(recv_map_out_Id)\n\n    def compute(): Unit = {\n      val EventTriggered(portIds) = Art.dispatchStatus(RadioDriver_Impl_BridgeId)\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- portIds) {\n\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/RadioDriver_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait RadioDriver_Impl {\n\n  def api : RadioDriver_Impl_Bridge.Api\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/RadioDriver_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class RadioDriver_Impl_Impl (val api : RadioDriver_Impl_Bridge.Api) extends RadioDriver_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendrecv_map_out(SW.Command_Impl.empty())\n  }\n\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/SW\/FlightPlanner_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class FlightPlanner_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  mission_rcv: Port[Base_Types.Boolean],\n  recv_map: Port[SW.Command_Impl],\n  flight_plan: Port[SW.Mission]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(mission_rcv,\n              recv_map,\n              flight_plan),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(mission_rcv,\n                   recv_map),\n\n    eventOuts = ISZ(flight_plan)\n  )\n\n  val api : FlightPlanner_Impl_Bridge.Api =\n    FlightPlanner_Impl_Bridge.Api(\n      id,\n      mission_rcv.id,\n      recv_map.id,\n      flight_plan.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    FlightPlanner_Impl_Bridge.EntryPoints(\n      id,\n\n      mission_rcv.id,\n      recv_map.id,\n      flight_plan.id,\n\n      FlightPlanner_Impl_Impl(api)\n    )\n}\n\nobject FlightPlanner_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    mission_rcv_Id : Art.PortId,\n    recv_map_Id : Art.PortId,\n    flight_plan_Id : Art.PortId) {\n\n    def getmission_rcv() : Option[Base_Types.Boolean] = {\n      val value : Option[Base_Types.Boolean] = Art.getValue(mission_rcv_Id) match {\n        case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n        case _ => None[Base_Types.Boolean]()\n      }\n      return value\n    }\n\n    def getrecv_map() : Option[SW.Command_Impl] = {\n      val value : Option[SW.Command_Impl] = Art.getValue(recv_map_Id) match {\n        case Some(SW.Command_Impl_Payload(v)) => Some(v)\n        case _ => None[SW.Command_Impl]()\n      }\n      return value\n    }\n\n    def sendflight_plan(value : SW.Mission) : Unit = {\n      Art.putValue(flight_plan_Id, SW.Mission_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    FlightPlanner_Impl_BridgeId : Art.BridgeId,\n\n    mission_rcv_Id : Art.PortId,\n    recv_map_Id : Art.PortId,\n    flight_plan_Id : Art.PortId,\n\n    component : FlightPlanner_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(mission_rcv_Id,\n                                              recv_map_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(flight_plan_Id)\n\n    def compute(): Unit = {\n      val EventTriggered(portIds) = Art.dispatchStatus(FlightPlanner_Impl_BridgeId)\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- portIds) {\n\n        if(portId == mission_rcv_Id){\n          val Some(Base_Types.Boolean_Payload(value)) = Art.getValue(mission_rcv_Id)\n          component.handlemission_rcv(value)\n        }\n        else if(portId == recv_map_Id){\n          val Some(SW.Command_Impl_Payload(value)) = Art.getValue(recv_map_Id)\n          component.handlerecv_map(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/FlightPlanner_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait FlightPlanner_Impl {\n\n  def api : FlightPlanner_Impl_Bridge.Api\n\n  def handlemission_rcv(value : Base_Types.Boolean): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlemission_rcv implementation\")\n  }\n\n  def handlerecv_map(value : SW.Command_Impl): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlerecv_map implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/FlightPlanner_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class FlightPlanner_Impl_Impl (val api : FlightPlanner_Impl_Bridge.Api) extends FlightPlanner_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_mission_rcv: Option[Base_Types.Boolean] = api.getmission_rcv()\n    val apiUsage_recv_map: Option[SW.Command_Impl] = api.getrecv_map()\n    api.sendflight_plan(SW.Mission.empty())\n  }\n\n  override def handlemission_rcv(value : Base_Types.Boolean): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlemission_rcv implementation\")\n  }\n\n  override def handlerecv_map(value : SW.Command_Impl): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlerecv_map implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/SW\/WaypointManager_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class WaypointManager_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  flight_plan: Port[SW.Mission],\n  tracking_id: Port[Base_Types.Integer_64],\n  mission_rcv: Port[Base_Types.Boolean],\n  mission_window: Port[SW.MissionWindow]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(flight_plan,\n              tracking_id,\n              mission_rcv,\n              mission_window),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(flight_plan,\n                   tracking_id),\n\n    eventOuts = ISZ(mission_rcv,\n                    mission_window)\n  )\n\n  val api : WaypointManager_Impl_Bridge.Api =\n    WaypointManager_Impl_Bridge.Api(\n      id,\n      flight_plan.id,\n      tracking_id.id,\n      mission_rcv.id,\n      mission_window.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    WaypointManager_Impl_Bridge.EntryPoints(\n      id,\n\n      flight_plan.id,\n      tracking_id.id,\n      mission_rcv.id,\n      mission_window.id,\n\n      WaypointManager_Impl_Impl(api)\n    )\n}\n\nobject WaypointManager_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    flight_plan_Id : Art.PortId,\n    tracking_id_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    mission_window_Id : Art.PortId) {\n\n    def getflight_plan() : Option[SW.Mission] = {\n      val value : Option[SW.Mission] = Art.getValue(flight_plan_Id) match {\n        case Some(SW.Mission_Payload(v)) => Some(v)\n        case _ => None[SW.Mission]()\n      }\n      return value\n    }\n\n    def gettracking_id() : Option[Base_Types.Integer_64] = {\n      val value : Option[Base_Types.Integer_64] = Art.getValue(tracking_id_Id) match {\n        case Some(Base_Types.Integer_64_Payload(v)) => Some(v)\n        case _ => None[Base_Types.Integer_64]()\n      }\n      return value\n    }\n\n    def sendmission_rcv(value : Base_Types.Boolean) : Unit = {\n      Art.putValue(mission_rcv_Id, Base_Types.Boolean_Payload(value))\n    }\n\n    def sendmission_window(value : SW.MissionWindow) : Unit = {\n      Art.putValue(mission_window_Id, SW.MissionWindow_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    WaypointManager_Impl_BridgeId : Art.BridgeId,\n\n    flight_plan_Id : Art.PortId,\n    tracking_id_Id : Art.PortId,\n    mission_rcv_Id : Art.PortId,\n    mission_window_Id : Art.PortId,\n\n    component : WaypointManager_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(flight_plan_Id,\n                                              tracking_id_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(mission_rcv_Id,\n                                               mission_window_Id)\n\n    def compute(): Unit = {\n      val EventTriggered(portIds) = Art.dispatchStatus(WaypointManager_Impl_BridgeId)\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- portIds) {\n\n        if(portId == flight_plan_Id){\n          val Some(SW.Mission_Payload(value)) = Art.getValue(flight_plan_Id)\n          component.handleflight_plan(value)\n        }\n        else if(portId == tracking_id_Id){\n          val Some(Base_Types.Integer_64_Payload(value)) = Art.getValue(tracking_id_Id)\n          component.handletracking_id(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/WaypointManager_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait WaypointManager_Impl {\n\n  def api : WaypointManager_Impl_Bridge.Api\n\n  def handleflight_plan(value : SW.Mission): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handleflight_plan implementation\")\n  }\n\n  def handletracking_id(value : Base_Types.Integer_64): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handletracking_id implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/WaypointManager_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class WaypointManager_Impl_Impl (val api : WaypointManager_Impl_Bridge.Api) extends WaypointManager_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_flight_plan: Option[SW.Mission] = api.getflight_plan()\n    val apiUsage_tracking_id: Option[Base_Types.Integer_64] = api.gettracking_id()\n    api.sendmission_rcv(Base_Types.Boolean_empty())\n    api.sendmission_window(SW.MissionWindow.empty())\n  }\n\n  override def handleflight_plan(value : SW.Mission): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handleflight_plan implementation\")\n  }\n\n  override def handletracking_id(value : Base_Types.Integer_64): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handletracking_id implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/SW\/UARTDriver_Impl_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class UARTDriver_Impl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n\n  mission_window: Port[SW.MissionWindow],\n  tracking_id: Port[Base_Types.Integer_64]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(mission_window,\n              tracking_id),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(mission_window),\n\n    eventOuts = ISZ(tracking_id)\n  )\n\n  val api : UARTDriver_Impl_Bridge.Api =\n    UARTDriver_Impl_Bridge.Api(\n      id,\n      mission_window.id,\n      tracking_id.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    UARTDriver_Impl_Bridge.EntryPoints(\n      id,\n\n      mission_window.id,\n      tracking_id.id,\n\n      UARTDriver_Impl_Impl(api)\n    )\n}\n\nobject UARTDriver_Impl_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId) {\n\n    def getmission_window() : Option[SW.MissionWindow] = {\n      val value : Option[SW.MissionWindow] = Art.getValue(mission_window_Id) match {\n        case Some(SW.MissionWindow_Payload(v)) => Some(v)\n        case _ => None[SW.MissionWindow]()\n      }\n      return value\n    }\n\n    def sendtracking_id(value : Base_Types.Integer_64) : Unit = {\n      Art.putValue(tracking_id_Id, Base_Types.Integer_64_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    UARTDriver_Impl_BridgeId : Art.BridgeId,\n\n    mission_window_Id : Art.PortId,\n    tracking_id_Id : Art.PortId,\n\n    component : UARTDriver_Impl_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(mission_window_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(tracking_id_Id)\n\n    def compute(): Unit = {\n      val EventTriggered(portIds) = Art.dispatchStatus(UARTDriver_Impl_BridgeId)\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- portIds) {\n\n        if(portId == mission_window_Id){\n          val Some(SW.MissionWindow_Payload(value)) = Art.getValue(mission_window_Id)\n          component.handlemission_window(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/UARTDriver_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait UARTDriver_Impl {\n\n  def api : UARTDriver_Impl_Bridge.Api\n\n  def handlemission_window(value : SW.MissionWindow): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"default handlemission_window implementation\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/SW\/UARTDriver_Impl_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded.SW\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ the contents of this file will not be overwritten\n@record class UARTDriver_Impl_Impl (val api : UARTDriver_Impl_Bridge.Api) extends UARTDriver_Impl {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_mission_window: Option[SW.MissionWindow] = api.getmission_window()\n    api.sendtracking_id(Base_Types.Integer_64_empty())\n  }\n\n  override def handlemission_window(value : SW.MissionWindow): Unit = {\n    api.logInfo(s\"received ${value}\")\n    api.logInfo(\"example handlemission_window implementation\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/UART_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject UART_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_UART_HW.entryPoints\n  val appPortId: Art.PortId = IPCPorts.UART_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val position_status_innPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_UART_HW.position_status_inn.id\n  val position_status_innPortIdOpt: Option[Art.PortId] = Some(position_status_innPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, position_status_innPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    Platform.receiveAsync(position_status_innPortIdOpt) match {\n      case Some((_, v: MC.MISSING_TYPE_Impl_Payload)) => ArtNix.updateData(position_status_innPortId, v)\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${position_status_innPortId}.  Expecting something of type MC.MISSING_TYPE_Impl_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    entryPoints.compute()\n    Process.sleep(1)\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"UART_Impl_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_UART_HW.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/WaypointManager_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject WaypointManager_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.entryPoints\n  val appPortId: Art.PortId = IPCPorts.WaypointManager_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val flight_planPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.flight_plan.id\n  val flight_planPortIdOpt: Option[Art.PortId] = Some(flight_planPortId)\n  val tracking_idPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.tracking_id.id\n  val tracking_idPortIdOpt: Option[Art.PortId] = Some(tracking_idPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, flight_planPortIdOpt)\n    Platform.initialise(seed, tracking_idPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    var dispatch = F\n    Platform.receiveAsync(flight_planPortIdOpt) match {\n      case Some((_, v: SW.Mission_Payload)) => ArtNix.updateData(flight_planPortId, v); dispatch = T\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${flight_planPortId}.  Expecting something of type SW.Mission_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    Platform.receiveAsync(tracking_idPortIdOpt) match {\n      case Some((_, v: Base_Types.Integer_64_Payload)) => ArtNix.updateData(tracking_idPortId, v); dispatch = T\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${tracking_idPortId}.  Expecting something of type Base_Types.Integer_64_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    if (dispatch) {\n      entryPoints.compute()\n      Process.sleep(1)\n    } else {\n      Process.sleep(10)\n    }\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"WaypointManager_Impl_App starting ...\")\n\n    ArtNix.eventDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Radio_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Radio_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_RADIO_HW.entryPoints\n  val appPortId: Art.PortId = IPCPorts.Radio_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val recv_map_innPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_RADIO_HW.recv_map_inn.id\n  val recv_map_innPortIdOpt: Option[Art.PortId] = Some(recv_map_innPortId)\n  val send_status_innPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_RADIO_HW.send_status_inn.id\n  val send_status_innPortIdOpt: Option[Art.PortId] = Some(send_status_innPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, recv_map_innPortIdOpt)\n    Platform.initialise(seed, send_status_innPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    Platform.receiveAsync(recv_map_innPortIdOpt) match {\n      case Some((_, v: MC.MISSING_TYPE_Impl_Payload)) => ArtNix.updateData(recv_map_innPortId, v)\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${recv_map_innPortId}.  Expecting something of type MC.MISSING_TYPE_Impl_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    Platform.receiveAsync(send_status_innPortIdOpt) match {\n      case Some((_, v: SW.Coordinate_Impl_Payload)) => ArtNix.updateData(send_status_innPortId, v)\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${send_status_innPortId}.  Expecting something of type SW.Coordinate_Impl_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    entryPoints.compute()\n    Process.sleep(1)\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"Radio_Impl_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_RADIO_HW.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/FlightPlanner_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject FlightPlanner_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.entryPoints\n  val appPortId: Art.PortId = IPCPorts.FlightPlanner_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val mission_rcvPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.mission_rcv.id\n  val mission_rcvPortIdOpt: Option[Art.PortId] = Some(mission_rcvPortId)\n  val recv_mapPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.recv_map.id\n  val recv_mapPortIdOpt: Option[Art.PortId] = Some(recv_mapPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, mission_rcvPortIdOpt)\n    Platform.initialise(seed, recv_mapPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    var dispatch = F\n    Platform.receiveAsync(mission_rcvPortIdOpt) match {\n      case Some((_, v: Base_Types.Boolean_Payload)) => ArtNix.updateData(mission_rcvPortId, v); dispatch = T\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${mission_rcvPortId}.  Expecting something of type Base_Types.Boolean_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    Platform.receiveAsync(recv_mapPortIdOpt) match {\n      case Some((_, v: SW.Command_Impl_Payload)) => ArtNix.updateData(recv_mapPortId, v); dispatch = T\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${recv_mapPortId}.  Expecting something of type SW.Command_Impl_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    if (dispatch) {\n      entryPoints.compute()\n      Process.sleep(1)\n    } else {\n      Process.sleep(10)\n    }\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"FlightPlanner_Impl_App starting ...\")\n\n    ArtNix.eventDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/UARTDriver_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject UARTDriver_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.entryPoints\n  val appPortId: Art.PortId = IPCPorts.UARTDriver_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val mission_windowPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.mission_window.id\n  val mission_windowPortIdOpt: Option[Art.PortId] = Some(mission_windowPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, mission_windowPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    var dispatch = F\n    Platform.receiveAsync(mission_windowPortIdOpt) match {\n      case Some((_, v: SW.MissionWindow_Payload)) => ArtNix.updateData(mission_windowPortId, v); dispatch = T\n      case Some((_, v)) => halt(s\"Unexpected payload on port ${mission_windowPortId}.  Expecting something of type SW.MissionWindow_Payload but received ${v}\")\n      case None() => \/\/ do nothing\n    }\n    if (dispatch) {\n      entryPoints.compute()\n      Process.sleep(1)\n    } else {\n      Process.sleep(10)\n    }\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"UARTDriver_Impl_App starting ...\")\n\n    ArtNix.eventDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/RadioDriver_Impl_App.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject RadioDriver_Impl_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO.entryPoints\n  val appPortId: Art.PortId = IPCPorts.RadioDriver_Impl_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n\n  def initialise(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def compute(): Unit = {\n    var dispatch = F\n    if (dispatch) {\n      entryPoints.compute()\n      Process.sleep(1)\n    } else {\n      Process.sleep(10)\n    }\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialise(seed)\n\n    Platform.receive(appPortIdOpt) \/\/ pause after setting up component\n\n    entryPoints.initialise()\n\n    Platform.receive(appPortIdOpt) \/\/ pause after component init\n\n    println(\"RadioDriver_Impl_App starting ...\")\n\n    ArtNix.eventDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val termOpt = Platform.receiveAsync(appPortIdOpt)\n      if (termOpt.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    return 0\n  }\n\n  def exit(): Unit = {\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO.entryPoints.finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/SharedMemory.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object SharedMemory {\n  def create(id: Z): Z = $\n  def get(id: Z): Z = $\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = $\n  def receive(port: Art.PortId): DataContent = $\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = $\n  def receiveAsync(port: Art.PortId): Option[DataContent] = $\n  def remove(id: Z): Unit = $\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/SharedMemory_Ext.scala", { "type" : "Resource","content" : "package slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject SharedMemory_Ext {\n  def create(id: Z): Z = halt(\"stub\")\n  def get(id: Z): Z = halt(\"stub\")\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = halt(\"stub\")\n  def receive(port: Art.PortId): DataContent = halt(\"stub\")\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = halt(\"stub\")\n  def receiveAsync(port: Art.PortId): Option[DataContent] = halt(\"stub\")\n  def remove(id: Z): Unit = halt(\"stub\")\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/IPC.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject IPCPorts {\n  val UART_Impl_App: Art.PortId = 17\n  val WaypointManager_Impl_App: Art.PortId = 18\n  val Radio_Impl_App: Art.PortId = 19\n  val FlightPlanner_Impl_App: Art.PortId = 20\n  val UARTDriver_Impl_App: Art.PortId = 21\n  val RadioDriver_Impl_App: Art.PortId = 22\n  val Main: Art.PortId = 23\n}\n\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/ArtNix.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ArtNix {\n\n  val maxPortIds: Art.PortId = IPCPorts.Main + 1\n  val timeTriggered: TimeTriggered = TimeTriggered()\n  val data: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, None())\n  val noData: Option[DataContent] = None()\n  val connection: MS[Art.PortId, ISZ[(Art.PortId, Art.PortId)]] = {\n    val r = MS.create[Art.PortId, ISZ[(Art.PortId, Art.PortId)]](maxPortIds, ISZ())\n\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO.recv_map_out.id) = ISZ(\n      (IPCPorts.FlightPlanner_Impl_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.recv_map.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.flight_plan.id) = ISZ(\n      (IPCPorts.WaypointManager_Impl_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.flight_plan.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_rcv.id) = ISZ(\n      (IPCPorts.FlightPlanner_Impl_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.mission_rcv.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.mission_window.id) = ISZ(\n      (IPCPorts.UARTDriver_Impl_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.mission_window.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.tracking_id.id) = ISZ(\n      (IPCPorts.WaypointManager_Impl_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.tracking_id.id)\n    )\n\n    r\n  }\n  val eventInPorts: MS[Z, Art.PortId] = MSZ(\n    Arch.UAV_Impl_Instance_MCMP_UART_HW.position_status_inn.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.flight_plan.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM.tracking_id.id,\n    Arch.UAV_Impl_Instance_MCMP_RADIO_HW.recv_map_inn.id,\n    Arch.UAV_Impl_Instance_MCMP_RADIO_HW.send_status_inn.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.mission_rcv.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FPLN.recv_map.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UART.mission_window.id\n  )\n  var frozen: MS[Art.PortId, Option[DataContent]] = MS()\n  var outgoing: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, None())\n  var isTimeDispatch: B = F\n\n  def updateData(port: Art.PortId, d: DataContent): Unit = {\n    data(port) = Some(d)\n  }\n\n  def timeDispatch(): Unit = {\n    isTimeDispatch = T\n  }\n\n  def eventDispatch(): Unit = {\n    isTimeDispatch = F\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    if (isTimeDispatch) {\n      return timeTriggered\n    } else {\n      var r = ISZ[Art.PortId]()\n      for (i <- eventInPorts if data(i).nonEmpty) {\n        r = r :+ i\n      }\n      return EventTriggered(r)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    frozen = data\n    for (i <- eventPortIds) {\n      data(i) = noData\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    outgoing(portId) = Some(data)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    return frozen(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (p <- dataPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n\n    for (p <- eventPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {\n  }\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Main.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Main extends App {\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    Platform.initialise(seed, None())\n\n    val empty = art.Empty()\n\n    Platform.sendAsync(IPCPorts.UART_Impl_App, IPCPorts.UART_Impl_App, empty)\n    Platform.sendAsync(IPCPorts.WaypointManager_Impl_App, IPCPorts.WaypointManager_Impl_App, empty)\n    Platform.sendAsync(IPCPorts.Radio_Impl_App, IPCPorts.Radio_Impl_App, empty)\n    Platform.sendAsync(IPCPorts.FlightPlanner_Impl_App, IPCPorts.FlightPlanner_Impl_App, empty)\n    Platform.sendAsync(IPCPorts.UARTDriver_Impl_App, IPCPorts.UARTDriver_Impl_App, empty)\n    Platform.sendAsync(IPCPorts.RadioDriver_Impl_App, IPCPorts.RadioDriver_Impl_App, empty)\n\n    Platform.finalise()\n    return 0\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Platform.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Platform {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = $\n  def receive(portOpt: Option[Art.PortId]): (Art.PortId, DataContent) = $\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = $\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = $\n  def receiveAsync(portOpt: Option[Art.PortId]): Option[(Art.PortId, DataContent)] = $\n  def finalise(): Unit = $\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Platform_Ext.scala", { "type" : "Resource","content" : "package slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Platform_Ext {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = halt(\"stub\")\n  def receive(portOpt: Option[Art.PortId]): (Art.PortId, DataContent) = halt(\"stub\")\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = halt(\"stub\")\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = halt(\"stub\")\n  def receiveAsync(portOpt: Option[Art.PortId]): Option[(Art.PortId, DataContent)] = halt(\"stub\")\n  def finalise(): Unit = halt(\"stub\")\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/PlatformNix.scala", { "type" : "Resource","content" : "\/\/ #Sireum\npackage slang_embedded\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject PlatformNix {\n\n  var seed: Z = 0\n  var ids: ISZ[Z] = ISZ()\n\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = {\n    PlatformNix.seed = seed\n    portOpt match {\n      case Some(port) =>\n        val id = seed + port\n        SharedMemory.create(id)\n        ids = ids :+ id\n      case _ =>\n    }\n  }\n\n  def receive(portOpt: Option[Art.PortId]): (Art.PortId, DataContent) = {\n    portOpt match {\n      case Some(port) =>\n        val d = SharedMemory.receive(seed + port)\n        return (port, d)\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = {\n    SharedMemory.send(port, seed + port, data)\n  }\n\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = {\n    val r = SharedMemory.sendAsync(port, seed + port, data)\n    return r\n  }\n\n  def receiveAsync(portOpt: Option[Art.PortId]): Option[(Art.PortId, DataContent)] = {\n    portOpt match {\n      case Some(port) =>\n        val dOpt = SharedMemory.receiveAsync(seed + port)\n        dOpt match {\n          case Some(d) => return Some((port, d))\n          case _ => return None()\n        }\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def finalise(): Unit = {\n    for (id <- ids) {\n      SharedMemory.remove(id)\n    }\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Process.scala", { "type" : "Resource","content" : "\/\/ #Sireum\npackage slang_embedded\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Process {\n  def sleep(n: Z): Unit = $\n\n  def time(): Art.Time = $\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/nix\/slang_embedded\/Process_Ext.scala", { "type" : "Resource","content" : "package slang_embedded\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Process_Ext {\n  def sleep(millis: Z): Unit = halt(\"stub\")\n\n  def time(): Art.Time = halt(\"stub\")\n}"}],[ "uav_alt_extern--SeL4\/hamr\/..\/compile-hamr-lib.sh", { "type" : "Resource","content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd \"${SCRIPT_HOME}\/hamr\"\nmkdir -p sel4-build\ncd sel4-build\ncmake ..\nmake $MAKE_ARGS\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/c\/ext-c\/ipc.c", { "type" : "Resource","content" : "#include <all.h>\n#include <sys\/types.h>\n#include <sys\/shm.h>\n#include <sys\/sem.h>\n#include <unistd.h>\n\n\/\/ This file is auto-generated.  Do not edit\n\nstatic inline void sem_op(int sid, short val) {\n    struct sembuf sem_op;\n    sem_op.sem_num = 0;\n    sem_op.sem_op = val;\n    sem_op.sem_flg = 0;\n    semop(sid, &sem_op, 1);\n}\n\nstatic inline void lock(int sid) {\n    sem_op(sid, -1);\n}\n\nstatic inline void unlock(int sid) {\n    sem_op(sid, 1);\n}\n\nstatic inline int create_sem(Z msgid) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n    int sem_set_id = semget((key_t) msgid, 1, mask | permission);\n\n    if (sem_set_id >= 0) {\n        union semun {\n            int val;\n            struct semid_ds *buf;\n            ushort *array;\n        } sem_val;\n        sem_val.val = 1;\n        semctl(sem_set_id, 0, SETVAL, sem_val);\n    }\n    return sem_set_id;\n}\n\nZ slang_embedded_SharedMemory_create(STACK_FRAME Z id) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n\n    create_sem(id);\n\n    int shmid = shmget((key_t) id, sizeof(union Option_8E9F45), (int) (permission | mask));\n    void *p = shmat(shmid, (void *) 0, 0);\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    return (Z) shmid;\n}\n\nvoid slang_embedded_SharedMemory_receive(STACK_FRAME art_DataContent result, Z port) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type != TSome_D29615) { \/\/ wait until there is a data\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    art_DataContent d = &p->Some_D29615.value;\n    Type_assign(result, d, sizeOf((Type) d));\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    unlock(sid);\n}\n\nvoid slang_embedded_SharedMemory_receiveAsync(STACK_FRAME Option_8E9F45 result, Z port) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    if (p->type == TSome_D29615) {\n        Type_assign(result, p, sizeOf((Type) p));\n        memset(p, 0, sizeof(union Option_8E9F45));\n    } else {\n        result->type = TNone_964667;\n    }\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nUnit slang_embedded_SharedMemory_send(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type == TSome_D29615) {\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nB slang_embedded_SharedMemory_sendAsync(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n    return T;\n}\n\nUnit slang_embedded_SharedMemory_remove(STACK_FRAME Z id) {\n    semctl(semget((key_t) id, 1, 0666), 0, IPC_RMID);\n    shmctl(shmget((key_t) id, sizeof(union Option_8E9F45), 0666), IPC_RMID, NULL);\n}\n\nUnit slang_embedded_Process_sleep(STACK_FRAME Z n) {\n    usleep((useconds_t) n * 1000);\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c", { "type" : "Resource","content" : "#include <all.h>\n#include <ext.h>\n\n\/\/ add c extension code here"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h", { "type" : "Resource","content" : "#ifndef EXT_H\n#define EXT_H\n\n#endif"}],[ "uav_alt_extern--SeL4\/slang-embedded\/bin\/transpile-sel4.sh", { "type" : "Resource","content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\" \\\n  --output-dir \"${SCRIPT_HOME}\/..\/..\/hamr\" \\\n  --name \"main\" \\\n  --apps \"slang_embedded.UART_Impl_App,slang_embedded.WaypointManager_Impl_App,slang_embedded.Radio_Impl_App,slang_embedded.FlightPlanner_Impl_App,slang_embedded.UARTDriver_Impl_App,slang_embedded.RadioDriver_Impl_App,slang_embedded.Main\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 24 \\\n  --forward \"art.ArtNative=slang_embedded.ArtNix,slang_embedded.Platform=slang_embedded.PlatformNix\" \\\n  --stack-size \"16*1024*1024\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h\" \\\n  --lib-only \\\n  --verbose\n\nFILE=${OUTPUT_DIR}\/CMakeLists.txt\necho -e \"\\n\\nadd_definitions(-DCAMKES)\" >> $FILE"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection[T](val from: Port[T], val to: Port[T])\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/Art.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val maxComponents: BridgeId = 6\n  val maxPorts: PortId = 24\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\nimport scala.util.Failure\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MMap[Art.PortId, (Bridge, UPort, MSet[Listener])] = ArtNative_Ext.concMap()\n\n  \/**\n    * Set to false to disable futures on listenerCallbacks. If false then avoid blocking the thread.\n    *\/\n  var forkListenerCallbacks: Boolean = true\n\n  protected[art] def portListenerCallback(p: Art.PortId, d: DataContent): Unit = {\n    if (forkListenerCallbacks) {\n      listeners.get(p).map(e => e._3.foreach( c =>\n        Future ( c.callback(e._1, e._2, d) ) onComplete {\n          case Failure(e) => throw e\n          case _ =>\n        }\n      ))\n    } else {\n      listeners.get(p).map(e => e._3.foreach(_.callback(e._1, e._2, d)))\n    }\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = data\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = data\n      }\n    }\n  }\n\n  def registerPortListener(portId: Art.PortId, listener: PortListener): Unit = {\n    val bridge = Art.bridges.elements.filter(_.nonEmpty).map(_.get).filter(b => b.ports.all.elements.map(_.id).contains(portId)).head\n    registerListener(bridge, Seq(Art.port(portId)), listener)\n  }\n\n  def registerBridgeListener(bridgeId:Art.BridgeId, listener: BridgeListener): Unit = {\n    val bridge = Art.bridge(bridgeId)\n    val ports = concSet[UPort]()\n\n    if(listener.isInstanceOf[BridgeInDataListener])\n      ports ++= bridge.ports.dataIns.elements\n    if(listener.isInstanceOf[BridgeInEventListener])\n      ports ++= bridge.ports.eventIns.elements\n\n    if(listener.isInstanceOf[BridgeOutDataListener])\n      ports ++= bridge.ports.dataOuts.elements\n    if(listener.isInstanceOf[BridgeOutEventListener])\n      ports ++= bridge.ports.eventOuts.elements\n\n    if(!(listener.isInstanceOf[BridgeInDataListener] || listener.isInstanceOf[BridgeInEventListener] ||\n        listener.isInstanceOf[BridgeOutDataListener] || listener.isInstanceOf[BridgeOutEventListener])) {\n      ports ++= bridge.ports.all.elements\n    }\n    registerListener(bridge, ports.toSeq, listener)\n  }\n\n  def registerProjectListener(listener: Listener): Unit = {\n    art.Art.bridges.elements.filter(_.nonEmpty).foreach(b => registerListener(b.get, b.get.ports.all.elements, listener))\n  }\n\n  private def registerListener(bridge: Bridge, ports: Seq[UPort], listener: Listener): Unit = {\n    for (port <- ports) {\n      val c = if (port.mode == PortMode.DataIn || port.mode == PortMode.EventIn) \"receives\" else \"sends\"\n      val t = if (port.mode == PortMode.DataIn || port.mode == PortMode.DataOut) \"data\" else \"event\"\n      ArtNative.logDebug(Art.logTitle, s\"Registered callback.  Triggered when port ${port.name} $c $t\")\n      listeners.getOrElseUpdate(port.id, (bridge, port, concSet()))._3.add(listener)\n    }\n  }\n\n  def concSet[K](): MSet[K] = {\n    import scala.collection.JavaConverters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, DataContent] = concMap()\n  val dataPortVariables: MMap[Art.PortId, DataContent] = concMap()\n  val receivedPortValues: MMap[Art.PortId, DataContent] = concMap()\n  val sentPortValues: MMap[Art.PortId, DataContent] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) TimeTriggered() else EventTriggered(portIds)\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = data\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(data) =>\n          ArtDebug_Ext.portListenerCallback(srcPortId, data)\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = data\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = data\n            }\n            ArtDebug_Ext.portListenerCallback(dstPortId, data)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    var terminated = false\n    var numTerminated = 0\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import scala.collection.JavaConverters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asScala\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n\n  def registerPortListener(id: Art.PortId, listener: PortListener): Unit = $\n\n  def registerBridgeListener(id:Art.BridgeId, listener: BridgeListener): Unit = $\n\n  def registerProjectListener(listener: Listener): Unit = $\n\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n\n@msig trait Listener {\n  def callback(bridge: Bridge, port : UPort, data: DataContent) : Unit\n}\n\n\/\/ listen to a specific port\n@msig trait PortListener extends Listener\n\n\/\/ listen to all incoming and outgoing ports of a bridge\n@msig trait BridgeListener extends Listener\n\n\/\/ mix both of these in to listen to all incoming ports of a bridge\n@msig trait BridgeInDataListener extends BridgeListener\n@msig trait BridgeInEventListener extends BridgeListener\n\n\/\/ mix both of these in to listen to all outgoing ports of a bridge\n@msig trait BridgeOutDataListener extends BridgeListener\n@msig trait BridgeOutEventListener extends BridgeListener\n"}],[ "uav_alt_extern--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n}\n"}],[ "uav_alt_extern--SeL4\/aux_code\/conversions.h", { "type" : "Resource","content" : "#ifndef CONVERSION_H\n#define CONVERSION_H\n\n#include <all.h>\n#include <sb_PROC_HW_types.h>\n\nvoid convertTo_bool(uav_project_extern_Base_Types_Boolean_Payload, bool*);\nvoid convertTo_SW__Command_Impl(uav_project_extern_SW_Command_Impl_Payload, SW__Command_Impl*);\nvoid convertTo_int64_t(uav_project_extern_Base_Types_Integer_64_Payload, int64_t*);\nvoid convertTo_sb_SW__Mission_container(uav_project_extern_SW_Mission_Payload, sb_SW__Mission_container*);\nvoid convertTo_sb_SW__MissionWindow_container(uav_project_extern_SW_MissionWindow_Payload, sb_SW__MissionWindow_container*);\n\nvoid convertTo_uav_project_extern_Base_Types_Boolean_Payload(bool, uav_project_extern_Base_Types_Boolean_Payload);\nvoid convertTo_uav_project_extern_SW_Command_Impl_Payload(SW__Command_Impl, uav_project_extern_SW_Command_Impl_Payload);\nvoid convertTo_uav_project_extern_Base_Types_Integer_64_Payload(int64_t, uav_project_extern_Base_Types_Integer_64_Payload);\nvoid convertTo_uav_project_extern_SW_Mission_Payload(sb_SW__Mission_container, uav_project_extern_SW_Mission_Payload);\nvoid convertTo_uav_project_extern_SW_MissionWindow_Payload(sb_SW__MissionWindow_container, uav_project_extern_SW_MissionWindow_Payload);\n\n#endif"}],[ "uav_alt_extern--SeL4\/aux_code\/conversions.c", { "type" : "Resource","content" : "#include <conversions.h>\n\nvoid convertTo_bool(uav_project_extern_Base_Types_Boolean_Payload src, bool* dest){\n  *dest = src->value;\n}\n\nvoid convertTo_SW__Command_Impl(uav_project_extern_SW_Command_Impl_Payload src, SW__Command_Impl* dest){\n  struct IS_83A978 is = src->value.Map.value;\n\n  for(int i = 0; i < 4; i++) {\n    SW__Coordinate_Impl c0 = {is.value[i].lat, is.value[i].longitude, is.value[i].alt};\n    memcpy(&(dest->Map[i]), &c0, sizeof(struct SW__Coordinate_Impl));\n  }\n\n  dest->Pattern = (SW__FlightPattern) src->value.Pattern;\n  dest->HMAC = (bool) src->value.HMAC;\n}\n\nvoid convertTo_int64_t(uav_project_extern_Base_Types_Integer_64_Payload src, int64_t* dest){\n  *dest = src->value;\n}\n\nvoid convertTo_sb_SW__Mission_container(uav_project_extern_SW_Mission_Payload src, sb_SW__Mission_container* dest){\n  struct IS_83A978 coords = src->value.value;\n\n  for(int i = 0; i < 10; i++) {\n    SW__Coordinate_Impl c0 = {coords.value[i].lat, coords.value[i].longitude, coords.value[i].alt};\n    memcpy(&(dest->f[i]), &c0, sizeof(SW__Coordinate_Impl));\n  }\n}\n\nvoid convertTo_sb_SW__MissionWindow_container(uav_project_extern_SW_MissionWindow_Payload src, sb_SW__MissionWindow_container* dest){\n  struct IS_83A978 coords = src->value.value;\n\n  for(int i = 0; i < 4; i++) {\n    SW__Coordinate_Impl c0 = {coords.value[i].lat, coords.value[i].longitude, coords.value[i].alt};\n    memcpy(&(dest->f[i]), &c0, sizeof(struct SW__Coordinate_Impl));\n  }\n}\n\n\nvoid convertTo_uav_project_extern_Base_Types_Boolean_Payload(bool src, uav_project_extern_Base_Types_Boolean_Payload dest){\n  uav_project_extern_Base_Types_Boolean_Payload_apply(SF dest, src);\n}\n\nvoid convertTo_uav_project_extern_SW_Command_Impl_Payload(SW__Command_Impl src, uav_project_extern_SW_Command_Impl_Payload dest){\n  DeclNewIS_83A978(is);\n  is.size = (int8_t) 4;\n\n  for(int i = 0; i < 4; i++){\n    DeclNewuav_project_extern_SW_Coordinate_Impl(c0);\n    uav_project_extern_SW_Coordinate_Impl_apply(SF &c0, src.Map[i].lat, src.Map[i].longitude, src.Map[i].alt);\n    Type_assign(&is.value[i], &c0, sizeof(struct uav_project_extern_SW_Coordinate_Impl));\n  }\n\n  DeclNewuav_project_extern_SW_Map(sw_map);\n  uav_project_extern_SW_Map_apply(SF &sw_map, &is);\n\n  uav_project_extern_SW_FlightPattern pattern = src.Pattern;\n\n  bool HMAC = src.HMAC;\n\n  DeclNewuav_project_extern_SW_Command_Impl(slang_command);\n  uav_project_extern_SW_Command_Impl_apply(SF &slang_command, &sw_map, pattern, HMAC);\n\n  uav_project_extern_SW_Command_Impl_Payload_apply(SF\n    (uav_project_extern_SW_Command_Impl_Payload) dest,\n    (uav_project_extern_SW_Command_Impl) &slang_command);\n}\n\nvoid convertTo_uav_project_extern_Base_Types_Integer_64_Payload(int64_t src, uav_project_extern_Base_Types_Integer_64_Payload dest){\n  uav_project_extern_Base_Types_Integer_64_Payload_apply(SF dest, src);\n}\n\nvoid convertTo_uav_project_extern_SW_Mission_Payload(sb_SW__Mission_container src, uav_project_extern_SW_Mission_Payload dest){\n  DeclNewIS_83A978(is);\n  is.size = (int8_t) 10;\n\n  for(int i = 0; i < 10; i++) {\n    DeclNewuav_project_extern_SW_Coordinate_Impl(c0);\n    uav_project_extern_SW_Coordinate_Impl_apply(SF &c0, src.f[i].lat, src.f[i].longitude, src.f[i].alt);\n    Type_assign(&is.value[i], &c0, sizeof(struct uav_project_extern_SW_Coordinate_Impl));\n  }\n\n  DeclNewuav_project_extern_SW_Mission(slang_mission);\n  uav_project_extern_SW_Mission_apply(SF &slang_mission, &is);\n\n  uav_project_extern_SW_Mission_Payload_apply(SF dest, &slang_mission);\n}\n\nvoid convertTo_uav_project_extern_SW_MissionWindow_Payload(sb_SW__MissionWindow_container src, uav_project_extern_SW_MissionWindow_Payload dest){\n  DeclNewIS_83A978(is);\n  is.size = (int8_t) 4;\n\n  for(int i = 0; i < 4; i++) {\n    DeclNewuav_project_extern_SW_Coordinate_Impl(c0);\n    uav_project_extern_SW_Coordinate_Impl_apply(SF &c0, src.f[i].lat, src.f[i].longitude, src.f[i].alt);\n    Type_assign(&is.value[i], &c0, sizeof(struct uav_project_extern_SW_Coordinate_Impl));\n  }\n\n  DeclNewuav_project_extern_SW_MissionWindow(slang_mission_window);\n  uav_project_extern_SW_MissionWindow_apply(SF &slang_mission_window, (IS_83A978) (&is));\n\n  uav_project_extern_SW_MissionWindow_Payload_apply(SF dest, &slang_mission_window);\n}"}],[ "uav_alt_extern--SeL4\/components\/RadioDriver_Impl\/RadioDriver_Impl.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\n\ncomponent RadioDriver_Impl {\n  include <sb_PROC_HW_types.h>;\n  control;\n  uses sb_Monitor_SW__Command_Impl_1 sb_recv_map_out0;\n  has semaphore sb_dispatch_sem;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/FlightPlanner_Impl\/FlightPlanner_Impl.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\n\ncomponent FlightPlanner_Impl {\n  include <sb_PROC_HW_types.h>;\n  control;\n  uses sb_Monitor_bool_1 sb_mission_rcv;\n  uses sb_Monitor_SW__Command_Impl_1 sb_recv_map;\n  uses sb_Monitor_SW__Mission_1 sb_flight_plan0;\n  consumes QueuedData sb_mission_rcv_notification;\n  consumes QueuedData sb_recv_map_notification;\n  has semaphore sb_dispatch_sem;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/WaypointManager_Impl\/WaypointManager_Impl.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_512.idl4\";\n\ncomponent WaypointManager_Impl {\n  include <sb_PROC_HW_types.h>;\n  control;\n  uses sb_Monitor_SW__Mission_1 sb_flight_plan;\n  uses sb_Monitor_int64_t_1 sb_tracking_id;\n  uses sb_Monitor_bool_1 sb_mission_rcv0;\n  uses sb_Monitor_SW__MissionWindow_512 sb_mission_window0;\n  consumes QueuedData sb_flight_plan_notification;\n  consumes QueuedData sb_tracking_id_notification;\n  has semaphore sb_dispatch_sem;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/UARTDriver_Impl\/UARTDriver_Impl.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_512.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\n\ncomponent UARTDriver_Impl {\n  include <sb_PROC_HW_types.h>;\n  control;\n  uses sb_Monitor_SW__MissionWindow_512 sb_mission_window;\n  uses sb_Monitor_int64_t_1 sb_tracking_id0;\n  consumes QueuedData sb_mission_window_notification;\n  has semaphore sb_dispatch_sem;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/sb_FPLN_mission_rcv_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\n\ncomponent sb_FPLN_mission_rcv_Monitor {\n\n  provides sb_Monitor_bool_1 mon;\n  emits QueuedData monsig;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/sb_WPM_tracking_id_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\n\ncomponent sb_WPM_tracking_id_Monitor {\n\n  provides sb_Monitor_int64_t_1 mon;\n  emits QueuedData monsig;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/sb_FPLN_recv_map_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\n\ncomponent sb_FPLN_recv_map_Monitor {\n\n  provides sb_Monitor_SW__Command_Impl_1 mon;\n  emits QueuedData monsig;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/sb_UART_mission_window_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_512.idl4\";\n\ncomponent sb_UART_mission_window_Monitor {\n\n  provides sb_Monitor_SW__MissionWindow_512 mon;\n  emits QueuedData monsig;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/sb_WPM_flight_plan_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\n\ncomponent sb_WPM_flight_plan_Monitor {\n\n  provides sb_Monitor_SW__Mission_1 mon;\n  emits QueuedData monsig;\n}\n"}],[ "uav_alt_extern--SeL4\/PROC_SW.camkes", { "type" : "Resource","content" : "import <std_connector.camkes>;\nimport \"components\/RadioDriver_Impl\/RadioDriver_Impl.camkes\";\nimport \"components\/FlightPlanner_Impl\/FlightPlanner_Impl.camkes\";\nimport \"components\/WaypointManager_Impl\/WaypointManager_Impl.camkes\";\nimport \"components\/UARTDriver_Impl\/UARTDriver_Impl.camkes\";\nimport \"components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/sb_FPLN_mission_rcv_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/sb_WPM_tracking_id_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/sb_FPLN_recv_map_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_UART_mission_window_Monitor\/sb_UART_mission_window_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/sb_WPM_flight_plan_Monitor.camkes\";\n\nassembly {\n  composition {\n    component RadioDriver_Impl RADIO;\n    component FlightPlanner_Impl FPLN;\n    component WaypointManager_Impl WPM;\n    component UARTDriver_Impl UART;\n    component sb_FPLN_mission_rcv_Monitor sb_fpln_mission_rcv_monitor;\n    component sb_WPM_tracking_id_Monitor sb_wpm_tracking_id_monitor;\n    component sb_FPLN_recv_map_Monitor sb_fpln_recv_map_monitor;\n    component sb_UART_mission_window_Monitor sb_uart_mission_window_monitor;\n    component sb_WPM_flight_plan_Monitor sb_wpm_flight_plan_monitor;\n\n    connection seL4RPCCall conn1(from RADIO.sb_recv_map_out0, to sb_fpln_recv_map_monitor.mon);\n    connection seL4RPCCall conn2(from FPLN.sb_recv_map, to sb_fpln_recv_map_monitor.mon);\n    connection seL4Notification conn3(from sb_fpln_recv_map_monitor.monsig, to FPLN.sb_recv_map_notification);\n    connection seL4RPCCall conn4(from FPLN.sb_flight_plan0, to sb_wpm_flight_plan_monitor.mon);\n    connection seL4RPCCall conn5(from WPM.sb_flight_plan, to sb_wpm_flight_plan_monitor.mon);\n    connection seL4Notification conn6(from sb_wpm_flight_plan_monitor.monsig, to WPM.sb_flight_plan_notification);\n    connection seL4RPCCall conn7(from WPM.sb_mission_rcv0, to sb_fpln_mission_rcv_monitor.mon);\n    connection seL4RPCCall conn8(from FPLN.sb_mission_rcv, to sb_fpln_mission_rcv_monitor.mon);\n    connection seL4Notification conn9(from sb_fpln_mission_rcv_monitor.monsig, to FPLN.sb_mission_rcv_notification);\n    connection seL4RPCCall conn10(from WPM.sb_mission_window0, to sb_uart_mission_window_monitor.mon);\n    connection seL4RPCCall conn11(from UART.sb_mission_window, to sb_uart_mission_window_monitor.mon);\n    connection seL4Notification conn12(from sb_uart_mission_window_monitor.monsig, to UART.sb_mission_window_notification);\n    connection seL4RPCCall conn13(from UART.sb_tracking_id0, to sb_wpm_tracking_id_monitor.mon);\n    connection seL4RPCCall conn14(from WPM.sb_tracking_id, to sb_wpm_tracking_id_monitor.mon);\n    connection seL4Notification conn15(from sb_wpm_tracking_id_monitor.monsig, to WPM.sb_tracking_id_notification);\n  }\n\n  configuration {\n    RADIO._stack_size = 8388608;\n    FPLN._stack_size = 8388608;\n    WPM._stack_size = 8388608;\n    UART._stack_size = 8388608;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/interfaces\/bool_writer.idl4", { "type" : "Resource","content" : "procedure bool_writer {\n  include <sb_PROC_HW_types.h>;\n  bool write_bool(refin bool arg);\n};"}],[ "uav_alt_extern--SeL4\/interfaces\/sb_Monitor_bool_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_bool_1 {\n  include <sb_PROC_HW_types.h>;\n  bool enqueue(refin bool m);\n  bool dequeue(out bool m);\n};"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/src\/sb_FPLN_mission_rcv_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include \"..\/..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n#include \"..\/includes\/sb_FPLN_mission_rcv_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nbool contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nstatic bool is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(bool * m) {\n  if (is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const bool * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/includes\/sb_FPLN_mission_rcv_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_FPLN_mission_rcv_Monitor_H__\n#define __sb_FPLN_mission_rcv_Monitor_H__\n\n#endif \/\/ __sb_FPLN_mission_rcv_Monitor_H__\n"}],[ "uav_alt_extern--SeL4\/interfaces\/int64_t_writer.idl4", { "type" : "Resource","content" : "procedure int64_t_writer {\n  include <sb_PROC_HW_types.h>;\n  bool write_int64_t(refin int64_t arg);\n};"}],[ "uav_alt_extern--SeL4\/interfaces\/sb_Monitor_int64_t_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_int64_t_1 {\n  include <sb_PROC_HW_types.h>;\n  bool enqueue(refin int64_t m);\n  bool dequeue(out int64_t m);\n};"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/src\/sb_WPM_tracking_id_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include \"..\/..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n#include \"..\/includes\/sb_WPM_tracking_id_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nint64_t contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nstatic bool is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(int64_t * m) {\n  if (is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const int64_t * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/includes\/sb_WPM_tracking_id_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_WPM_tracking_id_Monitor_H__\n#define __sb_WPM_tracking_id_Monitor_H__\n\n#endif \/\/ __sb_WPM_tracking_id_Monitor_H__\n"}],[ "uav_alt_extern--SeL4\/interfaces\/SW__Command_Impl_writer.idl4", { "type" : "Resource","content" : "procedure SW__Command_Impl_writer {\n  include <sb_PROC_HW_types.h>;\n  bool write_SW__Command_Impl(refin SW__Command_Impl arg);\n};"}],[ "uav_alt_extern--SeL4\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_SW__Command_Impl_1 {\n  include <sb_PROC_HW_types.h>;\n  bool enqueue(refin SW__Command_Impl m);\n  bool dequeue(out SW__Command_Impl m);\n};"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/src\/sb_FPLN_recv_map_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include \"..\/..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n#include \"..\/includes\/sb_FPLN_recv_map_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nSW__Command_Impl contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nstatic bool is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(SW__Command_Impl * m) {\n  if (is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const SW__Command_Impl * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/includes\/sb_FPLN_recv_map_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_FPLN_recv_map_Monitor_H__\n#define __sb_FPLN_recv_map_Monitor_H__\n\n#endif \/\/ __sb_FPLN_recv_map_Monitor_H__\n"}],[ "uav_alt_extern--SeL4\/interfaces\/SW__MissionWindow_writer.idl4", { "type" : "Resource","content" : "procedure SW__MissionWindow_writer {\n  include <sb_PROC_HW_types.h>;\n  bool write_SW__MissionWindow(refin sb_SW__MissionWindow_container arg);\n};"}],[ "uav_alt_extern--SeL4\/interfaces\/sb_Monitor_SW__MissionWindow_512.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_SW__MissionWindow_512 {\n  include <sb_PROC_HW_types.h>;\n  bool enqueue(refin sb_SW__MissionWindow_container m);\n  bool dequeue(out sb_SW__MissionWindow_container m);\n};"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/src\/sb_UART_mission_window_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include \"..\/..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n#include \"..\/includes\/sb_UART_mission_window_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nsb_SW__MissionWindow_container contents[512];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 512;\n}\n\nstatic bool is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(sb_SW__MissionWindow_container * m) {\n  if (is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 512;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const sb_SW__MissionWindow_container * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 512] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/includes\/sb_UART_mission_window_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_UART_mission_window_Monitor_H__\n#define __sb_UART_mission_window_Monitor_H__\n\n#endif \/\/ __sb_UART_mission_window_Monitor_H__\n"}],[ "uav_alt_extern--SeL4\/interfaces\/SW__Mission_writer.idl4", { "type" : "Resource","content" : "procedure SW__Mission_writer {\n  include <sb_PROC_HW_types.h>;\n  bool write_SW__Mission(refin sb_SW__Mission_container arg);\n};"}],[ "uav_alt_extern--SeL4\/interfaces\/sb_Monitor_SW__Mission_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_SW__Mission_1 {\n  include <sb_PROC_HW_types.h>;\n  bool enqueue(refin sb_SW__Mission_container m);\n  bool dequeue(out sb_SW__Mission_container m);\n};"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/src\/sb_WPM_flight_plan_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include \"..\/..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n#include \"..\/includes\/sb_WPM_flight_plan_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nsb_SW__Mission_container contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nstatic bool is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(sb_SW__Mission_container * m) {\n  if (is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const sb_SW__Mission_container * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n"}],[ "uav_alt_extern--SeL4\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/includes\/sb_WPM_flight_plan_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_WPM_flight_plan_Monitor_H__\n#define __sb_WPM_flight_plan_Monitor_H__\n\n#endif \/\/ __sb_WPM_flight_plan_Monitor_H__\n"}],[ "uav_alt_extern--SeL4\/CMakeLists.txt", { "type" : "Resource","content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject (PROC_SW C)\n\nexecute_process(COMMAND bash -c \"${CMAKE_CURRENT_LIST_DIR}\/compile-hamr-lib.sh\")\n\nset(HAMR_LIB ${CMAKE_CURRENT_LIST_DIR}\/hamr\/sel4-build\/libmain.a)\n\nset(AUX_C_SOURCES aux_code\/conversions.c)\nset(AUX_C_INCLUDES aux_code)\n\nDeclareCAmkESComponent(RadioDriver_Impl\n  SOURCES ${AUX_C_SOURCES} components\/RadioDriver_Impl\/src\/sb_RadioDriver_Impl.c includes\/ipc.c\n  INCLUDES ${AUX_C_INCLUDES} components\/RadioDriver_Impl\/includes\/ includes\n  LIBS ${HAMR_LIB}\n)\n\nDeclareCAmkESComponent(FlightPlanner_Impl\n  SOURCES ${AUX_C_SOURCES} components\/FlightPlanner_Impl\/src\/sb_FlightPlanner_Impl.c includes\/ipc.c\n  INCLUDES ${AUX_C_INCLUDES} components\/FlightPlanner_Impl\/includes\/ includes\n  LIBS ${HAMR_LIB}\n)\n\nDeclareCAmkESComponent(WaypointManager_Impl\n  SOURCES ${AUX_C_SOURCES} components\/WaypointManager_Impl\/src\/sb_WaypointManager_Impl.c includes\/ipc.c\n  INCLUDES ${AUX_C_INCLUDES} components\/WaypointManager_Impl\/includes\/ includes\n  LIBS ${HAMR_LIB}\n)\n\nDeclareCAmkESComponent(UARTDriver_Impl\n  SOURCES ${AUX_C_SOURCES} components\/UARTDriver_Impl\/src\/sb_UARTDriver_Impl.c includes\/ipc.c\n  INCLUDES ${AUX_C_INCLUDES} components\/UARTDriver_Impl\/includes\/ includes\n  LIBS ${HAMR_LIB}\n)\n\nDeclareCAmkESComponent(sb_FPLN_mission_rcv_Monitor\n  SOURCES components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/src\/sb_FPLN_mission_rcv_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/includes\/ includes\n\n)\n\nDeclareCAmkESComponent(sb_WPM_tracking_id_Monitor\n  SOURCES components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/src\/sb_WPM_tracking_id_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/includes\/ includes\n\n)\n\nDeclareCAmkESComponent(sb_FPLN_recv_map_Monitor\n  SOURCES components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/src\/sb_FPLN_recv_map_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/includes\/ includes\n\n)\n\nDeclareCAmkESComponent(sb_UART_mission_window_Monitor\n  SOURCES components\/sb_Monitors\/sb_UART_mission_window_Monitor\/src\/sb_UART_mission_window_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_UART_mission_window_Monitor\/includes\/ includes\n\n)\n\nDeclareCAmkESComponent(sb_WPM_flight_plan_Monitor\n  SOURCES components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/src\/sb_WPM_flight_plan_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/includes\/ includes\n\n)\n\nDeclareCAmkESRootserver(PROC_SW.camkes)\n"}],[ "uav_alt_extern--SeL4\/components\/RadioDriver_Impl\/src\/sb_RadioDriver_Impl.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_RadioDriver_Impl.h\"\n#include \"..\/..\/..\/aux_code\/conversions.h\"\n#include <all.h>\n#include <ipc.h>\n#include <string.h>\n#include <camkes.h>\n\nint32_t UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map_id;\n\n\/************************************************************************\n * sb_recv_map_out_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_recv_map_out_enqueue(const SW__Command_Impl * sb_recv_map_out){\n  bool sb_result = true;\n  sb_result &= sb_recv_map_out0_enqueue((SW__Command_Impl *) sb_recv_map_out);\n  return sb_result;\n}\n\nvoid camkes_sendAsync(Z port, art_DataContent d) {\n  if(port == UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map_id) {\n    slang_embedded_SW_Command_Impl_Payload payload = (slang_embedded_SW_Command_Impl_Payload) d;\n\n    \/\/ convert Slang type to CAmkES type\n    SW__Command_Impl val;\n    convertTo_SW__Command_Impl(payload, &val);\n\n    \/\/ deliver payload via CAmkES\n    sb_recv_map_out_enqueue(&val);\n  }\n  else {\n    printf(\"RadioDriver_Impl camkes_sendAsync: not expecting port id %i\\n\", port);\n  }\n}\n\n\nvoid transferIncomingDataToArt() {\n}\n\n\nvoid pre_init(void) {\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_RadioDriver_Impl_App_initialise(SF seed);\n\n  \/\/ fetch assigned port ids\n  UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_FPLN(SF)->recv_map.id + seed;\n\n  \/\/ call the component's initialise entrypoint\n  art_Bridge_EntryPoints_initialise_(SF slang_embedded_RadioDriver_Impl_App_entryPoints(SF));\n\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    transferIncomingDataToArt();\n\n    slang_embedded_RadioDriver_Impl_App_compute(SF);\n  }\n  return 0;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/RadioDriver_Impl\/includes\/sb_RadioDriver_Impl.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_RadioDriver_Impl_types__H\n#define __sb_AADL_RadioDriver_Impl_types__H\n\n#include \"..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n\nbool sb_recv_map_out_enqueue(const SW__Command_Impl * sb_recv_map_out);\n\n#endif \/\/ __sb_AADL_RadioDriver_Impl_types__H\n"}],[ "uav_alt_extern--SeL4\/components\/FlightPlanner_Impl\/src\/sb_FlightPlanner_Impl.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_FlightPlanner_Impl.h\"\n#include \"..\/..\/..\/aux_code\/conversions.h\"\n#include <all.h>\n#include <ipc.h>\n#include <string.h>\n#include <camkes.h>\n\nint32_t recv_map_id;\n\nint32_t mission_rcv_id;\n\nint32_t UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan_id;\n\nstatic void sb_mission_rcv_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n}\n\nstatic void sb_recv_map_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_flight_plan_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container * sb_flight_plan){\n  bool sb_result = true;\n  sb_result &= sb_flight_plan0_enqueue((sb_SW__Mission_container *) sb_flight_plan);\n  return sb_result;\n}\n\nvoid camkes_sendAsync(Z port, art_DataContent d) {\n  if(port == UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan_id) {\n    slang_embedded_SW_Mission_Payload payload = (slang_embedded_SW_Mission_Payload) d;\n\n    \/\/ convert Slang type to CAmkES type\n    sb_SW__Mission_container val;\n    convertTo_sb_SW__Mission_container(payload, &val);\n\n    \/\/ deliver payload via CAmkES\n    sb_flight_plan_enqueue(&val);\n  }\n  else {\n    printf(\"FlightPlanner_Impl camkes_sendAsync: not expecting port id %i\\n\", port);\n  }\n}\n\n\nvoid transferIncomingDataToArt() {\n  {\n    bool val;\n    while(sb_mission_rcv_dequeue((bool *) &val)){\n      \/\/ convert to slang payload\n      DeclNewslang_embedded_Base_Types_Boolean_Payload(payload);\n      convertTo_slang_embedded_Base_Types_Boolean_Payload(val, &payload);\n\n      \/\/ deliver payload via ART\n      camkes_In_Port_Data_Transfer(mission_rcv_id, (art_DataContent) &payload);\n    }\n  }\n\n  {\n    SW__Command_Impl val;\n    while(sb_recv_map_dequeue((SW__Command_Impl *) &val)){\n      \/\/ convert to slang payload\n      DeclNewslang_embedded_SW_Command_Impl_Payload(payload);\n      convertTo_slang_embedded_SW_Command_Impl_Payload(val, &payload);\n\n      \/\/ deliver payload via ART\n      camkes_In_Port_Data_Transfer(recv_map_id, (art_DataContent) &payload);\n    }\n  }\n\n}\n\n\nvoid pre_init(void) {\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_FlightPlanner_Impl_App_initialise(SF seed);\n\n  \/\/ fetch assigned port ids\n  UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_WPM(SF)->flight_plan.id + seed;\n  mission_rcv_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_FPLN(SF)->mission_rcv.id + seed;\n  recv_map_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_FPLN(SF)->recv_map.id + seed;\n\n  \/\/ call the component's initialise entrypoint\n  art_Bridge_EntryPoints_initialise_(SF slang_embedded_FlightPlanner_Impl_App_entryPoints(SF));\n\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    transferIncomingDataToArt();\n\n    slang_embedded_FlightPlanner_Impl_App_compute(SF);\n  }\n  return 0;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/FlightPlanner_Impl\/includes\/sb_FlightPlanner_Impl.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_FlightPlanner_Impl_types__H\n#define __sb_AADL_FlightPlanner_Impl_types__H\n\n#include \"..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n\nbool sb_mission_rcv_dequeue(bool * sb_mission_rcv);\n\nbool sb_recv_map_dequeue(SW__Command_Impl * sb_recv_map);\n\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container * sb_flight_plan);\n\n#endif \/\/ __sb_AADL_FlightPlanner_Impl_types__H\n"}],[ "uav_alt_extern--SeL4\/components\/WaypointManager_Impl\/src\/sb_WaypointManager_Impl.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_WaypointManager_Impl.h\"\n#include \"..\/..\/..\/aux_code\/conversions.h\"\n#include <all.h>\n#include <ipc.h>\n#include <string.h>\n#include <camkes.h>\n\nint32_t tracking_id_id;\n\nint32_t flight_plan_id;\n\nint32_t UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window_id;\n\nint32_t UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv_id;\n\nstatic void sb_flight_plan_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n}\n\nstatic void sb_tracking_id_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_mission_rcv_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_mission_rcv_enqueue(const bool * sb_mission_rcv){\n  bool sb_result = true;\n  sb_result &= sb_mission_rcv0_enqueue((bool *) sb_mission_rcv);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_mission_window_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container * sb_mission_window){\n  bool sb_result = true;\n  sb_result &= sb_mission_window0_enqueue((sb_SW__MissionWindow_container *) sb_mission_window);\n  return sb_result;\n}\n\nvoid camkes_sendAsync(Z port, art_DataContent d) {\n  if(port == UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv_id) {\n    slang_embedded_Base_Types_Boolean_Payload payload = (slang_embedded_Base_Types_Boolean_Payload) d;\n\n    \/\/ convert Slang type to CAmkES type\n    bool val;\n    convertTo_bool(payload, &val);\n\n    \/\/ deliver payload via CAmkES\n    sb_mission_rcv_enqueue(&val);\n  }\n  else if(port == UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window_id) {\n    slang_embedded_SW_MissionWindow_Payload payload = (slang_embedded_SW_MissionWindow_Payload) d;\n\n    \/\/ convert Slang type to CAmkES type\n    sb_SW__MissionWindow_container val;\n    convertTo_sb_SW__MissionWindow_container(payload, &val);\n\n    \/\/ deliver payload via CAmkES\n    sb_mission_window_enqueue(&val);\n  }\n  else {\n    printf(\"WaypointManager_Impl camkes_sendAsync: not expecting port id %i\\n\", port);\n  }\n}\n\n\nvoid transferIncomingDataToArt() {\n  {\n    sb_SW__Mission_container val;\n    while(sb_flight_plan_dequeue((sb_SW__Mission_container *) &val)){\n      \/\/ convert to slang payload\n      DeclNewslang_embedded_SW_Mission_Payload(payload);\n      convertTo_slang_embedded_SW_Mission_Payload(val, &payload);\n\n      \/\/ deliver payload via ART\n      camkes_In_Port_Data_Transfer(flight_plan_id, (art_DataContent) &payload);\n    }\n  }\n\n  {\n    int64_t val;\n    while(sb_tracking_id_dequeue((int64_t *) &val)){\n      \/\/ convert to slang payload\n      DeclNewslang_embedded_Base_Types_Integer_64_Payload(payload);\n      convertTo_slang_embedded_Base_Types_Integer_64_Payload(val, &payload);\n\n      \/\/ deliver payload via ART\n      camkes_In_Port_Data_Transfer(tracking_id_id, (art_DataContent) &payload);\n    }\n  }\n\n}\n\n\nvoid pre_init(void) {\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_WaypointManager_Impl_App_initialise(SF seed);\n\n  \/\/ fetch assigned port ids\n  UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_FPLN(SF)->mission_rcv.id + seed;\n  UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_UART(SF)->mission_window.id + seed;\n  flight_plan_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_WPM(SF)->flight_plan.id + seed;\n  tracking_id_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_WPM(SF)->tracking_id.id + seed;\n\n  \/\/ call the component's initialise entrypoint\n  art_Bridge_EntryPoints_initialise_(SF slang_embedded_WaypointManager_Impl_App_entryPoints(SF));\n\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    transferIncomingDataToArt();\n\n    slang_embedded_WaypointManager_Impl_App_compute(SF);\n  }\n  return 0;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/WaypointManager_Impl\/includes\/sb_WaypointManager_Impl.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_WaypointManager_Impl_types__H\n#define __sb_AADL_WaypointManager_Impl_types__H\n\n#include \"..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n\nbool sb_flight_plan_dequeue(sb_SW__Mission_container * sb_flight_plan);\n\nbool sb_tracking_id_dequeue(int64_t * sb_tracking_id);\n\nbool sb_mission_rcv_enqueue(const bool * sb_mission_rcv);\n\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container * sb_mission_window);\n\n#endif \/\/ __sb_AADL_WaypointManager_Impl_types__H\n"}],[ "uav_alt_extern--SeL4\/components\/UARTDriver_Impl\/src\/sb_UARTDriver_Impl.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_UARTDriver_Impl.h\"\n#include \"..\/..\/..\/aux_code\/conversions.h\"\n#include <all.h>\n#include <ipc.h>\n#include <string.h>\n#include <camkes.h>\n\nint32_t mission_window_id;\n\nint32_t UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id_id;\n\nstatic void sb_mission_window_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_tracking_id_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_tracking_id_enqueue(const int64_t * sb_tracking_id){\n  bool sb_result = true;\n  sb_result &= sb_tracking_id0_enqueue((int64_t *) sb_tracking_id);\n  return sb_result;\n}\n\nvoid camkes_sendAsync(Z port, art_DataContent d) {\n  if(port == UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id_id) {\n    slang_embedded_Base_Types_Integer_64_Payload payload = (slang_embedded_Base_Types_Integer_64_Payload) d;\n\n    \/\/ convert Slang type to CAmkES type\n    int64_t val;\n    convertTo_int64_t(payload, &val);\n\n    \/\/ deliver payload via CAmkES\n    sb_tracking_id_enqueue(&val);\n  }\n  else {\n    printf(\"UARTDriver_Impl camkes_sendAsync: not expecting port id %i\\n\", port);\n  }\n}\n\n\nvoid transferIncomingDataToArt() {\n  {\n    sb_SW__MissionWindow_container val;\n    while(sb_mission_window_dequeue((sb_SW__MissionWindow_container *) &val)){\n      \/\/ convert to slang payload\n      DeclNewslang_embedded_SW_MissionWindow_Payload(payload);\n      convertTo_slang_embedded_SW_MissionWindow_Payload(val, &payload);\n\n      \/\/ deliver payload via ART\n      camkes_In_Port_Data_Transfer(mission_window_id, (art_DataContent) &payload);\n    }\n  }\n\n}\n\n\nvoid pre_init(void) {\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_UARTDriver_Impl_App_initialise(SF seed);\n\n  \/\/ fetch assigned port ids\n  UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_WPM(SF)->tracking_id.id + seed;\n  mission_window_id = slang_embedded_Arch_UAV_Impl_Instance_MCMP_PROC_SW_UART(SF)->mission_window.id + seed;\n\n  \/\/ call the component's initialise entrypoint\n  art_Bridge_EntryPoints_initialise_(SF slang_embedded_UARTDriver_Impl_App_entryPoints(SF));\n\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    transferIncomingDataToArt();\n\n    slang_embedded_UARTDriver_Impl_App_compute(SF);\n  }\n  return 0;\n}\n"}],[ "uav_alt_extern--SeL4\/components\/UARTDriver_Impl\/includes\/sb_UARTDriver_Impl.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_UARTDriver_Impl_types__H\n#define __sb_AADL_UARTDriver_Impl_types__H\n\n#include \"..\/..\/..\/includes\/sb_PROC_HW_types.h\"\n\nbool sb_mission_window_dequeue(sb_SW__MissionWindow_container * sb_mission_window);\n\nbool sb_tracking_id_enqueue(const int64_t * sb_tracking_id);\n\n#endif \/\/ __sb_AADL_UARTDriver_Impl_types__H\n"}],[ "uav_alt_extern--SeL4\/includes\/sb_PROC_HW_types.h", { "type" : "Resource","content" : "#ifndef __SB_AADL_sb_PROC_HW_types__H\n#define __SB_AADL_sb_PROC_HW_types__H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef\n  struct MC__MISSING_TYPE_Impl {\n    int32_t MISSING;\n  } MC__MISSING_TYPE_Impl;\n\ntypedef\n  enum {ZigZag, StraightLine, Perimeter} SW__FlightPattern;\n\ntypedef\n  struct SW__Coordinate_Impl {\n    int32_t lat;\n    int32_t longitude;\n    int32_t alt;\n  } SW__Coordinate_Impl;\n\ntypedef SW__Coordinate_Impl SW__Map [4];\n\ntypedef\n  struct sb_SW__Map_container {\n    SW__Map f;\n  } sb_SW__Map_container;\n\ntypedef\n  struct SW__Command_Impl {\n    SW__Map Map;\n    SW__FlightPattern Pattern;\n    bool HMAC;\n  } SW__Command_Impl;\n\ntypedef SW__Coordinate_Impl SW__Mission [10];\n\ntypedef\n  struct sb_SW__Mission_container {\n    SW__Mission f;\n  } sb_SW__Mission_container;\n\ntypedef SW__Coordinate_Impl SW__MissionWindow [4];\n\ntypedef\n  struct sb_SW__MissionWindow_container {\n    SW__MissionWindow f;\n  } sb_SW__MissionWindow_container;\n\n#endif \/\/ __SB_AADL_sb_PROC_HW_types__H\n"}],[ "uav_alt_extern--SeL4\/includes\/ipc.h", { "type" : "Resource","content" : "#ifndef IPC_H\n#define IPC_H\n#include <all.h>\n\nstatic const int seed = 1;\n\nvoid camkes_In_Port_Data_Transfer (Z port, art_DataContent d);\n\nvoid camkes_sendAsync(Z port, art_DataContent d);\n\n#endif"}],[ "uav_alt_extern--SeL4\/includes\/ipc.c", { "type" : "Resource","content" : "#include <all.h>\n#include <ipc.h>\n\nstatic union Option_8E9F45 camkes_buffer[10] = { 0 };\n\nZ slang_embedded_SharedMemory_create(STACK_FRAME Z id) {\n  DeclNewNone_964667(t_0);\n  None_964667_apply(CALLER &t_0);\n  Type_assign((camkes_buffer + id), (&t_0), sizeof(union Option_8E9F45));\n\n  return -1;\n}\n\nvoid slang_embedded_SharedMemory_receive(STACK_FRAME art_DataContent result, Z port) {\n  printf(\"slang_embedded_SharedMemory_receive called with port %i -- NOT IMPLEMENTED\\n\", port);\n}\n\nvoid slang_embedded_SharedMemory_receiveAsync(STACK_FRAME Option_8E9F45 result, Z port) {\n  union Option_8E9F45 p = camkes_buffer[port];\n\n  if (p.type == TSome_D29615) {\n      Type_assign(result, &p, sizeOf((Type) &p));\n      memset(camkes_buffer + port, 0, sizeof(union Option_8E9F45));\n  } else {\n      result->type = TNone_964667;\n  }\n}\n\nUnit slang_embedded_SharedMemory_send(STACK_FRAME Z destid, Z port, art_DataContent d) {\n  printf(\"slang_embedded_SharedMemory_send called with port %i -- NOT IMPLEMENTED\\n\", port);\n}\n\nB slang_embedded_SharedMemory_sendAsync(STACK_FRAME Z id, Z port, art_DataContent d) {\n  camkes_sendAsync(port, d);\n\n  return T;\n}\n\nUnit slang_embedded_SharedMemory_remove(STACK_FRAME Z id) {\n  printf(\"slang_embedded_SharedMemory_remove called with %i -- NOT IMPLEMENTED\\n\", id);\n}\n\nUnit slang_embedded_Process_sleep(STACK_FRAME Z n) {}\n\nvoid camkes_In_Port_Data_Transfer (Z port, art_DataContent d) {\n  union Option_8E9F45 p = camkes_buffer[port];\n  camkes_buffer[port].type = TSome_D29615;\n  Type_assign(&(camkes_buffer[port].Some_D29615.value), d, sizeOf((Type) d));\n}\n"}]]}}