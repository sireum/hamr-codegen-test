{  "type" : "TestResult","map" : { "type" : "Map","entries" : [ [ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/TempUnit.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object TempUnit {\n  'Fahrenheit\n  'Celsius\n  'Kelvin\n}\n\nobject TempUnit_Payload {\n  def empty(): TempUnit_Payload = {\n    return TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class TempUnit_Payload(value: BuildingControl.TempUnit.Type) extends art.DataContent\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/Temperature_impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Temperature_impl {\n  def empty(): BuildingControl.Temperature_impl = {\n    return BuildingControl.Temperature_impl(Base_Types.Float_32_empty(), BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class Temperature_impl(\n  degrees : F32,\n  unit : BuildingControl.TempUnit.Type) {\n}\n\nobject Temperature_impl_Payload {\n  def empty(): Temperature_impl_Payload = {\n    return Temperature_impl_Payload(BuildingControl.Temperature_impl.empty())\n  }\n}\n\n@datatype class Temperature_impl_Payload(value: BuildingControl.Temperature_impl) extends art.DataContent\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/SetPoint_impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject SetPoint_impl {\n  def empty(): BuildingControl.SetPoint_impl = {\n    return BuildingControl.SetPoint_impl(BuildingControl.Temperature_impl.empty(), BuildingControl.Temperature_impl.empty())\n  }\n}\n\n@datatype class SetPoint_impl(\n  low : BuildingControl.Temperature_impl,\n  high : BuildingControl.Temperature_impl) {\n}\n\nobject SetPoint_impl_Payload {\n  def empty(): SetPoint_impl_Payload = {\n    return SetPoint_impl_Payload(BuildingControl.SetPoint_impl.empty())\n  }\n}\n\n@datatype class SetPoint_impl_Payload(value: BuildingControl.SetPoint_impl) extends art.DataContent\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/FanAck.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FanAck {\n  'Ok\n  'Error\n}\n\nobject FanAck_Payload {\n  def empty(): FanAck_Payload = {\n    return FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanAck_Payload(value: BuildingControl.FanAck.Type) extends art.DataContent\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/FanCmd.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FanCmd {\n  'On\n  'Off\n}\n\nobject FanCmd_Payload {\n  def empty(): FanCmd_Payload = {\n    return FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanCmd_Payload(value: BuildingControl.FanCmd.Type) extends art.DataContent\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/Base_Types.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = org.sireum.B\n\n  type Integer = org.sireum.Z\n\n  type Integer_8 = org.sireum.S8\n  type Integer_16 = org.sireum.S16\n  type Integer_32 = org.sireum.S32\n  type Integer_64 = org.sireum.S64\n\n  type Unsigned_8 = org.sireum.U8\n  type Unsigned_16 = org.sireum.U16\n  type Unsigned_32 = org.sireum.U32\n  type Unsigned_64 = org.sireum.U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = org.sireum.R\n  type Float_32 = org.sireum.F32\n  type Float_64 = org.sireum.F64\n\n  type Character = org.sireum.C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: Bits) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/Arch.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val BuildingControlDemo_i_Instance_tcp_tempSensor : building_control_gen_mixed.BuildingControl.TempSensor_i_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp\", mode = DataOut)\n    val tempChanged = Port[art.Empty] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.TempSensor_i_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempSensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_tempControl : building_control_gen_mixed.BuildingControl.TempControl_i_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 2, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp\", mode = DataIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 3, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanAck\", mode = EventIn)\n    val setPoint = Port[BuildingControl.SetPoint_impl] (id = 4, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_setPoint\", mode = EventIn)\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 5, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd\", mode = EventOut)\n    val tempChanged = Port[art.Empty] (id = 6, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged\", mode = EventIn)\n\n    building_control_gen_mixed.BuildingControl.TempControl_i_Bridge(\n      id = 1,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempControl\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      fanAck = fanAck,\n      setPoint = setPoint,\n      fanCmd = fanCmd,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_fan : building_control_gen_mixed.BuildingControl.Fan_i_Bridge = {\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 7, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanCmd\", mode = EventIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 8, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanAck\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.Fan_i_Bridge(\n      id = 2,\n      name = \"BuildingControlDemo_i_Instance_tcp_fan\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      fanCmd = fanCmd,\n      fanAck = fanAck\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (BuildingControlDemo_i_Instance_tcp_tempSensor, BuildingControlDemo_i_Instance_tcp_tempControl, BuildingControlDemo_i_Instance_tcp_fan),\n\n      connections = ISZ (Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.currentTemp, to = BuildingControlDemo_i_Instance_tcp_tempControl.currentTemp),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.tempChanged, to = BuildingControlDemo_i_Instance_tcp_tempControl.tempChanged),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_tempControl.fanCmd, to = BuildingControlDemo_i_Instance_tcp_fan.fanCmd),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_fan.fanAck, to = BuildingControlDemo_i_Instance_tcp_tempControl.fanAck))\n    )\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/Demo.scala", { "type" : "Resource","content" : "\/\/ This file was auto-generated.  Do not edit\npackage building_control_gen_mixed\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/BuildingControlDemo_i_Instance_tcp_tempSensor_Test.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass BuildingControlDemo_i_Instance_tcp_tempSensor_Test extends BridgeTestSuite[TempSensor_i_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_tempSensor) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ getter for out DataPort\n  def get_currentTemp(): Option[BuildingControl.Temperature_impl] = {\n    val value: Option[BuildingControl.Temperature_impl] = get_currentTemp_payload() match {\n      case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\") \n      case _ => None[BuildingControl.Temperature_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_currentTemp_payload(): Option[BuildingControl.Temperature_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.currentTemp_Id).asInstanceOf[Option[BuildingControl.Temperature_impl_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_tempChanged(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_tempChanged_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port tempChanged.  Expecting 'Empty' but received ${v}\") \n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_tempChanged_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.tempChanged_Id).asInstanceOf[Option[Empty]]\n  }\n\n  def getComponent(): TempSensor_i_Impl = {\n    return bridge.entryPoints.asInstanceOf[TempSensor_i_Bridge.EntryPoints].component\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class TempSensor_i_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(currentTemp,\n              tempChanged),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(currentTemp),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(tempChanged)\n  )\n\n  val api : TempSensor_i_Bridge.Api =\n    TempSensor_i_Bridge.Api(\n      id,\n      currentTemp.id,\n      tempChanged.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    TempSensor_i_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      TempSensor_i_Impl(api)\n    )\n}\n\nobject TempSensor_i_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    tempChanged_Id : Art.PortId) {\n\n    def sendtempChanged() : Unit = {\n      Art.putValue(tempChanged_Id, art.Empty())\n    }\n\n    def setcurrentTemp(value : BuildingControl.Temperature_impl) : Unit = {\n      Art.putValue(currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n    }\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    TempSensor_i_BridgeId : Art.BridgeId,\n\n    currentTemp_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : TempSensor_i_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(currentTemp_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(tempChanged_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered()\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempSensor_i.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait TempSensor_i {\n\n  def api : TempSensor_i_Bridge.Api\n\n  def timeTriggered() : Unit = {}\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ the contents of this file will not be overwritten\n@record class TempSensor_i_Impl (val api : TempSensor_i_Bridge.Api) extends TempSensor_i {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setcurrentTemp(BuildingControl.Temperature_impl.empty())\n    api.sendtempChanged()\n  }\n\n  override def timeTriggered(): Unit = {\n    \/\/ example override of timeTriggered\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/BridgeTestSuite.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[building_control_gen_mixed.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/BuildingControlDemo_i_Instance_tcp_tempControl_Test.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass BuildingControlDemo_i_Instance_tcp_tempControl_Test extends BridgeTestSuite[TempControl_i_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_tempControl) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in DataPort\n  def put_currentTemp(value : BuildingControl.Temperature_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_fanAck(value : BuildingControl.FanAck.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.fanAck_Id, BuildingControl.FanAck_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_setPoint(value : BuildingControl.SetPoint_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.setPoint_Id, BuildingControl.SetPoint_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_tempChanged(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.tempChanged_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanCmd(): Option[BuildingControl.FanCmd.Type] = {\n    val value: Option[BuildingControl.FanCmd.Type] = get_fanCmd_payload() match {\n      case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\") \n      case _ => None[BuildingControl.FanCmd.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanCmd_payload(): Option[BuildingControl.FanCmd_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.fanCmd_Id).asInstanceOf[Option[BuildingControl.FanCmd_Payload]]\n  }\n\n  def getComponent(): TempControl_i_Impl = {\n    return bridge.entryPoints.asInstanceOf[TempControl_i_Bridge.EntryPoints].component\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempControl_i_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class TempControl_i_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  fanAck: Port[BuildingControl.FanAck.Type],\n  setPoint: Port[BuildingControl.SetPoint_impl],\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(currentTemp,\n              fanAck,\n              setPoint,\n              fanCmd,\n              tempChanged),\n\n    dataIns = ISZ(currentTemp),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(fanAck,\n                   setPoint,\n                   tempChanged),\n\n    eventOuts = ISZ(fanCmd)\n  )\n\n  val api : TempControl_i_Bridge.Api =\n    TempControl_i_Bridge.Api(\n      id,\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    TempControl_i_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      TempControl_i_Impl(api)\n    )\n}\n\nobject TempControl_i_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    setPoint_Id : Art.PortId,\n    fanCmd_Id : Art.PortId,\n    tempChanged_Id : Art.PortId) {\n\n    def getfanAck() : Option[BuildingControl.FanAck.Type] = {\n      val value : Option[BuildingControl.FanAck.Type] = Art.getValue(fanAck_Id) match {\n        case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\")\n          None[BuildingControl.FanAck.Type]() \n        case _ => None[BuildingControl.FanAck.Type]()\n      }\n      return value\n    }\n\n    def getsetPoint() : Option[BuildingControl.SetPoint_impl] = {\n      val value : Option[BuildingControl.SetPoint_impl] = Art.getValue(setPoint_Id) match {\n        case Some(BuildingControl.SetPoint_impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port setPoint.  Expecting 'BuildingControl.SetPoint_impl_Payload' but received ${v}\")\n          None[BuildingControl.SetPoint_impl]() \n        case _ => None[BuildingControl.SetPoint_impl]()\n      }\n      return value\n    }\n\n    def sendfanCmd(value : BuildingControl.FanCmd.Type) : Unit = {\n      Art.putValue(fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n    }\n\n    def gettempChanged() : Option[art.Empty] = {\n      val value : Option[art.Empty] = Art.getValue(tempChanged_Id) match {\n        case Some(Empty()) => Some(Empty())\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port tempChanged.  Expecting 'Empty' but received ${v}\")\n          None[art.Empty]() \n        case _ => None[art.Empty]()\n      }\n      return value\n    }\n\n    def getcurrentTemp() : Option[BuildingControl.Temperature_impl] = {\n      val value : Option[BuildingControl.Temperature_impl] = Art.getValue(currentTemp_Id) match {\n        case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\")\n          None[BuildingControl.Temperature_impl]() \n        case _ => None[BuildingControl.Temperature_impl]()\n      }\n      return value\n    }\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    TempControl_i_BridgeId : Art.BridgeId,\n\n    currentTemp_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    setPoint_Id : Art.PortId,\n    fanCmd_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : TempControl_i_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(currentTemp_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(fanAck_Id,\n                                              setPoint_Id,\n                                              tempChanged_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(fanCmd_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n          component.handlefanAck(value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n          component.handlesetPoint(value)\n        }\n        else if(portId == tempChanged_Id) {\n          component.handletempChanged()\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n          component.handlefanAck(value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n          component.handlesetPoint(value)\n        }\n        else if(portId == tempChanged_Id) {\n          component.handletempChanged()\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempControl_i.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait TempControl_i {\n\n  def api : TempControl_i_Bridge.Api\n\n  def handlefanAck(value : BuildingControl.FanAck.Type): Unit = {\n    api.logInfo(\"default handlefanAck implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handlesetPoint(value : BuildingControl.SetPoint_impl): Unit = {\n    api.logInfo(\"default handlesetPoint implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handletempChanged(): Unit = {\n    api.logInfo(\"default handletempChanged implementation\")\n    api.logInfo(\"received tempChanged\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempControl_i_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ the contents of this file will not be overwritten\n@record class TempControl_i_Impl (val api : TempControl_i_Bridge.Api) extends TempControl_i {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_currentTemp: Option[BuildingControl.Temperature_impl] = api.getcurrentTemp()\n    val apiUsage_fanAck: Option[BuildingControl.FanAck.Type] = api.getfanAck()\n    val apiUsage_setPoint: Option[BuildingControl.SetPoint_impl] = api.getsetPoint()\n    api.sendfanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n    val apiUsage_tempChanged: Option[art.Empty] = api.gettempChanged()\n  }\n\n  override def handlefanAck(value : BuildingControl.FanAck.Type): Unit = {\n    api.logInfo(\"example handlefanAck implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  override def handlesetPoint(value : BuildingControl.SetPoint_impl): Unit = {\n    api.logInfo(\"example handlesetPoint implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  override def handletempChanged(): Unit = {\n    api.logInfo(\"example handletempChanged implementation\")\n    api.logInfo(\"received tempChanged\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/BuildingControlDemo_i_Instance_tcp_fan_Test.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\nimport org.sireum._\n\n\/\/ the contents of this file will not be overwritten\nclass BuildingControlDemo_i_Instance_tcp_fan_Test extends BridgeTestSuite[Fan_i_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_fan) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_fanCmd(value : BuildingControl.FanCmd.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.api.fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanAck(): Option[BuildingControl.FanAck.Type] = {\n    val value: Option[BuildingControl.FanAck.Type] = get_fanAck_payload() match {\n      case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\") \n      case _ => None[BuildingControl.FanAck.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanAck_payload(): Option[BuildingControl.FanAck_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.api.fanAck_Id).asInstanceOf[Option[BuildingControl.FanAck_Payload]]\n  }\n\n  def getComponent(): Fan_i_Impl = {\n    return bridge.entryPoints.asInstanceOf[Fan_i_Bridge.EntryPoints].component\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/Fan_i_Bridge.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Fan_i_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  fanAck: Port[BuildingControl.FanAck.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(fanCmd,\n              fanAck),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(fanCmd),\n\n    eventOuts = ISZ(fanAck)\n  )\n\n  val api : Fan_i_Bridge.Api =\n    Fan_i_Bridge.Api(\n      id,\n      fanCmd.id,\n      fanAck.id\n    )\n\n  val entryPoints : Bridge.EntryPoints =\n    Fan_i_Bridge.EntryPoints(\n      id,\n\n      fanCmd.id,\n      fanAck.id,\n\n      dispatchTriggers,\n\n      Fan_i_Impl(api)\n    )\n}\n\nobject Fan_i_Bridge {\n\n  @record class Api(\n    id : Art.BridgeId,\n    fanCmd_Id : Art.PortId,\n    fanAck_Id : Art.PortId) {\n\n    def getfanCmd() : Option[BuildingControl.FanCmd.Type] = {\n      val value : Option[BuildingControl.FanCmd.Type] = Art.getValue(fanCmd_Id) match {\n        case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n        case Some(v) => \n          Art.logError(id, s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\")\n          None[BuildingControl.FanCmd.Type]() \n        case _ => None[BuildingControl.FanCmd.Type]()\n      }\n      return value\n    }\n\n    def sendfanAck(value : BuildingControl.FanAck.Type) : Unit = {\n      Art.putValue(fanAck_Id, BuildingControl.FanAck_Payload(value))\n    }\n\n\n    def logInfo(msg: String): Unit = {\n      Art.logInfo(id, msg)\n    }\n\n    def logDebug(msg: String): Unit = {\n      Art.logDebug(id, msg)\n    }\n\n    def logError(msg: String): Unit = {\n      Art.logError(id, msg)\n    }\n  }\n\n  @record class EntryPoints(\n    Fan_i_BridgeId : Art.BridgeId,\n\n    fanCmd_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    component : Fan_i_Impl ) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(fanCmd_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(fanAck_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n          component.handlefanCmd(value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] = \n        if(dispatchTriggers.isEmpty) receivedEvents \n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n          component.handlefanCmd(value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate: Unit = {\n      component.activate()\n    }\n\n    def deactivate: Unit = {\n      component.deactivate()\n    }\n\n    def finalise: Unit = {\n      component.finalise()\n    }\n\n    def initialise: Unit = {\n      component.initialise()\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover: Unit = {\n      component.recover()\n    }\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/Fan_i.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@msig trait Fan_i {\n\n  def api : Fan_i_Bridge.Api\n\n  def handlefanCmd(value : BuildingControl.FanCmd.Type): Unit = {\n    api.logInfo(\"default handlefanCmd implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def activate(): Unit = {}\n\n  def deactivate(): Unit = {}\n\n  def finalise(): Unit = {}\n\n  def initialise(): Unit = {}\n\n  def recover(): Unit = {}\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/Fan_i_Impl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ the contents of this file will not be overwritten\n@record class Fan_i_Impl (val api : Fan_i_Bridge.Api) extends Fan_i {\n\n  override def initialise(): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    val apiUsage_fanCmd: Option[BuildingControl.FanCmd.Type] = api.getfanCmd()\n    api.sendfanAck(BuildingControl.FanAck.byOrdinal(0).get)\n  }\n\n  override def handlefanCmd(value : BuildingControl.FanCmd.Type): Unit = {\n    api.logInfo(\"example handlefanCmd implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  override def activate(): Unit = {\n    \/\/ example override of activate\n  }\n\n  override def deactivate(): Unit = {\n    \/\/ example override of deactivate\n  }\n\n  override def finalise(): Unit = {\n    \/\/ example override of finalise\n  }\n\n  override def recover(): Unit = {\n    \/\/ example override of recover\n  }\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempSensor\/tempSensor.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempSensor\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.TempSensor_i_seL4Nix\n\nobject tempSensor extends App {\n\n  val tempSensorBridge : building_control_gen_mixed.BuildingControl.TempSensor_i_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp\", mode = DataOut)\n    val tempChanged = Port[art.Empty] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.TempSensor_i_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempSensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      tempChanged = tempChanged\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = tempSensorBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ currentTemp: Out DataPort BuildingControl.Temperature_impl\n  val currentTemp_id: Art.PortId = tempSensorBridge.currentTemp.id\n  var currentTemp_port: Option[DataContent] = noData\n\n  \/\/ tempChanged: Out EventPort art.Empty\n  val tempChanged_id: Art.PortId = tempSensorBridge.tempChanged.id\n  var tempChanged_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    halt(s\"Unexpected: tempSensor.getValue called with: ${portId}\")\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == currentTemp_id) {\n      currentTemp_port = Some(data)\n    } else if(portId == tempChanged_id) {\n      tempChanged_port = Some(data)\n    } else {\n      halt(s\"Unexpected: tempSensor.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(currentTemp_port.nonEmpty) {\n      TempSensor_i_seL4Nix.currentTemp_Send(currentTemp_port.get)\n      currentTemp_port = noData\n    }\n\n    if(tempChanged_port.nonEmpty) {\n      TempSensor_i_seL4Nix.tempChanged_Send(tempChanged_port.get)\n      tempChanged_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = { \n    val ad = ArchitectureDescription(\n      components = MSZ (tempSensorBridge),\n      connections = ISZ ()\n    )   \n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n    printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n    printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.empty()))\n    printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.empty()))\n    printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n    printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_seL4Nix.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object TempSensor_i_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's currentTemp port\n  def currentTemp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's tempChanged port\n  def tempChanged_Send(d: DataContent): Unit = $\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_seL4Nix_Ext.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject TempSensor_i_seL4Nix_Ext {\n  def currentTemp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def tempChanged_Send(d: DataContent): Unit = halt(\"stub\")\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c", { "type" : "Resource","content" : "#include <all.h>\n#include <ext.h>\n\n\/\/ add c extension code here","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h", { "type" : "Resource","content" : "#ifndef EXT_H\n#define EXT_H\n\n#endif","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl_api.h", { "type" : "Resource","content" : "#ifndef TEMPSENSOR_I_IMPL_API_H\n#define TEMPSENSOR_I_IMPL_API_H\n\n#include <all.h>\n\nUnit api_send_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  building_control_gen_mixed_BuildingControl_Temperature_impl value);\n\nUnit api_send_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this);\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str);\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str);\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str);\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl_api.c", { "type" : "Resource","content" : "#include <TempSensor_i_Impl_api.h>\n\nUnit api_send_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  building_control_gen_mixed_BuildingControl_Temperature_impl value) {\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Bridge_Api_setcurrentTemp_(\n    building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_api_(this),\n    value);\n}\n\nUnit api_send_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this) {\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Bridge_Api_sendtempChanged_(\n    building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_api_(this));\n}\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Bridge_Api_logInfo_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Bridge_Api_logDebug_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Bridge_Api_logError_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_api_(this),\n    str);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl.c", { "type" : "Resource","content" : "#include <TempSensor_i_Impl_api.h>\n#include <ext.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_initialise_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this) {\n \/\/ example api usage\n\n api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(this, string(\"Example logInfo\"));\n api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(this, string(\"Example logDebug\"));\n api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_Impl(this, string(\"Example logError\"));\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_Impl_timeTriggered_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Impl this) {}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempSensor\/TempSensor_i_adapter.c", { "type" : "Resource","content" : "#include <TempSensor_i_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseArchitecture() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempSensor_tempSensor_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempSensor_tempSensor_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_computeEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempSensor_tempSensor_computeEntryPoint(SF_LAST);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempSensor\/TempSensor_i_adapter.h", { "type" : "Resource","content" : "#ifndef TEMPSENSOR_I_ADAPTER_H\n#define TEMPSENSOR_I_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseArchitecture();\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseEntryPoint();\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_computeEntryPoint();\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_fan\/fan.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_fan\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.Fan_i_seL4Nix\n\nobject fan extends App {\n\n  val fanBridge : building_control_gen_mixed.BuildingControl.Fan_i_Bridge = {\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanCmd\", mode = EventIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanAck\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.Fan_i_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_fan\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      fanCmd = fanCmd,\n      fanAck = fanAck\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = fanBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ fanCmd: In EventDataPort BuildingControl.FanCmd\n  val fanCmd_id: Art.PortId = fanBridge.fanCmd.id\n  var fanCmd_port: Option[DataContent] = noData\n\n  \/\/ fanAck: Out EventDataPort BuildingControl.FanAck\n  val fanAck_id: Art.PortId = fanBridge.fanAck.id\n  var fanAck_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    var portIds: ISZ[Art.PortId] = ISZ()\n    if(!Fan_i_seL4Nix.fanCmd_IsEmpty()) {\n      portIds = portIds :+ fanCmd_id\n    }\n    return EventTriggered(portIds)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == fanCmd_id) {\n      return fanCmd_port\n    } else {\n      halt(s\"Unexpected: fan.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    fanCmd_port = Fan_i_seL4Nix.fanCmd_Receive()  \n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == fanAck_id) {\n      fanAck_port = Some(data)\n    } else {\n      halt(s\"Unexpected: fan.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(fanAck_port.nonEmpty) {\n      Fan_i_seL4Nix.fanAck_Send(fanAck_port.get)\n      fanAck_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = { \n    val ad = ArchitectureDescription(\n      components = MSZ (fanBridge),\n      connections = ISZ ()\n    )   \n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n    printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n    printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.empty()))\n    printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.empty()))\n    printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n    printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/Fan_i_seL4Nix.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object Fan_i_seL4Nix {\n  \/\/ returns T if seL4's fanCmd port is empty, F otherwise \n  def fanCmd_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's fanCmd port \n  def fanCmd_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's fanAck port\n  def fanAck_Send(d: DataContent): Unit = $\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/Fan_i_seL4Nix_Ext.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject Fan_i_seL4Nix_Ext {\n  def fanCmd_IsEmpty(): B = halt(\"stub\")\n\n  def fanCmd_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanAck_Send(d: DataContent): Unit = halt(\"stub\")\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl_api.h", { "type" : "Resource","content" : "#ifndef FAN_I_IMPL_API_H\n#define FAN_I_IMPL_API_H\n\n#include <all.h>\n\nB api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanCmd *value);\n\nUnit api_send_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanAck value);\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str);\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str);\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str);\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl_api.c", { "type" : "Resource","content" : "#include <Fan_i_Impl_api.h>\n\nB api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanCmd *value){\n  \/\/ Option_4B44C1 = Option[building_control_gen_mixed.BuildingControl.FanCmd.Type]\n  \/\/ Some_A25D33 = Some[building_control_gen_mixed.BuildingControl.FanCmd.Type]\n  DeclNewOption_4B44C1(t_0);\n  building_control_gen_mixed_BuildingControl_Fan_i_Bridge_Api_getfanCmd_(\n    SF\n    (Option_4B44C1) &t_0,\n    building_control_gen_mixed_BuildingControl_Fan_i_Impl_api_(this));\n\n  if(t_0.type == TSome_A25D33){\n    Type_assign(value, &t_0.Some_A25D33.value, sizeof(building_control_gen_mixed_BuildingControl_FanCmd));\n    return T;\n  } else {\n    return F;\n  }\n}\n\nUnit api_send_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanAck value) {\n\n  building_control_gen_mixed_BuildingControl_Fan_i_Bridge_Api_sendfanAck_(\n    building_control_gen_mixed_BuildingControl_Fan_i_Impl_api_(this),\n    value);\n}\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_Fan_i_Bridge_Api_logInfo_(\n    SF\n    building_control_gen_mixed_BuildingControl_Fan_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_Fan_i_Bridge_Api_logDebug_(\n    SF\n    building_control_gen_mixed_BuildingControl_Fan_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_Fan_i_Impl(\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_Fan_i_Bridge_Api_logError_(\n    SF\n    building_control_gen_mixed_BuildingControl_Fan_i_Impl_api_(this),\n    str);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl.c", { "type" : "Resource","content" : "#include <Fan_i_Impl_api.h>\n#include <ext.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_Impl_initialise_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this) {\n \/\/ example api usage\n\n api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_Impl(this, string(\"Example logInfo\"));\n api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_Impl(this, string(\"Example logDebug\"));\n api_logError__building_control_gen_mixed_BuildingControl_Fan_i_Impl(this, string(\"Example logError\"));\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_Impl_handlefanCmd_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Fan_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanCmd value) {\n\n  DeclNewString(fanCmdString);\n  String__append((String) &fanCmdString, string(\"building_control_gen_mixed_BuildingControl_Fan_i_Impl_handlefanCmd called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_Impl (this, (String) &fanCmdString);\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_fan\/Fan_i_adapter.c", { "type" : "Resource","content" : "#include <Fan_i_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseArchitecture() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_fan_fan_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_fan_fan_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_computeEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_fan_fan_computeEntryPoint(SF_LAST);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_fan\/Fan_i_adapter.h", { "type" : "Resource","content" : "#ifndef FAN_I_ADAPTER_H\n#define FAN_I_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseArchitecture();\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseEntryPoint();\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_adapter_computeEntryPoint();\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempControl\/tempControl.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempControl\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.TempControl_i_seL4Nix\n\nobject tempControl extends App {\n\n  val tempControlBridge : building_control_gen_mixed.BuildingControl.TempControl_i_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp\", mode = DataIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanAck\", mode = EventIn)\n    val setPoint = Port[BuildingControl.SetPoint_impl] (id = 2, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_setPoint\", mode = EventIn)\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 3, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd\", mode = EventOut)\n    val tempChanged = Port[art.Empty] (id = 4, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged\", mode = EventIn)\n\n    building_control_gen_mixed.BuildingControl.TempControl_i_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempControl\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      fanAck = fanAck,\n      setPoint = setPoint,\n      fanCmd = fanCmd,\n      tempChanged = tempChanged\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = tempControlBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ currentTemp: In DataPort BuildingControl.Temperature_impl\n  val currentTemp_id: Art.PortId = tempControlBridge.currentTemp.id\n  var currentTemp_port: Option[DataContent] = noData\n\n  \/\/ fanAck: In EventDataPort BuildingControl.FanAck\n  val fanAck_id: Art.PortId = tempControlBridge.fanAck.id\n  var fanAck_port: Option[DataContent] = noData\n\n  \/\/ setPoint: In EventDataPort BuildingControl.SetPoint_impl\n  val setPoint_id: Art.PortId = tempControlBridge.setPoint.id\n  var setPoint_port: Option[DataContent] = noData\n\n  \/\/ fanCmd: Out EventDataPort BuildingControl.FanCmd\n  val fanCmd_id: Art.PortId = tempControlBridge.fanCmd.id\n  var fanCmd_port: Option[DataContent] = noData\n\n  \/\/ tempChanged: In EventPort art.Empty\n  val tempChanged_id: Art.PortId = tempControlBridge.tempChanged.id\n  var tempChanged_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    var portIds: ISZ[Art.PortId] = ISZ()\n    if(!TempControl_i_seL4Nix.fanAck_IsEmpty()) {\n      portIds = portIds :+ fanAck_id\n    }\n    if(!TempControl_i_seL4Nix.setPoint_IsEmpty()) {\n      portIds = portIds :+ setPoint_id\n    }\n    if(!TempControl_i_seL4Nix.tempChanged_IsEmpty()) {\n      portIds = portIds :+ tempChanged_id\n    }\n    return EventTriggered(portIds)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == currentTemp_id) {\n      return currentTemp_port\n    } else if(portId == fanAck_id) {\n      return fanAck_port\n    } else if(portId == setPoint_id) {\n      return setPoint_port\n    } else if(portId == tempChanged_id) {\n      return tempChanged_port\n    } else {\n      halt(s\"Unexpected: tempControl.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    currentTemp_port = TempControl_i_seL4Nix.currentTemp_Receive()\n\n    fanAck_port = TempControl_i_seL4Nix.fanAck_Receive()\n\n    setPoint_port = TempControl_i_seL4Nix.setPoint_Receive()\n\n    tempChanged_port = TempControl_i_seL4Nix.tempChanged_Receive()  \n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == fanCmd_id) {\n      fanCmd_port = Some(data)\n    } else {\n      halt(s\"Unexpected: tempControl.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(fanCmd_port.nonEmpty) {\n      TempControl_i_seL4Nix.fanCmd_Send(fanCmd_port.get)\n      fanCmd_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = { \n    val ad = ArchitectureDescription(\n      components = MSZ (tempControlBridge),\n      connections = ISZ ()\n    )   \n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n    printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n    printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.empty()))\n    printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.empty()))\n    printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n    printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempControl_i_seL4Nix.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object TempControl_i_seL4Nix {\n  \/\/ returns T if seL4's currentTemp port is empty, F otherwise \n  def currentTemp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's currentTemp port \n  def currentTemp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's fanAck port is empty, F otherwise \n  def fanAck_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's fanAck port \n  def fanAck_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's setPoint port is empty, F otherwise \n  def setPoint_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's setPoint port \n  def setPoint_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's fanCmd port\n  def fanCmd_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's tempChanged port is empty, F otherwise \n  def tempChanged_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's tempChanged port \n  def tempChanged_Receive(): Option[DataContent] = $\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempControl_i_seL4Nix_Ext.scala", { "type" : "Resource","content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject TempControl_i_seL4Nix_Ext {\n  def currentTemp_IsEmpty(): B = halt(\"stub\")\n\n  def currentTemp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanAck_IsEmpty(): B = halt(\"stub\")\n\n  def fanAck_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def setPoint_IsEmpty(): B = halt(\"stub\")\n\n  def setPoint_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanCmd_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def tempChanged_IsEmpty(): B = halt(\"stub\")\n\n  def tempChanged_Receive(): Option[DataContent] = halt(\"stub\")\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl_api.h", { "type" : "Resource","content" : "#ifndef TEMPCONTROL_I_IMPL_API_H\n#define TEMPCONTROL_I_IMPL_API_H\n\n#include <all.h>\n\nB api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_Temperature_impl value);\n\nB api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanAck *value);\n\nB api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value);\n\nUnit api_send_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanCmd value);\n\nB api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  art_Empty value);\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str);\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str);\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str);\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl_api.c", { "type" : "Resource","content" : "#include <TempControl_i_Impl_api.h>\n\nB api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_Temperature_impl value){\n  \/\/ Option_798EF5 = Option[building_control_gen_mixed.BuildingControl.Temperature_impl]\n  \/\/ Some_BE9CDE = Some[building_control_gen_mixed.BuildingControl.Temperature_impl]\n  DeclNewOption_798EF5(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_getcurrentTemp_(\n    SF\n    (Option_798EF5) &t_0,\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this));\n\n  if(t_0.type == TSome_BE9CDE){\n    Type_assign(value, &t_0.Some_BE9CDE.value, sizeof(struct building_control_gen_mixed_BuildingControl_Temperature_impl));\n    return T;\n  } else {\n    return F;\n  }\n}\n\nB api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanAck *value){\n  \/\/ Option_4CF4EB = Option[building_control_gen_mixed.BuildingControl.FanAck.Type]\n  \/\/ Some_132C1C = Some[building_control_gen_mixed.BuildingControl.FanAck.Type]\n  DeclNewOption_4CF4EB(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_getfanAck_(\n    SF\n    (Option_4CF4EB) &t_0,\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this));\n\n  if(t_0.type == TSome_132C1C){\n    Type_assign(value, &t_0.Some_132C1C.value, sizeof(building_control_gen_mixed_BuildingControl_FanAck));\n    return T;\n  } else {\n    return F;\n  }\n}\n\nB api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value){\n  \/\/ Option_D2E008 = Option[building_control_gen_mixed.BuildingControl.SetPoint_impl]\n  \/\/ Some_503278 = Some[building_control_gen_mixed.BuildingControl.SetPoint_impl]\n  DeclNewOption_D2E008(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_getsetPoint_(\n    SF\n    (Option_D2E008) &t_0,\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this));\n\n  if(t_0.type == TSome_503278){\n    Type_assign(value, &t_0.Some_503278.value, sizeof(struct building_control_gen_mixed_BuildingControl_SetPoint_impl));\n    return T;\n  } else {\n    return F;\n  }\n}\n\nUnit api_send_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanCmd value) {\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_sendfanCmd_(\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this),\n    value);\n}\n\nB api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  art_Empty value){\n  \/\/ Option_C622DB = Option[art.Empty]\n  \/\/ Some_4782C6 = Some[art.Empty]\n  DeclNewOption_C622DB(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_gettempChanged_(\n    SF\n    (Option_C622DB) &t_0,\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this));\n\n  if(t_0.type == TSome_4782C6){\n    Type_assign(value, &t_0.Some_4782C6.value, sizeof(struct art_Empty));\n    return T;\n  } else {\n    return F;\n  }\n}\n\nUnit api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_logInfo_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_logDebug_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this),\n    str);\n}\n\nUnit api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  String str) {\n  building_control_gen_mixed_BuildingControl_TempControl_i_Bridge_Api_logError_(\n    SF\n    building_control_gen_mixed_BuildingControl_TempControl_i_Impl_api_(this),\n    str);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl.c", { "type" : "Resource","content" : "#include <TempControl_i_Impl_api.h>\n#include <ext.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_Impl_initialise_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this) {\n \/\/ example api usage\n\n api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(this, string(\"Example logInfo\"));\n api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(this, string(\"Example logDebug\"));\n api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_Impl(this, string(\"Example logError\"));\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handlefanAck_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_FanAck value) {\n\n  DeclNewString(fanAckString);\n  String__append((String) &fanAckString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handlefanAck called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl (this, (String) &fanAckString);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handlesetPoint_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this,\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value) {\n\n  DeclNewString(setPointString);\n  String__append((String) &setPointString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handlesetPoint called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl (this, (String) &setPointString);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handletempChanged_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Impl this) {\n\n  DeclNewString(tempChangedString);\n  String__append((String) &tempChangedString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_Impl_handletempChanged called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_Impl (this, (String) &tempChangedString);\n}\n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempControl\/TempControl_i_adapter.c", { "type" : "Resource","content" : "#include <TempControl_i_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseArchitecture() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempControl_tempControl_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempControl_tempControl_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_computeEntryPoint() {\n  building_control_gen_mixed_BuildingControlDemo_i_Instance_tcp_tempControl_tempControl_computeEntryPoint(SF_LAST);\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempControl\/TempControl_i_adapter.h", { "type" : "Resource","content" : "#ifndef TEMPCONTROL_I_ADAPTER_H\n#define TEMPCONTROL_I_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseArchitecture();\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseEntryPoint();\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_adapter_computeEntryPoint();\n\n#endif\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/SlangTypeLibrary\/SlangTypeLibrary.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n    printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n    printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.empty()))\n    printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.empty()))\n    printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n    printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/compile-hamr-lib.sh", { "type" : "Resource","content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\ncd \"${SCRIPT_HOME}\/hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\"\nmkdir -p sel4-build\ncd sel4-build\ncmake ..\nmake $MAKE_ARGS\n\n\ncd \"${SCRIPT_HOME}\/hamr\/BuildingControlDemo_i_Instance_tcp_fan\"\nmkdir -p sel4-build\ncd sel4-build\ncmake ..\nmake $MAKE_ARGS\n\n\ncd \"${SCRIPT_HOME}\/hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\"\nmkdir -p sel4-build\ncd sel4-build\ncmake ..\nmake $MAKE_ARGS\n\n\ncd \"${SCRIPT_HOME}\/hamr\/SlangTypeLibrary\"\nmkdir -p sel4-build\ncd sel4-build\ncmake ..\nmake $MAKE_ARGS\n\n","overwrite" : true,"makeExecutable" : true}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/transpile-sel4.sh", { "type" : "Resource","content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempSensor\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"main\" \\\n  --apps \"building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempSensor.tempSensor\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --forward \"art.ArtNative=building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempSensor.tempSensor\" \\\n  --stack-size \"110592\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_Impl\/TempSensor_i_Impl.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempSensor\/TempSensor_i_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempSensor\/TempSensor_i_adapter.c\" \\\n  --exclude-build \"building_control_gen_mixed.BuildingControl.TempSensor_i_Impl,building_control_gen_mixed.BuildingControl.Fan_i_Impl,building_control_gen_mixed.BuildingControl.TempControl_i_Impl\" \\\n  --lib-only \\\n  --verbose\n\nFILE=${OUTPUT_DIR}\/CMakeLists.txt\necho -e \"\\n\\nadd_definitions(-DCAMKES)\" >> $FILE\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/hamr\/BuildingControlDemo_i_Instance_tcp_fan\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_fan\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"main\" \\\n  --apps \"building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_fan.fan\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --forward \"art.ArtNative=building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_fan.fan\" \\\n  --stack-size \"110592\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_Impl\/Fan_i_Impl.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_fan\/Fan_i_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_fan\/Fan_i_adapter.c\" \\\n  --exclude-build \"building_control_gen_mixed.BuildingControl.TempSensor_i_Impl,building_control_gen_mixed.BuildingControl.Fan_i_Impl,building_control_gen_mixed.BuildingControl.TempControl_i_Impl\" \\\n  --lib-only \\\n  --verbose\n\nFILE=${OUTPUT_DIR}\/CMakeLists.txt\necho -e \"\\n\\nadd_definitions(-DCAMKES)\" >> $FILE\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempControl\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"main\" \\\n  --apps \"building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempControl.tempControl\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=5\" \\\n  --forward \"art.ArtNative=building_control_gen_mixed.BuildingControlDemo_i_Instance_tcp_tempControl.tempControl\" \\\n  --stack-size \"110592\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_Impl\/TempControl_i_Impl.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempControl\/TempControl_i_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/BuildingControlDemo_i_Instance_tcp_tempControl\/TempControl_i_adapter.c\" \\\n  --exclude-build \"building_control_gen_mixed.BuildingControl.TempSensor_i_Impl,building_control_gen_mixed.BuildingControl.Fan_i_Impl,building_control_gen_mixed.BuildingControl.TempControl_i_Impl\" \\\n  --lib-only \\\n  --verbose\n\nFILE=${OUTPUT_DIR}\/CMakeLists.txt\necho -e \"\\n\\nadd_definitions(-DCAMKES)\" >> $FILE\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/hamr\/SlangTypeLibrary\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/SlangTypeLibrary\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"main\" \\\n  --apps \"building_control_gen_mixed.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --forward \"art.ArtNative=building_control_gen_mixed.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --lib-only \\\n  --verbose\n\nFILE=${OUTPUT_DIR}\/CMakeLists.txt\necho -e \"\\n\\nadd_definitions(-DCAMKES)\" >> $FILE","overwrite" : true,"makeExecutable" : true}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/Art.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 3\n  val maxPorts: PortId = 9\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import scala.collection.JavaConverters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala", { "type" : "Resource","content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtDebug_Ext.start()\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import scala.collection.JavaConverters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]\n    }\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala", { "type" : "Resource","content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/slang-embedded\/build.sbt", { "type" : "Resource","content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ To open the following project in Sireum IVE select 'File > Open ...' and then\n\/\/ navigate to the directory containing this file then click 'OK'.  To install\n\/\/ Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\nlazy val BuildingControlDemo_i_Instance = slangEmbeddedTestProject(\"BuildingControlDemo_i_Instance\", \".\")\n\n\nval scalaVer = \"2.12.10\"\n\nval sireumScalacVersion = \"4.20200212.6edf3e0\" \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20200212.6edf3e0\n\nval runtimeVersion = \"716ec0e\" \/\/ https:\/\/github.com\/sireum\/runtime\/tree\/716ec0e\n\nval scalaTestVersion = \"3.1.0\"\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.runtime\" %% \"library\" % runtimeVersion withSources() withJavadoc()\n  )\n)\n\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\"\n)\n\ndef standardProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).settings(commonSettings)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedTestProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++\n      Seq(\n        Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n        libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\")\n    )        \n","overwrite" : false,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempSensor_i\/TempSensor_i.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_BuildingControl__Temperature_impl.idl4\";\nimport \"..\/..\/interfaces\/AADLEvent_Sender.idl4\";\nimport <std_connector.camkes>;\n\ncomponent TempSensor_i {\n  include <sb_proc_types.h>;\n  control;\n  uses sb_Monitor_BuildingControl__Temperature_impl sb_currentTemp0;\n  uses AADLEvent_Sender sb_tempChanged0;\n  consumes Notification sb_periodic_dispatch_notification;\n  has semaphore sb_dispatch_sem;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempControl_i\/TempControl_i.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_BuildingControl__Temperature_impl.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_BuildingControl__FanAck_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_BuildingControl__FanCmd_1.idl4\";\nimport \"..\/..\/interfaces\/AADLEvent_Receiver.idl4\";\n\ncomponent TempControl_i {\n  include <sb_proc_types.h>;\n  control;\n  uses sb_Monitor_BuildingControl__Temperature_impl sb_currentTemp;\n  uses sb_Monitor_BuildingControl__FanAck_1 sb_fanAck;\n  uses sb_Monitor_BuildingControl__FanCmd_1 sb_fanCmd0;\n  uses AADLEvent_Receiver sb_tempChanged;\n  consumes DataportWrite sb_currentTemp_notification;\n  consumes QueuedData sb_fanAck_notification;\n  consumes ReceiveEvent sb_tempChanged_notification;\n  has semaphore sb_dispatch_sem;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/Fan_i\/Fan_i.camkes", { "type" : "Resource","content" : "import \"..\/..\/interfaces\/sb_Monitor_BuildingControl__FanCmd_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_BuildingControl__FanAck_1.idl4\";\n\ncomponent Fan_i {\n  include <sb_proc_types.h>;\n  control;\n  uses sb_Monitor_BuildingControl__FanCmd_1 sb_fanCmd;\n  uses sb_Monitor_BuildingControl__FanAck_1 sb_fanAck0;\n  consumes QueuedData sb_fanCmd_notification;\n  has semaphore sb_dispatch_sem;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/sb_fan_fanCmd_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_BuildingControl__FanCmd_1.idl4\";\n\ncomponent sb_fan_fanCmd_Monitor {\n\n  provides sb_Monitor_BuildingControl__FanCmd_1 mon;\n  emits QueuedData monsig;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/sb_tempControl_currentTemp_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_BuildingControl__Temperature_impl.idl4\";\n\ncomponent sb_tempControl_currentTemp_Monitor {\n\n  provides sb_Monitor_BuildingControl__Temperature_impl mon;\n  emits DataportWrite monsig;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/sb_tempControl_fanAck_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_BuildingControl__FanAck_1.idl4\";\n\ncomponent sb_tempControl_fanAck_Monitor {\n\n  provides sb_Monitor_BuildingControl__FanAck_1 mon;\n  emits QueuedData monsig;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/sb_tempControl_tempChanged_Monitor.camkes", { "type" : "Resource","content" : "import \"..\/..\/..\/interfaces\/AADLEvent_Receiver.idl4\";\nimport \"..\/..\/..\/interfaces\/AADLEvent_Sender.idl4\";\n\ncomponent sb_tempControl_tempChanged_Monitor {\n\n  provides AADLEvent_Receiver mon_receive;\n  provides AADLEvent_Sender mon_send;\n  emits ReceiveEvent monsig;\n  has mutex m;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/dispatch_periodic\/dispatch_periodic.camkes", { "type" : "Resource","content" : "import <global-connectors.camkes>;\n\ncomponent dispatch_periodic {\n  control;\n  uses Timer timer;\n  emits Notification sb_tempSensor_periodic_dispatch_notification;\n  consumes Notification timer_complete;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/tcp.camkes", { "type" : "Resource","content" : "import <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <TimeServer\/TimeServer.camkes>;;\nimport \"components\/TempSensor_i\/TempSensor_i.camkes\";\nimport \"components\/TempControl_i\/TempControl_i.camkes\";\nimport \"components\/Fan_i\/Fan_i.camkes\";\nimport \"components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/sb_fan_fanCmd_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/sb_tempControl_currentTemp_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/sb_tempControl_fanAck_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/sb_tempControl_tempChanged_Monitor.camkes\";\nimport \"components\/dispatch_periodic\/dispatch_periodic.camkes\";\n\nassembly {\n  composition {\n    component TempSensor_i tempSensor;\n    component TempControl_i tempControl;\n    component Fan_i fan;\n    component sb_fan_fanCmd_Monitor sb_fan_fancmd_monitor;\n    component sb_tempControl_currentTemp_Monitor sb_tempcontrol_currenttemp_monitor;\n    component sb_tempControl_fanAck_Monitor sb_tempcontrol_fanack_monitor;\n    component sb_tempControl_tempChanged_Monitor sb_tempcontrol_tempchanged_monitor;\n    component dispatch_periodic dispatch_periodic_inst;\n    component TimeServer time_server;\n\n    connection seL4Notification conn1(from dispatch_periodic_inst.sb_tempSensor_periodic_dispatch_notification, to tempSensor.sb_periodic_dispatch_notification);\n    connection seL4RPCCall conn2(from tempSensor.sb_currentTemp0, to sb_tempcontrol_currenttemp_monitor.mon);\n    connection seL4RPCCall conn3(from tempControl.sb_currentTemp, to sb_tempcontrol_currenttemp_monitor.mon);\n    connection seL4Notification conn4(from sb_tempcontrol_currenttemp_monitor.monsig, to tempControl.sb_currentTemp_notification);\n    connection seL4RPCCall conn5(from tempSensor.sb_tempChanged0, to sb_tempcontrol_tempchanged_monitor.mon_send);\n    connection seL4RPCCall conn6(from tempControl.sb_tempChanged, to sb_tempcontrol_tempchanged_monitor.mon_receive);\n    connection seL4Notification conn7(from sb_tempcontrol_tempchanged_monitor.monsig, to tempControl.sb_tempChanged_notification);\n    connection seL4RPCCall conn8(from tempControl.sb_fanCmd0, to sb_fan_fancmd_monitor.mon);\n    connection seL4RPCCall conn9(from fan.sb_fanCmd, to sb_fan_fancmd_monitor.mon);\n    connection seL4Notification conn10(from sb_fan_fancmd_monitor.monsig, to fan.sb_fanCmd_notification);\n    connection seL4RPCCall conn11(from fan.sb_fanAck0, to sb_tempcontrol_fanack_monitor.mon);\n    connection seL4RPCCall conn12(from tempControl.sb_fanAck, to sb_tempcontrol_fanack_monitor.mon);\n    connection seL4Notification conn13(from sb_tempcontrol_fanack_monitor.monsig, to tempControl.sb_fanAck_notification);\n    connection seL4TimeServer conn14(from dispatch_periodic_inst.timer, to time_server.the_timer);\n    connection seL4GlobalAsynchCallback conn15(from time_server.timer_notification, to dispatch_periodic_inst.timer_complete);\n  }\n\n  configuration {\n    tempSensor._stack_size = 110592;\n    tempControl._stack_size = 110592;\n    fan._stack_size = 110592;\n    time_server.timers_per_client = 1;\n    dispatch_periodic_inst.timer_attributes = 1;\n    dispatch_periodic_inst.priority = 201;\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/interfaces\/sb_Monitor_BuildingControl__FanCmd_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_BuildingControl__FanCmd_1 {\n  include <sb_proc_types.h>;\n  bool is_empty();\n  bool enqueue(refin union_art_DataContent m);\n  bool dequeue(out union_art_DataContent m);\n};","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/src\/sb_fan_fanCmd_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_proc_types.h>\n#include \"..\/includes\/sb_fan_fanCmd_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nunion_art_DataContent contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(union_art_DataContent * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const union_art_DataContent * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/includes\/sb_fan_fanCmd_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_fan_fanCmd_Monitor_H__\n#define __sb_fan_fanCmd_Monitor_H__\n\n#endif \/\/ __sb_fan_fanCmd_Monitor_H__\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/interfaces\/sb_Monitor_BuildingControl__Temperature_impl.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_BuildingControl__Temperature_impl {\n  include <sb_proc_types.h>;\n  bool is_empty();\n  bool read(out union_art_DataContent m);\n  bool write(refin union_art_DataContent m);\n};","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/src\/sb_tempControl_currentTemp_Monitor.c", { "type" : "Resource","content" : "#include <sb_proc_types.h>\n#include \"..\/includes\/sb_tempControl_currentTemp_Monitor.h\"\n\nint monsig_emit(void);\n\nstatic union_art_DataContent contents;\nbool receivedData = false;\n\nbool mon_is_empty() {\n  return !receivedData;\n}\n\nbool mon_read(union_art_DataContent * m) {\n  *m = contents;\n  return receivedData;\n}\n\nbool mon_write(const union_art_DataContent * m) {\n  receivedData = true;\n  contents = *m;\n  monsig_emit();\n  return receivedData;\n}","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/includes\/sb_tempControl_currentTemp_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_tempControl_currentTemp_Monitor_H__\n#define __sb_tempControl_currentTemp_Monitor_H__\n\n#endif \/\/ __sb_tempControl_currentTemp_Monitor_H__\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/interfaces\/sb_Monitor_BuildingControl__FanAck_1.idl4", { "type" : "Resource","content" : "procedure sb_Monitor_BuildingControl__FanAck_1 {\n  include <sb_proc_types.h>;\n  bool is_empty();\n  bool enqueue(refin union_art_DataContent m);\n  bool dequeue(out union_art_DataContent m);\n};","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/src\/sb_tempControl_fanAck_Monitor.c", { "type" : "Resource","content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_proc_types.h>\n#include \"..\/includes\/sb_tempControl_fanAck_Monitor.h\"\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nunion_art_DataContent contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(union_art_DataContent * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const union_art_DataContent * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/includes\/sb_tempControl_fanAck_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_tempControl_fanAck_Monitor_H__\n#define __sb_tempControl_fanAck_Monitor_H__\n\n#endif \/\/ __sb_tempControl_fanAck_Monitor_H__\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/interfaces\/AADLEvent_Receiver.idl4", { "type" : "Resource","content" : "procedure AADLEvent_Receiver {\n  include <sb_proc_types.h>;\n  bool is_empty();\n  bool dequeue();\n};","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/interfaces\/AADLEvent_Sender.idl4", { "type" : "Resource","content" : "procedure AADLEvent_Sender {\n  include <sb_proc_types.h>;\n  bool enqueue();\n};","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/src\/sb_tempControl_tempChanged_Monitor.c", { "type" : "Resource","content" : "#include <camkes.h>\n#include <stdio.h>\n#include <string.h>\n\nint32_t num_events = 0;\n\nstatic inline void ignore_result(long long int unused_result) { (void) unused_result; }\n\n\/\/ Send interfaces\nbool mon_send_enqueue(void) {\n  int do_emit = 0;\n  ignore_result(m_lock());\n  if (num_events < 1) {\n    num_events++;\n    do_emit = 1;\n  }\n  ignore_result(m_unlock());\n  if (do_emit) {\n    monsig_emit();\n  }\n  return true;\n}\n\n\/\/ Receive interfaces \nbool mon_receive_is_empty(void) {\n  return num_events == 0;\n}\n\nbool mon_receive_dequeue(void) {\n  ignore_result(m_lock());\n  bool ret = false;\n  if(num_events > 0){\n    num_events--;\n    ret = true;\n  }\n  ignore_result(m_unlock());\n  return ret;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/includes\/sb_tempControl_tempChanged_Monitor.h", { "type" : "Resource","content" : "#ifdef __sb_tempControl_tempChanged_Monitor_H__\n#define __sb_tempControl_tempChanged_Monitor_H__\n\n#endif \/\/ __sb_tempControl_tempChanged_Monitor_H__\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/CMakeLists.txt", { "type" : "Resource","content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject (tcp C)\n\nadd_definitions(-DCAMKES)\n\nincludeGlobalComponents()\n\nexecute_process(COMMAND bash -c \"${CMAKE_CURRENT_LIST_DIR}\/compile-hamr-lib.sh\")\n\nset(HAMR_LIB_BuildingControlDemo_i_Instance_tcp_tempSensor ${CMAKE_CURRENT_LIST_DIR}\/hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/sel4-build\/libmain.a)\n\nset(HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_tempSensor\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/ext\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/runtime\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/org\/sireum\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/building_control_gen_mixed\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempSensor\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/building_control_gen_mixed\/BuildingControl\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/building_control_gen_mixed\/Base_Types\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/art\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/art\/Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempSensor\/library\/art\/DispatchPropertyProtocol\n)\n\nset(HAMR_LIB_BuildingControlDemo_i_Instance_tcp_tempControl ${CMAKE_CURRENT_LIST_DIR}\/hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/sel4-build\/libmain.a)\n\nset(HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_tempControl\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/ext\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/runtime\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/org\/sireum\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/org\/sireum\/ops\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/building_control_gen_mixed\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/building_control_gen_mixed\/BuildingControl\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/building_control_gen_mixed\/BuildingControl\/TempControl_i_Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_tempControl\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/building_control_gen_mixed\/Base_Types\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/art\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/art\/Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_tempControl\/library\/art\/DispatchPropertyProtocol\n)\n\nset(HAMR_LIB_BuildingControlDemo_i_Instance_tcp_fan ${CMAKE_CURRENT_LIST_DIR}\/hamr\/BuildingControlDemo_i_Instance_tcp_fan\/sel4-build\/libmain.a)\n\nset(HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_fan\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/ext\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/runtime\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/org\/sireum\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/org\/sireum\/ops\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/building_control_gen_mixed\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/building_control_gen_mixed\/BuildingControl\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/building_control_gen_mixed\/BuildingControl\/Fan_i_Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/building_control_gen_mixed\/BuildingControlDemo_i_Instance_tcp_fan\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/building_control_gen_mixed\/Base_Types\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/art\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/art\/Bridge\n  hamr\/BuildingControlDemo_i_Instance_tcp_fan\/library\/art\/DispatchPropertyProtocol\n)\n\nset(HAMR_LIB_SlangTypeLibrary ${CMAKE_CURRENT_LIST_DIR}\/hamr\/SlangTypeLibrary\/sel4-build\/libmain.a)\n\nset(HAMR_INCLUDES_SlangTypeLibrary\n  hamr\/SlangTypeLibrary\/runtime\n  hamr\/SlangTypeLibrary\/library\/org\/sireum\n  hamr\/SlangTypeLibrary\/library\/building_control_gen_mixed\n  hamr\/SlangTypeLibrary\/library\/building_control_gen_mixed\/BuildingControl\n  hamr\/SlangTypeLibrary\/library\/building_control_gen_mixed\/Base_Types\n  hamr\/SlangTypeLibrary\/library\/building_control_gen_mixed\/SlangTypeLibrary\n  hamr\/SlangTypeLibrary\/library\/art\n)\n\nDeclareCAmkESComponent(TempSensor_i\n  SOURCES components\/TempSensor_i\/src\/sb_TempSensor_i.c\n  INCLUDES ${HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_tempSensor} components\/TempSensor_i\/includes\/ includes\n  LIBS ${HAMR_LIB_BuildingControlDemo_i_Instance_tcp_tempSensor}\n)\n\nDeclareCAmkESComponent(TempControl_i\n  SOURCES components\/TempControl_i\/src\/sb_TempControl_i.c\n  INCLUDES ${HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_tempControl} components\/TempControl_i\/includes\/ includes\n  LIBS ${HAMR_LIB_BuildingControlDemo_i_Instance_tcp_tempControl}\n)\n\nDeclareCAmkESComponent(Fan_i\n  SOURCES components\/Fan_i\/src\/sb_Fan_i.c\n  INCLUDES ${HAMR_INCLUDES_BuildingControlDemo_i_Instance_tcp_fan} components\/Fan_i\/includes\/ includes\n  LIBS ${HAMR_LIB_BuildingControlDemo_i_Instance_tcp_fan}\n)\n\nDeclareCAmkESComponent(dispatch_periodic\n  SOURCES components\/dispatch_periodic\/src\/sb_dispatch_periodic.c\n  INCLUDES ${HAMR_INCLUDES_SlangTypeLibrary} includes\n  LIBS ${HAMR_LIB_SlangTypeLibrary}\n)\n\nDeclareCAmkESComponent(sb_fan_fanCmd_Monitor\n  SOURCES components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/src\/sb_fan_fanCmd_Monitor.c\n  INCLUDES ${HAMR_INCLUDES_SlangTypeLibrary} components\/sb_Monitors\/sb_fan_fanCmd_Monitor\/includes\/ includes\n  LIBS ${HAMR_LIB_SlangTypeLibrary}\n)\n\nDeclareCAmkESComponent(sb_tempControl_currentTemp_Monitor\n  SOURCES components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/src\/sb_tempControl_currentTemp_Monitor.c\n  INCLUDES ${HAMR_INCLUDES_SlangTypeLibrary} components\/sb_Monitors\/sb_tempControl_currentTemp_Monitor\/includes\/ includes\n  LIBS ${HAMR_LIB_SlangTypeLibrary}\n)\n\nDeclareCAmkESComponent(sb_tempControl_fanAck_Monitor\n  SOURCES components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/src\/sb_tempControl_fanAck_Monitor.c\n  INCLUDES ${HAMR_INCLUDES_SlangTypeLibrary} components\/sb_Monitors\/sb_tempControl_fanAck_Monitor\/includes\/ includes\n  LIBS ${HAMR_LIB_SlangTypeLibrary}\n)\n\nDeclareCAmkESComponent(sb_tempControl_tempChanged_Monitor\n  SOURCES components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/src\/sb_tempControl_tempChanged_Monitor.c\n  INCLUDES ${HAMR_INCLUDES_SlangTypeLibrary} components\/sb_Monitors\/sb_tempControl_tempChanged_Monitor\/includes\/ includes\n  LIBS ${HAMR_LIB_SlangTypeLibrary}\n)\n\nDeclareCAmkESRootserver(tcp.camkes)\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempSensor_i\/src\/sb_TempSensor_i.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_TempSensor_i.h\"\n#include <TempSensor_i_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic bool sb_occurred_periodic_dispatcher;\nstatic int64_t sb_time_periodic_dispatcher;\n\n\/************************************************************************\n * periodic_dispatcher_write_int64_t\n * Invoked from remote periodic dispatch thread.\n *\n * This function records the current time and triggers the active thread\n * dispatch from a periodic event.  Note that the periodic dispatch\n * thread is the *only* thread that triggers a dispatch, so we do not\n * mutex lock the function.\n *\n ************************************************************************\/\n\nbool periodic_dispatcher_write_int64_t(const int64_t * arg) {\n    sb_occurred_periodic_dispatcher = true;\n    sb_time_periodic_dispatcher = *arg;\n    MUTEXOP(sb_dispatch_sem_post());\n    return true;\n}\n\nvoid sb_periodic_dispatch_notification_callback(void *_ UNUSED) {\n   \/\/ we want time in microseconds, not nanoseconds, so we divide by 1000.\n   int64_t sb_time_periodic_dispatcher = 0; \/\/ sb_timer_time() \/ 1000LL -- timer connection disabled;\n   (void)periodic_dispatcher_write_int64_t(&sb_time_periodic_dispatcher);\n   CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n}\n\n\n\/************************************************************************\n * sb_currentTemp_write:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_currentTemp_write(const union_art_DataContent * sb_currentTemp){\n  bool sb_result = true;\n  sb_result &= sb_currentTemp0_write((union_art_DataContent *) sb_currentTemp);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_tempChanged_enqueue\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to send to a remote event port.\n *\n ************************************************************************\/\nbool sb_tempChanged_enqueue(void) {\n  sb_tempChanged0_enqueue();\n  return true;\n}\n\n\n\/\/ send currentTemp: Out DataPort BuildingControl__Temperature_impl\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_seL4Nix_currentTemp_Send(STACK_FRAME \n  art_DataContent d) {\n  sb_currentTemp_write(d);\n}\n\n\/\/ send tempChanged: Out EventPort\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_seL4Nix_tempChanged_Send(STACK_FRAME \n  art_DataContent d) {\n\n  \/\/ event port - can ignore the Slang Empty payload\n  art_Empty payload = (art_Empty) d;\n\n  \/\/ send event via CAmkES\n  sb_tempChanged_enqueue();\n}\n\nvoid pre_init(void) {\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_initialiseEntryPoint(SF_LAST);\n\n}\n\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n  \/\/ Initial lock to await dispatch input.\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_TempSensor_i_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempSensor_i\/includes\/sb_TempSensor_i.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_TempSensor_i_types__H\n#define __sb_AADL_TempSensor_i_types__H\n\n#include <sb_proc_types.h>\n\nbool sb_currentTemp_write(const union_art_DataContent * sb_currentTemp);\n\nbool sb_tempChanged_enqueue(void);\n\n#endif \/\/ __sb_AADL_TempSensor_i_types__H\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempControl_i\/src\/sb_TempControl_i.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_TempControl_i.h\"\n#include <TempControl_i_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic void sb_fanAck_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_fanAck_notification_reg_callback(sb_fanAck_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_fanCmd_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_fanCmd_enqueue(const union_art_DataContent * sb_fanCmd){\n  bool sb_result = true;\n  sb_result &= sb_fanCmd0_enqueue((union_art_DataContent *) sb_fanCmd);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_tempChanged_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback that  \n * dispatches the active-thread due to the arrival of an event on \n * its tempChanged event port\n *\n ************************************************************************\/\nstatic void sb_tempChanged_handler(void *_ UNUSED){\n  MUTEXOP(sb_dispatch_sem_post());\n  CALLBACKOP(sb_tempChanged_notification_reg_callback(sb_tempChanged_handler, NULL));\n}\n\n\/\/ send fanCmd: Out EventDataPort BuildingControl__FanCmd\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_fanCmd_Send(STACK_FRAME \n  art_DataContent d) {\n  sb_fanCmd_enqueue(d);\n}\n\nB building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_currentTemp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_currentTemp_is_empty();\n}\n\n\/\/ receive currentTemp: In DataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_currentTemp_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  union_art_DataContent val;\n  if(sb_currentTemp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(STACK_FRAME &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nB building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_fanAck_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_fanAck_is_empty();\n}\n\n\/\/ receive fanAck: In EventDataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_fanAck_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  union_art_DataContent val;\n  if(sb_fanAck_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(STACK_FRAME &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nB building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_tempChanged_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_tempChanged_is_empty();\n}\n\n\/\/ receive tempChanged: In EventPort\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_tempChanged_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  if(sb_tempChanged_dequeue()) {\n    \/\/ event port - ART requires an Empty payload be sent\n    DeclNewart_Empty(payload);\n\n    \/\/ wrap it in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(STACK_FRAME &some, (art_DataContent) &payload);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n} \n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_setPoint_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_seL4Nix_setPoint_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  CALLBACKOP(sb_fanAck_notification_reg_callback(sb_fanAck_notification_handler, NULL));\n  CALLBACKOP(sb_tempChanged_notification_reg_callback(sb_tempChanged_handler, NULL));\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_TempControl_i_adapter_initialiseEntryPoint(SF_LAST);\n\n}\n\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_TempControl_i_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/TempControl_i\/includes\/sb_TempControl_i.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_TempControl_i_types__H\n#define __sb_AADL_TempControl_i_types__H\n\n#include <sb_proc_types.h>\n\nbool sb_currentTemp_read(union_art_DataContent * sb_currentTemp);\n\nbool sb_fanAck_dequeue(union_art_DataContent * sb_fanAck);\n\nbool sb_setPoint_dequeue(union_art_DataContent * sb_setPoint);\n\nbool sb_fanCmd_enqueue(const union_art_DataContent * sb_fanCmd);\n\nbool sb_tempChanged_dequeue(void);\n\n#endif \/\/ __sb_AADL_TempControl_i_types__H\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/Fan_i\/src\/sb_Fan_i.c", { "type" : "Resource","content" : "#include \"..\/includes\/sb_Fan_i.h\"\n#include <Fan_i_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic void sb_fanCmd_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_fanCmd_notification_reg_callback(sb_fanCmd_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_fanAck_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_fanAck_enqueue(const union_art_DataContent * sb_fanAck){\n  bool sb_result = true;\n  sb_result &= sb_fanAck0_enqueue((union_art_DataContent *) sb_fanAck);\n  return sb_result;\n}\n\n\/\/ send fanAck: Out EventDataPort BuildingControl__FanAck\nUnit building_control_gen_mixed_BuildingControl_Fan_i_seL4Nix_fanAck_Send(STACK_FRAME \n  art_DataContent d) {\n  sb_fanAck_enqueue(d);\n}\n\nB building_control_gen_mixed_BuildingControl_Fan_i_seL4Nix_fanCmd_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_fanCmd_is_empty();\n}\n\n\/\/ receive fanCmd: In EventDataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_Fan_i_seL4Nix_fanCmd_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  union_art_DataContent val;\n  if(sb_fanCmd_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(STACK_FRAME &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  CALLBACKOP(sb_fanCmd_notification_reg_callback(sb_fanCmd_notification_handler, NULL));\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_Fan_i_adapter_initialiseEntryPoint(SF_LAST);\n\n}\n\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_Fan_i_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/Fan_i\/includes\/sb_Fan_i.h", { "type" : "Resource","content" : "#ifndef __sb_AADL_Fan_i_types__H\n#define __sb_AADL_Fan_i_types__H\n\n#include <sb_proc_types.h>\n\nbool sb_fanCmd_dequeue(union_art_DataContent * sb_fanCmd);\n\nbool sb_fanAck_enqueue(const union_art_DataContent * sb_fanAck);\n\n#endif \/\/ __sb_AADL_Fan_i_types__H\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/components\/dispatch_periodic\/src\/sb_dispatch_periodic.c", { "type" : "Resource","content" : "#include <string.h>\n#include <camkes.h>\n#include <sb_proc_types.h>\n\n\/\/ prototypes for clock functions\nvoid clock_init();\nvoid clock_set_interval_in_ms(uint32_t interval);\nvoid clock_start_timer(void);\nvoid clock_irq_callback(void);\nuint64_t clock_get_time();\n\n\/\/ Declarations for managing periodic thread dispatch\nconst uint32_t aadl_tick_interval = 1;\nuint32_t aadl_calendar_counter = 0;\n\nvoid sb_thread_calendar() {\n  if ((aadl_calendar_counter % (1000 \/ aadl_tick_interval)) == 0) {\n    sb_tempSensor_periodic_dispatch_notification_emit();\n  }\n\n  aadl_calendar_counter++;\n}\n\nvoid timer_complete_callback() {\n  sb_thread_calendar();\n}\n\n\/\/ no op under the new time server scheme.\nvoid clock_init() { }\n\n\/\/ Set interrupt interval, in milliseconds.\nvoid clock_set_interval_in_ms(uint32_t interval) {\n  timer_periodic(0, ((uint64_t)interval) * NS_IN_MS);\n}\n\n\/\/ no op under the new time server scheme\nvoid clock_start_timer(void) { }\n\n\/\/ defer to time server\nuint64_t clock_get_time() {\n  return (timer_time() \/ NS_IN_MS);\n}\n\nint run(void) {\n  clock_init();\n  clock_set_interval_in_ms(1);\n  clock_start_timer();\n  return 0;\n}\n","overwrite" : true,"makeExecutable" : false}],[ "building_control_gen_mixed--SeL4\/includes\/sb_proc_types.h", { "type" : "Resource","content" : "#ifndef __SB_AADL_sb_proc_types__H\n#define __SB_AADL_sb_proc_types__H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ __SB_AADL_sb_proc_types__H\n","overwrite" : true,"makeExecutable" : false}]]}}