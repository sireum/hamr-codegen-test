package TempControlSimpleTemp.TempControlSoftwareSystem

import TempControlSimpleTemp.CoolingFan.{FanAck, FanCmd, FanCmd_Gen}
import org.sireum._
import TempControlSimpleTemp.TempControlSoftwareSystem.TempControl_i_tcproc_tempControl_XContracts._
import TempControlSimpleTemp.TempSensor.{Temperature_i, Temperature_i_Gen}
import TempControlSimpleTemp.TempControlSoftwareSystem.TempControl_i_tcproc_tempControl_Gen_CounterExampleTemplates
import org.scalacheck.Gen
import org.scalacheck.Gen._
import org.scalacheck.Test.Parameters
import org.scalacheck.Prop
import org.scalacheck.util.ConsoleReporter
import org.scalacheck.Test
import org.scalacheck.rng.Seed

// This file will not be overwritten so is safe to edit
class TempControl_i_tcproc_tempControl_Test_ScalaCheck extends TempControl_i_tcproc_tempControl_TestApi {

  // GUMBOCheck test for counter-example
  test("Failing Case: XXX") {
    assert(tempChanged_harness_setlocals(Temperature_i(59.98989f), // currentTemp (in port)
      SetPoint_i(Temperature_i(82.810684f), Temperature_i(86.48279f)), // local state
      FanCmd.On // local state
    ))
  }

  //----------------------------------------------------------------------
  //  t e m p C h a n g e d   dispatch
  //
  //    - auto-generated
  //    - Illustrate auto-generated random testing for tempChanged dispatch
  //      with local state randomized
  //----------------------------------------------------------------------
  test("XContract / ScalaCheck - tempChanged dispatch / inputs autogenerated") {
    val prop =
      Prop.forAll(// null input for tempChange (no data on event port)
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default,
        // ====== local state GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        //    ToDo: This could/should be replaced by a generator for a tuple of local state variables
        //      that satisfies the component invariants.
        //   currentSetPoint GENERATOR
        SetPoint_i_Gen.default,
        //   fanCmd GENERATOR
        FanCmd_Gen.default
      ){(currentTempApi: Temperature_i, currentSetPoint_in: SetPoint_i, currentFanState_in: FanCmd.Type)  =>
          // invoke auto-generated testing harness for tempChanged dispatch
         val testResult: Boolean =  tempChanged_harness_setlocals(currentTempApi,currentSetPoint_in,currentFanState_in)
         // output counter example test
         if (!testResult) {
           println(TempControl_i_tcproc_tempControl_Gen_CounterExampleTemplates.tempChangedDispatch(
             currentTempApi,
             currentSetPoint_in,
             currentFanState_in
           ))
         }
         testResult
      }

    // invoke ScalaCheck property with auto-generated values
    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose.withMinSuccessfulTests(10000),prop)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)
  }

    //----------------------------------------------------------------------
    //  s e t P o i n t   dispatch
    //
    //    - auto-generated
    //    - Illustrate auto-generated random testing for setPoint dispatch
    //      with local state randomized
    //
    //   * Note limitation: Framework parameters must be tweaked to get enough
    //     non-failing tests
    //----------------------------------------------------------------------
    test("XContract / ScalaCheck - setPoint dispatch / inputs autogenerated") {
    val prop =
      Prop.forAll(// null input for tempChange (no data on event port)
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.setPoint_port.default,
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default,
        // ====== local state GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        //    ToDo: This could/should be replaced by a generator for a tuple of local state variables
        //      that satisfies the component invariants.
        TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default,
        //   currentSetPoint GENERATOR
        SetPoint_i_Gen.default,
        //   fanCmd GENERATOR
        FanCmd_Gen.default
      ){(setPointApi: SetPoint_i, currentTempApi: Temperature_i, latestTemp_in: Temperature_i, currentSetPoint_in: SetPoint_i, currentFanState_in: FanCmd.Type)  =>
        // invoke auto-generated testing harness for tempChanged dispatch
        setPoint_harness_setlocals(setPointApi,currentTempApi,latestTemp_in, currentSetPoint_in,currentFanState_in)
      }

    // invoke ScalaCheck property with auto-generated values
    // ToDo: Note the use of the MaxDiscardRatio in this example
    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose.withMaxDiscardRatio(1000),prop)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)
  }

  test("Case: Failing FanCmd Case") {
    // Test: Temperature_i(75.68258f), SetPoint_i(Temperature_i(57.379486f), Temperature_i(66.77897f)), Off
    // { "log" : "info", "title" : "TempControlSoftwareSystem_i_Instance_tcproc_tempControl", "msg" : "received tempChanged", "time" : "1638319106387" }
    // { "log" : "info", "title" : "TempControlSoftwareSystem_i_Instance_tcproc_tempControl", "msg" : "Set fan command: On", "time" : "1638319106388" }
    val currentTemp = Temperature_i(75.68258f)
    val current_setPoint = SetPoint_i(Temperature_i(57.379486f), Temperature_i(66.77897f))
    val current_fanState = FanCmd.Off

    assert(tempChanged_harness_setlocals(currentTemp,current_setPoint,current_fanState))
  }

  //----------------------------------------------------------------------
  //  ******************* Temporary Code *****************
  //    building up to randomized dispatches
  //----------------------------------------------------------------------
  test("XContract / ScalaCheck - tempChanged dispatch / inputs autogenerated (inherited locals)") {
    val prop =
      Prop.forAll(// null input for tempChange (no data on event port)
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default,
      ){currentTempApi: Temperature_i  =>
        // invoke auto-generated testing harness for tempChanged dispatch
        tempChanged_harness_inheritedlocals(currentTempApi)
      }

    // invoke ScalaCheck property with auto-generated values
    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose,prop)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)
  }

  test("Playing with distributions") {
    // define generator with distribution
    val distributionGen = frequency(
      (1, 10),
      (5, 20)
    )

    val distributionProp = Prop.forAll(distributionGen) {n =>
      Prop.collect(n)(true)
    }

//    for (i <- 1 to 10) {
//      println(distributionGen.sample)
//    }
    // sample and print some values

    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose, distributionProp)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)

  }

  test("Playing with sampling - Temperature") {

    for (i <- 1 to 20) {
      println(TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default.sample)
    }
    // assert for ScalaTest
    assert(true)
  }

  test("Playing with sampling - SetPoint - note: illustrates failing to sample") {

    for (i <- 1 to 20) {
      println(TempControl_i_tcproc_tempControl_Gen.setPoint_port.default.sample)
    }
    // assert for ScalaTest
    assert(true)
  }

  test("Playing with sampling - SetPoint - use Params to specify explicit retries") {

    for (i <- 1 to 20) {
      // moving up to 1000 retries from default of 100
      println(TempControl_i_tcproc_tempControl_Gen.setPoint_port.default.doPureApply(Gen.Parameters.default,Seed.random(),1000).retrieve)
    }
    // assert for ScalaTest
    assert(true)
  }

  test("Temperature_i fault model illustration") {
    val distributionProp = Prop.forAll(TempControl_i_tcproc_tempControl_Gen.currentTemp_port.faultModel) { t: Temperature_i =>
      val classification = {
        if (t.degrees < -70.0f) "BelowRange"
        else if (t.degrees > 180.0f) "AboveRange"
        else "InRange"
      }
      println(t)
      Prop.collect(classification)(true)
    }

    // invoke ScalaCheck property with auto-generated values
    // ToDo: Note the use of the MaxDiscardRatio in this example
    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose.withMaxDiscardRatio(1000).withMinSuccessfulTests(100),distributionProp)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)
  }


  //----------------------------------------------------------------------
  //  s e t P o i n t   dispatch
  //
  //    - auto-generated
  //    - Illustrate auto-generated random testing for setPoint dispatch
  //      with local state randomized
  //
  //   * Note limitation: Framework parameters must be tweaked to get enough
  //     non-failing tests
  //----------------------------------------------------------------------
  test("XContract / ScalaCheck - setPoint dispatch / inputs autogenerated (inherit locals)") {
    val prop =
      Prop.forAll(// null input for tempChange (no data on event port)
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.setPoint_port.default,
        // ====== in data port GENERATOR =======
        //    (generated values should satisfy data invariant and port invariant)
        TempControl_i_tcproc_tempControl_Gen.currentTemp_port.default
      ){(setPointApi: SetPoint_i, currentTempApi: Temperature_i)  =>
        // invoke auto-generated testing harness for tempChanged dispatch
        setPoint_harness_inheritedlocals(setPointApi,currentTempApi)
      }

    // invoke ScalaCheck property with auto-generated values
    // ToDo: Note the use of the MaxDiscardRatio in this example
    val scalaCheckResult: Test.Result = Test.check(Parameters.defaultVerbose.withMaxDiscardRatio(1000),prop)
    // assert for ScalaTest
    assert(scalaCheckResult.passed)
  }

  //=======================================================================================
  //  H a r n e s s e s
  //    (since these are auto-generated, it would be better to have them in a separate file
  //     in the test/util folder)
  //     We can't have them there now, because the port testing APIs and execute test are
  //     defined in an abstract class that inherits from ScalaTest testing framework)
  //=======================================================================================

  //------------------------------------------------
  //  tempChanged, with local state randomized
  //
  //    - receives pre-state values for tempChange dispatch
  //    - executes entry point
  //    - checks pre-state and post-state values against auto-generated executable representation of contract
  //------------------------------------------------
  def tempChanged_harness_setlocals
  (currentTempApi: Temperature_i, currentSetPoint_in: SetPoint_i, currentFanState_in: FanCmd.Type):Boolean = {
    println(s"Test: ${currentTempApi}, ${currentSetPoint_in}, ${currentFanState_in}")
    // ------------ s e t   i n p u t s  ------------
    // set dispatching port
    put_tempChanged()
    // set input data ports
    put_currentTemp(currentTempApi)
    // set local state
    TempControl_i_tcproc_tempControl.currentSetPoint = currentSetPoint_in
    TempControl_i_tcproc_tempControl.currentFanState = currentFanState_in

    // ------------ e x e c u t e    c o m p o n e n t ------------
    executeTest()

    // ------------- g e t    o u t p u t s  -----------------
    // get output port value
    val fanCmdApi: Option[FanCmd.Type] = get_fanCmd()
    // get output state values
    val currentSetPoint: SetPoint_i = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState: FanCmd.Type = TempControl_i_tcproc_tempControl.currentFanState

    // ------------- i n v o k e     o r a c l e -----------------
    // call oracle to see if contract for this dispatch trigger is satisfied
    val oracle_result = tempChanged_oracle(currentTempApi,fanCmdApi,
      currentSetPoint,currentSetPoint_in,currentFanState,currentFanState_in)
    oracle_result.value // convert from B to bool to make ScalaCheck happy
  }

  //------------------------------------------------
  //  tempChanged, with local state inherited from previous dispatch
  //
  //    - receives pre-state values for tempChange dispatch
  //    - executes entry point
  //    - checks pre-state and post-state values against auto-generated executable representation of contract
  //------------------------------------------------
  def tempChanged_harness_inheritedlocals
  (currentTempApi: Temperature_i):Boolean = {
    println(s"Test: ${currentTempApi}")
    // ------------ s e t   i n p u t s  ------------
    // set dispatching port
    put_tempChanged()
    // set input data ports
    put_currentTemp(currentTempApi)
    // save current local state (needed for checking post-state contract)
    val currentSetPoint_in = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState_in = TempControl_i_tcproc_tempControl.currentFanState

    // ------------ e x e c u t e    c o m p o n e n t ------------
    executeTest()

    // ------------- g e t    o u t p u t s  -----------------
    // get output port value
    val fanCmdApi: Option[FanCmd.Type] = get_fanCmd()
    // get output state values
    val currentSetPoint: SetPoint_i = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState: FanCmd.Type = TempControl_i_tcproc_tempControl.currentFanState

    // ------------- i n v o k e     o r a c l e -----------------
    // call oracle to see if contract for this dispatch trigger is satisfied
    val oracle_result = tempChanged_oracle(currentTempApi,fanCmdApi,
      currentSetPoint,currentSetPoint_in,currentFanState,currentFanState_in)
    oracle_result.value // convert from B to bool to make ScalaCheck happy
  }

  //------------------------------------------------
  //  setPoint, with local state randomized
  //
  //    - receives pre-state values for tempChange dispatch
  //    - executes entry point
  //    - checks pre-state and post-state values against auto-generated executable representation of contract
  //------------------------------------------------
  def setPoint_harness_setlocals
  (setPointApi: SetPoint_i, currentTempApi: Temperature_i,   // port values
   latestTemp_in: Temperature_i,
   currentSetPoint_in: SetPoint_i,
   currentFanState_in: FanCmd.Type // local state values
  ):Boolean = {
    println(s"Test: ${setPointApi}, ${currentTempApi}, ${latestTemp_in}, ${currentSetPoint_in}, ${currentFanState_in}")
    // ------------ s e t   i n p u t s  ------------
    // set dispatching port
    put_setPoint(setPointApi)
    // set input data ports
    put_currentTemp(currentTempApi)
    // set local state
    // ToDo: should latestTemp be assigned here?
    TempControl_i_tcproc_tempControl.currentSetPoint = currentSetPoint_in
    TempControl_i_tcproc_tempControl.currentFanState = currentFanState_in

    // ------------ e x e c u t e    c o m p o n e n t ------------
    executeTest()

    // ------------- g e t    o u t p u t s  -----------------
    // get output port value
    val fanCmdApi: Option[FanCmd.Type] = get_fanCmd()
    // get output state values
    val latestTemp: Temperature_i = TempControl_i_tcproc_tempControl.latestTemp
    val currentSetPoint: SetPoint_i = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState: FanCmd.Type = TempControl_i_tcproc_tempControl.currentFanState

    // ------------- i n v o k e     o r a c l e -----------------
    // call oracle to see if contract for this dispatch trigger is satisfied
    val oracle_result = setPoint_oracle(setPointApi,currentTempApi, fanCmdApi,
      latestTemp, latestTemp_in,currentSetPoint,currentSetPoint_in,currentFanState,currentFanState_in)
    oracle_result.value // convert from B to bool to make ScalaCheck happy
  }

  //------------------------------------------------
  //  setPoint, with local state inherited from previous dispatch
  //
  //    - receives pre-state values for tempChange dispatch
  //    - executes entry point
  //    - checks pre-state and post-state values against auto-generated executable representation of contract
  //------------------------------------------------
  def setPoint_harness_inheritedlocals
  (setPointApi: SetPoint_i, currentTempApi: Temperature_i,   // port values
  ):Boolean = {
    println(s"Test: ${setPointApi}, ${currentTempApi}")
    // ------------ s e t   i n p u t s  ------------
    // set dispatching port
    put_setPoint(setPointApi)
    // set input data ports
    put_currentTemp(currentTempApi)
    // save local state
    val currentSetPoint_in = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState_in = TempControl_i_tcproc_tempControl.currentFanState
    val latestTemp_in = TempControl_i_tcproc_tempControl.latestTemp

    // ------------ e x e c u t e    c o m p o n e n t ------------
    executeTest()

    // ------------- g e t    o u t p u t s  -----------------
    // get output port value
    val fanCmdApi: Option[FanCmd.Type] = get_fanCmd()
    // get output state values
    val latestTemp: Temperature_i = TempControl_i_tcproc_tempControl.latestTemp
    val currentSetPoint: SetPoint_i = TempControl_i_tcproc_tempControl.currentSetPoint
    val currentFanState: FanCmd.Type = TempControl_i_tcproc_tempControl.currentFanState

    // ------------- i n v o k e     o r a c l e -----------------
    // call oracle to see if contract for this dispatch trigger is satisfied
    val oracle_result = setPoint_oracle(setPointApi,currentTempApi, fanCmdApi,
      latestTemp, latestTemp_in,currentSetPoint,currentSetPoint_in,currentFanState,currentFanState_in)
    oracle_result.value // convert from B to bool to make ScalaCheck happy
  }
}
