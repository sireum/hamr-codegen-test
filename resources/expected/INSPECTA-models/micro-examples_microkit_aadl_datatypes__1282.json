{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "microkit\/types\/include\/sb_aadl_types.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdbool.h>\n#include <stdint.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ntypedef\n  enum {On, Off} Aadl_Datatypes_MyEnum;\n\ntypedef struct Aadl_Datatypes_MyStruct2_i {\n  char fieldSChar;\n} Aadl_Datatypes_MyStruct2_i;\n\n#define Base_Types_String_BYTE_SIZE 43\n#define Base_Types_String_DIM_0 43\n\ntypedef char Base_Types_String [Base_Types_String_DIM_0];\n\n#define Aadl_Datatypes_MyArrayOneDim_BYTE_SIZE 40\n#define Aadl_Datatypes_MyArrayOneDim_DIM_0 10\n\ntypedef int32_t Aadl_Datatypes_MyArrayOneDim [Aadl_Datatypes_MyArrayOneDim_DIM_0];\n\ntypedef struct Aadl_Datatypes_MyStruct_i {\n  int64_t fieldInt64;\n  Base_Types_String fieldStr;\n  Aadl_Datatypes_MyEnum fieldEnum;\n  Aadl_Datatypes_MyStruct2_i fieldRec;\n  Aadl_Datatypes_MyArrayOneDim fieldArray;\n} Aadl_Datatypes_MyStruct_i;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_bool_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_BOOL_1_SIZE-1 elements.\n#define SB_QUEUE_BOOL_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_bool_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type bool\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  bool elt[SB_QUEUE_BOOL_1_SIZE];\n\n} sb_queue_bool_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_bool_1_init(sb_queue_bool_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_bool_1_enqueue(\n  sb_queue_bool_1_t *queue,\n  bool *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_bool_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_bool_1_t *queue;\n\n} sb_queue_bool_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_bool_1_Recv_init(\n  sb_queue_bool_1_Recv_t *recvQueue,\n  sb_queue_bool_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_bool_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_bool_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_bool_1_dequeue(\n  sb_queue_bool_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  bool *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_bool_1_is_empty(sb_queue_bool_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_bool_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_bool_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_bool_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_bool_1_init(sb_queue_bool_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_bool_1_enqueue(\n  sb_queue_bool_1_t *queue,\n  bool *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_BOOL_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_BOOL_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_bool_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_bool_1_Recv_init(\n  sb_queue_bool_1_Recv_t *recvQueue,\n  sb_queue_bool_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_bool_1_dequeue(\n  sb_queue_bool_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  bool *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_bool_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_BOOL_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_BOOL_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_BOOL_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_BOOL_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_BOOL_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_bool_1_is_empty(sb_queue_bool_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_char_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_CHAR_1_SIZE-1 elements.\n#define SB_QUEUE_CHAR_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_char_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type char\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  char elt[SB_QUEUE_CHAR_1_SIZE];\n\n} sb_queue_char_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_char_1_init(sb_queue_char_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_char_1_enqueue(\n  sb_queue_char_1_t *queue,\n  char *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_char_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_char_1_t *queue;\n\n} sb_queue_char_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_char_1_Recv_init(\n  sb_queue_char_1_Recv_t *recvQueue,\n  sb_queue_char_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_char_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_char_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_char_1_dequeue(\n  sb_queue_char_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  char *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_char_1_is_empty(sb_queue_char_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_char_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_char_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_char_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_char_1_init(sb_queue_char_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_char_1_enqueue(\n  sb_queue_char_1_t *queue,\n  char *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_CHAR_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_CHAR_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_char_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_char_1_Recv_init(\n  sb_queue_char_1_Recv_t *recvQueue,\n  sb_queue_char_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_char_1_dequeue(\n  sb_queue_char_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  char *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_char_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_CHAR_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_CHAR_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_CHAR_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_CHAR_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_CHAR_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_char_1_is_empty(sb_queue_char_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Base_Types_String_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_BASE_TYPES_STRING_1_SIZE-1 elements.\n#define SB_QUEUE_BASE_TYPES_STRING_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Base_Types_String_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Base_Types_String\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Base_Types_String elt[SB_QUEUE_BASE_TYPES_STRING_1_SIZE];\n\n} sb_queue_Base_Types_String_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Base_Types_String_1_init(sb_queue_Base_Types_String_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Base_Types_String_1_enqueue(\n  sb_queue_Base_Types_String_1_t *queue,\n  Base_Types_String *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Base_Types_String_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Base_Types_String_1_t *queue;\n\n} sb_queue_Base_Types_String_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Base_Types_String_1_Recv_init(\n  sb_queue_Base_Types_String_1_Recv_t *recvQueue,\n  sb_queue_Base_Types_String_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Base_Types_String_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Base_Types_String_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Base_Types_String_1_dequeue(\n  sb_queue_Base_Types_String_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Base_Types_String *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Base_Types_String_1_is_empty(sb_queue_Base_Types_String_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Base_Types_String_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Base_Types_String_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Base_Types_String_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Base_Types_String_1_init(sb_queue_Base_Types_String_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Base_Types_String_1_enqueue(\n  sb_queue_Base_Types_String_1_t *queue,\n  Base_Types_String *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_BASE_TYPES_STRING_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_BASE_TYPES_STRING_1_SIZE;\n\n  memcpy(&queue->elt[index], data, Base_Types_String_BYTE_SIZE); \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Base_Types_String_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Base_Types_String_1_Recv_init(\n  sb_queue_Base_Types_String_1_Recv_t *recvQueue,\n  sb_queue_Base_Types_String_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Base_Types_String_1_dequeue(\n  sb_queue_Base_Types_String_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Base_Types_String *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Base_Types_String_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_BASE_TYPES_STRING_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_BASE_TYPES_STRING_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_BASE_TYPES_STRING_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_BASE_TYPES_STRING_1_SIZE;\n  memcpy(data, &queue->elt[index], Base_Types_String_BYTE_SIZE); \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_BASE_TYPES_STRING_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Base_Types_String_1_is_empty(sb_queue_Base_Types_String_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_int8_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_INT8_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT8_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int8_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int8_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  int8_t elt[SB_QUEUE_INT8_T_1_SIZE];\n\n} sb_queue_int8_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue,\n  int8_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int8_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int8_t_1_t *queue;\n\n} sb_queue_int8_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_queue_int8_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int8_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int8_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int8_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_int8_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int8_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue,\n  int8_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_INT8_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT8_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_queue_int8_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int8_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int8_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT8_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT8_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT8_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT8_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT8_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_int16_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_INT16_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT16_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int16_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int16_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  int16_t elt[SB_QUEUE_INT16_T_1_SIZE];\n\n} sb_queue_int16_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int16_t_1_init(sb_queue_int16_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int16_t_1_enqueue(\n  sb_queue_int16_t_1_t *queue,\n  int16_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int16_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int16_t_1_t *queue;\n\n} sb_queue_int16_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int16_t_1_Recv_init(\n  sb_queue_int16_t_1_Recv_t *recvQueue,\n  sb_queue_int16_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int16_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int16_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int16_t_1_dequeue(\n  sb_queue_int16_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int16_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int16_t_1_is_empty(sb_queue_int16_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_int16_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int16_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int16_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int16_t_1_init(sb_queue_int16_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int16_t_1_enqueue(\n  sb_queue_int16_t_1_t *queue,\n  int16_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_INT16_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT16_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int16_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int16_t_1_Recv_init(\n  sb_queue_int16_t_1_Recv_t *recvQueue,\n  sb_queue_int16_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int16_t_1_dequeue(\n  sb_queue_int16_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int16_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int16_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT16_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT16_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT16_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT16_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT16_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_int16_t_1_is_empty(sb_queue_int16_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_int32_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_INT32_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT32_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int32_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int32_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  int32_t elt[SB_QUEUE_INT32_T_1_SIZE];\n\n} sb_queue_int32_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int32_t_1_init(sb_queue_int32_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int32_t_1_enqueue(\n  sb_queue_int32_t_1_t *queue,\n  int32_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int32_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int32_t_1_t *queue;\n\n} sb_queue_int32_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int32_t_1_Recv_init(\n  sb_queue_int32_t_1_Recv_t *recvQueue,\n  sb_queue_int32_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int32_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int32_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int32_t_1_dequeue(\n  sb_queue_int32_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int32_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int32_t_1_is_empty(sb_queue_int32_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_int32_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int32_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int32_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int32_t_1_init(sb_queue_int32_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int32_t_1_enqueue(\n  sb_queue_int32_t_1_t *queue,\n  int32_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_INT32_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT32_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int32_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int32_t_1_Recv_init(\n  sb_queue_int32_t_1_Recv_t *recvQueue,\n  sb_queue_int32_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int32_t_1_dequeue(\n  sb_queue_int32_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int32_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int32_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT32_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT32_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT32_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT32_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT32_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_int32_t_1_is_empty(sb_queue_int32_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_int64_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_INT64_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT64_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int64_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int64_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  int64_t elt[SB_QUEUE_INT64_T_1_SIZE];\n\n} sb_queue_int64_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int64_t_1_init(sb_queue_int64_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int64_t_1_enqueue(\n  sb_queue_int64_t_1_t *queue,\n  int64_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int64_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int64_t_1_t *queue;\n\n} sb_queue_int64_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int64_t_1_Recv_init(\n  sb_queue_int64_t_1_Recv_t *recvQueue,\n  sb_queue_int64_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int64_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int64_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int64_t_1_dequeue(\n  sb_queue_int64_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int64_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int64_t_1_is_empty(sb_queue_int64_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_int64_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int64_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int64_t_1_init(sb_queue_int64_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int64_t_1_enqueue(\n  sb_queue_int64_t_1_t *queue,\n  int64_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_INT64_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT64_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int64_t_1_Recv_init(\n  sb_queue_int64_t_1_Recv_t *recvQueue,\n  sb_queue_int64_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int64_t_1_dequeue(\n  sb_queue_int64_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int64_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int64_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT64_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT64_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT64_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT64_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT64_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_int64_t_1_is_empty(sb_queue_int64_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_uint8_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UINT8_T_1_SIZE-1 elements.\n#define SB_QUEUE_UINT8_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_uint8_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type uint8_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  uint8_t elt[SB_QUEUE_UINT8_T_1_SIZE];\n\n} sb_queue_uint8_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_uint8_t_1_init(sb_queue_uint8_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_uint8_t_1_enqueue(\n  sb_queue_uint8_t_1_t *queue,\n  uint8_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_uint8_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_uint8_t_1_t *queue;\n\n} sb_queue_uint8_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_uint8_t_1_Recv_init(\n  sb_queue_uint8_t_1_Recv_t *recvQueue,\n  sb_queue_uint8_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_uint8_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_uint8_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_uint8_t_1_dequeue(\n  sb_queue_uint8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint8_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_uint8_t_1_is_empty(sb_queue_uint8_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_uint8_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_uint8_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_uint8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint8_t_1_init(sb_queue_uint8_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_uint8_t_1_enqueue(\n  sb_queue_uint8_t_1_t *queue,\n  uint8_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UINT8_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UINT8_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_uint8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint8_t_1_Recv_init(\n  sb_queue_uint8_t_1_Recv_t *recvQueue,\n  sb_queue_uint8_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_uint8_t_1_dequeue(\n  sb_queue_uint8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint8_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_uint8_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UINT8_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UINT8_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UINT8_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UINT8_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UINT8_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_uint8_t_1_is_empty(sb_queue_uint8_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_uint16_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UINT16_T_1_SIZE-1 elements.\n#define SB_QUEUE_UINT16_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_uint16_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type uint16_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  uint16_t elt[SB_QUEUE_UINT16_T_1_SIZE];\n\n} sb_queue_uint16_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_uint16_t_1_init(sb_queue_uint16_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_uint16_t_1_enqueue(\n  sb_queue_uint16_t_1_t *queue,\n  uint16_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_uint16_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_uint16_t_1_t *queue;\n\n} sb_queue_uint16_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_uint16_t_1_Recv_init(\n  sb_queue_uint16_t_1_Recv_t *recvQueue,\n  sb_queue_uint16_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_uint16_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_uint16_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_uint16_t_1_dequeue(\n  sb_queue_uint16_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint16_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_uint16_t_1_is_empty(sb_queue_uint16_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_uint16_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_uint16_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_uint16_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint16_t_1_init(sb_queue_uint16_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_uint16_t_1_enqueue(\n  sb_queue_uint16_t_1_t *queue,\n  uint16_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UINT16_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UINT16_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_uint16_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint16_t_1_Recv_init(\n  sb_queue_uint16_t_1_Recv_t *recvQueue,\n  sb_queue_uint16_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_uint16_t_1_dequeue(\n  sb_queue_uint16_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint16_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_uint16_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UINT16_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UINT16_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UINT16_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UINT16_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UINT16_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_uint16_t_1_is_empty(sb_queue_uint16_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_uint32_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UINT32_T_1_SIZE-1 elements.\n#define SB_QUEUE_UINT32_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_uint32_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type uint32_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  uint32_t elt[SB_QUEUE_UINT32_T_1_SIZE];\n\n} sb_queue_uint32_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_uint32_t_1_init(sb_queue_uint32_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_uint32_t_1_enqueue(\n  sb_queue_uint32_t_1_t *queue,\n  uint32_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_uint32_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_uint32_t_1_t *queue;\n\n} sb_queue_uint32_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_uint32_t_1_Recv_init(\n  sb_queue_uint32_t_1_Recv_t *recvQueue,\n  sb_queue_uint32_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_uint32_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_uint32_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_uint32_t_1_dequeue(\n  sb_queue_uint32_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint32_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_uint32_t_1_is_empty(sb_queue_uint32_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_uint32_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_uint32_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_uint32_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint32_t_1_init(sb_queue_uint32_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_uint32_t_1_enqueue(\n  sb_queue_uint32_t_1_t *queue,\n  uint32_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UINT32_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UINT32_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_uint32_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint32_t_1_Recv_init(\n  sb_queue_uint32_t_1_Recv_t *recvQueue,\n  sb_queue_uint32_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_uint32_t_1_dequeue(\n  sb_queue_uint32_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint32_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_uint32_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UINT32_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UINT32_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UINT32_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UINT32_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UINT32_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_uint32_t_1_is_empty(sb_queue_uint32_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_uint64_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UINT64_T_1_SIZE-1 elements.\n#define SB_QUEUE_UINT64_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_uint64_t_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type uint64_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  uint64_t elt[SB_QUEUE_UINT64_T_1_SIZE];\n\n} sb_queue_uint64_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_uint64_t_1_init(sb_queue_uint64_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_uint64_t_1_enqueue(\n  sb_queue_uint64_t_1_t *queue,\n  uint64_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_uint64_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_uint64_t_1_t *queue;\n\n} sb_queue_uint64_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_uint64_t_1_Recv_init(\n  sb_queue_uint64_t_1_Recv_t *recvQueue,\n  sb_queue_uint64_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_uint64_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_uint64_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_uint64_t_1_dequeue(\n  sb_queue_uint64_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint64_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_uint64_t_1_is_empty(sb_queue_uint64_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_uint64_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_uint64_t_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_uint64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint64_t_1_init(sb_queue_uint64_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_uint64_t_1_enqueue(\n  sb_queue_uint64_t_1_t *queue,\n  uint64_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UINT64_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UINT64_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_uint64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_uint64_t_1_Recv_init(\n  sb_queue_uint64_t_1_Recv_t *recvQueue,\n  sb_queue_uint64_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_uint64_t_1_dequeue(\n  sb_queue_uint64_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  uint64_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_uint64_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UINT64_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UINT64_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UINT64_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UINT64_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UINT64_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_uint64_t_1_is_empty(sb_queue_uint64_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_float_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_FLOAT_1_SIZE-1 elements.\n#define SB_QUEUE_FLOAT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_float_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type float\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  float elt[SB_QUEUE_FLOAT_1_SIZE];\n\n} sb_queue_float_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_float_1_init(sb_queue_float_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_float_1_enqueue(\n  sb_queue_float_1_t *queue,\n  float *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_float_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_float_1_t *queue;\n\n} sb_queue_float_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_float_1_Recv_init(\n  sb_queue_float_1_Recv_t *recvQueue,\n  sb_queue_float_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_float_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_float_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_float_1_dequeue(\n  sb_queue_float_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  float *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_float_1_is_empty(sb_queue_float_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_float_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_float_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_float_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_float_1_init(sb_queue_float_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_float_1_enqueue(\n  sb_queue_float_1_t *queue,\n  float *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_FLOAT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_FLOAT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_float_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_float_1_Recv_init(\n  sb_queue_float_1_Recv_t *recvQueue,\n  sb_queue_float_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_float_1_dequeue(\n  sb_queue_float_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  float *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_float_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_FLOAT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_FLOAT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_FLOAT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_FLOAT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_FLOAT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_float_1_is_empty(sb_queue_float_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_double_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_DOUBLE_1_SIZE-1 elements.\n#define SB_QUEUE_DOUBLE_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_double_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type double\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  double elt[SB_QUEUE_DOUBLE_1_SIZE];\n\n} sb_queue_double_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_double_1_init(sb_queue_double_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_double_1_enqueue(\n  sb_queue_double_1_t *queue,\n  double *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_double_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_double_1_t *queue;\n\n} sb_queue_double_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_double_1_Recv_init(\n  sb_queue_double_1_Recv_t *recvQueue,\n  sb_queue_double_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_double_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_double_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_double_1_dequeue(\n  sb_queue_double_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  double *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_double_1_is_empty(sb_queue_double_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_double_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_double_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_double_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_double_1_init(sb_queue_double_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_double_1_enqueue(\n  sb_queue_double_1_t *queue,\n  double *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_DOUBLE_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_DOUBLE_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_double_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_double_1_Recv_init(\n  sb_queue_double_1_Recv_t *recvQueue,\n  sb_queue_double_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_double_1_dequeue(\n  sb_queue_double_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  double *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_double_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_DOUBLE_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_DOUBLE_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_DOUBLE_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_DOUBLE_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_DOUBLE_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_double_1_is_empty(sb_queue_double_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Aadl_Datatypes_MyEnum_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE-1 elements.\n#define SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Aadl_Datatypes_MyEnum_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Aadl_Datatypes_MyEnum\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Aadl_Datatypes_MyEnum elt[SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE];\n\n} sb_queue_Aadl_Datatypes_MyEnum_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_init(sb_queue_Aadl_Datatypes_MyEnum_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue,\n  Aadl_Datatypes_MyEnum *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Aadl_Datatypes_MyEnum_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue;\n\n} sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Aadl_Datatypes_MyEnum_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Aadl_Datatypes_MyEnum_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Aadl_Datatypes_MyEnum_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyEnum *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Aadl_Datatypes_MyEnum_1_is_empty(sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Aadl_Datatypes_MyEnum_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Aadl_Datatypes_MyEnum_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyEnum_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_init(sb_queue_Aadl_Datatypes_MyEnum_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue,\n  Aadl_Datatypes_MyEnum *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyEnum_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyEnum_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Aadl_Datatypes_MyEnum_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyEnum *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Aadl_Datatypes_MyEnum_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_AADL_DATATYPES_MYENUM_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Aadl_Datatypes_MyEnum_1_is_empty(sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Aadl_Datatypes_MyStruct_i_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE-1 elements.\n#define SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Aadl_Datatypes_MyStruct_i_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Aadl_Datatypes_MyStruct_i\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Aadl_Datatypes_MyStruct_i elt[SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE];\n\n} sb_queue_Aadl_Datatypes_MyStruct_i_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_init(sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue,\n  Aadl_Datatypes_MyStruct_i *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue;\n\n} sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Aadl_Datatypes_MyStruct_i_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Aadl_Datatypes_MyStruct_i_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Aadl_Datatypes_MyStruct_i_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyStruct_i *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Aadl_Datatypes_MyStruct_i_1_is_empty(sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Aadl_Datatypes_MyStruct_i_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Aadl_Datatypes_MyStruct_i_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyStruct_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_init(sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue,\n  Aadl_Datatypes_MyStruct_i *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyStruct_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Aadl_Datatypes_MyStruct_i_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyStruct_i *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_AADL_DATATYPES_MYSTRUCT_I_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Aadl_Datatypes_MyStruct_i_1_is_empty(sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Aadl_Datatypes_MyArrayOneDim_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE-1 elements.\n#define SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Aadl_Datatypes_MyArrayOneDim_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Aadl_Datatypes_MyArrayOneDim\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Aadl_Datatypes_MyArrayOneDim elt[SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE];\n\n} sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_init(sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue,\n  Aadl_Datatypes_MyArrayOneDim *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue;\n\n} sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Aadl_Datatypes_MyArrayOneDim_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Aadl_Datatypes_MyArrayOneDim_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Aadl_Datatypes_MyArrayOneDim_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyArrayOneDim *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Aadl_Datatypes_MyArrayOneDim_1_is_empty(sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Aadl_Datatypes_MyArrayOneDim_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Aadl_Datatypes_MyArrayOneDim_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyArrayOneDim_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_init(sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_enqueue(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue,\n  Aadl_Datatypes_MyArrayOneDim *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE;\n\n  memcpy(&queue->elt[index], data, Aadl_Datatypes_MyArrayOneDim_BYTE_SIZE); \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Aadl_Datatypes_MyArrayOneDim_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_init(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue,\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Aadl_Datatypes_MyArrayOneDim_1_dequeue(\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Aadl_Datatypes_MyArrayOneDim *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE;\n  memcpy(data, &queue->elt[index], Aadl_Datatypes_MyArrayOneDim_BYTE_SIZE); \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_AADL_DATATYPES_MYARRAYONEDIM_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Aadl_Datatypes_MyArrayOneDim_1_is_empty(sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#include <sb_aadl_types.h>\n#include <sb_queue_bool_1.h>\n#include <sb_queue_char_1.h>\n#include <sb_queue_Base_Types_String_1.h>\n#include <sb_queue_int8_t_1.h>\n#include <sb_queue_int16_t_1.h>\n#include <sb_queue_int32_t_1.h>\n#include <sb_queue_int64_t_1.h>\n#include <sb_queue_uint8_t_1.h>\n#include <sb_queue_uint16_t_1.h>\n#include <sb_queue_uint32_t_1.h>\n#include <sb_queue_uint64_t_1.h>\n#include <sb_queue_float_1.h>\n#include <sb_queue_double_1.h>\n#include <sb_queue_Aadl_Datatypes_MyEnum_1.h>\n#include <sb_queue_Aadl_Datatypes_MyStruct_i_1.h>\n#include <sb_queue_Aadl_Datatypes_MyArrayOneDim_1.h>\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/components\/producer_producer\/src\/producer_producer_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 61\n\n#define PORT_TO_CHILD 60\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/producer_producer\/src\/producer_producer.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"producer_producer.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid producer_producer_initialize(void);\nvoid producer_producer_notify(microkit_channel channel);\nvoid producer_producer_timeTriggered(void);\n\nvolatile sb_queue_bool_1_t *myBoolean_queue_1;\nvolatile sb_queue_char_1_t *myCharacter_queue_1;\nvolatile sb_queue_Base_Types_String_1_t *myString_queue_1;\nvolatile sb_queue_int8_t_1_t *myInt8_queue_1;\nvolatile sb_queue_int16_t_1_t *myInt16_queue_1;\nvolatile sb_queue_int32_t_1_t *myInt32_queue_1;\nvolatile sb_queue_int64_t_1_t *myInt64_queue_1;\nvolatile sb_queue_uint8_t_1_t *myUInt8_queue_1;\nvolatile sb_queue_uint16_t_1_t *myUInt16_queue_1;\nvolatile sb_queue_uint32_t_1_t *myUInt32_queue_1;\nvolatile sb_queue_uint64_t_1_t *myUInt64_queue_1;\nvolatile sb_queue_float_1_t *myFloat32_queue_1;\nvolatile sb_queue_double_1_t *myFloat64_queue_1;\nvolatile sb_queue_Aadl_Datatypes_MyEnum_1_t *myEnum_queue_1;\nvolatile sb_queue_Aadl_Datatypes_MyStruct_i_1_t *myStruct_queue_1;\nvolatile sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *myArray1_queue_1;\n\n#define PORT_FROM_MON 60\n\nbool put_myBoolean(const bool *data) {\n  sb_queue_bool_1_enqueue((sb_queue_bool_1_t *) myBoolean_queue_1, (bool *) data);\n\n  return true;\n}\n\nbool put_myCharacter(const char *data) {\n  sb_queue_char_1_enqueue((sb_queue_char_1_t *) myCharacter_queue_1, (char *) data);\n\n  return true;\n}\n\nbool put_myString(const Base_Types_String *data) {\n  sb_queue_Base_Types_String_1_enqueue((sb_queue_Base_Types_String_1_t *) myString_queue_1, (Base_Types_String *) data);\n\n  return true;\n}\n\nbool put_myInt8(const int8_t *data) {\n  sb_queue_int8_t_1_enqueue((sb_queue_int8_t_1_t *) myInt8_queue_1, (int8_t *) data);\n\n  return true;\n}\n\nbool put_myInt16(const int16_t *data) {\n  sb_queue_int16_t_1_enqueue((sb_queue_int16_t_1_t *) myInt16_queue_1, (int16_t *) data);\n\n  return true;\n}\n\nbool put_myInt32(const int32_t *data) {\n  sb_queue_int32_t_1_enqueue((sb_queue_int32_t_1_t *) myInt32_queue_1, (int32_t *) data);\n\n  return true;\n}\n\nbool put_myInt64(const int64_t *data) {\n  sb_queue_int64_t_1_enqueue((sb_queue_int64_t_1_t *) myInt64_queue_1, (int64_t *) data);\n\n  return true;\n}\n\nbool put_myUInt8(const uint8_t *data) {\n  sb_queue_uint8_t_1_enqueue((sb_queue_uint8_t_1_t *) myUInt8_queue_1, (uint8_t *) data);\n\n  return true;\n}\n\nbool put_myUInt16(const uint16_t *data) {\n  sb_queue_uint16_t_1_enqueue((sb_queue_uint16_t_1_t *) myUInt16_queue_1, (uint16_t *) data);\n\n  return true;\n}\n\nbool put_myUInt32(const uint32_t *data) {\n  sb_queue_uint32_t_1_enqueue((sb_queue_uint32_t_1_t *) myUInt32_queue_1, (uint32_t *) data);\n\n  return true;\n}\n\nbool put_myUInt64(const uint64_t *data) {\n  sb_queue_uint64_t_1_enqueue((sb_queue_uint64_t_1_t *) myUInt64_queue_1, (uint64_t *) data);\n\n  return true;\n}\n\nbool put_myFloat32(const float *data) {\n  sb_queue_float_1_enqueue((sb_queue_float_1_t *) myFloat32_queue_1, (float *) data);\n\n  return true;\n}\n\nbool put_myFloat64(const double *data) {\n  sb_queue_double_1_enqueue((sb_queue_double_1_t *) myFloat64_queue_1, (double *) data);\n\n  return true;\n}\n\nbool put_myEnum(const Aadl_Datatypes_MyEnum *data) {\n  sb_queue_Aadl_Datatypes_MyEnum_1_enqueue((sb_queue_Aadl_Datatypes_MyEnum_1_t *) myEnum_queue_1, (Aadl_Datatypes_MyEnum *) data);\n\n  return true;\n}\n\nbool put_myStruct(const Aadl_Datatypes_MyStruct_i *data) {\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_enqueue((sb_queue_Aadl_Datatypes_MyStruct_i_1_t *) myStruct_queue_1, (Aadl_Datatypes_MyStruct_i *) data);\n\n  return true;\n}\n\nbool put_myArray1(const Aadl_Datatypes_MyArrayOneDim *data) {\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_enqueue((sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *) myArray1_queue_1, (Aadl_Datatypes_MyArrayOneDim *) data);\n\n  return true;\n}\n\nvoid init(void) {\n  sb_queue_bool_1_init((sb_queue_bool_1_t *) myBoolean_queue_1);\n\n  sb_queue_char_1_init((sb_queue_char_1_t *) myCharacter_queue_1);\n\n  sb_queue_Base_Types_String_1_init((sb_queue_Base_Types_String_1_t *) myString_queue_1);\n\n  sb_queue_int8_t_1_init((sb_queue_int8_t_1_t *) myInt8_queue_1);\n\n  sb_queue_int16_t_1_init((sb_queue_int16_t_1_t *) myInt16_queue_1);\n\n  sb_queue_int32_t_1_init((sb_queue_int32_t_1_t *) myInt32_queue_1);\n\n  sb_queue_int64_t_1_init((sb_queue_int64_t_1_t *) myInt64_queue_1);\n\n  sb_queue_uint8_t_1_init((sb_queue_uint8_t_1_t *) myUInt8_queue_1);\n\n  sb_queue_uint16_t_1_init((sb_queue_uint16_t_1_t *) myUInt16_queue_1);\n\n  sb_queue_uint32_t_1_init((sb_queue_uint32_t_1_t *) myUInt32_queue_1);\n\n  sb_queue_uint64_t_1_init((sb_queue_uint64_t_1_t *) myUInt64_queue_1);\n\n  sb_queue_float_1_init((sb_queue_float_1_t *) myFloat32_queue_1);\n\n  sb_queue_double_1_init((sb_queue_double_1_t *) myFloat64_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyEnum_1_init((sb_queue_Aadl_Datatypes_MyEnum_1_t *) myEnum_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_init((sb_queue_Aadl_Datatypes_MyStruct_i_1_t *) myStruct_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_init((sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *) myArray1_queue_1);\n\n  producer_producer_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      producer_producer_timeTriggered();\n      break;\n    default:\n      producer_producer_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/producer_producer\/src\/producer_producer_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"producer_producer.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid producer_producer_initialize(void) {\n  printf(\"%s: producer_producer_initialize invoked\\n\", microkit_name);\n}\n\nvoid producer_producer_timeTriggered(void) {\n  printf(\"%s: producer_producer_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid producer_producer_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/producer_producer\/include\/producer_producer.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_myBoolean(const bool *data);\nbool put_myCharacter(const char *data);\nbool put_myString(const Base_Types_String *data);\nbool put_myInt8(const int8_t *data);\nbool put_myInt16(const int16_t *data);\nbool put_myInt32(const int32_t *data);\nbool put_myInt64(const int64_t *data);\nbool put_myUInt8(const uint8_t *data);\nbool put_myUInt16(const uint16_t *data);\nbool put_myUInt32(const uint32_t *data);\nbool put_myUInt64(const uint64_t *data);\nbool put_myFloat32(const float *data);\nbool put_myFloat64(const double *data);\nbool put_myEnum(const Aadl_Datatypes_MyEnum *data);\nbool put_myStruct(const Aadl_Datatypes_MyStruct_i *data);\nbool put_myArray1(const Aadl_Datatypes_MyArrayOneDim *data);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/consumer_consumer\/src\/consumer_consumer_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 59\n\n#define PORT_TO_CHILD 58\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/consumer_consumer\/src\/consumer_consumer.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"consumer_consumer.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid consumer_consumer_initialize(void);\nvoid consumer_consumer_notify(microkit_channel channel);\nvoid consumer_consumer_timeTriggered(void);\n\nvolatile sb_queue_bool_1_t *myBoolean_queue_1;\nsb_queue_bool_1_Recv_t myBoolean_recv_queue;\nvolatile sb_queue_char_1_t *myCharacter_queue_1;\nsb_queue_char_1_Recv_t myCharacter_recv_queue;\nvolatile sb_queue_Base_Types_String_1_t *myString_queue_1;\nsb_queue_Base_Types_String_1_Recv_t myString_recv_queue;\nvolatile sb_queue_int8_t_1_t *myInt8_queue_1;\nsb_queue_int8_t_1_Recv_t myInt8_recv_queue;\nvolatile sb_queue_int16_t_1_t *myInt16_queue_1;\nsb_queue_int16_t_1_Recv_t myInt16_recv_queue;\nvolatile sb_queue_int32_t_1_t *myInt32_queue_1;\nsb_queue_int32_t_1_Recv_t myInt32_recv_queue;\nvolatile sb_queue_int64_t_1_t *myInt64_queue_1;\nsb_queue_int64_t_1_Recv_t myInt64_recv_queue;\nvolatile sb_queue_uint8_t_1_t *myUInt8_queue_1;\nsb_queue_uint8_t_1_Recv_t myUInt8_recv_queue;\nvolatile sb_queue_uint16_t_1_t *myUInt16_queue_1;\nsb_queue_uint16_t_1_Recv_t myUInt16_recv_queue;\nvolatile sb_queue_uint32_t_1_t *myUInt32_queue_1;\nsb_queue_uint32_t_1_Recv_t myUInt32_recv_queue;\nvolatile sb_queue_uint64_t_1_t *myUInt64_queue_1;\nsb_queue_uint64_t_1_Recv_t myUInt64_recv_queue;\nvolatile sb_queue_float_1_t *myFloat32_queue_1;\nsb_queue_float_1_Recv_t myFloat32_recv_queue;\nvolatile sb_queue_double_1_t *myFloat64_queue_1;\nsb_queue_double_1_Recv_t myFloat64_recv_queue;\nvolatile sb_queue_Aadl_Datatypes_MyEnum_1_t *myEnum_queue_1;\nsb_queue_Aadl_Datatypes_MyEnum_1_Recv_t myEnum_recv_queue;\nvolatile sb_queue_Aadl_Datatypes_MyStruct_i_1_t *myStruct_queue_1;\nsb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t myStruct_recv_queue;\nvolatile sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *myArray1_queue_1;\nsb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t myArray1_recv_queue;\n\n#define PORT_FROM_MON 58\n\nbool myBoolean_is_empty(void) {\n  return sb_queue_bool_1_is_empty(&myBoolean_recv_queue);\n}\n\nbool get_myBoolean_poll(sb_event_counter_t *numDropped, bool *data) {\n  return sb_queue_bool_1_dequeue((sb_queue_bool_1_Recv_t *) &myBoolean_recv_queue, numDropped, data);\n}\n\nbool get_myBoolean(bool *data) {\n  sb_event_counter_t numDropped;\n  return get_myBoolean_poll (&numDropped, data);\n}\n\nbool myCharacter_is_empty(void) {\n  return sb_queue_char_1_is_empty(&myCharacter_recv_queue);\n}\n\nbool get_myCharacter_poll(sb_event_counter_t *numDropped, char *data) {\n  return sb_queue_char_1_dequeue((sb_queue_char_1_Recv_t *) &myCharacter_recv_queue, numDropped, data);\n}\n\nbool get_myCharacter(char *data) {\n  sb_event_counter_t numDropped;\n  return get_myCharacter_poll (&numDropped, data);\n}\n\nbool myString_is_empty(void) {\n  return sb_queue_Base_Types_String_1_is_empty(&myString_recv_queue);\n}\n\nbool get_myString_poll(sb_event_counter_t *numDropped, Base_Types_String *data) {\n  return sb_queue_Base_Types_String_1_dequeue((sb_queue_Base_Types_String_1_Recv_t *) &myString_recv_queue, numDropped, data);\n}\n\nbool get_myString(Base_Types_String *data) {\n  sb_event_counter_t numDropped;\n  return get_myString_poll (&numDropped, data);\n}\n\nbool myInt8_is_empty(void) {\n  return sb_queue_int8_t_1_is_empty(&myInt8_recv_queue);\n}\n\nbool get_myInt8_poll(sb_event_counter_t *numDropped, int8_t *data) {\n  return sb_queue_int8_t_1_dequeue((sb_queue_int8_t_1_Recv_t *) &myInt8_recv_queue, numDropped, data);\n}\n\nbool get_myInt8(int8_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myInt8_poll (&numDropped, data);\n}\n\nbool myInt16_is_empty(void) {\n  return sb_queue_int16_t_1_is_empty(&myInt16_recv_queue);\n}\n\nbool get_myInt16_poll(sb_event_counter_t *numDropped, int16_t *data) {\n  return sb_queue_int16_t_1_dequeue((sb_queue_int16_t_1_Recv_t *) &myInt16_recv_queue, numDropped, data);\n}\n\nbool get_myInt16(int16_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myInt16_poll (&numDropped, data);\n}\n\nbool myInt32_is_empty(void) {\n  return sb_queue_int32_t_1_is_empty(&myInt32_recv_queue);\n}\n\nbool get_myInt32_poll(sb_event_counter_t *numDropped, int32_t *data) {\n  return sb_queue_int32_t_1_dequeue((sb_queue_int32_t_1_Recv_t *) &myInt32_recv_queue, numDropped, data);\n}\n\nbool get_myInt32(int32_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myInt32_poll (&numDropped, data);\n}\n\nbool myInt64_is_empty(void) {\n  return sb_queue_int64_t_1_is_empty(&myInt64_recv_queue);\n}\n\nbool get_myInt64_poll(sb_event_counter_t *numDropped, int64_t *data) {\n  return sb_queue_int64_t_1_dequeue((sb_queue_int64_t_1_Recv_t *) &myInt64_recv_queue, numDropped, data);\n}\n\nbool get_myInt64(int64_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myInt64_poll (&numDropped, data);\n}\n\nbool myUInt8_is_empty(void) {\n  return sb_queue_uint8_t_1_is_empty(&myUInt8_recv_queue);\n}\n\nbool get_myUInt8_poll(sb_event_counter_t *numDropped, uint8_t *data) {\n  return sb_queue_uint8_t_1_dequeue((sb_queue_uint8_t_1_Recv_t *) &myUInt8_recv_queue, numDropped, data);\n}\n\nbool get_myUInt8(uint8_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myUInt8_poll (&numDropped, data);\n}\n\nbool myUInt16_is_empty(void) {\n  return sb_queue_uint16_t_1_is_empty(&myUInt16_recv_queue);\n}\n\nbool get_myUInt16_poll(sb_event_counter_t *numDropped, uint16_t *data) {\n  return sb_queue_uint16_t_1_dequeue((sb_queue_uint16_t_1_Recv_t *) &myUInt16_recv_queue, numDropped, data);\n}\n\nbool get_myUInt16(uint16_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myUInt16_poll (&numDropped, data);\n}\n\nbool myUInt32_is_empty(void) {\n  return sb_queue_uint32_t_1_is_empty(&myUInt32_recv_queue);\n}\n\nbool get_myUInt32_poll(sb_event_counter_t *numDropped, uint32_t *data) {\n  return sb_queue_uint32_t_1_dequeue((sb_queue_uint32_t_1_Recv_t *) &myUInt32_recv_queue, numDropped, data);\n}\n\nbool get_myUInt32(uint32_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myUInt32_poll (&numDropped, data);\n}\n\nbool myUInt64_is_empty(void) {\n  return sb_queue_uint64_t_1_is_empty(&myUInt64_recv_queue);\n}\n\nbool get_myUInt64_poll(sb_event_counter_t *numDropped, uint64_t *data) {\n  return sb_queue_uint64_t_1_dequeue((sb_queue_uint64_t_1_Recv_t *) &myUInt64_recv_queue, numDropped, data);\n}\n\nbool get_myUInt64(uint64_t *data) {\n  sb_event_counter_t numDropped;\n  return get_myUInt64_poll (&numDropped, data);\n}\n\nbool myFloat32_is_empty(void) {\n  return sb_queue_float_1_is_empty(&myFloat32_recv_queue);\n}\n\nbool get_myFloat32_poll(sb_event_counter_t *numDropped, float *data) {\n  return sb_queue_float_1_dequeue((sb_queue_float_1_Recv_t *) &myFloat32_recv_queue, numDropped, data);\n}\n\nbool get_myFloat32(float *data) {\n  sb_event_counter_t numDropped;\n  return get_myFloat32_poll (&numDropped, data);\n}\n\nbool myFloat64_is_empty(void) {\n  return sb_queue_double_1_is_empty(&myFloat64_recv_queue);\n}\n\nbool get_myFloat64_poll(sb_event_counter_t *numDropped, double *data) {\n  return sb_queue_double_1_dequeue((sb_queue_double_1_Recv_t *) &myFloat64_recv_queue, numDropped, data);\n}\n\nbool get_myFloat64(double *data) {\n  sb_event_counter_t numDropped;\n  return get_myFloat64_poll (&numDropped, data);\n}\n\nbool myEnum_is_empty(void) {\n  return sb_queue_Aadl_Datatypes_MyEnum_1_is_empty(&myEnum_recv_queue);\n}\n\nbool get_myEnum_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyEnum *data) {\n  return sb_queue_Aadl_Datatypes_MyEnum_1_dequeue((sb_queue_Aadl_Datatypes_MyEnum_1_Recv_t *) &myEnum_recv_queue, numDropped, data);\n}\n\nbool get_myEnum(Aadl_Datatypes_MyEnum *data) {\n  sb_event_counter_t numDropped;\n  return get_myEnum_poll (&numDropped, data);\n}\n\nbool myStruct_is_empty(void) {\n  return sb_queue_Aadl_Datatypes_MyStruct_i_1_is_empty(&myStruct_recv_queue);\n}\n\nbool get_myStruct_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyStruct_i *data) {\n  return sb_queue_Aadl_Datatypes_MyStruct_i_1_dequeue((sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_t *) &myStruct_recv_queue, numDropped, data);\n}\n\nbool get_myStruct(Aadl_Datatypes_MyStruct_i *data) {\n  sb_event_counter_t numDropped;\n  return get_myStruct_poll (&numDropped, data);\n}\n\nbool myArray1_is_empty(void) {\n  return sb_queue_Aadl_Datatypes_MyArrayOneDim_1_is_empty(&myArray1_recv_queue);\n}\n\nbool get_myArray1_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyArrayOneDim *data) {\n  return sb_queue_Aadl_Datatypes_MyArrayOneDim_1_dequeue((sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *) &myArray1_recv_queue, numDropped, data);\n}\n\nbool get_myArray1(Aadl_Datatypes_MyArrayOneDim *data) {\n  sb_event_counter_t numDropped;\n  return get_myArray1_poll (&numDropped, data);\n}\n\nvoid init(void) {\n  sb_queue_bool_1_Recv_init(&myBoolean_recv_queue, (sb_queue_bool_1_t *) myBoolean_queue_1);\n\n  sb_queue_char_1_Recv_init(&myCharacter_recv_queue, (sb_queue_char_1_t *) myCharacter_queue_1);\n\n  sb_queue_Base_Types_String_1_Recv_init(&myString_recv_queue, (sb_queue_Base_Types_String_1_t *) myString_queue_1);\n\n  sb_queue_int8_t_1_Recv_init(&myInt8_recv_queue, (sb_queue_int8_t_1_t *) myInt8_queue_1);\n\n  sb_queue_int16_t_1_Recv_init(&myInt16_recv_queue, (sb_queue_int16_t_1_t *) myInt16_queue_1);\n\n  sb_queue_int32_t_1_Recv_init(&myInt32_recv_queue, (sb_queue_int32_t_1_t *) myInt32_queue_1);\n\n  sb_queue_int64_t_1_Recv_init(&myInt64_recv_queue, (sb_queue_int64_t_1_t *) myInt64_queue_1);\n\n  sb_queue_uint8_t_1_Recv_init(&myUInt8_recv_queue, (sb_queue_uint8_t_1_t *) myUInt8_queue_1);\n\n  sb_queue_uint16_t_1_Recv_init(&myUInt16_recv_queue, (sb_queue_uint16_t_1_t *) myUInt16_queue_1);\n\n  sb_queue_uint32_t_1_Recv_init(&myUInt32_recv_queue, (sb_queue_uint32_t_1_t *) myUInt32_queue_1);\n\n  sb_queue_uint64_t_1_Recv_init(&myUInt64_recv_queue, (sb_queue_uint64_t_1_t *) myUInt64_queue_1);\n\n  sb_queue_float_1_Recv_init(&myFloat32_recv_queue, (sb_queue_float_1_t *) myFloat32_queue_1);\n\n  sb_queue_double_1_Recv_init(&myFloat64_recv_queue, (sb_queue_double_1_t *) myFloat64_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyEnum_1_Recv_init(&myEnum_recv_queue, (sb_queue_Aadl_Datatypes_MyEnum_1_t *) myEnum_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyStruct_i_1_Recv_init(&myStruct_recv_queue, (sb_queue_Aadl_Datatypes_MyStruct_i_1_t *) myStruct_queue_1);\n\n  sb_queue_Aadl_Datatypes_MyArrayOneDim_1_Recv_init(&myArray1_recv_queue, (sb_queue_Aadl_Datatypes_MyArrayOneDim_1_t *) myArray1_queue_1);\n\n  consumer_consumer_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      consumer_consumer_timeTriggered();\n      break;\n    default:\n      consumer_consumer_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/consumer_consumer\/src\/consumer_consumer_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"consumer_consumer.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid consumer_consumer_initialize(void) {\n  printf(\"%s: consumer_consumer_initialize invoked\\n\", microkit_name);\n}\n\nvoid consumer_consumer_timeTriggered(void) {\n  printf(\"%s: consumer_consumer_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid consumer_consumer_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/consumer_consumer\/include\/consumer_consumer.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool myBoolean_is_empty(void);\nbool get_myBoolean_poll(sb_event_counter_t *numDropped, bool *data);\nbool get_myBoolean(bool *data);\nbool myCharacter_is_empty(void);\nbool get_myCharacter_poll(sb_event_counter_t *numDropped, char *data);\nbool get_myCharacter(char *data);\nbool myString_is_empty(void);\nbool get_myString_poll(sb_event_counter_t *numDropped, Base_Types_String *data);\nbool get_myString(Base_Types_String *data);\nbool myInt8_is_empty(void);\nbool get_myInt8_poll(sb_event_counter_t *numDropped, int8_t *data);\nbool get_myInt8(int8_t *data);\nbool myInt16_is_empty(void);\nbool get_myInt16_poll(sb_event_counter_t *numDropped, int16_t *data);\nbool get_myInt16(int16_t *data);\nbool myInt32_is_empty(void);\nbool get_myInt32_poll(sb_event_counter_t *numDropped, int32_t *data);\nbool get_myInt32(int32_t *data);\nbool myInt64_is_empty(void);\nbool get_myInt64_poll(sb_event_counter_t *numDropped, int64_t *data);\nbool get_myInt64(int64_t *data);\nbool myUInt8_is_empty(void);\nbool get_myUInt8_poll(sb_event_counter_t *numDropped, uint8_t *data);\nbool get_myUInt8(uint8_t *data);\nbool myUInt16_is_empty(void);\nbool get_myUInt16_poll(sb_event_counter_t *numDropped, uint16_t *data);\nbool get_myUInt16(uint16_t *data);\nbool myUInt32_is_empty(void);\nbool get_myUInt32_poll(sb_event_counter_t *numDropped, uint32_t *data);\nbool get_myUInt32(uint32_t *data);\nbool myUInt64_is_empty(void);\nbool get_myUInt64_poll(sb_event_counter_t *numDropped, uint64_t *data);\nbool get_myUInt64(uint64_t *data);\nbool myFloat32_is_empty(void);\nbool get_myFloat32_poll(sb_event_counter_t *numDropped, float *data);\nbool get_myFloat32(float *data);\nbool myFloat64_is_empty(void);\nbool get_myFloat64_poll(sb_event_counter_t *numDropped, double *data);\nbool get_myFloat64(double *data);\nbool myEnum_is_empty(void);\nbool get_myEnum_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyEnum *data);\nbool get_myEnum(Aadl_Datatypes_MyEnum *data);\nbool myStruct_is_empty(void);\nbool get_myStruct_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyStruct_i *data);\nbool get_myStruct(Aadl_Datatypes_MyStruct_i *data);\nbool myArray1_is_empty(void);\nbool get_myArray1_poll(sb_event_counter_t *numDropped, Aadl_Datatypes_MyArrayOneDim *data);\nbool get_myArray1(Aadl_Datatypes_MyArrayOneDim *data);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/pacer\/src\/pacer.c",
        {
          "type" : "ITestResource",
          "content" : "#include <stdint.h>\n#include <microkit.h>\n\n#define PORT_TO_PRODUCER_PRODUCER_MON 61\n#define PORT_TO_CONSUMER_CONSUMER_MON 59\n\nvoid init(void) {}\n\nvoid notified(microkit_channel channel) {\n  switch(channel) {\n    case PORT_TO_PRODUCER_PRODUCER_MON:\n      microkit_notify(PORT_TO_PRODUCER_PRODUCER_MON);\n      break;\n    case PORT_TO_CONSUMER_CONSUMER_MON:\n      microkit_notify(PORT_TO_CONSUMER_CONSUMER_MON);\n      break;\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/microkit.system",
        {
          "type" : "ITestResource",
          "content" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<system>\n  <domain_schedule>\n    <domain name=\"domain_1\" length=\"10\" \/>\n    <domain name=\"domain_2\" length=\"50\" \/>\n    <domain name=\"domain_1\" length=\"10\" \/>\n    <domain name=\"domain_3\" length=\"50\" \/>\n    <domain name=\"domain_0\" length=\"880\" \/>\n  <\/domain_schedule>\n\n  <protection_domain name=\"producer_producer_MON\" domain=\"domain_2\">\n    <program_image path=\"producer_producer_MON.elf\" \/>\n    <protection_domain name=\"producer_producer\" domain=\"domain_2\" id=\"1\">\n      <program_image path=\"producer_producer.elf\" \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myBoolean_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myCharacter_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myString_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myString_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt8_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myInt8_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt16_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myInt16_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt32_1_Memory_Region\"\n           vaddr=\"0x10_005_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myInt32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt64_1_Memory_Region\"\n           vaddr=\"0x10_006_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myInt64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region\"\n           vaddr=\"0x10_007_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myUInt8_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region\"\n           vaddr=\"0x10_008_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myUInt16_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region\"\n           vaddr=\"0x10_009_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myUInt32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region\"\n           vaddr=\"0x10_00A_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myUInt64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region\"\n           vaddr=\"0x10_00B_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myFloat32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region\"\n           vaddr=\"0x10_00C_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myFloat64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myEnum_1_Memory_Region\"\n           vaddr=\"0x10_00D_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myEnum_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myStruct_1_Memory_Region\"\n           vaddr=\"0x10_00E_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myStruct_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myArray1_1_Memory_Region\"\n           vaddr=\"0x10_00F_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"myArray1_queue_1\"\n      \/>\n    <\/protection_domain>\n  <\/protection_domain>\n\n  <protection_domain name=\"consumer_consumer_MON\" domain=\"domain_3\">\n    <program_image path=\"consumer_consumer_MON.elf\" \/>\n    <protection_domain name=\"consumer_consumer\" domain=\"domain_3\" id=\"1\">\n      <program_image path=\"consumer_consumer.elf\" \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myBoolean_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myCharacter_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myString_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myString_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt8_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myInt8_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt16_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myInt16_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt32_1_Memory_Region\"\n           vaddr=\"0x10_005_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myInt32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myInt64_1_Memory_Region\"\n           vaddr=\"0x10_006_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myInt64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region\"\n           vaddr=\"0x10_007_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myUInt8_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region\"\n           vaddr=\"0x10_008_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myUInt16_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region\"\n           vaddr=\"0x10_009_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myUInt32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region\"\n           vaddr=\"0x10_00A_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myUInt64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region\"\n           vaddr=\"0x10_00B_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myFloat32_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region\"\n           vaddr=\"0x10_00C_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myFloat64_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myEnum_1_Memory_Region\"\n           vaddr=\"0x10_00D_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myEnum_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myStruct_1_Memory_Region\"\n           vaddr=\"0x10_00E_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myStruct_queue_1\"\n      \/>\n      <map mr=\"Sys_i_Instance_producer_producer_myArray1_1_Memory_Region\"\n           vaddr=\"0x10_00F_000\"\n           perms=\"r\"\n           setvar_vaddr=\"myArray1_queue_1\"\n      \/>\n    <\/protection_domain>\n  <\/protection_domain>\n\n  <protection_domain name=\"pacer\" domain=\"domain_1\">\n    <program_image path=\"pacer.elf\" \/>\n  <\/protection_domain>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myString_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myInt8_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myInt16_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myInt32_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myInt64_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myEnum_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myStruct_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Sys_i_Instance_producer_producer_myArray1_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <channel>\n    <end pd=\"pacer\" id=\"61\" \/>\n    <end pd=\"producer_producer_MON\" id=\"61\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"producer_producer_MON\" id=\"60\" \/>\n    <end pd=\"producer_producer\" id=\"60\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"59\" \/>\n    <end pd=\"consumer_consumer_MON\" id=\"59\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"consumer_consumer_MON\" id=\"58\" \/>\n    <end pd=\"consumer_consumer\" id=\"58\" \/>\n  <\/channel>\n<\/system>",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/microkit.dot",
        {
          "type" : "ITestResource",
          "content" : "digraph microkit {\n  compound=true;\n\n  \/\/ protection domains\n  graph [style=rounded]\n  subgraph cluster_producer_producer_MON {\n    label = \"producer_producer_MON\";\n    producer_producer_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_producer_producer {\n      label = \"producer_producer\";\n      producer_producer_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_producer_producer_myBoolean_queue_1 [label=myBoolean_queue_1];\n      pd_producer_producer_myCharacter_queue_1 [label=myCharacter_queue_1];\n      pd_producer_producer_myString_queue_1 [label=myString_queue_1];\n      pd_producer_producer_myInt8_queue_1 [label=myInt8_queue_1];\n      pd_producer_producer_myInt16_queue_1 [label=myInt16_queue_1];\n      pd_producer_producer_myInt32_queue_1 [label=myInt32_queue_1];\n      pd_producer_producer_myInt64_queue_1 [label=myInt64_queue_1];\n      pd_producer_producer_myUInt8_queue_1 [label=myUInt8_queue_1];\n      pd_producer_producer_myUInt16_queue_1 [label=myUInt16_queue_1];\n      pd_producer_producer_myUInt32_queue_1 [label=myUInt32_queue_1];\n      pd_producer_producer_myUInt64_queue_1 [label=myUInt64_queue_1];\n      pd_producer_producer_myFloat32_queue_1 [label=myFloat32_queue_1];\n      pd_producer_producer_myFloat64_queue_1 [label=myFloat64_queue_1];\n      pd_producer_producer_myEnum_queue_1 [label=myEnum_queue_1];\n      pd_producer_producer_myStruct_queue_1 [label=myStruct_queue_1];\n      pd_producer_producer_myArray1_queue_1 [label=myArray1_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_consumer_consumer_MON {\n    label = \"consumer_consumer_MON\";\n    consumer_consumer_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_consumer_consumer {\n      label = \"consumer_consumer\";\n      consumer_consumer_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_consumer_consumer_myBoolean_queue_1 [label=myBoolean_queue_1];\n      pd_consumer_consumer_myCharacter_queue_1 [label=myCharacter_queue_1];\n      pd_consumer_consumer_myString_queue_1 [label=myString_queue_1];\n      pd_consumer_consumer_myInt8_queue_1 [label=myInt8_queue_1];\n      pd_consumer_consumer_myInt16_queue_1 [label=myInt16_queue_1];\n      pd_consumer_consumer_myInt32_queue_1 [label=myInt32_queue_1];\n      pd_consumer_consumer_myInt64_queue_1 [label=myInt64_queue_1];\n      pd_consumer_consumer_myUInt8_queue_1 [label=myUInt8_queue_1];\n      pd_consumer_consumer_myUInt16_queue_1 [label=myUInt16_queue_1];\n      pd_consumer_consumer_myUInt32_queue_1 [label=myUInt32_queue_1];\n      pd_consumer_consumer_myUInt64_queue_1 [label=myUInt64_queue_1];\n      pd_consumer_consumer_myFloat32_queue_1 [label=myFloat32_queue_1];\n      pd_consumer_consumer_myFloat64_queue_1 [label=myFloat64_queue_1];\n      pd_consumer_consumer_myEnum_queue_1 [label=myEnum_queue_1];\n      pd_consumer_consumer_myStruct_queue_1 [label=myStruct_queue_1];\n      pd_consumer_consumer_myArray1_queue_1 [label=myArray1_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_pacer {\n    label = \"pacer\";\n    pacer_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n  }\n\n  \/\/ memory regions\n  Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myString_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myInt8_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myInt16_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myInt32_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myInt64_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myEnum_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myStruct_1_Memory_Region;\n\n  Sys_i_Instance_producer_producer_myArray1_1_Memory_Region;\n\n  \/\/ channels\n  pacer_INVIS -> producer_producer_MON_INVIS [lhead=cluster_producer_producer_MON, minlen=2, dir=both];\n  producer_producer_MON_INVIS -> producer_producer_INVIS [lhead=cluster_producer_producer, minlen=2, dir=both];\n  pacer_INVIS -> consumer_consumer_MON_INVIS [lhead=cluster_consumer_consumer_MON, minlen=2, dir=both];\n  consumer_consumer_MON_INVIS -> consumer_consumer_INVIS [lhead=cluster_consumer_consumer, minlen=2, dir=both];\n\n  \/\/ shared memory mappings\n  pd_producer_producer_myBoolean_queue_1 -> Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myCharacter_queue_1 -> Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myString_queue_1 -> Sys_i_Instance_producer_producer_myString_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myInt8_queue_1 -> Sys_i_Instance_producer_producer_myInt8_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myInt16_queue_1 -> Sys_i_Instance_producer_producer_myInt16_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myInt32_queue_1 -> Sys_i_Instance_producer_producer_myInt32_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myInt64_queue_1 -> Sys_i_Instance_producer_producer_myInt64_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myUInt8_queue_1 -> Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myUInt16_queue_1 -> Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myUInt32_queue_1 -> Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myUInt64_queue_1 -> Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myFloat32_queue_1 -> Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myFloat64_queue_1 -> Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myEnum_queue_1 -> Sys_i_Instance_producer_producer_myEnum_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myStruct_queue_1 -> Sys_i_Instance_producer_producer_myStruct_1_Memory_Region [dir=both, style=dashed];\n  pd_producer_producer_myArray1_queue_1 -> Sys_i_Instance_producer_producer_myArray1_1_Memory_Region [dir=both, style=dashed];\n  pd_consumer_consumer_myBoolean_queue_1 -> Sys_i_Instance_producer_producer_myBoolean_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myCharacter_queue_1 -> Sys_i_Instance_producer_producer_myCharacter_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myString_queue_1 -> Sys_i_Instance_producer_producer_myString_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myInt8_queue_1 -> Sys_i_Instance_producer_producer_myInt8_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myInt16_queue_1 -> Sys_i_Instance_producer_producer_myInt16_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myInt32_queue_1 -> Sys_i_Instance_producer_producer_myInt32_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myInt64_queue_1 -> Sys_i_Instance_producer_producer_myInt64_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myUInt8_queue_1 -> Sys_i_Instance_producer_producer_myUInt8_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myUInt16_queue_1 -> Sys_i_Instance_producer_producer_myUInt16_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myUInt32_queue_1 -> Sys_i_Instance_producer_producer_myUInt32_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myUInt64_queue_1 -> Sys_i_Instance_producer_producer_myUInt64_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myFloat32_queue_1 -> Sys_i_Instance_producer_producer_myFloat32_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myFloat64_queue_1 -> Sys_i_Instance_producer_producer_myFloat64_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myEnum_queue_1 -> Sys_i_Instance_producer_producer_myEnum_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myStruct_queue_1 -> Sys_i_Instance_producer_producer_myStruct_1_Memory_Region [dir=back, style=dashed];\n  pd_consumer_consumer_myArray1_queue_1 -> Sys_i_Instance_producer_producer_myArray1_1_Memory_Region [dir=back, style=dashed];\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if codegen is rerun\n\nifeq ($(strip $(MICROKIT_SDK)),)\n$(error MICROKIT_SDK must be specified)\nendif\noverride MICROKIT_SDK := $(abspath ${MICROKIT_SDK})\n\nSYSTEM_MAKEFILE ?= system.mk\n\nexport CPU = cortex-a53\nexport QEMU = qemu-system-aarch64\n\nexport AR := ar\nexport CC := clang\nexport DTC := dtc\nexport LD := ld.lld\nexport RANLIB := llvm-ranlib\n\nexport TOP_DIR := $(abspath $(dir ${MAKEFILE_LIST}))\nexport TOP_BUILD_DIR := $(abspath build)\n\nexport CRATES_DIR := $(TOP_DIR)\/crates\n\nexport TARGET := aarch64-none-elf\n\n# By default we make a debug build so that the client debug prints can be seen.\nexport MICROKIT_CONFIG ?= debug\n\nexport MICROKIT_SDK := $(abspath $(MICROKIT_SDK))\nexport MICROKIT_TOOL := $(abspath $(MICROKIT_SDK)\/bin\/microkit)\nexport MICROKIT_BOARD_DIR := $(abspath $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG))\n\n\nIMAGE_FILE := $(TOP_BUILD_DIR)\/loader.img\nREPORT_FILE := $(TOP_BUILD_DIR)\/report.txt\n\nall: ${IMAGE_FILE}\n\nqemu ${IMAGE_FILE} ${REPORT_FILE} clean clobber: $(IMAGE_FILE) ${TOP_BUILD_DIR}\/Makefile FORCE\n\t${MAKE} -C ${TOP_BUILD_DIR} $(notdir $@)\n\n${TOP_BUILD_DIR}\/Makefile: $(SYSTEM_MAKEFILE)\n\tmkdir -p ${TOP_BUILD_DIR}\n\tcp $(SYSTEM_MAKEFILE) ${TOP_BUILD_DIR}\/Makefile\n\ntest: \n\tmake -C ${CRATES_DIR}\/consumer_consumer test\n\nFORCE:\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/system.mk",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if codegen is rerun\n\nifeq ($(strip $(MICROKIT_SDK)),)\n$(error MICROKIT_SDK must be specified)\nendif\n\nMICROKIT_TOOL ?= $(MICROKIT_SDK)\/bin\/microkit\n\nifeq (\"$(wildcard $(MICROKIT_TOOL))\",\"\")\n$(error Microkit tool not found at ${MICROKIT_TOOL})\nendif\n\nifeq ($(strip $(MICROKIT_BOARD)),)\n$(error MICROKIT_BOARD must be specified)\nendif\n\nCFLAGS := -mcpu=$(CPU) \\\n\t-mstrict-align \\\n\t-ffreestanding \\\n\t-nostdlib \\\n\t-g3 \\\n\t-O3 \\\n\t-Wall -Wno-unused-function -Werror -Wno-unused-command-line-argument \\\n\t-I$(MICROKIT_BOARD_DIR)\/include \\\n\t-target $(TARGET)\n\nLDFLAGS := -L$(MICROKIT_BOARD_DIR)\/lib\nLIBS := --start-group -lmicrokit -Tmicrokit.ld --end-group\n\nSYSTEM_FILE := $(TOP_DIR)\/microkit.system\n\nIMAGES := producer_producer.elf producer_producer_MON.elf consumer_consumer.elf consumer_consumer_MON.elf pacer.elf\nIMAGE_FILE = loader.img\nREPORT_FILE = report.txt\n\nUTIL_OBJS = printf.o util.o\n\nTYPES_DIR = $(TOP_DIR)\/types\nTYPE_OBJS := $(TOP_DIR)\/build\/sb_queue_bool_1.o $(TOP_DIR)\/build\/sb_queue_char_1.o $(TOP_DIR)\/build\/sb_queue_Base_Types_String_1.o $(TOP_DIR)\/build\/sb_queue_int8_t_1.o $(TOP_DIR)\/build\/sb_queue_int16_t_1.o $(TOP_DIR)\/build\/sb_queue_int32_t_1.o $(TOP_DIR)\/build\/sb_queue_int64_t_1.o $(TOP_DIR)\/build\/sb_queue_uint8_t_1.o $(TOP_DIR)\/build\/sb_queue_uint16_t_1.o $(TOP_DIR)\/build\/sb_queue_uint32_t_1.o $(TOP_DIR)\/build\/sb_queue_uint64_t_1.o $(TOP_DIR)\/build\/sb_queue_float_1.o $(TOP_DIR)\/build\/sb_queue_double_1.o $(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyEnum_1.o $(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyStruct_i_1.o $(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyArrayOneDim_1.o\n\n# exporting TOP_TYPES_INCLUDE in case other makefiles need it\nexport TOP_TYPES_INCLUDE = -I$(TYPES_DIR)\/include\n\nTOP_INCLUDE = $(TOP_TYPES_INCLUDE) -I$(TOP_DIR)\/util\/include\n\nall: $(IMAGE_FILE)\n\tCHECK_FLAGS_BOARD_MD5:=.board_cflags-$(shell echo -- ${CFLAGS} ${MICROKIT_BOARD} ${MICROKIT_CONFIG}| shasum | sed 's\/ *-\/\/')\n\n${CHECK_FLAGS_BOARD_MD5}:\n\t-rm -f .board_cflags-*\n\ttouch $@\n\n%.o: ${TOP_DIR}\/util\/src\/%.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ -I$(TOP_DIR)\/util\/include\n\n$(TOP_DIR)\/build\/sb_queue_bool_1.o: $(TOP_DIR)\/types\/src\/sb_queue_bool_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_char_1.o: $(TOP_DIR)\/types\/src\/sb_queue_char_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Base_Types_String_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Base_Types_String_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_int8_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_int8_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_int16_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_int16_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_int32_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_int32_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_int64_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_int64_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_uint8_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_uint8_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_uint16_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_uint16_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_uint32_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_uint32_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_uint64_t_1.o: $(TOP_DIR)\/types\/src\/sb_queue_uint64_t_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_float_1.o: $(TOP_DIR)\/types\/src\/sb_queue_float_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_double_1.o: $(TOP_DIR)\/types\/src\/sb_queue_double_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyEnum_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Aadl_Datatypes_MyEnum_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyStruct_i_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Aadl_Datatypes_MyStruct_i_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Aadl_Datatypes_MyArrayOneDim_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Aadl_Datatypes_MyArrayOneDim_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n# monitor\nproducer_producer_MON.o: $(TOP_DIR)\/components\/producer_producer\/src\/producer_producer_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/producer_producer\/include\n\n# user code\nproducer_producer_user.o: $(TOP_DIR)\/components\/producer_producer\/src\/producer_producer_user.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\/ -I$(TOP_DIR)\/components\/producer_producer\/include\n\nproducer_producer.o: $(TOP_DIR)\/components\/producer_producer\/src\/producer_producer.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/producer_producer\/include\n\n# monitor\nconsumer_consumer_MON.o: $(TOP_DIR)\/components\/consumer_consumer\/src\/consumer_consumer_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/consumer_consumer\/include\n\n# user code\nconsumer_consumer_rust:\n\tmake -C ${CRATES_DIR}\/consumer_consumer\n\nconsumer_consumer.o: $(TOP_DIR)\/components\/consumer_consumer\/src\/consumer_consumer.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/consumer_consumer\/include\n\npacer.o: $(TOP_DIR)\/components\/pacer\/src\/pacer.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ -I$(TOP_INCLUDE)\n\nproducer_producer_MON.elf: producer_producer_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nproducer_producer.elf: $(UTIL_OBJS) $(TYPE_OBJS) producer_producer_user.o producer_producer.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nconsumer_consumer_MON.elf: consumer_consumer_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nconsumer_consumer.elf: $(UTIL_OBJS) $(TYPE_OBJS) consumer_consumer_rust consumer_consumer.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/consumer_consumer\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lconsumer_consumer -o $@\n\npacer.elf: $(UTIL_OBJS) $(TYPE_OBJS) pacer.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\n$(IMAGE_FILE): $(IMAGES) $(SYSTEM_FILE)\n\t$(MICROKIT_TOOL) $(SYSTEM_FILE) --search-path $(TOP_BUILD_DIR) --board $(MICROKIT_BOARD) --config $(MICROKIT_CONFIG) -o $(IMAGE_FILE) -r $(REPORT_FILE)\n\n\nqemu: $(IMAGE_FILE)\n\t$(QEMU) -machine virt,virtualization=on \\\n\t\t\t-cpu cortex-a53 \\\n\t\t\t-serial mon:stdio \\\n\t\t\t-device loader,file=$(IMAGE_FILE),addr=0x70000000,cpu-num=0 \\\n\t\t\t-m size=2G \\\n\t\t\t-nographic\n\nclean::\n\trm -f ${(oFiles, \" \")}\n\nclobber:: clean\n\trm -f producer_producer.elf producer_producer_MON.elf consumer_consumer.elf consumer_consumer_MON.elf pacer.elf ${IMAGE_FILE} ${REPORT_FILE}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/include\/printf.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ \\author (c) Marco Paland (info@paland.com)\n\/\/             2014-2019, PALANDesign Hannover, Germany\n\/\/\n\/\/ \\license The MIT License (MIT)\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\/\/ \\brief Tiny printf, sprintf and snprintf implementation, optimized for speed on\n\/\/        embedded systems with a very limited resources.\n\/\/        Use this instead of bloated standard\/newlib printf.\n\/\/        These routines are thread safe and reentrant.\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#ifndef _PRINTF_H_\n#define _PRINTF_H_\n\n#include <stdarg.h>\n#include <stddef.h>\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\/**\n * Output a character to a custom device like UART, used by the printf() function\n * This function is declared here only. You have to write your custom implementation somewhere\n * \\param character Character to output\n *\/\nvoid _putchar(char character);\n\n\n\/**\n * Tiny printf implementation\n * You have to implement _putchar if you use printf()\n * To avoid conflicts with the regular printf() API it is overridden by macro defines\n * and internal underscore-appended functions like printf_() are used\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are written into the array, not counting the terminating null character\n *\/\n#define printf printf_\nint printf_(const char* format, ...);\n\n\n\/**\n * Tiny sprintf implementation\n * Due to security reasons (buffer overflow) YOU SHOULD CONSIDER USING (V)SNPRINTF INSTEAD!\n * \\param buffer A pointer to the buffer where to store the formatted string. MUST be big enough to store the output!\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\n *\/\n#define sprintf sprintf_\nint sprintf_(char* buffer, const char* format, ...);\n\n\n\/**\n * Tiny snprintf\/vsnprintf implementation\n * \\param buffer A pointer to the buffer where to store the formatted string\n * \\param count The maximum number of characters to store in the buffer, including a terminating null character\n * \\param format A string that specifies the format of the output\n * \\param va A value identifying a variable arguments list\n * \\return The number of characters that COULD have been written into the buffer, not counting the terminating\n *         null character. A value equal or larger than count indicates truncation. Only when the returned value\n *         is non-negative and less than count, the string has been completely written.\n *\/\n#define snprintf  snprintf_\n#define vsnprintf vsnprintf_\nint  snprintf_(char* buffer, size_t count, const char* format, ...);\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va);\n\n\n\/**\n * Tiny vprintf implementation\n * \\param format A string that specifies the format of the output\n * \\param va A value identifying a variable arguments list\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\n *\/\n#define vprintf vprintf_\nint vprintf_(const char* format, va_list va);\n\n\n\/**\n * printf with output function\n * You may use this as dynamic alternative to printf() with its fixed _putchar() output\n * \\param out An output function which takes one character and an argument pointer\n * \\param arg An argument pointer for user data passed to output function\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are sent to the output function, not counting the terminating null character\n *\/\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif  \/\/ _PRINTF_H_\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/src\/printf.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ \\author (c) Marco Paland (info@paland.com)\n\/\/             2014-2019, PALANDesign Hannover, Germany\n\/\/\n\/\/ \\license The MIT License (MIT)\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\/\/ \\brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on\n\/\/        embedded systems with a very limited resources. These routines are thread\n\/\/        safe and reentrant!\n\/\/        Use this instead of the bloated standard\/newlib printf cause these use\n\/\/        malloc for printf (and may not be thread safe).\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"printf.h\"\n\n\n\/\/ define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the\n\/\/ printf_config.h header file\n\/\/ default: undefined\n#ifdef PRINTF_INCLUDE_CONFIG_H\n#include \"printf_config.h\"\n#endif\n\n\n\/\/ 'ntoa' conversion buffer size, this must be big enough to hold one converted\n\/\/ numeric number including padded zeros (dynamically created on stack)\n\/\/ default: 32 byte\n#ifndef PRINTF_NTOA_BUFFER_SIZE\n#define PRINTF_NTOA_BUFFER_SIZE    32U\n#endif\n\n\/\/ 'ftoa' conversion buffer size, this must be big enough to hold one converted\n\/\/ float number including padded zeros (dynamically created on stack)\n\/\/ default: 32 byte\n#ifndef PRINTF_FTOA_BUFFER_SIZE\n#define PRINTF_FTOA_BUFFER_SIZE    32U\n#endif\n\n\/\/ support for the floating point type (%f)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\n#define PRINTF_SUPPORT_FLOAT\n#endif\n\n\/\/ support for exponential floating point notation (%e\/%g)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\n#define PRINTF_SUPPORT_EXPONENTIAL\n#endif\n\n\/\/ define the default floating point precision\n\/\/ default: 6 digits\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\n#endif\n\n\/\/ define the largest float suitable to print with %f\n\/\/ default: 1e9\n#ifndef PRINTF_MAX_FLOAT\n#define PRINTF_MAX_FLOAT  1e9\n#endif\n\n\/\/ support for the long long types (%llu or %p)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\n#define PRINTF_SUPPORT_LONG_LONG\n#endif\n\n\/\/ support for the ptrdiff_t type (%t)\n\/\/ ptrdiff_t is normally defined in <stddef.h> as long or long long type\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\n#define PRINTF_SUPPORT_PTRDIFF_T\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ internal flag definitions\n#define FLAGS_ZEROPAD   (1U <<  0U)\n#define FLAGS_LEFT      (1U <<  1U)\n#define FLAGS_PLUS      (1U <<  2U)\n#define FLAGS_SPACE     (1U <<  3U)\n#define FLAGS_HASH      (1U <<  4U)\n#define FLAGS_UPPERCASE (1U <<  5U)\n#define FLAGS_CHAR      (1U <<  6U)\n#define FLAGS_SHORT     (1U <<  7U)\n#define FLAGS_LONG      (1U <<  8U)\n#define FLAGS_LONG_LONG (1U <<  9U)\n#define FLAGS_PRECISION (1U << 10U)\n#define FLAGS_ADAPT_EXP (1U << 11U)\n\n\n\/\/ import float.h for DBL_MAX\n#if defined(PRINTF_SUPPORT_FLOAT)\n#include <float.h>\n#endif\n\n\n\/\/ output function type\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\n\n\n\/\/ wrapper (used as buffer) for output function type\ntypedef struct {\n  void  (*fct)(char character, void* arg);\n  void* arg;\n} out_fct_wrap_type;\n\n\n\/\/ internal buffer output\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  if (idx < maxlen) {\n    ((char*)buffer)[idx] = character;\n  }\n}\n\n\n\/\/ internal null output\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)character; (void)buffer; (void)idx; (void)maxlen;\n}\n\n\n\/\/ internal _putchar wrapper\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)buffer; (void)idx; (void)maxlen;\n  if (character) {\n    _putchar(character);\n  }\n}\n\n\n\/\/ internal output function wrapper\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)idx; (void)maxlen;\n  if (character) {\n    \/\/ buffer is the output fct pointer\n    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\n  }\n}\n\n\n\/\/ internal secure strlen\n\/\/ \\return The length of the string (excluding the terminating 0) limited by 'maxsize'\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\n{\n  const char* s;\n  for (s = str; *s && maxsize--; ++s);\n  return (unsigned int)(s - str);\n}\n\n\n\/\/ internal test if char is a digit (0-9)\n\/\/ \\return true if char is a digit\nstatic inline bool _is_digit(char ch)\n{\n  return (ch >= '0') && (ch <= '9');\n}\n\n\n\/\/ internal ASCII string to unsigned int conversion\nstatic unsigned int _atoi(const char** str)\n{\n  unsigned int i = 0U;\n  while (_is_digit(**str)) {\n    i = i * 10U + (unsigned int)(*((*str)++) - '0');\n  }\n  return i;\n}\n\n\n\/\/ output the specified string in reverse, taking care of any zero-padding\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\n{\n  const size_t start_idx = idx;\n\n  \/\/ pad spaces up to given width\n  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\n    for (size_t i = len; i < width; i++) {\n      out(' ', buffer, idx++, maxlen);\n    }\n  }\n\n  \/\/ reverse string\n  while (len) {\n    out(buf[--len], buffer, idx++, maxlen);\n  }\n\n  \/\/ append pad spaces up to given width\n  if (flags & FLAGS_LEFT) {\n    while (idx - start_idx < width) {\n      out(' ', buffer, idx++, maxlen);\n    }\n  }\n\n  return idx;\n}\n\n\n\/\/ internal itoa format\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  \/\/ pad leading zeros\n  if (!(flags & FLAGS_LEFT)) {\n    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\n      width--;\n    }\n    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n  }\n\n  \/\/ handle hash\n  if (flags & FLAGS_HASH) {\n    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\n      len--;\n      if (len && (base == 16U)) {\n        len--;\n      }\n    }\n    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'x';\n    }\n    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'X';\n    }\n    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'b';\n    }\n    if (len < PRINTF_NTOA_BUFFER_SIZE) {\n      buf[len++] = '0';\n    }\n  }\n\n  if (len < PRINTF_NTOA_BUFFER_SIZE) {\n    if (negative) {\n      buf[len++] = '-';\n    }\n    else if (flags & FLAGS_PLUS) {\n      buf[len++] = '+';  \/\/ ignore the space if the '+' exists\n    }\n    else if (flags & FLAGS_SPACE) {\n      buf[len++] = ' ';\n    }\n  }\n\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\n}\n\n\n\/\/ internal itoa for 'long' type\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\n  size_t len = 0U;\n\n  \/\/ no hash for 0 values\n  if (!value) {\n    flags &= ~FLAGS_HASH;\n  }\n\n  \/\/ write if precision != 0 and value is != 0\n  if (!(flags & FLAGS_PRECISION) || value) {\n    do {\n      const char digit = (char)(value % base);\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n      value \/= base;\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\n  }\n\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}\n\n\n\/\/ internal itoa for 'long long' type\n#if defined(PRINTF_SUPPORT_LONG_LONG)\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\n  size_t len = 0U;\n\n  \/\/ no hash for 0 values\n  if (!value) {\n    flags &= ~FLAGS_HASH;\n  }\n\n  \/\/ write if precision != 0 and value is != 0\n  if (!(flags & FLAGS_PRECISION) || value) {\n    do {\n      const char digit = (char)(value % base);\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n      value \/= base;\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\n  }\n\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}\n#endif  \/\/ PRINTF_SUPPORT_LONG_LONG\n\n\n#if defined(PRINTF_SUPPORT_FLOAT)\n\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n\/\/ forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\n#endif\n\n\n\/\/ internal ftoa for fixed decimal floating point\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_FTOA_BUFFER_SIZE];\n  size_t len  = 0U;\n  double diff = 0.0;\n\n  \/\/ powers of 10\n  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\n  \/\/ test for special values\n  if (value != value)\n    return _out_rev(out, buffer, idx, maxlen, \"nan\", 3, width, flags);\n  if (value < -DBL_MAX)\n    return _out_rev(out, buffer, idx, maxlen, \"fni-\", 4, width, flags);\n  if (value > DBL_MAX)\n    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \"fni+\" : \"fni\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\n\n  \/\/ test for very large values\n  \/\/ standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad\n  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\n#else\n    return 0U;\n#endif\n  }\n\n  \/\/ test for negative\n  bool negative = false;\n  if (value < 0) {\n    negative = true;\n    value = 0 - value;\n  }\n\n  \/\/ set default precision, if not set explicitly\n  if (!(flags & FLAGS_PRECISION)) {\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\n  }\n  \/\/ limit precision to 9, cause a prec >= 10 can lead to overflow errors\n  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\n    buf[len++] = '0';\n    prec--;\n  }\n\n  int whole = (int)value;\n  double tmp = (value - whole) * pow10[prec];\n  unsigned long frac = (unsigned long)tmp;\n  diff = tmp - frac;\n\n  if (diff > 0.5) {\n    ++frac;\n    \/\/ handle rollover, e.g. case 0.99 with prec 1 is 1.0\n    if (frac >= pow10[prec]) {\n      frac = 0;\n      ++whole;\n    }\n  }\n  else if (diff < 0.5) {\n  }\n  else if ((frac == 0U) || (frac & 1U)) {\n    \/\/ if halfway, round up if odd OR if last digit is 0\n    ++frac;\n  }\n\n  if (prec == 0U) {\n    diff = value - (double)whole;\n    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\n      \/\/ exactly 0.5 and ODD, then round up\n      \/\/ 1.5 -> 2, but 2.5 -> 2\n      ++whole;\n    }\n  }\n  else {\n    unsigned int count = prec;\n    \/\/ now do fractional part, as an unsigned number\n    while (len < PRINTF_FTOA_BUFFER_SIZE) {\n      --count;\n      buf[len++] = (char)(48U + (frac % 10U));\n      if (!(frac \/= 10U)) {\n        break;\n      }\n    }\n    \/\/ add extra 0s\n    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\n      buf[len++] = '0';\n    }\n    if (len < PRINTF_FTOA_BUFFER_SIZE) {\n      \/\/ add decimal\n      buf[len++] = '.';\n    }\n  }\n\n  \/\/ do whole part, number is reversed\n  while (len < PRINTF_FTOA_BUFFER_SIZE) {\n    buf[len++] = (char)(48 + (whole % 10));\n    if (!(whole \/= 10)) {\n      break;\n    }\n  }\n\n  \/\/ pad leading zeros\n  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\n    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\n      width--;\n    }\n    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n  }\n\n  if (len < PRINTF_FTOA_BUFFER_SIZE) {\n    if (negative) {\n      buf[len++] = '-';\n    }\n    else if (flags & FLAGS_PLUS) {\n      buf[len++] = '+';  \/\/ ignore the space if the '+' exists\n    }\n    else if (flags & FLAGS_SPACE) {\n      buf[len++] = ' ';\n    }\n  }\n\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\n}\n\n\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n\/\/ internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  \/\/ check for NaN and special values\n  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\n    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\n  }\n\n  \/\/ determine the sign\n  const bool negative = value < 0;\n  if (negative) {\n    value = -value;\n  }\n\n  \/\/ default precision\n  if (!(flags & FLAGS_PRECISION)) {\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\n  }\n\n  \/\/ determine the decimal exponent\n  \/\/ based on the algorithm by David Gay (https:\/\/www.ampl.com\/netlib\/fp\/dtoa.c)\n  union {\n    uint64_t U;\n    double   F;\n  } conv;\n\n  conv.F = value;\n  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           \/\/ effectively log2\n  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  \/\/ drop the exponent so conv.F is now in [1,2)\n  \/\/ now approximate log10 from the log2 integer part and an expansion of ln around 1.5\n  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\n  \/\/ now we want to compute 10^expval but we want to be sure it won't overflow\n  exp2 = (int)(expval * 3.321928094887362 + 0.5);\n  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\n  const double z2 = z * z;\n  conv.U = (uint64_t)(exp2 + 1023) << 52U;\n  \/\/ compute exp(z) using continued fractions, see https:\/\/en.wikipedia.org\/wiki\/Exponential_function#Continued_fractions_for_ex\n  conv.F *= 1 + 2 * z \/ (2 - z + (z2 \/ (6 + (z2 \/ (10 + z2 \/ 14)))));\n  \/\/ correct for rounding errors\n  if (value < conv.F) {\n    expval--;\n    conv.F \/= 10;\n  }\n\n  \/\/ the exponent format is \"%+03d\" and largest value is \"307\", so set aside 4-5 characters\n  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\n\n  \/\/ in \"%g\" mode, \"prec\" is the number of *significant figures* not decimals\n  if (flags & FLAGS_ADAPT_EXP) {\n    \/\/ do we want to fall-back to \"%f\" mode?\n    if ((value >= 1e-4) && (value < 1e6)) {\n      if ((int)prec > expval) {\n        prec = (unsigned)((int)prec - expval - 1);\n      }\n      else {\n        prec = 0;\n      }\n      flags |= FLAGS_PRECISION;   \/\/ make sure _ftoa respects precision\n      \/\/ no characters in exponent\n      minwidth = 0U;\n      expval   = 0;\n    }\n    else {\n      \/\/ we use one sigfig for the whole part\n      if ((prec > 0) && (flags & FLAGS_PRECISION)) {\n        --prec;\n      }\n    }\n  }\n\n  \/\/ will everything fit?\n  unsigned int fwidth = width;\n  if (width > minwidth) {\n    \/\/ we didn't fall-back so subtract the characters required for the exponent\n    fwidth -= minwidth;\n  } else {\n    \/\/ not enough characters, so go back to default sizing\n    fwidth = 0U;\n  }\n  if ((flags & FLAGS_LEFT) && minwidth) {\n    \/\/ if we're padding on the right, DON'T pad the floating part\n    fwidth = 0U;\n  }\n\n  \/\/ rescale the float value\n  if (expval) {\n    value \/= conv.F;\n  }\n\n  \/\/ output the floating part\n  const size_t start_idx = idx;\n  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\n\n  \/\/ output the exponent part\n  if (minwidth) {\n    \/\/ output the exponential symbol\n    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\n    \/\/ output the exponent value\n    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\n    \/\/ might need to right-pad spaces\n    if (flags & FLAGS_LEFT) {\n      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\n    }\n  }\n  return idx;\n}\n#endif  \/\/ PRINTF_SUPPORT_EXPONENTIAL\n#endif  \/\/ PRINTF_SUPPORT_FLOAT\n\n\n\/\/ internal vsnprintf\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\n{\n  unsigned int flags, width, precision, n;\n  size_t idx = 0U;\n\n  if (!buffer) {\n    \/\/ use null output function\n    out = _out_null;\n  }\n\n  while (*format)\n  {\n    \/\/ format specifier?  %[flags][width][.precision][length]\n    if (*format != '%') {\n      \/\/ no\n      out(*format, buffer, idx++, maxlen);\n      format++;\n      continue;\n    }\n    else {\n      \/\/ yes, evaluate it\n      format++;\n    }\n\n    \/\/ evaluate flags\n    flags = 0U;\n    do {\n      switch (*format) {\n        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\n        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\n        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\n        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\n        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\n        default :                                   n = 0U; break;\n      }\n    } while (n);\n\n    \/\/ evaluate width field\n    width = 0U;\n    if (_is_digit(*format)) {\n      width = _atoi(&format);\n    }\n    else if (*format == '*') {\n      const int w = va_arg(va, int);\n      if (w < 0) {\n        flags |= FLAGS_LEFT;    \/\/ reverse padding\n        width = (unsigned int)-w;\n      }\n      else {\n        width = (unsigned int)w;\n      }\n      format++;\n    }\n\n    \/\/ evaluate precision field\n    precision = 0U;\n    if (*format == '.') {\n      flags |= FLAGS_PRECISION;\n      format++;\n      if (_is_digit(*format)) {\n        precision = _atoi(&format);\n      }\n      else if (*format == '*') {\n        const int prec = (int)va_arg(va, int);\n        precision = prec > 0 ? (unsigned int)prec : 0U;\n        format++;\n      }\n    }\n\n    \/\/ evaluate length field\n    switch (*format) {\n      case 'l' :\n        flags |= FLAGS_LONG;\n        format++;\n        if (*format == 'l') {\n          flags |= FLAGS_LONG_LONG;\n          format++;\n        }\n        break;\n      case 'h' :\n        flags |= FLAGS_SHORT;\n        format++;\n        if (*format == 'h') {\n          flags |= FLAGS_CHAR;\n          format++;\n        }\n        break;\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\n      case 't' :\n        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n#endif\n      case 'j' :\n        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n      case 'z' :\n        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n      default :\n        break;\n    }\n\n    \/\/ evaluate specifier\n    switch (*format) {\n      case 'd' :\n      case 'i' :\n      case 'u' :\n      case 'x' :\n      case 'X' :\n      case 'o' :\n      case 'b' : {\n        \/\/ set the base\n        unsigned int base;\n        if (*format == 'x' || *format == 'X') {\n          base = 16U;\n        }\n        else if (*format == 'o') {\n          base =  8U;\n        }\n        else if (*format == 'b') {\n          base =  2U;\n        }\n        else {\n          base = 10U;\n          flags &= ~FLAGS_HASH;   \/\/ no hash for dec format\n        }\n        \/\/ uppercase\n        if (*format == 'X') {\n          flags |= FLAGS_UPPERCASE;\n        }\n\n        \/\/ no plus or space flag for u, x, X, o, b\n        if ((*format != 'i') && (*format != 'd')) {\n          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);\n        }\n\n        \/\/ ignore '0' flag when precision is given\n        if (flags & FLAGS_PRECISION) {\n          flags &= ~FLAGS_ZEROPAD;\n        }\n\n        \/\/ convert the integer\n        if ((*format == 'i') || (*format == 'd')) {\n          \/\/ signed\n          if (flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n            const long long value = va_arg(va, long long);\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n#endif\n          }\n          else if (flags & FLAGS_LONG) {\n            const long value = va_arg(va, long);\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n          }\n          else {\n            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n          }\n        }\n        else {\n          \/\/ unsigned\n          if (flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\n#endif\n          }\n          else if (flags & FLAGS_LONG) {\n            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\n          }\n          else {\n            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\n            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\n          }\n        }\n        format++;\n        break;\n      }\n#if defined(PRINTF_SUPPORT_FLOAT)\n      case 'f' :\n      case 'F' :\n        if (*format == 'F') flags |= FLAGS_UPPERCASE;\n        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n        format++;\n        break;\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n      case 'e':\n      case 'E':\n      case 'g':\n      case 'G':\n        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\n        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\n        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n        format++;\n        break;\n#endif  \/\/ PRINTF_SUPPORT_EXPONENTIAL\n#endif  \/\/ PRINTF_SUPPORT_FLOAT\n      case 'c' : {\n        unsigned int l = 1U;\n        \/\/ pre padding\n        if (!(flags & FLAGS_LEFT)) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        \/\/ char output\n        out((char)va_arg(va, int), buffer, idx++, maxlen);\n        \/\/ post padding\n        if (flags & FLAGS_LEFT) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        format++;\n        break;\n      }\n\n      case 's' : {\n        const char* p = va_arg(va, char*);\n        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\n        \/\/ pre padding\n        if (flags & FLAGS_PRECISION) {\n          l = (l < precision ? l : precision);\n        }\n        if (!(flags & FLAGS_LEFT)) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        \/\/ string output\n        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\n          out(*(p++), buffer, idx++, maxlen);\n        }\n        \/\/ post padding\n        if (flags & FLAGS_LEFT) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        format++;\n        break;\n      }\n\n      case 'p' : {\n        width = sizeof(void*) * 2U;\n        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);\n        if (is_ll) {\n          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\n        }\n        else {\n#endif\n          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n        }\n#endif\n        format++;\n        break;\n      }\n\n      case '%' :\n        out('%', buffer, idx++, maxlen);\n        format++;\n        break;\n\n      default :\n        out(*format, buffer, idx++, maxlen);\n        format++;\n        break;\n    }\n  }\n\n  \/\/ termination\n  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\n\n  \/\/ return written chars without terminating \\0\n  return (int)idx;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nint printf_(const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  char buffer[1];\n  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint sprintf_(char* buffer, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint snprintf_(char* buffer, size_t count, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint vprintf_(const char* format, va_list va)\n{\n  char buffer[1];\n  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\n}\n\n\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\n{\n  return _vsnprintf(_out_buffer, buffer, count, format, va);\n}\n\n\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const out_fct_wrap_type out_fct_wrap = { out, arg };\n  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/include\/util.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2021, Breakaway Consulting Pty. Ltd.\n * Copyright 2022, UNSW (ABN 57 195 873 179)\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\/\n\n#pragma once\n\n#include <stdint.h>\n#include <microkit.h>\n#include \"printf.h\"\n\n\/\/ @ivanv: these are here for convience, should not be here though\n#define GUEST_ID 0\n#define GUEST_VCPU_ID 0\n#define GUEST_NUM_VCPUS 1\n\/\/ Note that this is AArch64 specific\n#if defined(CONFIG_ARCH_AARCH64)\n    #define SEL4_USER_CONTEXT_SIZE 0x24\n#endif\n\n#define PAGE_SIZE_4K 4096\n\n#define ARRAY_SIZE(x) (sizeof(x)\/sizeof((x)[0]))\n\n#define CTZ(x) __builtin_ctz(x)\n\n#if __STDC_VERSION__ >= 201112L && !defined(__cplusplus)\n#define static_assert _Static_assert\n#endif\n\n\/\/  __attribute__ ((__noreturn__))\n\/\/ void __assert_func(const char *file, int line, const char *function, const char *str);\n\nvoid _putchar(char character);\n\n#define LOG_VMM(...) do{ printf(\"%s|INFO: \", microkit_name); printf(__VA_ARGS__); }while(0)\n#define LOG_VMM_ERR(...) do{ printf(\"%s|ERROR: \", microkit_name); printf(__VA_ARGS__); }while(0)\n\nstatic char\ndecchar(unsigned int v) {\n    return '0' + v;\n}\n\nstatic void\nput8(uint8_t x)\n{\n    char tmp[4];\n    unsigned i = 3;\n    tmp[3] = 0;\n    do {\n        uint8_t c = x % 10;\n        tmp[--i] = decchar(c);\n        x \/= 10;\n    } while (x);\n    microkit_dbg_puts(&tmp[i]);\n}\n\n\/\/ @ivanv: sort this out...\nstatic void\nreply_to_fault()\n{\n    microkit_msginfo msg = microkit_msginfo_new(0, 0);\n    seL4_Send(4, msg);\n}\n\nstatic uint64_t get_vmm_id(char *microkit_name)\n{\n    \/\/ @ivanv: Absolute hack\n    return microkit_name[4] - '0';\n}\n\nstatic void\nprint_tcb_regs(seL4_UserContext *ctx) {\n#if defined(ARCH_aarch64)\n    \/\/ I don't know if it's the best idea, but here we'll just dump the\n    \/\/ registers in the same order they are defined in seL4_UserContext\n    printf(\"VMM|INFO: TCB registers:\\n\");\n    \/\/ Frame registers\n    printf(\"    pc:   0x%016lx\\n\", ctx->pc);\n    printf(\"    sp:   0x%016lx\\n\", ctx->sp);\n    printf(\"    spsr: 0x%016lx\\n\", ctx->spsr);\n    printf(\"    x0:   0x%016lx\\n\", ctx->x0);\n    printf(\"    x1:   0x%016lx\\n\", ctx->x1);\n    printf(\"    x2:   0x%016lx\\n\", ctx->x2);\n    printf(\"    x3:   0x%016lx\\n\", ctx->x3);\n    printf(\"    x4:   0x%016lx\\n\", ctx->x4);\n    printf(\"    x5:   0x%016lx\\n\", ctx->x5);\n    printf(\"    x6:   0x%016lx\\n\", ctx->x6);\n    printf(\"    x7:   0x%016lx\\n\", ctx->x7);\n    printf(\"    x8:   0x%016lx\\n\", ctx->x8);\n    printf(\"    x16:  0x%016lx\\n\", ctx->x16);\n    printf(\"    x17:  0x%016lx\\n\", ctx->x17);\n    printf(\"    x18:  0x%016lx\\n\", ctx->x18);\n    printf(\"    x29:  0x%016lx\\n\", ctx->x29);\n    printf(\"    x30:  0x%016lx\\n\", ctx->x30);\n    \/\/ Other integer registers\n    printf(\"    x9:   0x%016lx\\n\", ctx->x9);\n    printf(\"    x10:  0x%016lx\\n\", ctx->x10);\n    printf(\"    x11:  0x%016lx\\n\", ctx->x11);\n    printf(\"    x12:  0x%016lx\\n\", ctx->x12);\n    printf(\"    x13:  0x%016lx\\n\", ctx->x13);\n    printf(\"    x14:  0x%016lx\\n\", ctx->x14);\n    printf(\"    x15:  0x%016lx\\n\", ctx->x15);\n    printf(\"    x19:  0x%016lx\\n\", ctx->x19);\n    printf(\"    x20:  0x%016lx\\n\", ctx->x20);\n    printf(\"    x21:  0x%016lx\\n\", ctx->x21);\n    printf(\"    x22:  0x%016lx\\n\", ctx->x22);\n    printf(\"    x23:  0x%016lx\\n\", ctx->x23);\n    printf(\"    x24:  0x%016lx\\n\", ctx->x24);\n    printf(\"    x25:  0x%016lx\\n\", ctx->x25);\n    printf(\"    x26:  0x%016lx\\n\", ctx->x26);\n    printf(\"    x27:  0x%016lx\\n\", ctx->x27);\n    printf(\"    x28:  0x%016lx\\n\", ctx->x28);\n    \/\/ TODO(ivanv): print out thread ID registers?\n#endif\n}\n\nvoid *memcpy(void *restrict dest, const void *restrict src, size_t n);\nvoid *memset(void *dest, int c, size_t n);\n\nstatic void assert_fail(\n    const char  *assertion,\n    const char  *file,\n    unsigned int line,\n    const char  *function)\n{\n    printf(\"Failed assertion '%s' at %s:%u in function %s\\n\", assertion, file, line, function);\n    while (1) {}\n}\n\n#define assert(expr) \\\n    do { \\\n        if (!(expr)) { \\\n            assert_fail(#expr, __FILE__, __LINE__, __FUNCTION__); \\\n        } \\\n    } while(0)\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/src\/util.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2022, UNSW (ABN 57 195 873 179)\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\/\n\n#include \"util.h\"\n\n\/* This is required to use the printf library we brought in, it is\n   simply for convenience since there's a lot of logging\/debug printing\n   in the VMM. *\/\nvoid _putchar(char character)\n{\n    microkit_dbg_putc(character);\n}\n\n __attribute__ ((__noreturn__))\nvoid __assert_func(const char *file, int line, const char *function, const char *str)\n{\n    microkit_dbg_puts(\"assert failed: \");\n    microkit_dbg_puts(str);\n    microkit_dbg_puts(\" \");\n    microkit_dbg_puts(file);\n    microkit_dbg_puts(\" \");\n    microkit_dbg_puts(function);\n    microkit_dbg_puts(\"\\n\");\n    while (1) {}\n}\n\nvoid *memcpy(void *restrict dest, const void *restrict src, size_t n)\n{\n    unsigned char *d = dest;\n    const unsigned char *s = src;\n    for (; n; n--) *d++ = *s++;\n    return dest;\n}\n\nvoid *memset(void *dest, int c, size_t n)\n{\n    unsigned char *s = dest;\n    for (; n; n--, s++) *s = c;\n    return dest;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/data\/src\/Aadl_Datatypes\/MyEnum.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq, Structural)]\n  pub enum MyEnum {\n    pub On = 0,\n    pub Off = 1,\n  }\n\n  impl Default for MyEnum {\n    fn default() -> Self\n    {\n      MyEnum::On\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Aadl_Datatypes\/MyStruct2_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct MyStruct2_i {\n    pub fieldSChar: u8\n  }\n\n  impl Default for MyStruct2_i {\n    fn default() -> Self\n    {\n      Self { fieldSChar: 0 }\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Base_Types\/String.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  pub const Base_Types_String_BYTE_SIZE: usize = 43;\n  pub const Base_Types_String_DIM_0: usize = 43;\n\n  pub type String = [u8; Base_Types_String_DIM_0];\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Aadl_Datatypes\/MyArrayOneDim.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  pub const Aadl_Datatypes_MyArrayOneDim_BYTE_SIZE: usize = 40;\n  pub const Aadl_Datatypes_MyArrayOneDim_DIM_0: usize = 10;\n\n  pub type MyArrayOneDim = [i32; Aadl_Datatypes_MyArrayOneDim_DIM_0];\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Aadl_Datatypes\/MyStruct_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nuse super::Base_Types::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct MyStruct_i {\n    pub fieldInt64: i64,\n    pub fieldStr: String,\n    pub fieldEnum: MyEnum,\n    pub fieldRec: MyStruct2_i,\n    pub fieldArray: MyArrayOneDim\n  }\n\n  impl Default for MyStruct_i {\n    fn default() -> Self\n    {\n      Self { fieldInt64: 0, fieldStr: [0; Base_Types::Base_Types_String_DIM_0], fieldEnum: Aadl_Datatypes::MyEnum::default(), fieldRec: Aadl_Datatypes::MyStruct2_i::default(), fieldArray: [0; Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0] }\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Aadl_Datatypes\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ninclude!(\"MyEnum.rs\");\ninclude!(\"MyStruct2_i.rs\");\ninclude!(\"MyArrayOneDim.rs\");\ninclude!(\"MyStruct_i.rs\");\n\n\/*\nNOTE: the include!(\"xx.rs\") inlines the file contents directly so a module for\nxx is not created.  An alternative would be to do\n\npub mod xx.rs;\npub use xx::*;\n\nhowever this would create a module out of xx.rs so to refer to the datatype\nit contains you'd have to do something like \"use data::xx::xx\"\nin lib.rs. A workaround is to rename the file, e.g. xx_STRUCT.rs but leave the\nfile contents unchanged.  Then in this file do\n\npub mod xx_STRUCT;\npub use xx_STRUCT::*;\n\nthen xx would be imported in lib.rs via \"use data::Aadl_Datatypes::*\"\n*\/\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Base_Types\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ninclude!(\"String.rs\");\n\n\/*\nNOTE: the include!(\"xx.rs\") inlines the file contents directly so a module for\nxx is not created.  An alternative would be to do\n\npub mod xx.rs;\npub use xx::*;\n\nhowever this would create a module out of xx.rs so to refer to the datatype\nit contains you'd have to do something like \"use data::xx::xx\"\nin lib.rs. A workaround is to rename the file, e.g. xx_STRUCT.rs but leave the\nfile contents unchanged.  Then in this file do\n\npub mod xx_STRUCT;\npub use xx_STRUCT::*;\n\nthen xx would be imported in lib.rs via \"use data::Base_Types::*\"\n*\/\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/sb_event_counter.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub type sb_event_counter_t = usize;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/sb_microkit_types.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub type microkit_channel = u32;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod Aadl_Datatypes;\npub mod Base_Types;\n\ninclude!(\"sb_event_counter.rs\");\ninclude!(\"sb_microkit_types.rs\");\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"data\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2025.06.14.9b557d7\"}\nbuiltin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2025.06.14.9b557d7\" }\nbuiltin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2025.06.14.9b557d7\" }\n\n[package.metadata.verus]\nverify = true\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly-2024-12-30\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_myBoolean(value: *mut bool) -> bool;\n  fn get_myCharacter(value: *mut u8) -> bool;\n  fn get_myString(value: *mut Base_Types::String) -> bool;\n  fn get_myInt8(value: *mut i8) -> bool;\n  fn get_myInt16(value: *mut i16) -> bool;\n  fn get_myInt32(value: *mut i32) -> bool;\n  fn get_myInt64(value: *mut i64) -> bool;\n  fn get_myUInt8(value: *mut u8) -> bool;\n  fn get_myUInt16(value: *mut u16) -> bool;\n  fn get_myUInt32(value: *mut u32) -> bool;\n  fn get_myUInt64(value: *mut u64) -> bool;\n  fn get_myFloat32(value: *mut f32) -> bool;\n  fn get_myFloat64(value: *mut f64) -> bool;\n  fn get_myEnum(value: *mut Aadl_Datatypes::MyEnum) -> bool;\n  fn get_myStruct(value: *mut Aadl_Datatypes::MyStruct_i) -> bool;\n  fn get_myArray1(value: *mut Aadl_Datatypes::MyArrayOneDim) -> bool;\n}\n\npub fn unsafe_get_myBoolean() -> Option<bool>\n{\n  unsafe {\n    let value: *mut bool = &mut false;\n    if (get_myBoolean(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myCharacter() -> Option<u8>\n{\n  unsafe {\n    let value: *mut u8 = &mut 0;\n    if (get_myCharacter(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myString() -> Option<Base_Types::String>\n{\n  unsafe {\n    let value: *mut Base_Types::String = &mut [0; Base_Types::Base_Types_String_DIM_0];\n    if (get_myString(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myInt8() -> Option<i8>\n{\n  unsafe {\n    let value: *mut i8 = &mut 0;\n    if (get_myInt8(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myInt16() -> Option<i16>\n{\n  unsafe {\n    let value: *mut i16 = &mut 0;\n    if (get_myInt16(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myInt32() -> Option<i32>\n{\n  unsafe {\n    let value: *mut i32 = &mut 0;\n    if (get_myInt32(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myInt64() -> Option<i64>\n{\n  unsafe {\n    let value: *mut i64 = &mut 0;\n    if (get_myInt64(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myUInt8() -> Option<u8>\n{\n  unsafe {\n    let value: *mut u8 = &mut 0;\n    if (get_myUInt8(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myUInt16() -> Option<u16>\n{\n  unsafe {\n    let value: *mut u16 = &mut 0;\n    if (get_myUInt16(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myUInt32() -> Option<u32>\n{\n  unsafe {\n    let value: *mut u32 = &mut 0;\n    if (get_myUInt32(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myUInt64() -> Option<u64>\n{\n  unsafe {\n    let value: *mut u64 = &mut 0;\n    if (get_myUInt64(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myFloat32() -> Option<f32>\n{\n  unsafe {\n    let value: *mut f32 = &mut 0.0;\n    if (get_myFloat32(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myFloat64() -> Option<f64>\n{\n  unsafe {\n    let value: *mut f64 = &mut 0.0;\n    if (get_myFloat64(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myEnum() -> Option<Aadl_Datatypes::MyEnum>\n{\n  unsafe {\n    let value: *mut Aadl_Datatypes::MyEnum = &mut Aadl_Datatypes::MyEnum::default();\n    if (get_myEnum(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myStruct() -> Option<Aadl_Datatypes::MyStruct_i>\n{\n  unsafe {\n    let value: *mut Aadl_Datatypes::MyStruct_i = &mut Aadl_Datatypes::MyStruct_i::default();\n    if (get_myStruct(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\npub fn unsafe_get_myArray1() -> Option<Aadl_Datatypes::MyArrayOneDim>\n{\n  unsafe {\n    let value: *mut Aadl_Datatypes::MyArrayOneDim = &mut [0; Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0];\n    if (get_myArray1(value)) {\n      return Some(*value);\n    } else {\n      return None;\n    }\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_myBoolean: Mutex<Option<bool>> = Mutex::new(None);\n  pub static ref IN_myCharacter: Mutex<Option<u8>> = Mutex::new(None);\n  pub static ref IN_myString: Mutex<Option<Base_Types::String>> = Mutex::new(None);\n  pub static ref IN_myInt8: Mutex<Option<i8>> = Mutex::new(None);\n  pub static ref IN_myInt16: Mutex<Option<i16>> = Mutex::new(None);\n  pub static ref IN_myInt32: Mutex<Option<i32>> = Mutex::new(None);\n  pub static ref IN_myInt64: Mutex<Option<i64>> = Mutex::new(None);\n  pub static ref IN_myUInt8: Mutex<Option<u8>> = Mutex::new(None);\n  pub static ref IN_myUInt16: Mutex<Option<u16>> = Mutex::new(None);\n  pub static ref IN_myUInt32: Mutex<Option<u32>> = Mutex::new(None);\n  pub static ref IN_myUInt64: Mutex<Option<u64>> = Mutex::new(None);\n  pub static ref IN_myFloat32: Mutex<Option<f32>> = Mutex::new(None);\n  pub static ref IN_myFloat64: Mutex<Option<f64>> = Mutex::new(None);\n  pub static ref IN_myEnum: Mutex<Option<Aadl_Datatypes::MyEnum>> = Mutex::new(None);\n  pub static ref IN_myStruct: Mutex<Option<Aadl_Datatypes::MyStruct_i>> = Mutex::new(None);\n  pub static ref IN_myArray1: Mutex<Option<Aadl_Datatypes::MyArrayOneDim>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_myBoolean.lock().unwrap() = None;\n    *IN_myCharacter.lock().unwrap() = None;\n    *IN_myString.lock().unwrap() = None;\n    *IN_myInt8.lock().unwrap() = None;\n    *IN_myInt16.lock().unwrap() = None;\n    *IN_myInt32.lock().unwrap() = None;\n    *IN_myInt64.lock().unwrap() = None;\n    *IN_myUInt8.lock().unwrap() = None;\n    *IN_myUInt16.lock().unwrap() = None;\n    *IN_myUInt32.lock().unwrap() = None;\n    *IN_myUInt64.lock().unwrap() = None;\n    *IN_myFloat32.lock().unwrap() = None;\n    *IN_myFloat64.lock().unwrap() = None;\n    *IN_myEnum.lock().unwrap() = None;\n    *IN_myStruct.lock().unwrap() = None;\n    *IN_myArray1.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_myBoolean(value: *mut bool) -> bool\n{\n  unsafe {\n    match *IN_myBoolean.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myCharacter(value: *mut u8) -> bool\n{\n  unsafe {\n    match *IN_myCharacter.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myString(value: *mut Base_Types::String) -> bool\n{\n  unsafe {\n    match *IN_myString.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myInt8(value: *mut i8) -> bool\n{\n  unsafe {\n    match *IN_myInt8.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myInt16(value: *mut i16) -> bool\n{\n  unsafe {\n    match *IN_myInt16.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myInt32(value: *mut i32) -> bool\n{\n  unsafe {\n    match *IN_myInt32.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myInt64(value: *mut i64) -> bool\n{\n  unsafe {\n    match *IN_myInt64.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myUInt8(value: *mut u8) -> bool\n{\n  unsafe {\n    match *IN_myUInt8.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myUInt16(value: *mut u16) -> bool\n{\n  unsafe {\n    match *IN_myUInt16.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myUInt32(value: *mut u32) -> bool\n{\n  unsafe {\n    match *IN_myUInt32.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myUInt64(value: *mut u64) -> bool\n{\n  unsafe {\n    match *IN_myUInt64.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myFloat32(value: *mut f32) -> bool\n{\n  unsafe {\n    match *IN_myFloat32.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myFloat64(value: *mut f64) -> bool\n{\n  unsafe {\n    match *IN_myFloat64.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myEnum(value: *mut Aadl_Datatypes::MyEnum) -> bool\n{\n  unsafe {\n    match *IN_myEnum.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myStruct(value: *mut Aadl_Datatypes::MyStruct_i) -> bool\n{\n  unsafe {\n    match *IN_myStruct.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n\n#[cfg(test)]\npub fn get_myArray1(value: *mut Aadl_Datatypes::MyArrayOneDim) -> bool\n{\n  unsafe {\n    match *IN_myArray1.lock().unwrap() {\n      Some(v) => {\n        *value = v;\n        return true;\n      },\n      None => return false,\n    }\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/bridge\/consumer_consumer_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait consumer_consumer_Api {}\n\n  pub trait consumer_consumer_Put_Api: consumer_consumer_Api {\n  }\n\n  pub trait consumer_consumer_Get_Api: consumer_consumer_Api {\n    #[verifier::external_body]\n    fn unverified_get_myBoolean(\n      &mut self,\n      value: &Ghost<Option<bool>>) -> (res : Option<bool>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myBoolean();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myCharacter(\n      &mut self,\n      value: &Ghost<Option<u8>>) -> (res : Option<u8>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myCharacter();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myString(\n      &mut self,\n      value: &Ghost<Option<Base_Types::String>>) -> (res : Option<Base_Types::String>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myString();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myInt8(\n      &mut self,\n      value: &Ghost<Option<i8>>) -> (res : Option<i8>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myInt8();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myInt16(\n      &mut self,\n      value: &Ghost<Option<i16>>) -> (res : Option<i16>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myInt16();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myInt32(\n      &mut self,\n      value: &Ghost<Option<i32>>) -> (res : Option<i32>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myInt32();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myInt64(\n      &mut self,\n      value: &Ghost<Option<i64>>) -> (res : Option<i64>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myInt64();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myUInt8(\n      &mut self,\n      value: &Ghost<Option<u8>>) -> (res : Option<u8>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myUInt8();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myUInt16(\n      &mut self,\n      value: &Ghost<Option<u16>>) -> (res : Option<u16>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myUInt16();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myUInt32(\n      &mut self,\n      value: &Ghost<Option<u32>>) -> (res : Option<u32>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myUInt32();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myUInt64(\n      &mut self,\n      value: &Ghost<Option<u64>>) -> (res : Option<u64>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myUInt64();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myFloat32(\n      &mut self,\n      value: &Ghost<Option<f32>>) -> (res : Option<f32>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myFloat32();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myFloat64(\n      &mut self,\n      value: &Ghost<Option<f64>>) -> (res : Option<f64>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myFloat64();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myEnum(\n      &mut self,\n      value: &Ghost<Option<Aadl_Datatypes::MyEnum>>) -> (res : Option<Aadl_Datatypes::MyEnum>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myEnum();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myStruct(\n      &mut self,\n      value: &Ghost<Option<Aadl_Datatypes::MyStruct_i>>) -> (res : Option<Aadl_Datatypes::MyStruct_i>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myStruct();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_myArray1(\n      &mut self,\n      value: &Ghost<Option<Aadl_Datatypes::MyArrayOneDim>>) -> (res : Option<Aadl_Datatypes::MyArrayOneDim>)\n      ensures\n        res == value@\n    {\n      return extern_api::unsafe_get_myArray1();\n    }\n  }\n\n  pub trait consumer_consumer_Full_Api: consumer_consumer_Put_Api + consumer_consumer_Get_Api {}\n\n  pub struct consumer_consumer_Application_Api<API: consumer_consumer_Api> {\n    pub api: API,\n\n    pub ghost myBoolean: Option<bool>,\n    pub ghost myCharacter: Option<u8>,\n    pub ghost myString: Option<Base_Types::String>,\n    pub ghost myInt8: Option<i8>,\n    pub ghost myInt16: Option<i16>,\n    pub ghost myInt32: Option<i32>,\n    pub ghost myInt64: Option<i64>,\n    pub ghost myUInt8: Option<u8>,\n    pub ghost myUInt16: Option<u16>,\n    pub ghost myUInt32: Option<u32>,\n    pub ghost myUInt64: Option<u64>,\n    pub ghost myFloat32: Option<f32>,\n    pub ghost myFloat64: Option<f64>,\n    pub ghost myEnum: Option<Aadl_Datatypes::MyEnum>,\n    pub ghost myStruct: Option<Aadl_Datatypes::MyStruct_i>,\n    pub ghost myArray1: Option<Aadl_Datatypes::MyArrayOneDim>\n  }\n\n  impl<API: consumer_consumer_Put_Api> consumer_consumer_Application_Api<API> {\n  }\n\n  impl<API: consumer_consumer_Get_Api> consumer_consumer_Application_Api<API> {\n    pub fn get_myBoolean(&mut self) -> (res : Option<bool>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        res == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myBoolean(&Ghost(self.myBoolean))\n    }\n    pub fn get_myCharacter(&mut self) -> (res : Option<u8>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        res == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myCharacter(&Ghost(self.myCharacter))\n    }\n    pub fn get_myString(&mut self) -> (res : Option<Base_Types::String>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        res == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myString(&Ghost(self.myString))\n    }\n    pub fn get_myInt8(&mut self) -> (res : Option<i8>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        res == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myInt8(&Ghost(self.myInt8))\n    }\n    pub fn get_myInt16(&mut self) -> (res : Option<i16>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        res == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myInt16(&Ghost(self.myInt16))\n    }\n    pub fn get_myInt32(&mut self) -> (res : Option<i32>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        res == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myInt32(&Ghost(self.myInt32))\n    }\n    pub fn get_myInt64(&mut self) -> (res : Option<i64>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        res == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myInt64(&Ghost(self.myInt64))\n    }\n    pub fn get_myUInt8(&mut self) -> (res : Option<u8>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        res == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myUInt8(&Ghost(self.myUInt8))\n    }\n    pub fn get_myUInt16(&mut self) -> (res : Option<u16>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        res == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myUInt16(&Ghost(self.myUInt16))\n    }\n    pub fn get_myUInt32(&mut self) -> (res : Option<u32>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        res == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myUInt32(&Ghost(self.myUInt32))\n    }\n    pub fn get_myUInt64(&mut self) -> (res : Option<u64>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        res == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myUInt64(&Ghost(self.myUInt64))\n    }\n    pub fn get_myFloat32(&mut self) -> (res : Option<f32>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        res == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myFloat32(&Ghost(self.myFloat32))\n    }\n    pub fn get_myFloat64(&mut self) -> (res : Option<f64>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        res == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myFloat64(&Ghost(self.myFloat64))\n    }\n    pub fn get_myEnum(&mut self) -> (res : Option<Aadl_Datatypes::MyEnum>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        res == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myEnum(&Ghost(self.myEnum))\n    }\n    pub fn get_myStruct(&mut self) -> (res : Option<Aadl_Datatypes::MyStruct_i>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        res == self.myStruct,\n        old(self).myArray1 == self.myArray1\n    {\n      self.api.unverified_get_myStruct(&Ghost(self.myStruct))\n    }\n    pub fn get_myArray1(&mut self) -> (res : Option<Aadl_Datatypes::MyArrayOneDim>)\n      ensures\n        old(self).myBoolean == self.myBoolean,\n        old(self).myCharacter == self.myCharacter,\n        old(self).myString == self.myString,\n        old(self).myInt8 == self.myInt8,\n        old(self).myInt16 == self.myInt16,\n        old(self).myInt32 == self.myInt32,\n        old(self).myInt64 == self.myInt64,\n        old(self).myUInt8 == self.myUInt8,\n        old(self).myUInt16 == self.myUInt16,\n        old(self).myUInt32 == self.myUInt32,\n        old(self).myUInt64 == self.myUInt64,\n        old(self).myFloat32 == self.myFloat32,\n        old(self).myFloat64 == self.myFloat64,\n        old(self).myEnum == self.myEnum,\n        old(self).myStruct == self.myStruct,\n        old(self).myArray1 == self.myArray1,\n        res == self.myArray1\n    {\n      self.api.unverified_get_myArray1(&Ghost(self.myArray1))\n    }\n  }\n\n  pub struct consumer_consumer_Initialization_Api;\n  impl consumer_consumer_Api for consumer_consumer_Initialization_Api {}\n  impl consumer_consumer_Put_Api for consumer_consumer_Initialization_Api {}\n\n  pub const fn init_api() -> consumer_consumer_Application_Api<consumer_consumer_Initialization_Api> {\n    return consumer_consumer_Application_Api {\n      api: consumer_consumer_Initialization_Api {},\n\n      myBoolean: None,\n      myCharacter: None,\n      myString: None,\n      myInt8: None,\n      myInt16: None,\n      myInt32: None,\n      myInt64: None,\n      myUInt8: None,\n      myUInt16: None,\n      myUInt32: None,\n      myUInt64: None,\n      myFloat32: None,\n      myFloat64: None,\n      myEnum: None,\n      myStruct: None,\n      myArray1: None\n    }\n  }\n\n  pub struct consumer_consumer_Compute_Api;\n  impl consumer_consumer_Api for consumer_consumer_Compute_Api {}\n  impl consumer_consumer_Put_Api for consumer_consumer_Compute_Api {}\n  impl consumer_consumer_Get_Api for consumer_consumer_Compute_Api {}\n  impl consumer_consumer_Full_Api for consumer_consumer_Compute_Api {}\n\n  pub const fn compute_api() -> consumer_consumer_Application_Api<consumer_consumer_Compute_Api> {\n    return consumer_consumer_Application_Api {\n      api: consumer_consumer_Compute_Api {},\n\n      myBoolean: None,\n      myCharacter: None,\n      myString: None,\n      myInt8: None,\n      myInt16: None,\n      myInt32: None,\n      myInt64: None,\n      myUInt8: None,\n      myUInt16: None,\n      myUInt32: None,\n      myUInt64: None,\n      myFloat32: None,\n      myFloat64: None,\n      myEnum: None,\n      myStruct: None,\n      myArray1: None\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/bridge\/test_api.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg(test)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn put_myBoolean(value: Option<bool>)\n{\n  *extern_api::IN_myBoolean.lock().unwrap() = value\n}\n\npub fn put_myCharacter(value: Option<u8>)\n{\n  *extern_api::IN_myCharacter.lock().unwrap() = value\n}\n\npub fn put_myString(value: Option<Base_Types::String>)\n{\n  *extern_api::IN_myString.lock().unwrap() = value\n}\n\npub fn put_myInt8(value: Option<i8>)\n{\n  *extern_api::IN_myInt8.lock().unwrap() = value\n}\n\npub fn put_myInt16(value: Option<i16>)\n{\n  *extern_api::IN_myInt16.lock().unwrap() = value\n}\n\npub fn put_myInt32(value: Option<i32>)\n{\n  *extern_api::IN_myInt32.lock().unwrap() = value\n}\n\npub fn put_myInt64(value: Option<i64>)\n{\n  *extern_api::IN_myInt64.lock().unwrap() = value\n}\n\npub fn put_myUInt8(value: Option<u8>)\n{\n  *extern_api::IN_myUInt8.lock().unwrap() = value\n}\n\npub fn put_myUInt16(value: Option<u16>)\n{\n  *extern_api::IN_myUInt16.lock().unwrap() = value\n}\n\npub fn put_myUInt32(value: Option<u32>)\n{\n  *extern_api::IN_myUInt32.lock().unwrap() = value\n}\n\npub fn put_myUInt64(value: Option<u64>)\n{\n  *extern_api::IN_myUInt64.lock().unwrap() = value\n}\n\npub fn put_myFloat32(value: Option<f32>)\n{\n  *extern_api::IN_myFloat32.lock().unwrap() = value\n}\n\npub fn put_myFloat64(value: Option<f64>)\n{\n  *extern_api::IN_myFloat64.lock().unwrap() = value\n}\n\npub fn put_myEnum(value: Option<Aadl_Datatypes::MyEnum>)\n{\n  *extern_api::IN_myEnum.lock().unwrap() = value\n}\n\npub fn put_myStruct(value: Option<Aadl_Datatypes::MyStruct_i>)\n{\n  *extern_api::IN_myStruct.lock().unwrap() = value\n}\n\npub fn put_myArray1(value: Option<Aadl_Datatypes::MyArrayOneDim>)\n{\n  *extern_api::IN_myArray1.lock().unwrap() = value\n}\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Aadl_Datatypes_MyEnum_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyEnum>\n{\n  prop_oneof![\n    Just(Aadl_Datatypes::MyEnum::On),\n    Just(Aadl_Datatypes::MyEnum::Off)\n  ]\n}\n\npub fn Aadl_Datatypes_MyStruct2_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyStruct2_i>\n{\n  Aadl_Datatypes_MyStruct2_i_stategy_cust(\n    any::<u8>()\n  )\n}\n\npub fn Aadl_Datatypes_MyStruct2_i_stategy_cust<u8_strategy: Strategy<Value = u8>> (fieldSChar_strategy: u8_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyStruct2_i>\n{\n  (fieldSChar_strategy).prop_map(|(fieldSChar)| {\n    Aadl_Datatypes::MyStruct2_i { fieldSChar }\n  })\n}\n\npub fn Base_Types_String_strategy_default() -> impl Strategy<Value = Base_Types::String>\n{\n  Base_Types_String_stategy_cust(any::<u8>())\n}\n\npub fn Base_Types_String_stategy_cust<u8_strategy: Strategy<Value = u8>> (base_strategy: u8_strategy) -> impl Strategy<Value = Base_Types::String>\n{\n  proptest::collection::vec(base_strategy, Base_Types::Base_Types_String_DIM_0)\n    .prop_map(|v| {\n      let boxed: Box<[u8; Base_Types::Base_Types_String_DIM_0]> = v.into_boxed_slice().try_into().unwrap();\n      *boxed\n  })\n}\n\npub fn Aadl_Datatypes_MyArrayOneDim_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyArrayOneDim>\n{\n  Aadl_Datatypes_MyArrayOneDim_stategy_cust(any::<i32>())\n}\n\npub fn Aadl_Datatypes_MyArrayOneDim_stategy_cust<i32_strategy: Strategy<Value = i32>> (base_strategy: i32_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyArrayOneDim>\n{\n  proptest::collection::vec(base_strategy, Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0)\n    .prop_map(|v| {\n      let boxed: Box<[i32; Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0]> = v.into_boxed_slice().try_into().unwrap();\n      *boxed\n  })\n}\n\npub fn Aadl_Datatypes_MyStruct_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyStruct_i>\n{\n  Aadl_Datatypes_MyStruct_i_stategy_cust(\n    any::<i64>(),\n    Base_Types_String_strategy_default(),\n    Aadl_Datatypes_MyEnum_strategy_default(),\n    Aadl_Datatypes_MyStruct2_i_strategy_default(),\n    Aadl_Datatypes_MyArrayOneDim_strategy_default()\n  )\n}\n\npub fn Aadl_Datatypes_MyStruct_i_stategy_cust\n  <i64_strategy: Strategy<Value = i64>, \n   Base_Types_String_strategy: Strategy<Value = Base_Types::String>, \n   Aadl_Datatypes_MyEnum_strategy: Strategy<Value = Aadl_Datatypes::MyEnum>, \n   Aadl_Datatypes_MyStruct2_i_strategy: Strategy<Value = Aadl_Datatypes::MyStruct2_i>, \n   Aadl_Datatypes_MyArrayOneDim_strategy: Strategy<Value = Aadl_Datatypes::MyArrayOneDim>> (\n  fieldInt64_strategy: i64_strategy,\n  fieldStr_strategy: Base_Types_String_strategy,\n  fieldEnum_strategy: Aadl_Datatypes_MyEnum_strategy,\n  fieldRec_strategy: Aadl_Datatypes_MyStruct2_i_strategy,\n  fieldArray_strategy: Aadl_Datatypes_MyArrayOneDim_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyStruct_i>\n{\n  (fieldInt64_strategy, fieldStr_strategy, fieldEnum_strategy, fieldRec_strategy, fieldArray_strategy).prop_map(|(fieldInt64, fieldStr, fieldEnum, fieldRec, fieldArray)| {\n    Aadl_Datatypes::MyStruct_i { fieldInt64, fieldStr, fieldEnum, fieldRec, fieldArray }\n  })\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod test_api;\npub mod consumer_consumer_api;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\nmod tests;\n\nuse crate::bridge::consumer_consumer_api::{self as api, *};\nuse crate::component::consumer_consumer_app::*;\nuse data::*;\n\n#[allow(unused_imports)]\nuse log::{error, warn, info, debug, trace};\n\nstatic mut app: Option<consumer_consumer> = None;\nstatic mut init_api: consumer_consumer_Application_Api<consumer_consumer_Initialization_Api> = api::init_api();\nstatic mut compute_api: consumer_consumer_Application_Api<consumer_consumer_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn consumer_consumer_initialize() {\n  #[cfg(not(test))]\n  #[cfg(feature = \"sel4\")]\n  logging::LOGGER.set().unwrap();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = consumer_consumer::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn consumer_consumer_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn consumer_consumer_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg(feature = \"sel4\")]\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nuse sel4::debug_print;\nuse sel4_logging::{LevelFilter, Logger, LoggerBuilder};\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\npub static LOGGER: Logger = LoggerBuilder::const_default()\n  .level_filter(LOG_LEVEL)\n  .write(|s| debug_print!(\"{}\", s))\n  .build();\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/component\/consumer_consumer_app.rs",
        {
          "type" : "ITestResource",
          "content" : "#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::consumer_consumer_api::*;\n#[cfg(feature = \"sel4\")]\n#[allow(unused_imports)]\nuse log::{error, warn, info, debug, trace};\n\npub struct consumer_consumer {\n}\n\nimpl consumer_consumer {\n  pub fn new() -> Self\n  {\n    Self {\n    }\n  }\n\n  pub fn initialize<API: consumer_consumer_Put_Api> (\n    &mut self,\n    api: &mut consumer_consumer_Application_Api<API>)\n  {\n    #[cfg(feature = \"sel4\")]\n    info!(\"initialize entrypoint invoked\");\n  }\n\n  pub fn timeTriggered<API: consumer_consumer_Full_Api> (\n    &mut self,\n    api: &mut consumer_consumer_Application_Api<API>)\n  {\n    #[cfg(feature = \"sel4\")]\n    info!(\"compute entrypoint invoked\");\n  }\n\n  pub fn notify(\n    &mut self,\n    channel: microkit_channel)\n  {\n    \/\/ this method is called when the monitor does not handle the passed in channel\n    match channel {\n      _ => {\n        #[cfg(feature = \"sel4\")]\n        warn!(\"Unexpected channel {}\", channel)\n      }\n    }\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod consumer_consumer_app;\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/src\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg(test)]\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::bridge::test_api;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    unsafe {\n      crate::consumer_consumer_initialize();\n    }\n  }\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    unsafe {\n      crate::consumer_consumer_initialize();\n\n      crate::consumer_consumer_timeTriggered();\n    }\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"consumer_consumer\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nlog = \"0.4.27\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true}\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2025.06.14.9b557d7\"}\nbuiltin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2025.06.14.9b557d7\" }\nbuiltin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2025.06.14.9b557d7\" }\ndata = { path = \"..\/data\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.7.0\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nall:\n\tRUSTC_BOOTSTRAP=1 \\\n\tSEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs)) \\\n\tcargo build \\\n\t\t--features sel4 \\\n\t\t-Z build-std=core,alloc,compiler_builtins \\\n\t\t-Z build-std-features=compiler-builtins-mem \\\n\t\t--target aarch64-unknown-none \\\n\t\t--release\n\nverus:\n\tRUSTC_BOOTSTRAP=1 \\\n\tSEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs)) \\\n\tcargo verus verify \\\n\t\t-Z build-std=core,alloc,compiler_builtins \\\n\t\t-Z build-std-features=compiler-builtins-mem \\\n\t\t--target aarch64-unknown-none \\\n\t\t--release\n\ntest:\n\tcargo test\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/consumer_consumer\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly-2024-12-30\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ]
    ]
  }
}