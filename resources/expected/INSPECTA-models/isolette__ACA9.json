{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "microkit\/types\/include\/sb_aadl_types.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdbool.h>\n#include <stdint.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ntypedef\n  enum {Valid, Invalid} Isolette_Data_Model_ValueStatus;\n\ntypedef\n  enum {Init_Regulator_Mode, Normal_Regulator_Mode, Failed_Regulator_Mode} Isolette_Data_Model_Regulator_Mode;\n\ntypedef\n  enum {Init_Status, On_Status, Failed_Status} Isolette_Data_Model_Status;\n\ntypedef\n  enum {Onn, Off} Isolette_Data_Model_On_Off;\n\ntypedef\n  enum {Init_Monitor_Mode, Normal_Monitor_Mode, Failed_Monitor_Mode} Isolette_Data_Model_Monitor_Mode;\n\ntypedef\n  enum {Dummy_Head_Enum} Isolette_Environment_Heat;\n\ntypedef struct Isolette_Data_Model_Temp_i {\n  int32_t degrees;\n} Isolette_Data_Model_Temp_i;\n\ntypedef struct Isolette_Data_Model_PhysicalTemp_i {\n  int32_t degrees;\n} Isolette_Data_Model_PhysicalTemp_i;\n\ntypedef struct Isolette_Data_Model_TempWstatus_i {\n  int32_t degrees;\n  Isolette_Data_Model_ValueStatus status;\n} Isolette_Data_Model_TempWstatus_i;\n\ntypedef struct Isolette_Data_Model_Failure_Flag_i {\n  bool flag;\n} Isolette_Data_Model_Failure_Flag_i;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_Temp_i_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_Temp_i_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_Temp_i\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_Temp_i elt[SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_Temp_i_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_init(sb_queue_Isolette_Data_Model_Temp_i_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue,\n  Isolette_Data_Model_Temp_i *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_Temp_i_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_Temp_i_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_Temp_i_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_Temp_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Temp_i *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_Temp_i_1_is_empty(sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_Temp_i_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Temp_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_init(sb_queue_Isolette_Data_Model_Temp_i_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue,\n  Isolette_Data_Model_Temp_i *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Temp_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_Temp_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Temp_i *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_Temp_i_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_TEMP_I_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_Temp_i_1_is_empty(sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_Status_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_Status_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_Status\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_Status elt[SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_Status_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_Status_1_init(sb_queue_Isolette_Data_Model_Status_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_Status_1_enqueue(\n  sb_queue_Isolette_Data_Model_Status_1_t *queue,\n  Isolette_Data_Model_Status *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_Status_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_Status_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_Status_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_Status_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Status_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_Status_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_Status_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_Status_1_dequeue(\n  sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Status *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_Status_1_is_empty(sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_Status_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_Status_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Status_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Status_1_init(sb_queue_Isolette_Data_Model_Status_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_Status_1_enqueue(\n  sb_queue_Isolette_Data_Model_Status_1_t *queue,\n  Isolette_Data_Model_Status *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Status_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Status_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Status_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_Status_1_dequeue(\n  sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Status *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_Status_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_STATUS_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_Status_1_is_empty(sb_queue_Isolette_Data_Model_Status_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_Failure_Flag_i_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_Failure_Flag_i\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_Failure_Flag_i elt[SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init(sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue,\n  Isolette_Data_Model_Failure_Flag_i *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Failure_Flag_i *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_Failure_Flag_i_1_is_empty(sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init(sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue,\n  Isolette_Data_Model_Failure_Flag_i *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Failure_Flag_i *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_FAILURE_FLAG_I_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_Failure_Flag_i_1_is_empty(sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_On_Off_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_On_Off_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_On_Off\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_On_Off elt[SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_On_Off_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_On_Off_1_init(sb_queue_Isolette_Data_Model_On_Off_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_On_Off_1_enqueue(\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue,\n  Isolette_Data_Model_On_Off *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_On_Off_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_On_Off_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_On_Off_1_Recv_init(\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_On_Off_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_On_Off_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_On_Off_1_dequeue(\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_On_Off *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_On_Off_1_is_empty(sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_On_Off_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_On_Off_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_On_Off_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_On_Off_1_init(sb_queue_Isolette_Data_Model_On_Off_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_On_Off_1_enqueue(\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue,\n  Isolette_Data_Model_On_Off *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_On_Off_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_On_Off_1_Recv_init(\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_On_Off_1_dequeue(\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_On_Off *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_On_Off_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_ON_OFF_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_On_Off_1_is_empty(sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_Regulator_Mode_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_Regulator_Mode_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_Regulator_Mode\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_Regulator_Mode elt[SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_Regulator_Mode_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_init(sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_enqueue(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue,\n  Isolette_Data_Model_Regulator_Mode *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Regulator_Mode *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_Regulator_Mode_1_is_empty(sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_Regulator_Mode_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_Regulator_Mode_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Regulator_Mode_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_init(sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_enqueue(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue,\n  Isolette_Data_Model_Regulator_Mode *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Regulator_Mode_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue(\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Regulator_Mode *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_REGULATOR_MODE_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_Regulator_Mode_1_is_empty(sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_Monitor_Mode_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_Monitor_Mode_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_Monitor_Mode\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_Monitor_Mode elt[SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_Monitor_Mode_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_init(sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_enqueue(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue,\n  Isolette_Data_Model_Monitor_Mode *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Monitor_Mode *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_Monitor_Mode_1_is_empty(sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_Monitor_Mode_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_Monitor_Mode_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Monitor_Mode_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_init(sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_enqueue(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue,\n  Isolette_Data_Model_Monitor_Mode *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_Monitor_Mode_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_init(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue(\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_Monitor_Mode *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_MONITOR_MODE_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_Monitor_Mode_1_is_empty(sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_TempWstatus_i_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_TempWstatus_i\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_TempWstatus_i elt[SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_TempWstatus_i_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_init(sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue,\n  Isolette_Data_Model_TempWstatus_i *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_TempWstatus_i *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_TempWstatus_i_1_is_empty(sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_TempWstatus_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_init(sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue,\n  Isolette_Data_Model_TempWstatus_i *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_TempWstatus_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_TempWstatus_i *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_TEMPWSTATUS_I_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_TempWstatus_i_1_is_empty(sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Data_Model_PhysicalTemp_i_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Data_Model_PhysicalTemp_i\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Data_Model_PhysicalTemp_i elt[SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE];\n\n} sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_init(sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue,\n  Isolette_Data_Model_PhysicalTemp_i *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue;\n\n} sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_PhysicalTemp_i *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_is_empty(sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_init(sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_enqueue(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue,\n  Isolette_Data_Model_PhysicalTemp_i *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_init(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_dequeue(\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Data_Model_PhysicalTemp_i *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_DATA_MODEL_PHYSICALTEMP_I_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_is_empty(sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_queue_Isolette_Environment_Heat_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_aadl_types.h>\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#if __has_include(\"util.h\")\n#include <util.h>\n#elif __has_include(\"libvmm\/util.util.h\")\n#include <libvmm\/util\/util.h>\n#endif\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE-1 elements.\n#define SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ component definition files. The seL4 runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_Isolette_Environment_Heat_1 {\n  \/\/ Number of elements enqueued by the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type Isolette_Environment_Heat\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  Isolette_Environment_Heat elt[SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE];\n\n} sb_queue_Isolette_Environment_Heat_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_Isolette_Environment_Heat_1_init(sb_queue_Isolette_Environment_Heat_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_Isolette_Environment_Heat_1_enqueue(\n  sb_queue_Isolette_Environment_Heat_1_t *queue,\n  Isolette_Environment_Heat *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_Isolette_Environment_Heat_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_Isolette_Environment_Heat_1_t *queue;\n\n} sb_queue_Isolette_Environment_Heat_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_Isolette_Environment_Heat_1_Recv_init(\n  sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Environment_Heat_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_Isolette_Environment_Heat_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_Isolette_Environment_Heat_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_Isolette_Environment_Heat_1_dequeue(\n  sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Environment_Heat *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_Isolette_Environment_Heat_1_is_empty(sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/src\/sb_queue_Isolette_Environment_Heat_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_Isolette_Environment_Heat_1.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_Isolette_Environment_Heat_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Environment_Heat_1_init(sb_queue_Isolette_Environment_Heat_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_Isolette_Environment_Heat_1_enqueue(\n  sb_queue_Isolette_Environment_Heat_1_t *queue,\n  Isolette_Environment_Heat *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_Isolette_Environment_Heat_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_Isolette_Environment_Heat_1_Recv_init(\n  sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue,\n  sb_queue_Isolette_Environment_Heat_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_Isolette_Environment_Heat_1_dequeue(\n  sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  Isolette_Environment_Heat *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_Isolette_Environment_Heat_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_ISOLETTE_ENVIRONMENT_HEAT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_Isolette_Environment_Heat_1_is_empty(sb_queue_Isolette_Environment_Heat_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/types\/include\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#include <sb_aadl_types.h>\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Status_1.h>\n#include <sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h>\n#include <sb_queue_Isolette_Data_Model_On_Off_1.h>\n#include <sb_queue_Isolette_Data_Model_Regulator_Mode_1.h>\n#include <sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Temp_i_1.h>\n#include <sb_queue_Isolette_Data_Model_Status_1.h>\n#include <sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h>\n#include <sb_queue_Isolette_Data_Model_On_Off_1.h>\n#include <sb_queue_Isolette_Data_Model_Monitor_Mode_1.h>\n#include <sb_queue_Isolette_Data_Model_Failure_Flag_i_1.h>\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n#include <sb_queue_Isolette_Data_Model_TempWstatus_i_1.h>\n#include <sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.h>\n#include <sb_queue_Isolette_Environment_Heat_1.h>\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mri_mri\/src\/thermostat_rt_mri_mri_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 61\n\n#define PORT_TO_CHILD 60\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mri_mri\/src\/thermostat_rt_mri_mri.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mri_mri.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_rt_mri_mri_initialize(void);\nvoid thermostat_rt_mri_mri_notify(microkit_channel channel);\nvoid thermostat_rt_mri_mri_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *upper_desired_temp_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *lower_desired_temp_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *displayed_temp_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Status_1_t *regulator_status_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *interface_failure_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *regulator_mode_queue_1;\nsb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t regulator_mode_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *lower_desired_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t lower_desired_tempWstatus_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *upper_desired_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t upper_desired_tempWstatus_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 60\n\nbool put_upper_desired_temp(const Isolette_Data_Model_Temp_i *data) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_enqueue((sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_desired_temp_queue_1, (Isolette_Data_Model_Temp_i *) data);\n\n  return true;\n}\n\nbool put_lower_desired_temp(const Isolette_Data_Model_Temp_i *data) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_enqueue((sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_desired_temp_queue_1, (Isolette_Data_Model_Temp_i *) data);\n\n  return true;\n}\n\nbool put_displayed_temp(const Isolette_Data_Model_Temp_i *data) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_enqueue((sb_queue_Isolette_Data_Model_Temp_i_1_t *) displayed_temp_queue_1, (Isolette_Data_Model_Temp_i *) data);\n\n  return true;\n}\n\nbool put_regulator_status(const Isolette_Data_Model_Status *data) {\n  sb_queue_Isolette_Data_Model_Status_1_enqueue((sb_queue_Isolette_Data_Model_Status_1_t *) regulator_status_queue_1, (Isolette_Data_Model_Status *) data);\n\n  return true;\n}\n\nbool put_interface_failure(const Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1, (Isolette_Data_Model_Failure_Flag_i *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Regulator_Mode last_regulator_mode_payload;\n\nbool get_regulator_mode(Isolette_Data_Model_Regulator_Mode *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Regulator_Mode fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue((sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *) &regulator_mode_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_regulator_mode_payload = fresh_data;\n  }\n  *data = last_regulator_mode_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_lower_desired_tempWstatus_payload;\n\nbool get_lower_desired_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &lower_desired_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_lower_desired_tempWstatus_payload = fresh_data;\n  }\n  *data = last_lower_desired_tempWstatus_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_upper_desired_tempWstatus_payload;\n\nbool get_upper_desired_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &upper_desired_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_upper_desired_tempWstatus_payload = fresh_data;\n  }\n  *data = last_upper_desired_tempWstatus_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_init((sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_desired_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Temp_i_1_init((sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_desired_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Temp_i_1_init((sb_queue_Isolette_Data_Model_Temp_i_1_t *) displayed_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Status_1_init((sb_queue_Isolette_Data_Model_Status_1_t *) regulator_status_queue_1);\n\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_init(&regulator_mode_recv_queue, (sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *) regulator_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&lower_desired_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_desired_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&upper_desired_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_desired_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_rt_mri_mri_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_rt_mri_mri_timeTriggered();\n      break;\n    default:\n      thermostat_rt_mri_mri_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mri_mri\/src\/thermostat_rt_mri_mri_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mri_mri.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_rt_mri_mri_initialize(void) {\n  printf(\"%s: thermostat_rt_mri_mri_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mri_mri_timeTriggered(void) {\n  printf(\"%s: thermostat_rt_mri_mri_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mri_mri_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mri_mri\/include\/thermostat_rt_mri_mri.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_upper_desired_temp(const Isolette_Data_Model_Temp_i *data);\nbool put_lower_desired_temp(const Isolette_Data_Model_Temp_i *data);\nbool put_displayed_temp(const Isolette_Data_Model_Temp_i *data);\nbool put_regulator_status(const Isolette_Data_Model_Status *data);\nbool put_interface_failure(const Isolette_Data_Model_Failure_Flag_i *data);\nbool get_regulator_mode(Isolette_Data_Model_Regulator_Mode *data);\nbool get_lower_desired_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\nbool get_upper_desired_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mhs_mhs\/src\/thermostat_rt_mhs_mhs_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 59\n\n#define PORT_TO_CHILD 58\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mhs_mhs\/src\/thermostat_rt_mhs_mhs.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mhs_mhs.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_rt_mhs_mhs_initialize(void);\nvoid thermostat_rt_mhs_mhs_notify(microkit_channel channel);\nvoid thermostat_rt_mhs_mhs_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *upper_desired_temp_queue_1;\nsb_queue_Isolette_Data_Model_Temp_i_1_Recv_t upper_desired_temp_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *lower_desired_temp_queue_1;\nsb_queue_Isolette_Data_Model_Temp_i_1_Recv_t lower_desired_temp_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_On_Off_1_t *heat_control_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *regulator_mode_queue_1;\nsb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t regulator_mode_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 58\n\nIsolette_Data_Model_Temp_i last_upper_desired_temp_payload;\n\nbool get_upper_desired_temp(Isolette_Data_Model_Temp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Temp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Temp_i_1_dequeue((sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *) &upper_desired_temp_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_upper_desired_temp_payload = fresh_data;\n  }\n  *data = last_upper_desired_temp_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_Temp_i last_lower_desired_temp_payload;\n\nbool get_lower_desired_temp(Isolette_Data_Model_Temp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Temp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Temp_i_1_dequeue((sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *) &lower_desired_temp_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_lower_desired_temp_payload = fresh_data;\n  }\n  *data = last_lower_desired_temp_payload;\n  return isFresh;\n}\n\nbool put_heat_control(const Isolette_Data_Model_On_Off *data) {\n  sb_queue_Isolette_Data_Model_On_Off_1_enqueue((sb_queue_Isolette_Data_Model_On_Off_1_t *) heat_control_queue_1, (Isolette_Data_Model_On_Off *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Regulator_Mode last_regulator_mode_payload;\n\nbool get_regulator_mode(Isolette_Data_Model_Regulator_Mode *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Regulator_Mode fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Regulator_Mode_1_dequeue((sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_t *) &regulator_mode_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_regulator_mode_payload = fresh_data;\n  }\n  *data = last_regulator_mode_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(&upper_desired_temp_recv_queue, (sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_desired_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(&lower_desired_temp_recv_queue, (sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_desired_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_On_Off_1_init((sb_queue_Isolette_Data_Model_On_Off_1_t *) heat_control_queue_1);\n\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_Recv_init(&regulator_mode_recv_queue, (sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *) regulator_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_rt_mhs_mhs_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_rt_mhs_mhs_timeTriggered();\n      break;\n    default:\n      thermostat_rt_mhs_mhs_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mhs_mhs\/src\/thermostat_rt_mhs_mhs_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mhs_mhs.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_rt_mhs_mhs_initialize(void) {\n  printf(\"%s: thermostat_rt_mhs_mhs_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mhs_mhs_timeTriggered(void) {\n  printf(\"%s: thermostat_rt_mhs_mhs_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mhs_mhs_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mhs_mhs\/include\/thermostat_rt_mhs_mhs.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_upper_desired_temp(Isolette_Data_Model_Temp_i *data);\nbool get_lower_desired_temp(Isolette_Data_Model_Temp_i *data);\nbool put_heat_control(const Isolette_Data_Model_On_Off *data);\nbool get_regulator_mode(Isolette_Data_Model_Regulator_Mode *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mrm_mrm\/src\/thermostat_rt_mrm_mrm_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 57\n\n#define PORT_TO_CHILD 56\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mrm_mrm\/src\/thermostat_rt_mrm_mrm.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mrm_mrm.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_rt_mrm_mrm_initialize(void);\nvoid thermostat_rt_mrm_mrm_notify(microkit_channel channel);\nvoid thermostat_rt_mrm_mrm_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *interface_failure_queue_1;\nsb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t interface_failure_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *regulator_mode_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *internal_failure_queue_1;\nsb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t internal_failure_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 56\n\nIsolette_Data_Model_Failure_Flag_i last_interface_failure_payload;\n\nbool get_interface_failure(Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Failure_Flag_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *) &interface_failure_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_interface_failure_payload = fresh_data;\n  }\n  *data = last_interface_failure_payload;\n  return isFresh;\n}\n\nbool put_regulator_mode(const Isolette_Data_Model_Regulator_Mode *data) {\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_enqueue((sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *) regulator_mode_queue_1, (Isolette_Data_Model_Regulator_Mode *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Failure_Flag_i last_internal_failure_payload;\n\nbool get_internal_failure(Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Failure_Flag_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *) &internal_failure_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_internal_failure_payload = fresh_data;\n  }\n  *data = last_internal_failure_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(&interface_failure_recv_queue, (sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_Regulator_Mode_1_init((sb_queue_Isolette_Data_Model_Regulator_Mode_1_t *) regulator_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(&internal_failure_recv_queue, (sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_rt_mrm_mrm_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_rt_mrm_mrm_timeTriggered();\n      break;\n    default:\n      thermostat_rt_mrm_mrm_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mrm_mrm\/src\/thermostat_rt_mrm_mrm_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_mrm_mrm.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_rt_mrm_mrm_initialize(void) {\n  printf(\"%s: thermostat_rt_mrm_mrm_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mrm_mrm_timeTriggered(void) {\n  printf(\"%s: thermostat_rt_mrm_mrm_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_mrm_mrm_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_mrm_mrm\/include\/thermostat_rt_mrm_mrm.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_interface_failure(Isolette_Data_Model_Failure_Flag_i *data);\nbool put_regulator_mode(const Isolette_Data_Model_Regulator_Mode *data);\nbool get_internal_failure(Isolette_Data_Model_Failure_Flag_i *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_drf_drf\/src\/thermostat_rt_drf_drf_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 55\n\n#define PORT_TO_CHILD 54\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_drf_drf\/src\/thermostat_rt_drf_drf.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_drf_drf.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_rt_drf_drf_initialize(void);\nvoid thermostat_rt_drf_drf_notify(microkit_channel channel);\nvoid thermostat_rt_drf_drf_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *internal_failure_queue_1;\n\n#define PORT_FROM_MON 54\n\nbool put_internal_failure(const Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1, (Isolette_Data_Model_Failure_Flag_i *) data);\n\n  return true;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1);\n\n  thermostat_rt_drf_drf_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_rt_drf_drf_timeTriggered();\n      break;\n    default:\n      thermostat_rt_drf_drf_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_drf_drf\/src\/thermostat_rt_drf_drf_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_rt_drf_drf.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_rt_drf_drf_initialize(void) {\n  printf(\"%s: thermostat_rt_drf_drf_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_drf_drf_timeTriggered(void) {\n  printf(\"%s: thermostat_rt_drf_drf_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_rt_drf_drf_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_rt_drf_drf\/include\/thermostat_rt_drf_drf.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_internal_failure(const Isolette_Data_Model_Failure_Flag_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmi_mmi\/src\/thermostat_mt_mmi_mmi_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 53\n\n#define PORT_TO_CHILD 52\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmi_mmi\/src\/thermostat_mt_mmi_mmi.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_mmi_mmi.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_mt_mmi_mmi_initialize(void);\nvoid thermostat_mt_mmi_mmi_notify(microkit_channel channel);\nvoid thermostat_mt_mmi_mmi_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *upper_alarm_temp_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *lower_alarm_temp_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Status_1_t *monitor_status_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *interface_failure_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *monitor_mode_queue_1;\nsb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t monitor_mode_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *lower_alarm_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t lower_alarm_tempWstatus_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *upper_alarm_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t upper_alarm_tempWstatus_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 52\n\nbool put_upper_alarm_temp(const Isolette_Data_Model_Temp_i *data) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_enqueue((sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_alarm_temp_queue_1, (Isolette_Data_Model_Temp_i *) data);\n\n  return true;\n}\n\nbool put_lower_alarm_temp(const Isolette_Data_Model_Temp_i *data) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_enqueue((sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_alarm_temp_queue_1, (Isolette_Data_Model_Temp_i *) data);\n\n  return true;\n}\n\nbool put_monitor_status(const Isolette_Data_Model_Status *data) {\n  sb_queue_Isolette_Data_Model_Status_1_enqueue((sb_queue_Isolette_Data_Model_Status_1_t *) monitor_status_queue_1, (Isolette_Data_Model_Status *) data);\n\n  return true;\n}\n\nbool put_interface_failure(const Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1, (Isolette_Data_Model_Failure_Flag_i *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Monitor_Mode last_monitor_mode_payload;\n\nbool get_monitor_mode(Isolette_Data_Model_Monitor_Mode *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Monitor_Mode fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue((sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *) &monitor_mode_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_monitor_mode_payload = fresh_data;\n  }\n  *data = last_monitor_mode_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_lower_alarm_tempWstatus_payload;\n\nbool get_lower_alarm_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &lower_alarm_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_lower_alarm_tempWstatus_payload = fresh_data;\n  }\n  *data = last_lower_alarm_tempWstatus_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_upper_alarm_tempWstatus_payload;\n\nbool get_upper_alarm_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &upper_alarm_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_upper_alarm_tempWstatus_payload = fresh_data;\n  }\n  *data = last_upper_alarm_tempWstatus_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_init((sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_alarm_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Temp_i_1_init((sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_alarm_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Status_1_init((sb_queue_Isolette_Data_Model_Status_1_t *) monitor_status_queue_1);\n\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_init(&monitor_mode_recv_queue, (sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *) monitor_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&lower_alarm_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_alarm_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&upper_alarm_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_alarm_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_mt_mmi_mmi_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_mt_mmi_mmi_timeTriggered();\n      break;\n    default:\n      thermostat_mt_mmi_mmi_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmi_mmi\/src\/thermostat_mt_mmi_mmi_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_mmi_mmi.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_mt_mmi_mmi_initialize(void) {\n  printf(\"%s: thermostat_mt_mmi_mmi_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_mmi_mmi_timeTriggered(void) {\n  printf(\"%s: thermostat_mt_mmi_mmi_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_mmi_mmi_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmi_mmi\/include\/thermostat_mt_mmi_mmi.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_upper_alarm_temp(const Isolette_Data_Model_Temp_i *data);\nbool put_lower_alarm_temp(const Isolette_Data_Model_Temp_i *data);\nbool put_monitor_status(const Isolette_Data_Model_Status *data);\nbool put_interface_failure(const Isolette_Data_Model_Failure_Flag_i *data);\nbool get_monitor_mode(Isolette_Data_Model_Monitor_Mode *data);\nbool get_lower_alarm_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\nbool get_upper_alarm_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_ma_ma\/src\/thermostat_mt_ma_ma_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 51\n\n#define PORT_TO_CHILD 50\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_ma_ma\/src\/thermostat_mt_ma_ma.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_ma_ma.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_mt_ma_ma_initialize(void);\nvoid thermostat_mt_ma_ma_notify(microkit_channel channel);\nvoid thermostat_mt_ma_ma_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *upper_alarm_temp_queue_1;\nsb_queue_Isolette_Data_Model_Temp_i_1_Recv_t upper_alarm_temp_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *lower_alarm_temp_queue_1;\nsb_queue_Isolette_Data_Model_Temp_i_1_Recv_t lower_alarm_temp_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_On_Off_1_t *alarm_control_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *monitor_mode_queue_1;\nsb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t monitor_mode_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 50\n\nIsolette_Data_Model_Temp_i last_upper_alarm_temp_payload;\n\nbool get_upper_alarm_temp(Isolette_Data_Model_Temp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Temp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Temp_i_1_dequeue((sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *) &upper_alarm_temp_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_upper_alarm_temp_payload = fresh_data;\n  }\n  *data = last_upper_alarm_temp_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_Temp_i last_lower_alarm_temp_payload;\n\nbool get_lower_alarm_temp(Isolette_Data_Model_Temp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Temp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Temp_i_1_dequeue((sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *) &lower_alarm_temp_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_lower_alarm_temp_payload = fresh_data;\n  }\n  *data = last_lower_alarm_temp_payload;\n  return isFresh;\n}\n\nbool put_alarm_control(const Isolette_Data_Model_On_Off *data) {\n  sb_queue_Isolette_Data_Model_On_Off_1_enqueue((sb_queue_Isolette_Data_Model_On_Off_1_t *) alarm_control_queue_1, (Isolette_Data_Model_On_Off *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Monitor_Mode last_monitor_mode_payload;\n\nbool get_monitor_mode(Isolette_Data_Model_Monitor_Mode *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Monitor_Mode fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Monitor_Mode_1_dequeue((sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_t *) &monitor_mode_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_monitor_mode_payload = fresh_data;\n  }\n  *data = last_monitor_mode_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(&upper_alarm_temp_recv_queue, (sb_queue_Isolette_Data_Model_Temp_i_1_t *) upper_alarm_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(&lower_alarm_temp_recv_queue, (sb_queue_Isolette_Data_Model_Temp_i_1_t *) lower_alarm_temp_queue_1);\n\n  sb_queue_Isolette_Data_Model_On_Off_1_init((sb_queue_Isolette_Data_Model_On_Off_1_t *) alarm_control_queue_1);\n\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_Recv_init(&monitor_mode_recv_queue, (sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *) monitor_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_mt_ma_ma_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_mt_ma_ma_timeTriggered();\n      break;\n    default:\n      thermostat_mt_ma_ma_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_ma_ma\/src\/thermostat_mt_ma_ma_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_ma_ma.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_mt_ma_ma_initialize(void) {\n  printf(\"%s: thermostat_mt_ma_ma_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_ma_ma_timeTriggered(void) {\n  printf(\"%s: thermostat_mt_ma_ma_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_ma_ma_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_ma_ma\/include\/thermostat_mt_ma_ma.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_upper_alarm_temp(Isolette_Data_Model_Temp_i *data);\nbool get_lower_alarm_temp(Isolette_Data_Model_Temp_i *data);\nbool put_alarm_control(const Isolette_Data_Model_On_Off *data);\nbool get_monitor_mode(Isolette_Data_Model_Monitor_Mode *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmm_mmm\/src\/thermostat_mt_mmm_mmm_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 49\n\n#define PORT_TO_CHILD 48\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmm_mmm\/src\/thermostat_mt_mmm_mmm.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_mmm_mmm.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_mt_mmm_mmm_initialize(void);\nvoid thermostat_mt_mmm_mmm_notify(microkit_channel channel);\nvoid thermostat_mt_mmm_mmm_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *interface_failure_queue_1;\nsb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t interface_failure_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *monitor_mode_queue_1;\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *internal_failure_queue_1;\nsb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t internal_failure_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nsb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t current_tempWstatus_recv_queue;\n\n#define PORT_FROM_MON 48\n\nIsolette_Data_Model_Failure_Flag_i last_interface_failure_payload;\n\nbool get_interface_failure(Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Failure_Flag_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *) &interface_failure_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_interface_failure_payload = fresh_data;\n  }\n  *data = last_interface_failure_payload;\n  return isFresh;\n}\n\nbool put_monitor_mode(const Isolette_Data_Model_Monitor_Mode *data) {\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_enqueue((sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *) monitor_mode_queue_1, (Isolette_Data_Model_Monitor_Mode *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_Failure_Flag_i last_internal_failure_payload;\n\nbool get_internal_failure(Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Failure_Flag_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Failure_Flag_i_1_dequeue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_t *) &internal_failure_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_internal_failure_payload = fresh_data;\n  }\n  *data = last_internal_failure_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_TempWstatus_i last_current_tempWstatus_payload;\n\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_TempWstatus_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_TempWstatus_i_1_dequeue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_t *) &current_tempWstatus_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_current_tempWstatus_payload = fresh_data;\n  }\n  *data = last_current_tempWstatus_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(&interface_failure_recv_queue, (sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) interface_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_Monitor_Mode_1_init((sb_queue_Isolette_Data_Model_Monitor_Mode_1_t *) monitor_mode_queue_1);\n\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_Recv_init(&internal_failure_recv_queue, (sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_Recv_init(&current_tempWstatus_recv_queue, (sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  thermostat_mt_mmm_mmm_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_mt_mmm_mmm_timeTriggered();\n      break;\n    default:\n      thermostat_mt_mmm_mmm_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmm_mmm\/src\/thermostat_mt_mmm_mmm_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_mmm_mmm.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_mt_mmm_mmm_initialize(void) {\n  printf(\"%s: thermostat_mt_mmm_mmm_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_mmm_mmm_timeTriggered(void) {\n  printf(\"%s: thermostat_mt_mmm_mmm_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_mmm_mmm_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_mmm_mmm\/include\/thermostat_mt_mmm_mmm.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_interface_failure(Isolette_Data_Model_Failure_Flag_i *data);\nbool put_monitor_mode(const Isolette_Data_Model_Monitor_Mode *data);\nbool get_internal_failure(Isolette_Data_Model_Failure_Flag_i *data);\nbool get_current_tempWstatus(Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_dmf_dmf\/src\/thermostat_mt_dmf_dmf_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 47\n\n#define PORT_TO_CHILD 46\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_dmf_dmf\/src\/thermostat_mt_dmf_dmf.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_dmf_dmf.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid thermostat_mt_dmf_dmf_initialize(void);\nvoid thermostat_mt_dmf_dmf_notify(microkit_channel channel);\nvoid thermostat_mt_dmf_dmf_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *internal_failure_queue_1;\n\n#define PORT_FROM_MON 46\n\nbool put_internal_failure(const Isolette_Data_Model_Failure_Flag_i *data) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_enqueue((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1, (Isolette_Data_Model_Failure_Flag_i *) data);\n\n  return true;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Failure_Flag_i_1_init((sb_queue_Isolette_Data_Model_Failure_Flag_i_1_t *) internal_failure_queue_1);\n\n  thermostat_mt_dmf_dmf_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      thermostat_mt_dmf_dmf_timeTriggered();\n      break;\n    default:\n      thermostat_mt_dmf_dmf_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_dmf_dmf\/src\/thermostat_mt_dmf_dmf_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"thermostat_mt_dmf_dmf.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid thermostat_mt_dmf_dmf_initialize(void) {\n  printf(\"%s: thermostat_mt_dmf_dmf_initialize invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_dmf_dmf_timeTriggered(void) {\n  printf(\"%s: thermostat_mt_dmf_dmf_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid thermostat_mt_dmf_dmf_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/thermostat_mt_dmf_dmf\/include\/thermostat_mt_dmf_dmf.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_internal_failure(const Isolette_Data_Model_Failure_Flag_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/operator_interface_oip_oit\/src\/operator_interface_oip_oit_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 45\n\n#define PORT_TO_CHILD 44\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/operator_interface_oip_oit\/src\/operator_interface_oip_oit.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"operator_interface_oip_oit.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid operator_interface_oip_oit_initialize(void);\nvoid operator_interface_oip_oit_notify(microkit_channel channel);\nvoid operator_interface_oip_oit_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_Temp_i_1_t *display_temperature_queue_1;\nsb_queue_Isolette_Data_Model_Temp_i_1_Recv_t display_temperature_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Status_1_t *regulator_status_queue_1;\nsb_queue_Isolette_Data_Model_Status_1_Recv_t regulator_status_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_Status_1_t *monitor_status_queue_1;\nsb_queue_Isolette_Data_Model_Status_1_Recv_t monitor_status_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_On_Off_1_t *alarm_control_queue_1;\nsb_queue_Isolette_Data_Model_On_Off_1_Recv_t alarm_control_recv_queue;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *lower_desired_tempWstatus_queue_1;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *upper_desired_tempWstatus_queue_1;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *lower_alarm_tempWstatus_queue_1;\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *upper_alarm_tempWstatus_queue_1;\n\n#define PORT_FROM_MON 44\n\nIsolette_Data_Model_Temp_i last_display_temperature_payload;\n\nbool get_display_temperature(Isolette_Data_Model_Temp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Temp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Temp_i_1_dequeue((sb_queue_Isolette_Data_Model_Temp_i_1_Recv_t *) &display_temperature_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_display_temperature_payload = fresh_data;\n  }\n  *data = last_display_temperature_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_Status last_regulator_status_payload;\n\nbool get_regulator_status(Isolette_Data_Model_Status *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Status fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Status_1_dequeue((sb_queue_Isolette_Data_Model_Status_1_Recv_t *) &regulator_status_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_regulator_status_payload = fresh_data;\n  }\n  *data = last_regulator_status_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_Status last_monitor_status_payload;\n\nbool get_monitor_status(Isolette_Data_Model_Status *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_Status fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_Status_1_dequeue((sb_queue_Isolette_Data_Model_Status_1_Recv_t *) &monitor_status_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_monitor_status_payload = fresh_data;\n  }\n  *data = last_monitor_status_payload;\n  return isFresh;\n}\n\nIsolette_Data_Model_On_Off last_alarm_control_payload;\n\nbool get_alarm_control(Isolette_Data_Model_On_Off *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_On_Off fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_On_Off_1_dequeue((sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *) &alarm_control_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_alarm_control_payload = fresh_data;\n  }\n  *data = last_alarm_control_payload;\n  return isFresh;\n}\n\nbool put_lower_desired_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_desired_tempWstatus_queue_1, (Isolette_Data_Model_TempWstatus_i *) data);\n\n  return true;\n}\n\nbool put_upper_desired_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_desired_tempWstatus_queue_1, (Isolette_Data_Model_TempWstatus_i *) data);\n\n  return true;\n}\n\nbool put_lower_alarm_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_alarm_tempWstatus_queue_1, (Isolette_Data_Model_TempWstatus_i *) data);\n\n  return true;\n}\n\nbool put_upper_alarm_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_alarm_tempWstatus_queue_1, (Isolette_Data_Model_TempWstatus_i *) data);\n\n  return true;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_Temp_i_1_Recv_init(&display_temperature_recv_queue, (sb_queue_Isolette_Data_Model_Temp_i_1_t *) display_temperature_queue_1);\n\n  sb_queue_Isolette_Data_Model_Status_1_Recv_init(&regulator_status_recv_queue, (sb_queue_Isolette_Data_Model_Status_1_t *) regulator_status_queue_1);\n\n  sb_queue_Isolette_Data_Model_Status_1_Recv_init(&monitor_status_recv_queue, (sb_queue_Isolette_Data_Model_Status_1_t *) monitor_status_queue_1);\n\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_init(&alarm_control_recv_queue, (sb_queue_Isolette_Data_Model_On_Off_1_t *) alarm_control_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_init((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_desired_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_init((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_desired_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_init((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) lower_alarm_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_init((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) upper_alarm_tempWstatus_queue_1);\n\n  operator_interface_oip_oit_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      operator_interface_oip_oit_timeTriggered();\n      break;\n    default:\n      operator_interface_oip_oit_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/operator_interface_oip_oit\/src\/operator_interface_oip_oit_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"operator_interface_oip_oit.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid operator_interface_oip_oit_initialize(void) {\n  printf(\"%s: operator_interface_oip_oit_initialize invoked\\n\", microkit_name);\n}\n\nvoid operator_interface_oip_oit_timeTriggered(void) {\n  printf(\"%s: operator_interface_oip_oit_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid operator_interface_oip_oit_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/operator_interface_oip_oit\/include\/operator_interface_oip_oit.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_display_temperature(Isolette_Data_Model_Temp_i *data);\nbool get_regulator_status(Isolette_Data_Model_Status *data);\nbool get_monitor_status(Isolette_Data_Model_Status *data);\nbool get_alarm_control(Isolette_Data_Model_On_Off *data);\nbool put_lower_desired_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data);\nbool put_upper_desired_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data);\nbool put_lower_alarm_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data);\nbool put_upper_alarm_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 43\n\n#define PORT_TO_CHILD 42\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"temperature_sensor_cpi_thermostat.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid temperature_sensor_cpi_thermostat_initialize(void);\nvoid temperature_sensor_cpi_thermostat_notify(microkit_channel channel);\nvoid temperature_sensor_cpi_thermostat_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *current_tempWstatus_queue_1;\nvolatile sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *air_queue_1;\nsb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t air_recv_queue;\n\n#define PORT_FROM_MON 42\n\nbool put_current_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_enqueue((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1, (Isolette_Data_Model_TempWstatus_i *) data);\n\n  return true;\n}\n\nIsolette_Data_Model_PhysicalTemp_i last_air_payload;\n\nbool get_air(Isolette_Data_Model_PhysicalTemp_i *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_PhysicalTemp_i fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_dequeue((sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_t *) &air_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_air_payload = fresh_data;\n  }\n  *data = last_air_payload;\n  return isFresh;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_TempWstatus_i_1_init((sb_queue_Isolette_Data_Model_TempWstatus_i_1_t *) current_tempWstatus_queue_1);\n\n  sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_Recv_init(&air_recv_queue, (sb_queue_Isolette_Data_Model_PhysicalTemp_i_1_t *) air_queue_1);\n\n  temperature_sensor_cpi_thermostat_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      temperature_sensor_cpi_thermostat_timeTriggered();\n      break;\n    default:\n      temperature_sensor_cpi_thermostat_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"temperature_sensor_cpi_thermostat.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid temperature_sensor_cpi_thermostat_initialize(void) {\n  printf(\"%s: temperature_sensor_cpi_thermostat_initialize invoked\\n\", microkit_name);\n}\n\nvoid temperature_sensor_cpi_thermostat_timeTriggered(void) {\n  printf(\"%s: temperature_sensor_cpi_thermostat_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid temperature_sensor_cpi_thermostat_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/temperature_sensor_cpi_thermostat\/include\/temperature_sensor_cpi_thermostat.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool put_current_tempWstatus(const Isolette_Data_Model_TempWstatus_i *data);\nbool get_air(Isolette_Data_Model_PhysicalTemp_i *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller_MON.c",
        {
          "type" : "ITestResource",
          "content" : "#include <microkit.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n#define PORT_PACER 41\n\n#define PORT_TO_CHILD 40\n\nvoid init(void) {\n  microkit_notify(PORT_PACER);\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_PACER:\n      \/\/ notify child\n      microkit_notify(PORT_TO_CHILD);\n\n      \/\/ send response back to pacer\n      microkit_notify(PORT_PACER);\n      break;\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"heat_source_cpi_heat_controller.h\"\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nvoid heat_source_cpi_heat_controller_initialize(void);\nvoid heat_source_cpi_heat_controller_notify(microkit_channel channel);\nvoid heat_source_cpi_heat_controller_timeTriggered(void);\n\nvolatile sb_queue_Isolette_Data_Model_On_Off_1_t *heat_control_queue_1;\nsb_queue_Isolette_Data_Model_On_Off_1_Recv_t heat_control_recv_queue;\nvolatile sb_queue_Isolette_Environment_Heat_1_t *heat_out_queue_1;\n\n#define PORT_FROM_MON 40\n\nIsolette_Data_Model_On_Off last_heat_control_payload;\n\nbool get_heat_control(Isolette_Data_Model_On_Off *data) {\n  sb_event_counter_t numDropped;\n  Isolette_Data_Model_On_Off fresh_data;\n  bool isFresh = sb_queue_Isolette_Data_Model_On_Off_1_dequeue((sb_queue_Isolette_Data_Model_On_Off_1_Recv_t *) &heat_control_recv_queue, &numDropped, &fresh_data);\n  if (isFresh) {\n    last_heat_control_payload = fresh_data;\n  }\n  *data = last_heat_control_payload;\n  return isFresh;\n}\n\nbool put_heat_out(const Isolette_Environment_Heat *data) {\n  sb_queue_Isolette_Environment_Heat_1_enqueue((sb_queue_Isolette_Environment_Heat_1_t *) heat_out_queue_1, (Isolette_Environment_Heat *) data);\n\n  return true;\n}\n\nvoid init(void) {\n  sb_queue_Isolette_Data_Model_On_Off_1_Recv_init(&heat_control_recv_queue, (sb_queue_Isolette_Data_Model_On_Off_1_t *) heat_control_queue_1);\n\n  sb_queue_Isolette_Environment_Heat_1_init((sb_queue_Isolette_Environment_Heat_1_t *) heat_out_queue_1);\n\n  heat_source_cpi_heat_controller_initialize();\n}\n\nvoid notified(microkit_channel channel) {\n  switch (channel) {\n    case PORT_FROM_MON:\n      heat_source_cpi_heat_controller_timeTriggered();\n      break;\n    default:\n      heat_source_cpi_heat_controller_notify(channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller_user.c",
        {
          "type" : "ITestResource",
          "content" : "#include \"heat_source_cpi_heat_controller.h\"\n\n\/\/ This file will not be overwritten if codegen is rerun\n\nvoid heat_source_cpi_heat_controller_initialize(void) {\n  printf(\"%s: heat_source_cpi_heat_controller_initialize invoked\\n\", microkit_name);\n}\n\nvoid heat_source_cpi_heat_controller_timeTriggered(void) {\n  printf(\"%s: heat_source_cpi_heat_controller_timeTriggered invoked\\n\", microkit_name);\n}\n\nvoid heat_source_cpi_heat_controller_notify(microkit_channel channel) {\n  \/\/ this method is called when the monitor does not handle the passed in channel\n  switch (channel) {\n    default:\n      printf(\"%s: Unexpected channel %d\\n\", microkit_name, channel);\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/heat_source_cpi_heat_controller\/include\/heat_source_cpi_heat_controller.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <printf.h>\n#include <util.h>\n#include <stdint.h>\n#include <microkit.h>\n#include <sb_types.h>\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\nbool get_heat_control(Isolette_Data_Model_On_Off *data);\nbool put_heat_out(const Isolette_Environment_Heat *data);\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/components\/pacer\/src\/pacer.c",
        {
          "type" : "ITestResource",
          "content" : "#include <stdint.h>\n#include <microkit.h>\n\n#define PORT_TO_THERMOSTAT_RT_MRI_MRI_MON 61\n#define PORT_TO_THERMOSTAT_RT_MHS_MHS_MON 59\n#define PORT_TO_THERMOSTAT_RT_MRM_MRM_MON 57\n#define PORT_TO_THERMOSTAT_RT_DRF_DRF_MON 55\n#define PORT_TO_THERMOSTAT_MT_MMI_MMI_MON 53\n#define PORT_TO_THERMOSTAT_MT_MA_MA_MON 51\n#define PORT_TO_THERMOSTAT_MT_MMM_MMM_MON 49\n#define PORT_TO_THERMOSTAT_MT_DMF_DMF_MON 47\n#define PORT_TO_OPERATOR_INTERFACE_OIP_OIT_MON 45\n#define PORT_TO_TEMPERATURE_SENSOR_CPI_THERMOSTAT_MON 43\n#define PORT_TO_HEAT_SOURCE_CPI_HEAT_CONTROLLER_MON 41\n\nvoid init(void) {}\n\nvoid notified(microkit_channel channel) {\n  switch(channel) {\n    case PORT_TO_THERMOSTAT_RT_MRI_MRI_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_RT_MRI_MRI_MON);\n      break;\n    case PORT_TO_THERMOSTAT_RT_MHS_MHS_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_RT_MHS_MHS_MON);\n      break;\n    case PORT_TO_THERMOSTAT_RT_MRM_MRM_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_RT_MRM_MRM_MON);\n      break;\n    case PORT_TO_THERMOSTAT_RT_DRF_DRF_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_RT_DRF_DRF_MON);\n      break;\n    case PORT_TO_THERMOSTAT_MT_MMI_MMI_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_MT_MMI_MMI_MON);\n      break;\n    case PORT_TO_THERMOSTAT_MT_MA_MA_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_MT_MA_MA_MON);\n      break;\n    case PORT_TO_THERMOSTAT_MT_MMM_MMM_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_MT_MMM_MMM_MON);\n      break;\n    case PORT_TO_THERMOSTAT_MT_DMF_DMF_MON:\n      microkit_notify(PORT_TO_THERMOSTAT_MT_DMF_DMF_MON);\n      break;\n    case PORT_TO_OPERATOR_INTERFACE_OIP_OIT_MON:\n      microkit_notify(PORT_TO_OPERATOR_INTERFACE_OIP_OIT_MON);\n      break;\n    case PORT_TO_TEMPERATURE_SENSOR_CPI_THERMOSTAT_MON:\n      microkit_notify(PORT_TO_TEMPERATURE_SENSOR_CPI_THERMOSTAT_MON);\n      break;\n    case PORT_TO_HEAT_SOURCE_CPI_HEAT_CONTROLLER_MON:\n      microkit_notify(PORT_TO_HEAT_SOURCE_CPI_HEAT_CONTROLLER_MON);\n      break;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/microkit.system",
        {
          "type" : "ITestResource",
          "content" : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<system xmlns:xi=\"http:\/\/www.w3.org\/2001\/XInclude\">\n  <!-- Content in between markers will be preserved if codegen is rerun -->\n\n  <xi:include href=\"microkit.schedule.xml\" \/>\n\n  <protection_domain name=\"thermostat_rt_mri_mri_MON\" domain=\"domain_7\">\n    <program_image path=\"thermostat_rt_mri_mri_MON.elf\" \/>\n    <protection_domain name=\"thermostat_rt_mri_mri\" domain=\"domain_7\" id=\"1\">\n      <program_image path=\"thermostat_rt_mri_mri.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"upper_desired_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"lower_desired_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"displayed_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"regulator_status_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"interface_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region\"\n           vaddr=\"0x10_005_000\"\n           perms=\"r\"\n           setvar_vaddr=\"regulator_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_006_000\"\n           perms=\"r\"\n           setvar_vaddr=\"lower_desired_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_007_000\"\n           perms=\"r\"\n           setvar_vaddr=\"upper_desired_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_008_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_rt_mri_mri -->\n      <!-- END CONTENT MARKER thermostat_rt_mri_mri -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_rt_mri_mri_MON -->\n    <!-- END CONTENT MARKER thermostat_rt_mri_mri_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_rt_mhs_mhs_MON\" domain=\"domain_9\">\n    <program_image path=\"thermostat_rt_mhs_mhs_MON.elf\" \/>\n    <protection_domain name=\"thermostat_rt_mhs_mhs\" domain=\"domain_9\" id=\"1\">\n      <program_image path=\"thermostat_rt_mhs_mhs.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"upper_desired_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"r\"\n           setvar_vaddr=\"lower_desired_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"heat_control_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"regulator_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_rt_mhs_mhs -->\n      <!-- END CONTENT MARKER thermostat_rt_mhs_mhs -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_rt_mhs_mhs_MON -->\n    <!-- END CONTENT MARKER thermostat_rt_mhs_mhs_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_rt_mrm_mrm_MON\" domain=\"domain_8\">\n    <program_image path=\"thermostat_rt_mrm_mrm_MON.elf\" \/>\n    <protection_domain name=\"thermostat_rt_mrm_mrm\" domain=\"domain_8\" id=\"1\">\n      <program_image path=\"thermostat_rt_mrm_mrm.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"interface_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"regulator_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"r\"\n           setvar_vaddr=\"internal_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_rt_mrm_mrm -->\n      <!-- END CONTENT MARKER thermostat_rt_mrm_mrm -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_rt_mrm_mrm_MON -->\n    <!-- END CONTENT MARKER thermostat_rt_mrm_mrm_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_rt_drf_drf_MON\" domain=\"domain_10\">\n    <program_image path=\"thermostat_rt_drf_drf_MON.elf\" \/>\n    <protection_domain name=\"thermostat_rt_drf_drf\" domain=\"domain_10\" id=\"1\">\n      <program_image path=\"thermostat_rt_drf_drf.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"internal_failure_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_rt_drf_drf -->\n      <!-- END CONTENT MARKER thermostat_rt_drf_drf -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_rt_drf_drf_MON -->\n    <!-- END CONTENT MARKER thermostat_rt_drf_drf_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_mt_mmi_mmi_MON\" domain=\"domain_4\">\n    <program_image path=\"thermostat_mt_mmi_mmi_MON.elf\" \/>\n    <protection_domain name=\"thermostat_mt_mmi_mmi\" domain=\"domain_4\" id=\"1\">\n      <program_image path=\"thermostat_mt_mmi_mmi.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"upper_alarm_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"lower_alarm_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"monitor_status_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"interface_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"r\"\n           setvar_vaddr=\"monitor_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_005_000\"\n           perms=\"r\"\n           setvar_vaddr=\"lower_alarm_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_006_000\"\n           perms=\"r\"\n           setvar_vaddr=\"upper_alarm_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_007_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_mt_mmi_mmi -->\n      <!-- END CONTENT MARKER thermostat_mt_mmi_mmi -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_mt_mmi_mmi_MON -->\n    <!-- END CONTENT MARKER thermostat_mt_mmi_mmi_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_mt_ma_ma_MON\" domain=\"domain_5\">\n    <program_image path=\"thermostat_mt_ma_ma_MON.elf\" \/>\n    <protection_domain name=\"thermostat_mt_ma_ma\" domain=\"domain_5\" id=\"1\">\n      <program_image path=\"thermostat_mt_ma_ma.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"upper_alarm_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"r\"\n           setvar_vaddr=\"lower_alarm_temp_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"alarm_control_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"monitor_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_mt_ma_ma -->\n      <!-- END CONTENT MARKER thermostat_mt_ma_ma -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_mt_ma_ma_MON -->\n    <!-- END CONTENT MARKER thermostat_mt_ma_ma_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_mt_mmm_mmm_MON\" domain=\"domain_3\">\n    <program_image path=\"thermostat_mt_mmm_mmm_MON.elf\" \/>\n    <protection_domain name=\"thermostat_mt_mmm_mmm\" domain=\"domain_3\" id=\"1\">\n      <program_image path=\"thermostat_mt_mmm_mmm.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"interface_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"monitor_mode_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"r\"\n           setvar_vaddr=\"internal_failure_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_mt_mmm_mmm -->\n      <!-- END CONTENT MARKER thermostat_mt_mmm_mmm -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_mt_mmm_mmm_MON -->\n    <!-- END CONTENT MARKER thermostat_mt_mmm_mmm_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"thermostat_mt_dmf_dmf_MON\" domain=\"domain_6\">\n    <program_image path=\"thermostat_mt_dmf_dmf_MON.elf\" \/>\n    <protection_domain name=\"thermostat_mt_dmf_dmf\" domain=\"domain_6\" id=\"1\">\n      <program_image path=\"thermostat_mt_dmf_dmf.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"internal_failure_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER thermostat_mt_dmf_dmf -->\n      <!-- END CONTENT MARKER thermostat_mt_dmf_dmf -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER thermostat_mt_dmf_dmf_MON -->\n    <!-- END CONTENT MARKER thermostat_mt_dmf_dmf_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"operator_interface_oip_oit_MON\" domain=\"domain_12\">\n    <program_image path=\"operator_interface_oip_oit_MON.elf\" \/>\n    <protection_domain name=\"operator_interface_oip_oit\" domain=\"domain_12\" id=\"1\">\n      <program_image path=\"operator_interface_oip_oit.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"display_temperature_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"r\"\n           setvar_vaddr=\"regulator_status_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region\"\n           vaddr=\"0x10_002_000\"\n           perms=\"r\"\n           setvar_vaddr=\"monitor_status_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region\"\n           vaddr=\"0x10_003_000\"\n           perms=\"r\"\n           setvar_vaddr=\"alarm_control_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_004_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"lower_desired_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_005_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"upper_desired_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_006_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"lower_alarm_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_007_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"upper_alarm_tempWstatus_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER operator_interface_oip_oit -->\n      <!-- END CONTENT MARKER operator_interface_oip_oit -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER operator_interface_oip_oit_MON -->\n    <!-- END CONTENT MARKER operator_interface_oip_oit_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"temperature_sensor_cpi_thermostat_MON\" domain=\"domain_2\">\n    <program_image path=\"temperature_sensor_cpi_thermostat_MON.elf\" \/>\n    <protection_domain name=\"temperature_sensor_cpi_thermostat\" domain=\"domain_2\" id=\"1\">\n      <program_image path=\"temperature_sensor_cpi_thermostat.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"current_tempWstatus_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_air_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"r\"\n           setvar_vaddr=\"air_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER temperature_sensor_cpi_thermostat -->\n      <!-- END CONTENT MARKER temperature_sensor_cpi_thermostat -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER temperature_sensor_cpi_thermostat_MON -->\n    <!-- END CONTENT MARKER temperature_sensor_cpi_thermostat_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"heat_source_cpi_heat_controller_MON\" domain=\"domain_11\">\n    <program_image path=\"heat_source_cpi_heat_controller_MON.elf\" \/>\n    <protection_domain name=\"heat_source_cpi_heat_controller\" domain=\"domain_11\" id=\"1\">\n      <program_image path=\"heat_source_cpi_heat_controller.elf\" \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region\"\n           vaddr=\"0x10_000_000\"\n           perms=\"r\"\n           setvar_vaddr=\"heat_control_queue_1\"\n      \/>\n      <map mr=\"Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_heat_out_1_Memory_Region\"\n           vaddr=\"0x10_001_000\"\n           perms=\"rw\"\n           setvar_vaddr=\"heat_out_queue_1\"\n      \/>\n\n      <!-- BEGIN CONTENT MARKER heat_source_cpi_heat_controller -->\n      <!-- END CONTENT MARKER heat_source_cpi_heat_controller -->\n    <\/protection_domain>\n\n    <!-- BEGIN CONTENT MARKER heat_source_cpi_heat_controller_MON -->\n    <!-- END CONTENT MARKER heat_source_cpi_heat_controller_MON -->\n  <\/protection_domain>\n\n  <protection_domain name=\"pacer\" domain=\"domain_1\">\n    <program_image path=\"pacer.elf\" \/>\n\n    <!-- BEGIN CONTENT MARKER pacer -->\n    <!-- END CONTENT MARKER pacer -->\n  <\/protection_domain>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_air_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <memory_region name=\"Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_heat_out_1_Memory_Region\"\n                 size=\"0x1_000\" \/>\n\n  <channel>\n    <end pd=\"pacer\" id=\"61\" \/>\n    <end pd=\"thermostat_rt_mri_mri_MON\" id=\"61\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_rt_mri_mri_MON\" id=\"60\" \/>\n    <end pd=\"thermostat_rt_mri_mri\" id=\"60\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"59\" \/>\n    <end pd=\"thermostat_rt_mhs_mhs_MON\" id=\"59\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_rt_mhs_mhs_MON\" id=\"58\" \/>\n    <end pd=\"thermostat_rt_mhs_mhs\" id=\"58\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"57\" \/>\n    <end pd=\"thermostat_rt_mrm_mrm_MON\" id=\"57\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_rt_mrm_mrm_MON\" id=\"56\" \/>\n    <end pd=\"thermostat_rt_mrm_mrm\" id=\"56\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"55\" \/>\n    <end pd=\"thermostat_rt_drf_drf_MON\" id=\"55\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_rt_drf_drf_MON\" id=\"54\" \/>\n    <end pd=\"thermostat_rt_drf_drf\" id=\"54\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"53\" \/>\n    <end pd=\"thermostat_mt_mmi_mmi_MON\" id=\"53\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_mt_mmi_mmi_MON\" id=\"52\" \/>\n    <end pd=\"thermostat_mt_mmi_mmi\" id=\"52\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"51\" \/>\n    <end pd=\"thermostat_mt_ma_ma_MON\" id=\"51\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_mt_ma_ma_MON\" id=\"50\" \/>\n    <end pd=\"thermostat_mt_ma_ma\" id=\"50\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"49\" \/>\n    <end pd=\"thermostat_mt_mmm_mmm_MON\" id=\"49\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_mt_mmm_mmm_MON\" id=\"48\" \/>\n    <end pd=\"thermostat_mt_mmm_mmm\" id=\"48\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"47\" \/>\n    <end pd=\"thermostat_mt_dmf_dmf_MON\" id=\"47\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"thermostat_mt_dmf_dmf_MON\" id=\"46\" \/>\n    <end pd=\"thermostat_mt_dmf_dmf\" id=\"46\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"45\" \/>\n    <end pd=\"operator_interface_oip_oit_MON\" id=\"45\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"operator_interface_oip_oit_MON\" id=\"44\" \/>\n    <end pd=\"operator_interface_oip_oit\" id=\"44\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"43\" \/>\n    <end pd=\"temperature_sensor_cpi_thermostat_MON\" id=\"43\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"temperature_sensor_cpi_thermostat_MON\" id=\"42\" \/>\n    <end pd=\"temperature_sensor_cpi_thermostat\" id=\"42\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"pacer\" id=\"41\" \/>\n    <end pd=\"heat_source_cpi_heat_controller_MON\" id=\"41\" \/>\n  <\/channel>\n\n  <channel>\n    <end pd=\"heat_source_cpi_heat_controller_MON\" id=\"40\" \/>\n    <end pd=\"heat_source_cpi_heat_controller\" id=\"40\" \/>\n  <\/channel>\n\n  <!-- BEGIN MSD CONTENT MARKER -->\n  <!-- END MSD CONTENT MARKER -->\n<\/system>",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mri_mri_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mri_mri",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mhs_mhs_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mhs_mhs",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mrm_mrm_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_mrm_mrm",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_drf_drf_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_rt_drf_drf",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_mmi_mmi_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_mmi_mmi",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_ma_ma_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_ma_ma",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_mmm_mmm_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_mmm_mmm",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_dmf_dmf_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER thermostat_mt_dmf_dmf",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER operator_interface_oip_oit_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER operator_interface_oip_oit",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER temperature_sensor_cpi_thermostat_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER temperature_sensor_cpi_thermostat",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER heat_source_cpi_heat_controller_MON",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER heat_source_cpi_heat_controller",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "CONTENT MARKER pacer",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MSD CONTENT MARKER",
              "beginPrefix" : "<!-- BEGIN",
              "optBeginSuffix" : {
                "type" : "Some",
                "value" : "-->"
              },
              "endPrefix" : "<!-- END",
              "optEndSuffix" : {
                "type" : "Some",
                "value" : "-->"
              }
            }
          ],
          "invertMarkers" : true,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/microkit.schedule.xml",
        {
          "type" : "ITestResource",
          "content" : "<!-- This file will not be overwritten if codegen is rerun -->\n\n<domain_schedule>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_2\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_3\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_4\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_5\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_6\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_7\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_8\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_9\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_10\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_11\" length=\"50\" \/>\n  <domain name=\"domain_1\" length=\"10\" \/>\n  <domain name=\"domain_12\" length=\"50\" \/>\n  <domain name=\"domain_0\" length=\"340\" \/>\n<\/domain_schedule>",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/microkit.dot",
        {
          "type" : "ITestResource",
          "content" : "digraph microkit {\n  compound=true;\n\n  \/\/ protection domains\n  graph [style=rounded]\n  subgraph cluster_thermostat_rt_mri_mri_MON {\n    label = \"thermostat_rt_mri_mri_MON\";\n    thermostat_rt_mri_mri_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_rt_mri_mri {\n      label = \"thermostat_rt_mri_mri\";\n      thermostat_rt_mri_mri_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_rt_mri_mri_upper_desired_temp_queue_1 [label=upper_desired_temp_queue_1];\n      pd_thermostat_rt_mri_mri_lower_desired_temp_queue_1 [label=lower_desired_temp_queue_1];\n      pd_thermostat_rt_mri_mri_displayed_temp_queue_1 [label=displayed_temp_queue_1];\n      pd_thermostat_rt_mri_mri_regulator_status_queue_1 [label=regulator_status_queue_1];\n      pd_thermostat_rt_mri_mri_interface_failure_queue_1 [label=interface_failure_queue_1];\n      pd_thermostat_rt_mri_mri_regulator_mode_queue_1 [label=regulator_mode_queue_1];\n      pd_thermostat_rt_mri_mri_lower_desired_tempWstatus_queue_1 [label=lower_desired_tempWstatus_queue_1];\n      pd_thermostat_rt_mri_mri_upper_desired_tempWstatus_queue_1 [label=upper_desired_tempWstatus_queue_1];\n      pd_thermostat_rt_mri_mri_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_rt_mhs_mhs_MON {\n    label = \"thermostat_rt_mhs_mhs_MON\";\n    thermostat_rt_mhs_mhs_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_rt_mhs_mhs {\n      label = \"thermostat_rt_mhs_mhs\";\n      thermostat_rt_mhs_mhs_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_rt_mhs_mhs_upper_desired_temp_queue_1 [label=upper_desired_temp_queue_1];\n      pd_thermostat_rt_mhs_mhs_lower_desired_temp_queue_1 [label=lower_desired_temp_queue_1];\n      pd_thermostat_rt_mhs_mhs_heat_control_queue_1 [label=heat_control_queue_1];\n      pd_thermostat_rt_mhs_mhs_regulator_mode_queue_1 [label=regulator_mode_queue_1];\n      pd_thermostat_rt_mhs_mhs_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_rt_mrm_mrm_MON {\n    label = \"thermostat_rt_mrm_mrm_MON\";\n    thermostat_rt_mrm_mrm_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_rt_mrm_mrm {\n      label = \"thermostat_rt_mrm_mrm\";\n      thermostat_rt_mrm_mrm_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_rt_mrm_mrm_interface_failure_queue_1 [label=interface_failure_queue_1];\n      pd_thermostat_rt_mrm_mrm_regulator_mode_queue_1 [label=regulator_mode_queue_1];\n      pd_thermostat_rt_mrm_mrm_internal_failure_queue_1 [label=internal_failure_queue_1];\n      pd_thermostat_rt_mrm_mrm_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_rt_drf_drf_MON {\n    label = \"thermostat_rt_drf_drf_MON\";\n    thermostat_rt_drf_drf_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_rt_drf_drf {\n      label = \"thermostat_rt_drf_drf\";\n      thermostat_rt_drf_drf_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_rt_drf_drf_internal_failure_queue_1 [label=internal_failure_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_mt_mmi_mmi_MON {\n    label = \"thermostat_mt_mmi_mmi_MON\";\n    thermostat_mt_mmi_mmi_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_mt_mmi_mmi {\n      label = \"thermostat_mt_mmi_mmi\";\n      thermostat_mt_mmi_mmi_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_mt_mmi_mmi_upper_alarm_temp_queue_1 [label=upper_alarm_temp_queue_1];\n      pd_thermostat_mt_mmi_mmi_lower_alarm_temp_queue_1 [label=lower_alarm_temp_queue_1];\n      pd_thermostat_mt_mmi_mmi_monitor_status_queue_1 [label=monitor_status_queue_1];\n      pd_thermostat_mt_mmi_mmi_interface_failure_queue_1 [label=interface_failure_queue_1];\n      pd_thermostat_mt_mmi_mmi_monitor_mode_queue_1 [label=monitor_mode_queue_1];\n      pd_thermostat_mt_mmi_mmi_lower_alarm_tempWstatus_queue_1 [label=lower_alarm_tempWstatus_queue_1];\n      pd_thermostat_mt_mmi_mmi_upper_alarm_tempWstatus_queue_1 [label=upper_alarm_tempWstatus_queue_1];\n      pd_thermostat_mt_mmi_mmi_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_mt_ma_ma_MON {\n    label = \"thermostat_mt_ma_ma_MON\";\n    thermostat_mt_ma_ma_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_mt_ma_ma {\n      label = \"thermostat_mt_ma_ma\";\n      thermostat_mt_ma_ma_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_mt_ma_ma_upper_alarm_temp_queue_1 [label=upper_alarm_temp_queue_1];\n      pd_thermostat_mt_ma_ma_lower_alarm_temp_queue_1 [label=lower_alarm_temp_queue_1];\n      pd_thermostat_mt_ma_ma_alarm_control_queue_1 [label=alarm_control_queue_1];\n      pd_thermostat_mt_ma_ma_monitor_mode_queue_1 [label=monitor_mode_queue_1];\n      pd_thermostat_mt_ma_ma_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_mt_mmm_mmm_MON {\n    label = \"thermostat_mt_mmm_mmm_MON\";\n    thermostat_mt_mmm_mmm_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_mt_mmm_mmm {\n      label = \"thermostat_mt_mmm_mmm\";\n      thermostat_mt_mmm_mmm_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_mt_mmm_mmm_interface_failure_queue_1 [label=interface_failure_queue_1];\n      pd_thermostat_mt_mmm_mmm_monitor_mode_queue_1 [label=monitor_mode_queue_1];\n      pd_thermostat_mt_mmm_mmm_internal_failure_queue_1 [label=internal_failure_queue_1];\n      pd_thermostat_mt_mmm_mmm_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_thermostat_mt_dmf_dmf_MON {\n    label = \"thermostat_mt_dmf_dmf_MON\";\n    thermostat_mt_dmf_dmf_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_thermostat_mt_dmf_dmf {\n      label = \"thermostat_mt_dmf_dmf\";\n      thermostat_mt_dmf_dmf_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_thermostat_mt_dmf_dmf_internal_failure_queue_1 [label=internal_failure_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_operator_interface_oip_oit_MON {\n    label = \"operator_interface_oip_oit_MON\";\n    operator_interface_oip_oit_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_operator_interface_oip_oit {\n      label = \"operator_interface_oip_oit\";\n      operator_interface_oip_oit_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_operator_interface_oip_oit_display_temperature_queue_1 [label=display_temperature_queue_1];\n      pd_operator_interface_oip_oit_regulator_status_queue_1 [label=regulator_status_queue_1];\n      pd_operator_interface_oip_oit_monitor_status_queue_1 [label=monitor_status_queue_1];\n      pd_operator_interface_oip_oit_alarm_control_queue_1 [label=alarm_control_queue_1];\n      pd_operator_interface_oip_oit_lower_desired_tempWstatus_queue_1 [label=lower_desired_tempWstatus_queue_1];\n      pd_operator_interface_oip_oit_upper_desired_tempWstatus_queue_1 [label=upper_desired_tempWstatus_queue_1];\n      pd_operator_interface_oip_oit_lower_alarm_tempWstatus_queue_1 [label=lower_alarm_tempWstatus_queue_1];\n      pd_operator_interface_oip_oit_upper_alarm_tempWstatus_queue_1 [label=upper_alarm_tempWstatus_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_temperature_sensor_cpi_thermostat_MON {\n    label = \"temperature_sensor_cpi_thermostat_MON\";\n    temperature_sensor_cpi_thermostat_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_temperature_sensor_cpi_thermostat {\n      label = \"temperature_sensor_cpi_thermostat\";\n      temperature_sensor_cpi_thermostat_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_temperature_sensor_cpi_thermostat_current_tempWstatus_queue_1 [label=current_tempWstatus_queue_1];\n      pd_temperature_sensor_cpi_thermostat_air_queue_1 [label=air_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_heat_source_cpi_heat_controller_MON {\n    label = \"heat_source_cpi_heat_controller_MON\";\n    heat_source_cpi_heat_controller_MON_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n    graph [style=rounded]\n    subgraph cluster_heat_source_cpi_heat_controller {\n      label = \"heat_source_cpi_heat_controller\";\n      heat_source_cpi_heat_controller_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n      pd_heat_source_cpi_heat_controller_heat_control_queue_1 [label=heat_control_queue_1];\n      pd_heat_source_cpi_heat_controller_heat_out_queue_1 [label=heat_out_queue_1];\n    }\n  }\n\n  graph [style=rounded]\n  subgraph cluster_pacer {\n    label = \"pacer\";\n    pacer_INVIS [label=\"\", style=invis, width=.5, height=.5, fixedsize=true]\n\n  }\n\n  \/\/ memory regions\n  Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_air_1_Memory_Region;\n\n  Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_heat_out_1_Memory_Region;\n\n  \/\/ channels\n  pacer_INVIS -> thermostat_rt_mri_mri_MON_INVIS [lhead=cluster_thermostat_rt_mri_mri_MON, minlen=2, dir=both];\n  thermostat_rt_mri_mri_MON_INVIS -> thermostat_rt_mri_mri_INVIS [lhead=cluster_thermostat_rt_mri_mri, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_rt_mhs_mhs_MON_INVIS [lhead=cluster_thermostat_rt_mhs_mhs_MON, minlen=2, dir=both];\n  thermostat_rt_mhs_mhs_MON_INVIS -> thermostat_rt_mhs_mhs_INVIS [lhead=cluster_thermostat_rt_mhs_mhs, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_rt_mrm_mrm_MON_INVIS [lhead=cluster_thermostat_rt_mrm_mrm_MON, minlen=2, dir=both];\n  thermostat_rt_mrm_mrm_MON_INVIS -> thermostat_rt_mrm_mrm_INVIS [lhead=cluster_thermostat_rt_mrm_mrm, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_rt_drf_drf_MON_INVIS [lhead=cluster_thermostat_rt_drf_drf_MON, minlen=2, dir=both];\n  thermostat_rt_drf_drf_MON_INVIS -> thermostat_rt_drf_drf_INVIS [lhead=cluster_thermostat_rt_drf_drf, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_mt_mmi_mmi_MON_INVIS [lhead=cluster_thermostat_mt_mmi_mmi_MON, minlen=2, dir=both];\n  thermostat_mt_mmi_mmi_MON_INVIS -> thermostat_mt_mmi_mmi_INVIS [lhead=cluster_thermostat_mt_mmi_mmi, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_mt_ma_ma_MON_INVIS [lhead=cluster_thermostat_mt_ma_ma_MON, minlen=2, dir=both];\n  thermostat_mt_ma_ma_MON_INVIS -> thermostat_mt_ma_ma_INVIS [lhead=cluster_thermostat_mt_ma_ma, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_mt_mmm_mmm_MON_INVIS [lhead=cluster_thermostat_mt_mmm_mmm_MON, minlen=2, dir=both];\n  thermostat_mt_mmm_mmm_MON_INVIS -> thermostat_mt_mmm_mmm_INVIS [lhead=cluster_thermostat_mt_mmm_mmm, minlen=2, dir=both];\n  pacer_INVIS -> thermostat_mt_dmf_dmf_MON_INVIS [lhead=cluster_thermostat_mt_dmf_dmf_MON, minlen=2, dir=both];\n  thermostat_mt_dmf_dmf_MON_INVIS -> thermostat_mt_dmf_dmf_INVIS [lhead=cluster_thermostat_mt_dmf_dmf, minlen=2, dir=both];\n  pacer_INVIS -> operator_interface_oip_oit_MON_INVIS [lhead=cluster_operator_interface_oip_oit_MON, minlen=2, dir=both];\n  operator_interface_oip_oit_MON_INVIS -> operator_interface_oip_oit_INVIS [lhead=cluster_operator_interface_oip_oit, minlen=2, dir=both];\n  pacer_INVIS -> temperature_sensor_cpi_thermostat_MON_INVIS [lhead=cluster_temperature_sensor_cpi_thermostat_MON, minlen=2, dir=both];\n  temperature_sensor_cpi_thermostat_MON_INVIS -> temperature_sensor_cpi_thermostat_INVIS [lhead=cluster_temperature_sensor_cpi_thermostat, minlen=2, dir=both];\n  pacer_INVIS -> heat_source_cpi_heat_controller_MON_INVIS [lhead=cluster_heat_source_cpi_heat_controller_MON, minlen=2, dir=both];\n  heat_source_cpi_heat_controller_MON_INVIS -> heat_source_cpi_heat_controller_INVIS [lhead=cluster_heat_source_cpi_heat_controller, minlen=2, dir=both];\n\n  \/\/ shared memory mappings\n  pd_thermostat_rt_mri_mri_upper_desired_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mri_mri_lower_desired_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mri_mri_displayed_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mri_mri_regulator_status_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mri_mri_interface_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mri_mri_regulator_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mri_mri_lower_desired_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mri_mri_upper_desired_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mri_mri_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mhs_mhs_upper_desired_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_upper_desired_temp_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mhs_mhs_lower_desired_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_lower_desired_temp_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mhs_mhs_heat_control_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mhs_mhs_regulator_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mhs_mhs_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mrm_mrm_interface_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_interface_failure_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mrm_mrm_regulator_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_regulator_mode_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_rt_mrm_mrm_internal_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_mrm_mrm_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_rt_drf_drf_internal_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_internal_failure_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmi_mmi_upper_alarm_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmi_mmi_lower_alarm_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmi_mmi_monitor_status_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmi_mmi_interface_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmi_mmi_monitor_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmi_mmi_lower_alarm_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmi_mmi_upper_alarm_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmi_mmi_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_ma_ma_upper_alarm_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_upper_alarm_temp_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_ma_ma_lower_alarm_temp_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_lower_alarm_temp_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_ma_ma_alarm_control_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_ma_ma_monitor_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_ma_ma_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmm_mmm_interface_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_interface_failure_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmm_mmm_monitor_mode_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_monitor_mode_1_Memory_Region [dir=both, style=dashed];\n  pd_thermostat_mt_mmm_mmm_internal_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_mmm_mmm_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=back, style=dashed];\n  pd_thermostat_mt_dmf_dmf_internal_failure_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_internal_failure_1_Memory_Region [dir=both, style=dashed];\n  pd_operator_interface_oip_oit_display_temperature_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_displayed_temp_1_Memory_Region [dir=back, style=dashed];\n  pd_operator_interface_oip_oit_regulator_status_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_regulator_status_1_Memory_Region [dir=back, style=dashed];\n  pd_operator_interface_oip_oit_monitor_status_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_monitor_status_1_Memory_Region [dir=back, style=dashed];\n  pd_operator_interface_oip_oit_alarm_control_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_alarm_control_1_Memory_Region [dir=back, style=dashed];\n  pd_operator_interface_oip_oit_lower_desired_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus_1_Memory_Region [dir=both, style=dashed];\n  pd_operator_interface_oip_oit_upper_desired_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus_1_Memory_Region [dir=both, style=dashed];\n  pd_operator_interface_oip_oit_lower_alarm_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus_1_Memory_Region [dir=both, style=dashed];\n  pd_operator_interface_oip_oit_upper_alarm_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus_1_Memory_Region [dir=both, style=dashed];\n  pd_temperature_sensor_cpi_thermostat_current_tempWstatus_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus_1_Memory_Region [dir=both, style=dashed];\n  pd_temperature_sensor_cpi_thermostat_air_queue_1 -> Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_air_1_Memory_Region [dir=back, style=dashed];\n  pd_heat_source_cpi_heat_controller_heat_control_queue_1 -> Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_heat_control_1_Memory_Region [dir=back, style=dashed];\n  pd_heat_source_cpi_heat_controller_heat_out_queue_1 -> Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_heat_out_1_Memory_Region [dir=both, style=dashed];\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if codegen is rerun\n\noverride MICROKIT_SDK := $(abspath ${MICROKIT_SDK})\n\nSYSTEM_MAKEFILE ?= system.mk\n\nexport CPU = cortex-a53\nexport QEMU = qemu-system-aarch64\n\nexport AR := ar\nexport CC := clang\nexport DTC := dtc\nexport LD := ld.lld\nexport RANLIB := llvm-ranlib\n\nexport TOP_DIR := $(abspath $(dir ${MAKEFILE_LIST}))\nexport TOP_BUILD_DIR := $(abspath build)\n\nexport CRATES_DIR := $(TOP_DIR)\/crates\n\nexport TARGET := aarch64-none-elf\n\n# By default we make a debug build so that the client debug prints can be seen.\nexport MICROKIT_CONFIG ?= debug\n\nexport MICROKIT_SDK := $(abspath $(MICROKIT_SDK))\nexport MICROKIT_TOOL := $(abspath $(MICROKIT_SDK)\/bin\/microkit)\nexport MICROKIT_BOARD_DIR := $(abspath $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG))\n\n\nIMAGE_FILE := $(TOP_BUILD_DIR)\/loader.img\nREPORT_FILE := $(TOP_BUILD_DIR)\/report.txt\n\n# By default, cargo-verus is used to build Rust crates, and it fails if verification does not succeed.\n# To skip verification, set the RUST_MAKE_TARGET environment variable to use a cargo build target.\n# Example:\n#\n#   RUST_MAKE_TARGET=build-release make\n\nall: ${IMAGE_FILE}\n\n.PHONY: check_microkit\ncheck_microkit:\n\t@if [ -z \"$(strip $(MICROKIT_BOARD))\" ]; then \\\n\t\techo \"MICROKIT_BOARD must be specified\"; \\\n\t\texit 1; \\\n\tfi\n\t@if [ -z \"$(strip $(MICROKIT_SDK))\" ]; then \\\n\t\techo \"MICROKIT_SDK must be specified\"; \\\n\t\texit 1; \\\n\tfi\n\nqemu ${IMAGE_FILE} ${REPORT_FILE}: check_microkit $(IMAGE_FILE) ${TOP_BUILD_DIR}\/Makefile FORCE\n\t${MAKE} -C ${TOP_BUILD_DIR} $(notdir $@)\n\nclean:: ${TOP_BUILD_DIR}\/Makefile\n\t${MAKE} -C ${TOP_BUILD_DIR} clean\n\nclobber:: clean\n\trm -rf $(TOP_DIR)\/build\n\n${TOP_BUILD_DIR}\/Makefile: $(SYSTEM_MAKEFILE)\n\tmkdir -p ${TOP_BUILD_DIR}\n\tcp $(SYSTEM_MAKEFILE) ${TOP_BUILD_DIR}\/Makefile\n\ntest:: ${TOP_BUILD_DIR}\/Makefile\n\t${MAKE} -C ${TOP_BUILD_DIR} test\n\nverus: ${TOP_BUILD_DIR}\/Makefile\n\t${MAKE} -C ${TOP_BUILD_DIR} verus\n\nFORCE:\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/system.mk",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if codegen is rerun\n\nMICROKIT_TOOL ?= $(MICROKIT_SDK)\/bin\/microkit\n\nCFLAGS := -mcpu=$(CPU) \\\n\t-mstrict-align \\\n\t-ffreestanding \\\n\t-nostdlib \\\n\t-g3 \\\n\t-O3 \\\n\t-Wall -Wno-unused-function -Werror -Wno-unused-command-line-argument \\\n\t-I$(MICROKIT_BOARD_DIR)\/include \\\n\t-target $(TARGET)\n\nLDFLAGS := -L$(MICROKIT_BOARD_DIR)\/lib\nLIBS := --start-group -lmicrokit -Tmicrokit.ld --end-group\n\nSYSTEM_FILE := $(TOP_DIR)\/microkit.system\nSCHEDULE_FILE := $(TOP_DIR)\/microkit.schedule.xml\n\nIMAGES := thermostat_rt_mri_mri.elf thermostat_rt_mri_mri_MON.elf thermostat_rt_mhs_mhs.elf thermostat_rt_mhs_mhs_MON.elf thermostat_rt_mrm_mrm.elf thermostat_rt_mrm_mrm_MON.elf thermostat_rt_drf_drf.elf thermostat_rt_drf_drf_MON.elf thermostat_mt_mmi_mmi.elf thermostat_mt_mmi_mmi_MON.elf thermostat_mt_ma_ma.elf thermostat_mt_ma_ma_MON.elf thermostat_mt_mmm_mmm.elf thermostat_mt_mmm_mmm_MON.elf thermostat_mt_dmf_dmf.elf thermostat_mt_dmf_dmf_MON.elf operator_interface_oip_oit.elf operator_interface_oip_oit_MON.elf temperature_sensor_cpi_thermostat.elf temperature_sensor_cpi_thermostat_MON.elf heat_source_cpi_heat_controller.elf heat_source_cpi_heat_controller_MON.elf pacer.elf\nIMAGE_FILE = loader.img\nREPORT_FILE = report.txt\n\nUTIL_OBJS = printf.o util.o\n\nTYPES_DIR = $(TOP_DIR)\/types\nTYPE_OBJS := $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Status_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_On_Off_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Regulator_Mode_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Status_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_On_Off_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Monitor_Mode_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.o $(TOP_DIR)\/build\/sb_queue_Isolette_Environment_Heat_1.o\n\n# exporting TOP_TYPES_INCLUDE in case other makefiles need it\nexport TOP_TYPES_INCLUDE = -I$(TYPES_DIR)\/include\n\nTOP_INCLUDE = $(TOP_TYPES_INCLUDE) -I$(TOP_DIR)\/util\/include\n\nall: $(IMAGE_FILE)\n\tCHECK_FLAGS_BOARD_MD5:=.board_cflags-$(shell echo -- ${CFLAGS} ${MICROKIT_BOARD} ${MICROKIT_CONFIG}| shasum | sed 's\/ *-\/\/')\n\n${CHECK_FLAGS_BOARD_MD5}:\n\t-rm -f .board_cflags-*\n\ttouch $@\n\n%.o: ${TOP_DIR}\/util\/src\/%.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ -I$(TOP_DIR)\/util\/include\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Temp_i_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_Temp_i_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Status_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_Status_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_Failure_Flag_i_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_On_Off_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_On_Off_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Regulator_Mode_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_Regulator_Mode_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_Monitor_Mode_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_Monitor_Mode_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_TempWstatus_i_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Data_Model_PhysicalTemp_i_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n$(TOP_DIR)\/build\/sb_queue_Isolette_Environment_Heat_1.o: $(TOP_DIR)\/types\/src\/sb_queue_Isolette_Environment_Heat_1.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\n\n\n# monitor\nthermostat_rt_mri_mri_MON.o: $(TOP_DIR)\/components\/thermostat_rt_mri_mri\/src\/thermostat_rt_mri_mri_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mri_mri\/include\n\n# user code\nthermostat_rt_mri_mri_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mri_mri $(RUST_MAKE_TARGET)\n\nthermostat_rt_mri_mri.o: $(TOP_DIR)\/components\/thermostat_rt_mri_mri\/src\/thermostat_rt_mri_mri.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mri_mri\/include\n\n# monitor\nthermostat_rt_mhs_mhs_MON.o: $(TOP_DIR)\/components\/thermostat_rt_mhs_mhs\/src\/thermostat_rt_mhs_mhs_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mhs_mhs\/include\n\n# user code\nthermostat_rt_mhs_mhs_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mhs_mhs $(RUST_MAKE_TARGET)\n\nthermostat_rt_mhs_mhs.o: $(TOP_DIR)\/components\/thermostat_rt_mhs_mhs\/src\/thermostat_rt_mhs_mhs.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mhs_mhs\/include\n\n# monitor\nthermostat_rt_mrm_mrm_MON.o: $(TOP_DIR)\/components\/thermostat_rt_mrm_mrm\/src\/thermostat_rt_mrm_mrm_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mrm_mrm\/include\n\n# user code\nthermostat_rt_mrm_mrm_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mrm_mrm $(RUST_MAKE_TARGET)\n\nthermostat_rt_mrm_mrm.o: $(TOP_DIR)\/components\/thermostat_rt_mrm_mrm\/src\/thermostat_rt_mrm_mrm.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_mrm_mrm\/include\n\n# monitor\nthermostat_rt_drf_drf_MON.o: $(TOP_DIR)\/components\/thermostat_rt_drf_drf\/src\/thermostat_rt_drf_drf_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_drf_drf\/include\n\n# user code\nthermostat_rt_drf_drf_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_rt_drf_drf $(RUST_MAKE_TARGET)\n\nthermostat_rt_drf_drf.o: $(TOP_DIR)\/components\/thermostat_rt_drf_drf\/src\/thermostat_rt_drf_drf.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_rt_drf_drf\/include\n\n# monitor\nthermostat_mt_mmi_mmi_MON.o: $(TOP_DIR)\/components\/thermostat_mt_mmi_mmi\/src\/thermostat_mt_mmi_mmi_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_mmi_mmi\/include\n\n# user code\nthermostat_mt_mmi_mmi_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmi_mmi $(RUST_MAKE_TARGET)\n\nthermostat_mt_mmi_mmi.o: $(TOP_DIR)\/components\/thermostat_mt_mmi_mmi\/src\/thermostat_mt_mmi_mmi.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_mmi_mmi\/include\n\n# monitor\nthermostat_mt_ma_ma_MON.o: $(TOP_DIR)\/components\/thermostat_mt_ma_ma\/src\/thermostat_mt_ma_ma_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_ma_ma\/include\n\n# user code\nthermostat_mt_ma_ma_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_mt_ma_ma $(RUST_MAKE_TARGET)\n\nthermostat_mt_ma_ma.o: $(TOP_DIR)\/components\/thermostat_mt_ma_ma\/src\/thermostat_mt_ma_ma.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_ma_ma\/include\n\n# monitor\nthermostat_mt_mmm_mmm_MON.o: $(TOP_DIR)\/components\/thermostat_mt_mmm_mmm\/src\/thermostat_mt_mmm_mmm_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_mmm_mmm\/include\n\n# user code\nthermostat_mt_mmm_mmm_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmm_mmm $(RUST_MAKE_TARGET)\n\nthermostat_mt_mmm_mmm.o: $(TOP_DIR)\/components\/thermostat_mt_mmm_mmm\/src\/thermostat_mt_mmm_mmm.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_mmm_mmm\/include\n\n# monitor\nthermostat_mt_dmf_dmf_MON.o: $(TOP_DIR)\/components\/thermostat_mt_dmf_dmf\/src\/thermostat_mt_dmf_dmf_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_dmf_dmf\/include\n\n# user code\nthermostat_mt_dmf_dmf_rust:\n\tmake -C ${CRATES_DIR}\/thermostat_mt_dmf_dmf $(RUST_MAKE_TARGET)\n\nthermostat_mt_dmf_dmf.o: $(TOP_DIR)\/components\/thermostat_mt_dmf_dmf\/src\/thermostat_mt_dmf_dmf.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/thermostat_mt_dmf_dmf\/include\n\n# monitor\noperator_interface_oip_oit_MON.o: $(TOP_DIR)\/components\/operator_interface_oip_oit\/src\/operator_interface_oip_oit_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/operator_interface_oip_oit\/include\n\n# user code\noperator_interface_oip_oit_rust:\n\tmake -C ${CRATES_DIR}\/operator_interface_oip_oit $(RUST_MAKE_TARGET)\n\noperator_interface_oip_oit.o: $(TOP_DIR)\/components\/operator_interface_oip_oit\/src\/operator_interface_oip_oit.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/operator_interface_oip_oit\/include\n\n# monitor\ntemperature_sensor_cpi_thermostat_MON.o: $(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/include\n\n# user code\ntemperature_sensor_cpi_thermostat_user.o: $(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat_user.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\/ -I$(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/include\n\ntemperature_sensor_cpi_thermostat.o: $(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/src\/temperature_sensor_cpi_thermostat.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/temperature_sensor_cpi_thermostat\/include\n\n# monitor\nheat_source_cpi_heat_controller_MON.o: $(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller_MON.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/include\n\n# user code\nheat_source_cpi_heat_controller_user.o: $(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller_user.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE)\/ -I$(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/include\n\nheat_source_cpi_heat_controller.o: $(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/src\/heat_source_cpi_heat_controller.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ $(TOP_INCLUDE) -I$(TOP_DIR)\/components\/heat_source_cpi_heat_controller\/include\n\npacer.o: $(TOP_DIR)\/components\/pacer\/src\/pacer.c Makefile\n\t$(CC) -c $(CFLAGS) $< -o $@ -I$(TOP_INCLUDE)\n\nthermostat_rt_mri_mri_MON.elf: thermostat_rt_mri_mri_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_rt_mri_mri.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_rt_mri_mri_rust thermostat_rt_mri_mri.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_rt_mri_mri\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_rt_mri_mri -o $@\n\nthermostat_rt_mhs_mhs_MON.elf: thermostat_rt_mhs_mhs_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_rt_mhs_mhs.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_rt_mhs_mhs_rust thermostat_rt_mhs_mhs.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_rt_mhs_mhs\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_rt_mhs_mhs -o $@\n\nthermostat_rt_mrm_mrm_MON.elf: thermostat_rt_mrm_mrm_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_rt_mrm_mrm.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_rt_mrm_mrm_rust thermostat_rt_mrm_mrm.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_rt_mrm_mrm\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_rt_mrm_mrm -o $@\n\nthermostat_rt_drf_drf_MON.elf: thermostat_rt_drf_drf_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_rt_drf_drf.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_rt_drf_drf_rust thermostat_rt_drf_drf.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_rt_drf_drf\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_rt_drf_drf -o $@\n\nthermostat_mt_mmi_mmi_MON.elf: thermostat_mt_mmi_mmi_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_mt_mmi_mmi.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_mt_mmi_mmi_rust thermostat_mt_mmi_mmi.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_mt_mmi_mmi\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_mt_mmi_mmi -o $@\n\nthermostat_mt_ma_ma_MON.elf: thermostat_mt_ma_ma_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_mt_ma_ma.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_mt_ma_ma_rust thermostat_mt_ma_ma.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_mt_ma_ma\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_mt_ma_ma -o $@\n\nthermostat_mt_mmm_mmm_MON.elf: thermostat_mt_mmm_mmm_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_mt_mmm_mmm.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_mt_mmm_mmm_rust thermostat_mt_mmm_mmm.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_mt_mmm_mmm\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_mt_mmm_mmm -o $@\n\nthermostat_mt_dmf_dmf_MON.elf: thermostat_mt_dmf_dmf_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nthermostat_mt_dmf_dmf.elf: $(UTIL_OBJS) $(TYPE_OBJS) thermostat_mt_dmf_dmf_rust thermostat_mt_dmf_dmf.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/thermostat_mt_dmf_dmf\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -lthermostat_mt_dmf_dmf -o $@\n\noperator_interface_oip_oit_MON.elf: operator_interface_oip_oit_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\noperator_interface_oip_oit.elf: $(UTIL_OBJS) $(TYPE_OBJS) operator_interface_oip_oit_rust operator_interface_oip_oit.o\n\t$(LD) $(LDFLAGS) -L ${CRATES_DIR}\/operator_interface_oip_oit\/target\/aarch64-unknown-none\/release $(filter %.o, $^) $(LIBS) -loperator_interface_oip_oit -o $@\n\ntemperature_sensor_cpi_thermostat_MON.elf: temperature_sensor_cpi_thermostat_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\ntemperature_sensor_cpi_thermostat.elf: $(UTIL_OBJS) $(TYPE_OBJS) temperature_sensor_cpi_thermostat_user.o temperature_sensor_cpi_thermostat.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nheat_source_cpi_heat_controller_MON.elf: heat_source_cpi_heat_controller_MON.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\nheat_source_cpi_heat_controller.elf: $(UTIL_OBJS) $(TYPE_OBJS) heat_source_cpi_heat_controller_user.o heat_source_cpi_heat_controller.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\npacer.elf: $(UTIL_OBJS) $(TYPE_OBJS) pacer.o\n\t$(LD) $(LDFLAGS) $^ $(LIBS) -o $@\n\n$(IMAGE_FILE): $(IMAGES) $(SYSTEM_FILE)\n\txmllint --xinclude $(SYSTEM_FILE) -o $(SYSTEM_FILE).merged\n\t$(MICROKIT_TOOL) $(SYSTEM_FILE).merged --search-path $(TOP_BUILD_DIR) --board $(MICROKIT_BOARD) --config $(MICROKIT_CONFIG) -o $(IMAGE_FILE) -r $(REPORT_FILE)\n\n\nqemu: $(IMAGE_FILE)\n\t$(QEMU) -machine virt,virtualization=on \\\n\t\t\t-cpu cortex-a53 \\\n\t\t\t-serial mon:stdio \\\n\t\t\t-device loader,file=$(IMAGE_FILE),addr=0x70000000,cpu-num=0 \\\n\t\t\t-m size=2G \\\n\t\t\t-nographic\n\nclean::\n\trm -f *.o\n\ntest:: \n\tmake -C ${CRATES_DIR}\/thermostat_rt_mri_mri test\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mhs_mhs test\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mrm_mrm test\n\tmake -C ${CRATES_DIR}\/thermostat_rt_drf_drf test\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmi_mmi test\n\tmake -C ${CRATES_DIR}\/thermostat_mt_ma_ma test\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmm_mmm test\n\tmake -C ${CRATES_DIR}\/thermostat_mt_dmf_dmf test\n\tmake -C ${CRATES_DIR}\/operator_interface_oip_oit test\n\nclean:: \n\tmake -C ${CRATES_DIR}\/thermostat_rt_mri_mri clean\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mhs_mhs clean\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mrm_mrm clean\n\tmake -C ${CRATES_DIR}\/thermostat_rt_drf_drf clean\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmi_mmi clean\n\tmake -C ${CRATES_DIR}\/thermostat_mt_ma_ma clean\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmm_mmm clean\n\tmake -C ${CRATES_DIR}\/thermostat_mt_dmf_dmf clean\n\tmake -C ${CRATES_DIR}\/operator_interface_oip_oit clean\n\nverus: \n\tmake -C ${CRATES_DIR}\/thermostat_rt_mri_mri verus\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mhs_mhs verus\n\tmake -C ${CRATES_DIR}\/thermostat_rt_mrm_mrm verus\n\tmake -C ${CRATES_DIR}\/thermostat_rt_drf_drf verus\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmi_mmi verus\n\tmake -C ${CRATES_DIR}\/thermostat_mt_ma_ma verus\n\tmake -C ${CRATES_DIR}\/thermostat_mt_mmm_mmm verus\n\tmake -C ${CRATES_DIR}\/thermostat_mt_dmf_dmf verus\n\tmake -C ${CRATES_DIR}\/operator_interface_oip_oit verus\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/include\/printf.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ \\author (c) Marco Paland (info@paland.com)\n\/\/             2014-2019, PALANDesign Hannover, Germany\n\/\/\n\/\/ \\license The MIT License (MIT)\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\/\/ \\brief Tiny printf, sprintf and snprintf implementation, optimized for speed on\n\/\/        embedded systems with a very limited resources.\n\/\/        Use this instead of bloated standard\/newlib printf.\n\/\/        These routines are thread safe and reentrant.\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#ifndef _PRINTF_H_\n#define _PRINTF_H_\n\n#include <stdarg.h>\n#include <stddef.h>\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\/**\n * Output a character to a custom device like UART, used by the printf() function\n * This function is declared here only. You have to write your custom implementation somewhere\n * \\param character Character to output\n *\/\nvoid _putchar(char character);\n\n\n\/**\n * Tiny printf implementation\n * You have to implement _putchar if you use printf()\n * To avoid conflicts with the regular printf() API it is overridden by macro defines\n * and internal underscore-appended functions like printf_() are used\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are written into the array, not counting the terminating null character\n *\/\n#define printf printf_\nint printf_(const char* format, ...);\n\n\n\/**\n * Tiny sprintf implementation\n * Due to security reasons (buffer overflow) YOU SHOULD CONSIDER USING (V)SNPRINTF INSTEAD!\n * \\param buffer A pointer to the buffer where to store the formatted string. MUST be big enough to store the output!\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\n *\/\n#define sprintf sprintf_\nint sprintf_(char* buffer, const char* format, ...);\n\n\n\/**\n * Tiny snprintf\/vsnprintf implementation\n * \\param buffer A pointer to the buffer where to store the formatted string\n * \\param count The maximum number of characters to store in the buffer, including a terminating null character\n * \\param format A string that specifies the format of the output\n * \\param va A value identifying a variable arguments list\n * \\return The number of characters that COULD have been written into the buffer, not counting the terminating\n *         null character. A value equal or larger than count indicates truncation. Only when the returned value\n *         is non-negative and less than count, the string has been completely written.\n *\/\n#define snprintf  snprintf_\n#define vsnprintf vsnprintf_\nint  snprintf_(char* buffer, size_t count, const char* format, ...);\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va);\n\n\n\/**\n * Tiny vprintf implementation\n * \\param format A string that specifies the format of the output\n * \\param va A value identifying a variable arguments list\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\n *\/\n#define vprintf vprintf_\nint vprintf_(const char* format, va_list va);\n\n\n\/**\n * printf with output function\n * You may use this as dynamic alternative to printf() with its fixed _putchar() output\n * \\param out An output function which takes one character and an argument pointer\n * \\param arg An argument pointer for user data passed to output function\n * \\param format A string that specifies the format of the output\n * \\return The number of characters that are sent to the output function, not counting the terminating null character\n *\/\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif  \/\/ _PRINTF_H_\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/src\/printf.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ \\author (c) Marco Paland (info@paland.com)\n\/\/             2014-2019, PALANDesign Hannover, Germany\n\/\/\n\/\/ \\license The MIT License (MIT)\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\/\/ \\brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on\n\/\/        embedded systems with a very limited resources. These routines are thread\n\/\/        safe and reentrant!\n\/\/        Use this instead of the bloated standard\/newlib printf cause these use\n\/\/        malloc for printf (and may not be thread safe).\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"printf.h\"\n\n\n\/\/ define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the\n\/\/ printf_config.h header file\n\/\/ default: undefined\n#ifdef PRINTF_INCLUDE_CONFIG_H\n#include \"printf_config.h\"\n#endif\n\n\n\/\/ 'ntoa' conversion buffer size, this must be big enough to hold one converted\n\/\/ numeric number including padded zeros (dynamically created on stack)\n\/\/ default: 32 byte\n#ifndef PRINTF_NTOA_BUFFER_SIZE\n#define PRINTF_NTOA_BUFFER_SIZE    32U\n#endif\n\n\/\/ 'ftoa' conversion buffer size, this must be big enough to hold one converted\n\/\/ float number including padded zeros (dynamically created on stack)\n\/\/ default: 32 byte\n#ifndef PRINTF_FTOA_BUFFER_SIZE\n#define PRINTF_FTOA_BUFFER_SIZE    32U\n#endif\n\n\/\/ support for the floating point type (%f)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\n#define PRINTF_SUPPORT_FLOAT\n#endif\n\n\/\/ support for exponential floating point notation (%e\/%g)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\n#define PRINTF_SUPPORT_EXPONENTIAL\n#endif\n\n\/\/ define the default floating point precision\n\/\/ default: 6 digits\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\n#endif\n\n\/\/ define the largest float suitable to print with %f\n\/\/ default: 1e9\n#ifndef PRINTF_MAX_FLOAT\n#define PRINTF_MAX_FLOAT  1e9\n#endif\n\n\/\/ support for the long long types (%llu or %p)\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\n#define PRINTF_SUPPORT_LONG_LONG\n#endif\n\n\/\/ support for the ptrdiff_t type (%t)\n\/\/ ptrdiff_t is normally defined in <stddef.h> as long or long long type\n\/\/ default: activated\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\n#define PRINTF_SUPPORT_PTRDIFF_T\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ internal flag definitions\n#define FLAGS_ZEROPAD   (1U <<  0U)\n#define FLAGS_LEFT      (1U <<  1U)\n#define FLAGS_PLUS      (1U <<  2U)\n#define FLAGS_SPACE     (1U <<  3U)\n#define FLAGS_HASH      (1U <<  4U)\n#define FLAGS_UPPERCASE (1U <<  5U)\n#define FLAGS_CHAR      (1U <<  6U)\n#define FLAGS_SHORT     (1U <<  7U)\n#define FLAGS_LONG      (1U <<  8U)\n#define FLAGS_LONG_LONG (1U <<  9U)\n#define FLAGS_PRECISION (1U << 10U)\n#define FLAGS_ADAPT_EXP (1U << 11U)\n\n\n\/\/ import float.h for DBL_MAX\n#if defined(PRINTF_SUPPORT_FLOAT)\n#include <float.h>\n#endif\n\n\n\/\/ output function type\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\n\n\n\/\/ wrapper (used as buffer) for output function type\ntypedef struct {\n  void  (*fct)(char character, void* arg);\n  void* arg;\n} out_fct_wrap_type;\n\n\n\/\/ internal buffer output\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  if (idx < maxlen) {\n    ((char*)buffer)[idx] = character;\n  }\n}\n\n\n\/\/ internal null output\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)character; (void)buffer; (void)idx; (void)maxlen;\n}\n\n\n\/\/ internal _putchar wrapper\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)buffer; (void)idx; (void)maxlen;\n  if (character) {\n    _putchar(character);\n  }\n}\n\n\n\/\/ internal output function wrapper\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\n{\n  (void)idx; (void)maxlen;\n  if (character) {\n    \/\/ buffer is the output fct pointer\n    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\n  }\n}\n\n\n\/\/ internal secure strlen\n\/\/ \\return The length of the string (excluding the terminating 0) limited by 'maxsize'\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\n{\n  const char* s;\n  for (s = str; *s && maxsize--; ++s);\n  return (unsigned int)(s - str);\n}\n\n\n\/\/ internal test if char is a digit (0-9)\n\/\/ \\return true if char is a digit\nstatic inline bool _is_digit(char ch)\n{\n  return (ch >= '0') && (ch <= '9');\n}\n\n\n\/\/ internal ASCII string to unsigned int conversion\nstatic unsigned int _atoi(const char** str)\n{\n  unsigned int i = 0U;\n  while (_is_digit(**str)) {\n    i = i * 10U + (unsigned int)(*((*str)++) - '0');\n  }\n  return i;\n}\n\n\n\/\/ output the specified string in reverse, taking care of any zero-padding\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\n{\n  const size_t start_idx = idx;\n\n  \/\/ pad spaces up to given width\n  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\n    for (size_t i = len; i < width; i++) {\n      out(' ', buffer, idx++, maxlen);\n    }\n  }\n\n  \/\/ reverse string\n  while (len) {\n    out(buf[--len], buffer, idx++, maxlen);\n  }\n\n  \/\/ append pad spaces up to given width\n  if (flags & FLAGS_LEFT) {\n    while (idx - start_idx < width) {\n      out(' ', buffer, idx++, maxlen);\n    }\n  }\n\n  return idx;\n}\n\n\n\/\/ internal itoa format\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  \/\/ pad leading zeros\n  if (!(flags & FLAGS_LEFT)) {\n    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\n      width--;\n    }\n    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n  }\n\n  \/\/ handle hash\n  if (flags & FLAGS_HASH) {\n    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\n      len--;\n      if (len && (base == 16U)) {\n        len--;\n      }\n    }\n    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'x';\n    }\n    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'X';\n    }\n    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\n      buf[len++] = 'b';\n    }\n    if (len < PRINTF_NTOA_BUFFER_SIZE) {\n      buf[len++] = '0';\n    }\n  }\n\n  if (len < PRINTF_NTOA_BUFFER_SIZE) {\n    if (negative) {\n      buf[len++] = '-';\n    }\n    else if (flags & FLAGS_PLUS) {\n      buf[len++] = '+';  \/\/ ignore the space if the '+' exists\n    }\n    else if (flags & FLAGS_SPACE) {\n      buf[len++] = ' ';\n    }\n  }\n\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\n}\n\n\n\/\/ internal itoa for 'long' type\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\n  size_t len = 0U;\n\n  \/\/ no hash for 0 values\n  if (!value) {\n    flags &= ~FLAGS_HASH;\n  }\n\n  \/\/ write if precision != 0 and value is != 0\n  if (!(flags & FLAGS_PRECISION) || value) {\n    do {\n      const char digit = (char)(value % base);\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n      value \/= base;\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\n  }\n\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}\n\n\n\/\/ internal itoa for 'long long' type\n#if defined(PRINTF_SUPPORT_LONG_LONG)\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\n  size_t len = 0U;\n\n  \/\/ no hash for 0 values\n  if (!value) {\n    flags &= ~FLAGS_HASH;\n  }\n\n  \/\/ write if precision != 0 and value is != 0\n  if (!(flags & FLAGS_PRECISION) || value) {\n    do {\n      const char digit = (char)(value % base);\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\n      value \/= base;\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\n  }\n\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\n}\n#endif  \/\/ PRINTF_SUPPORT_LONG_LONG\n\n\n#if defined(PRINTF_SUPPORT_FLOAT)\n\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n\/\/ forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\n#endif\n\n\n\/\/ internal ftoa for fixed decimal floating point\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  char buf[PRINTF_FTOA_BUFFER_SIZE];\n  size_t len  = 0U;\n  double diff = 0.0;\n\n  \/\/ powers of 10\n  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\n  \/\/ test for special values\n  if (value != value)\n    return _out_rev(out, buffer, idx, maxlen, \"nan\", 3, width, flags);\n  if (value < -DBL_MAX)\n    return _out_rev(out, buffer, idx, maxlen, \"fni-\", 4, width, flags);\n  if (value > DBL_MAX)\n    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \"fni+\" : \"fni\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\n\n  \/\/ test for very large values\n  \/\/ standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad\n  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\n#else\n    return 0U;\n#endif\n  }\n\n  \/\/ test for negative\n  bool negative = false;\n  if (value < 0) {\n    negative = true;\n    value = 0 - value;\n  }\n\n  \/\/ set default precision, if not set explicitly\n  if (!(flags & FLAGS_PRECISION)) {\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\n  }\n  \/\/ limit precision to 9, cause a prec >= 10 can lead to overflow errors\n  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\n    buf[len++] = '0';\n    prec--;\n  }\n\n  int whole = (int)value;\n  double tmp = (value - whole) * pow10[prec];\n  unsigned long frac = (unsigned long)tmp;\n  diff = tmp - frac;\n\n  if (diff > 0.5) {\n    ++frac;\n    \/\/ handle rollover, e.g. case 0.99 with prec 1 is 1.0\n    if (frac >= pow10[prec]) {\n      frac = 0;\n      ++whole;\n    }\n  }\n  else if (diff < 0.5) {\n  }\n  else if ((frac == 0U) || (frac & 1U)) {\n    \/\/ if halfway, round up if odd OR if last digit is 0\n    ++frac;\n  }\n\n  if (prec == 0U) {\n    diff = value - (double)whole;\n    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\n      \/\/ exactly 0.5 and ODD, then round up\n      \/\/ 1.5 -> 2, but 2.5 -> 2\n      ++whole;\n    }\n  }\n  else {\n    unsigned int count = prec;\n    \/\/ now do fractional part, as an unsigned number\n    while (len < PRINTF_FTOA_BUFFER_SIZE) {\n      --count;\n      buf[len++] = (char)(48U + (frac % 10U));\n      if (!(frac \/= 10U)) {\n        break;\n      }\n    }\n    \/\/ add extra 0s\n    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\n      buf[len++] = '0';\n    }\n    if (len < PRINTF_FTOA_BUFFER_SIZE) {\n      \/\/ add decimal\n      buf[len++] = '.';\n    }\n  }\n\n  \/\/ do whole part, number is reversed\n  while (len < PRINTF_FTOA_BUFFER_SIZE) {\n    buf[len++] = (char)(48 + (whole % 10));\n    if (!(whole \/= 10)) {\n      break;\n    }\n  }\n\n  \/\/ pad leading zeros\n  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\n    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\n      width--;\n    }\n    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\n      buf[len++] = '0';\n    }\n  }\n\n  if (len < PRINTF_FTOA_BUFFER_SIZE) {\n    if (negative) {\n      buf[len++] = '-';\n    }\n    else if (flags & FLAGS_PLUS) {\n      buf[len++] = '+';  \/\/ ignore the space if the '+' exists\n    }\n    else if (flags & FLAGS_SPACE) {\n      buf[len++] = ' ';\n    }\n  }\n\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\n}\n\n\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n\/\/ internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\n{\n  \/\/ check for NaN and special values\n  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\n    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\n  }\n\n  \/\/ determine the sign\n  const bool negative = value < 0;\n  if (negative) {\n    value = -value;\n  }\n\n  \/\/ default precision\n  if (!(flags & FLAGS_PRECISION)) {\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\n  }\n\n  \/\/ determine the decimal exponent\n  \/\/ based on the algorithm by David Gay (https:\/\/www.ampl.com\/netlib\/fp\/dtoa.c)\n  union {\n    uint64_t U;\n    double   F;\n  } conv;\n\n  conv.F = value;\n  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           \/\/ effectively log2\n  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  \/\/ drop the exponent so conv.F is now in [1,2)\n  \/\/ now approximate log10 from the log2 integer part and an expansion of ln around 1.5\n  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\n  \/\/ now we want to compute 10^expval but we want to be sure it won't overflow\n  exp2 = (int)(expval * 3.321928094887362 + 0.5);\n  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\n  const double z2 = z * z;\n  conv.U = (uint64_t)(exp2 + 1023) << 52U;\n  \/\/ compute exp(z) using continued fractions, see https:\/\/en.wikipedia.org\/wiki\/Exponential_function#Continued_fractions_for_ex\n  conv.F *= 1 + 2 * z \/ (2 - z + (z2 \/ (6 + (z2 \/ (10 + z2 \/ 14)))));\n  \/\/ correct for rounding errors\n  if (value < conv.F) {\n    expval--;\n    conv.F \/= 10;\n  }\n\n  \/\/ the exponent format is \"%+03d\" and largest value is \"307\", so set aside 4-5 characters\n  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\n\n  \/\/ in \"%g\" mode, \"prec\" is the number of *significant figures* not decimals\n  if (flags & FLAGS_ADAPT_EXP) {\n    \/\/ do we want to fall-back to \"%f\" mode?\n    if ((value >= 1e-4) && (value < 1e6)) {\n      if ((int)prec > expval) {\n        prec = (unsigned)((int)prec - expval - 1);\n      }\n      else {\n        prec = 0;\n      }\n      flags |= FLAGS_PRECISION;   \/\/ make sure _ftoa respects precision\n      \/\/ no characters in exponent\n      minwidth = 0U;\n      expval   = 0;\n    }\n    else {\n      \/\/ we use one sigfig for the whole part\n      if ((prec > 0) && (flags & FLAGS_PRECISION)) {\n        --prec;\n      }\n    }\n  }\n\n  \/\/ will everything fit?\n  unsigned int fwidth = width;\n  if (width > minwidth) {\n    \/\/ we didn't fall-back so subtract the characters required for the exponent\n    fwidth -= minwidth;\n  } else {\n    \/\/ not enough characters, so go back to default sizing\n    fwidth = 0U;\n  }\n  if ((flags & FLAGS_LEFT) && minwidth) {\n    \/\/ if we're padding on the right, DON'T pad the floating part\n    fwidth = 0U;\n  }\n\n  \/\/ rescale the float value\n  if (expval) {\n    value \/= conv.F;\n  }\n\n  \/\/ output the floating part\n  const size_t start_idx = idx;\n  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\n\n  \/\/ output the exponent part\n  if (minwidth) {\n    \/\/ output the exponential symbol\n    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\n    \/\/ output the exponent value\n    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\n    \/\/ might need to right-pad spaces\n    if (flags & FLAGS_LEFT) {\n      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\n    }\n  }\n  return idx;\n}\n#endif  \/\/ PRINTF_SUPPORT_EXPONENTIAL\n#endif  \/\/ PRINTF_SUPPORT_FLOAT\n\n\n\/\/ internal vsnprintf\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\n{\n  unsigned int flags, width, precision, n;\n  size_t idx = 0U;\n\n  if (!buffer) {\n    \/\/ use null output function\n    out = _out_null;\n  }\n\n  while (*format)\n  {\n    \/\/ format specifier?  %[flags][width][.precision][length]\n    if (*format != '%') {\n      \/\/ no\n      out(*format, buffer, idx++, maxlen);\n      format++;\n      continue;\n    }\n    else {\n      \/\/ yes, evaluate it\n      format++;\n    }\n\n    \/\/ evaluate flags\n    flags = 0U;\n    do {\n      switch (*format) {\n        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\n        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\n        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\n        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\n        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\n        default :                                   n = 0U; break;\n      }\n    } while (n);\n\n    \/\/ evaluate width field\n    width = 0U;\n    if (_is_digit(*format)) {\n      width = _atoi(&format);\n    }\n    else if (*format == '*') {\n      const int w = va_arg(va, int);\n      if (w < 0) {\n        flags |= FLAGS_LEFT;    \/\/ reverse padding\n        width = (unsigned int)-w;\n      }\n      else {\n        width = (unsigned int)w;\n      }\n      format++;\n    }\n\n    \/\/ evaluate precision field\n    precision = 0U;\n    if (*format == '.') {\n      flags |= FLAGS_PRECISION;\n      format++;\n      if (_is_digit(*format)) {\n        precision = _atoi(&format);\n      }\n      else if (*format == '*') {\n        const int prec = (int)va_arg(va, int);\n        precision = prec > 0 ? (unsigned int)prec : 0U;\n        format++;\n      }\n    }\n\n    \/\/ evaluate length field\n    switch (*format) {\n      case 'l' :\n        flags |= FLAGS_LONG;\n        format++;\n        if (*format == 'l') {\n          flags |= FLAGS_LONG_LONG;\n          format++;\n        }\n        break;\n      case 'h' :\n        flags |= FLAGS_SHORT;\n        format++;\n        if (*format == 'h') {\n          flags |= FLAGS_CHAR;\n          format++;\n        }\n        break;\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\n      case 't' :\n        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n#endif\n      case 'j' :\n        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n      case 'z' :\n        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\n        format++;\n        break;\n      default :\n        break;\n    }\n\n    \/\/ evaluate specifier\n    switch (*format) {\n      case 'd' :\n      case 'i' :\n      case 'u' :\n      case 'x' :\n      case 'X' :\n      case 'o' :\n      case 'b' : {\n        \/\/ set the base\n        unsigned int base;\n        if (*format == 'x' || *format == 'X') {\n          base = 16U;\n        }\n        else if (*format == 'o') {\n          base =  8U;\n        }\n        else if (*format == 'b') {\n          base =  2U;\n        }\n        else {\n          base = 10U;\n          flags &= ~FLAGS_HASH;   \/\/ no hash for dec format\n        }\n        \/\/ uppercase\n        if (*format == 'X') {\n          flags |= FLAGS_UPPERCASE;\n        }\n\n        \/\/ no plus or space flag for u, x, X, o, b\n        if ((*format != 'i') && (*format != 'd')) {\n          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);\n        }\n\n        \/\/ ignore '0' flag when precision is given\n        if (flags & FLAGS_PRECISION) {\n          flags &= ~FLAGS_ZEROPAD;\n        }\n\n        \/\/ convert the integer\n        if ((*format == 'i') || (*format == 'd')) {\n          \/\/ signed\n          if (flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n            const long long value = va_arg(va, long long);\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n#endif\n          }\n          else if (flags & FLAGS_LONG) {\n            const long value = va_arg(va, long);\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n          }\n          else {\n            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\n          }\n        }\n        else {\n          \/\/ unsigned\n          if (flags & FLAGS_LONG_LONG) {\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\n#endif\n          }\n          else if (flags & FLAGS_LONG) {\n            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\n          }\n          else {\n            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\n            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\n          }\n        }\n        format++;\n        break;\n      }\n#if defined(PRINTF_SUPPORT_FLOAT)\n      case 'f' :\n      case 'F' :\n        if (*format == 'F') flags |= FLAGS_UPPERCASE;\n        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n        format++;\n        break;\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\n      case 'e':\n      case 'E':\n      case 'g':\n      case 'G':\n        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\n        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\n        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\n        format++;\n        break;\n#endif  \/\/ PRINTF_SUPPORT_EXPONENTIAL\n#endif  \/\/ PRINTF_SUPPORT_FLOAT\n      case 'c' : {\n        unsigned int l = 1U;\n        \/\/ pre padding\n        if (!(flags & FLAGS_LEFT)) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        \/\/ char output\n        out((char)va_arg(va, int), buffer, idx++, maxlen);\n        \/\/ post padding\n        if (flags & FLAGS_LEFT) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        format++;\n        break;\n      }\n\n      case 's' : {\n        const char* p = va_arg(va, char*);\n        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\n        \/\/ pre padding\n        if (flags & FLAGS_PRECISION) {\n          l = (l < precision ? l : precision);\n        }\n        if (!(flags & FLAGS_LEFT)) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        \/\/ string output\n        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\n          out(*(p++), buffer, idx++, maxlen);\n        }\n        \/\/ post padding\n        if (flags & FLAGS_LEFT) {\n          while (l++ < width) {\n            out(' ', buffer, idx++, maxlen);\n          }\n        }\n        format++;\n        break;\n      }\n\n      case 'p' : {\n        width = sizeof(void*) * 2U;\n        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);\n        if (is_ll) {\n          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\n        }\n        else {\n#endif\n          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\n#if defined(PRINTF_SUPPORT_LONG_LONG)\n        }\n#endif\n        format++;\n        break;\n      }\n\n      case '%' :\n        out('%', buffer, idx++, maxlen);\n        format++;\n        break;\n\n      default :\n        out(*format, buffer, idx++, maxlen);\n        format++;\n        break;\n    }\n  }\n\n  \/\/ termination\n  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\n\n  \/\/ return written chars without terminating \\0\n  return (int)idx;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nint printf_(const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  char buffer[1];\n  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint sprintf_(char* buffer, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint snprintf_(char* buffer, size_t count, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\n  va_end(va);\n  return ret;\n}\n\n\nint vprintf_(const char* format, va_list va)\n{\n  char buffer[1];\n  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\n}\n\n\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\n{\n  return _vsnprintf(_out_buffer, buffer, count, format, va);\n}\n\n\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\n{\n  va_list va;\n  va_start(va, format);\n  const out_fct_wrap_type out_fct_wrap = { out, arg };\n  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\n  va_end(va);\n  return ret;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/include\/util.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2021, Breakaway Consulting Pty. Ltd.\n * Copyright 2022, UNSW (ABN 57 195 873 179)\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\/\n\n#pragma once\n\n#include <stdint.h>\n#include <microkit.h>\n#include \"printf.h\"\n\n\/\/ @ivanv: these are here for convience, should not be here though\n#define GUEST_ID 0\n#define GUEST_VCPU_ID 0\n#define GUEST_NUM_VCPUS 1\n\/\/ Note that this is AArch64 specific\n#if defined(CONFIG_ARCH_AARCH64)\n    #define SEL4_USER_CONTEXT_SIZE 0x24\n#endif\n\n#define PAGE_SIZE_4K 4096\n\n#define ARRAY_SIZE(x) (sizeof(x)\/sizeof((x)[0]))\n\n#define CTZ(x) __builtin_ctz(x)\n\n#if __STDC_VERSION__ >= 201112L && !defined(__cplusplus)\n#define static_assert _Static_assert\n#endif\n\n\/\/  __attribute__ ((__noreturn__))\n\/\/ void __assert_func(const char *file, int line, const char *function, const char *str);\n\nvoid _putchar(char character);\n\n#define LOG_VMM(...) do{ printf(\"%s|INFO: \", microkit_name); printf(__VA_ARGS__); }while(0)\n#define LOG_VMM_ERR(...) do{ printf(\"%s|ERROR: \", microkit_name); printf(__VA_ARGS__); }while(0)\n\nstatic char\ndecchar(unsigned int v) {\n    return '0' + v;\n}\n\nstatic void\nput8(uint8_t x)\n{\n    char tmp[4];\n    unsigned i = 3;\n    tmp[3] = 0;\n    do {\n        uint8_t c = x % 10;\n        tmp[--i] = decchar(c);\n        x \/= 10;\n    } while (x);\n    microkit_dbg_puts(&tmp[i]);\n}\n\n\/\/ @ivanv: sort this out...\nstatic void\nreply_to_fault()\n{\n    microkit_msginfo msg = microkit_msginfo_new(0, 0);\n    seL4_Send(4, msg);\n}\n\nstatic uint64_t get_vmm_id(char *microkit_name)\n{\n    \/\/ @ivanv: Absolute hack\n    return microkit_name[4] - '0';\n}\n\nstatic void\nprint_tcb_regs(seL4_UserContext *ctx) {\n#if defined(ARCH_aarch64)\n    \/\/ I don't know if it's the best idea, but here we'll just dump the\n    \/\/ registers in the same order they are defined in seL4_UserContext\n    printf(\"VMM|INFO: TCB registers:\\n\");\n    \/\/ Frame registers\n    printf(\"    pc:   0x%016lx\\n\", ctx->pc);\n    printf(\"    sp:   0x%016lx\\n\", ctx->sp);\n    printf(\"    spsr: 0x%016lx\\n\", ctx->spsr);\n    printf(\"    x0:   0x%016lx\\n\", ctx->x0);\n    printf(\"    x1:   0x%016lx\\n\", ctx->x1);\n    printf(\"    x2:   0x%016lx\\n\", ctx->x2);\n    printf(\"    x3:   0x%016lx\\n\", ctx->x3);\n    printf(\"    x4:   0x%016lx\\n\", ctx->x4);\n    printf(\"    x5:   0x%016lx\\n\", ctx->x5);\n    printf(\"    x6:   0x%016lx\\n\", ctx->x6);\n    printf(\"    x7:   0x%016lx\\n\", ctx->x7);\n    printf(\"    x8:   0x%016lx\\n\", ctx->x8);\n    printf(\"    x16:  0x%016lx\\n\", ctx->x16);\n    printf(\"    x17:  0x%016lx\\n\", ctx->x17);\n    printf(\"    x18:  0x%016lx\\n\", ctx->x18);\n    printf(\"    x29:  0x%016lx\\n\", ctx->x29);\n    printf(\"    x30:  0x%016lx\\n\", ctx->x30);\n    \/\/ Other integer registers\n    printf(\"    x9:   0x%016lx\\n\", ctx->x9);\n    printf(\"    x10:  0x%016lx\\n\", ctx->x10);\n    printf(\"    x11:  0x%016lx\\n\", ctx->x11);\n    printf(\"    x12:  0x%016lx\\n\", ctx->x12);\n    printf(\"    x13:  0x%016lx\\n\", ctx->x13);\n    printf(\"    x14:  0x%016lx\\n\", ctx->x14);\n    printf(\"    x15:  0x%016lx\\n\", ctx->x15);\n    printf(\"    x19:  0x%016lx\\n\", ctx->x19);\n    printf(\"    x20:  0x%016lx\\n\", ctx->x20);\n    printf(\"    x21:  0x%016lx\\n\", ctx->x21);\n    printf(\"    x22:  0x%016lx\\n\", ctx->x22);\n    printf(\"    x23:  0x%016lx\\n\", ctx->x23);\n    printf(\"    x24:  0x%016lx\\n\", ctx->x24);\n    printf(\"    x25:  0x%016lx\\n\", ctx->x25);\n    printf(\"    x26:  0x%016lx\\n\", ctx->x26);\n    printf(\"    x27:  0x%016lx\\n\", ctx->x27);\n    printf(\"    x28:  0x%016lx\\n\", ctx->x28);\n    \/\/ TODO(ivanv): print out thread ID registers?\n#endif\n}\n\nvoid *memcpy(void *restrict dest, const void *restrict src, size_t n);\nvoid *memset(void *dest, int c, size_t n);\n\nstatic void assert_fail(\n    const char  *assertion,\n    const char  *file,\n    unsigned int line,\n    const char  *function)\n{\n    printf(\"Failed assertion '%s' at %s:%u in function %s\\n\", assertion, file, line, function);\n    while (1) {}\n}\n\n#define assert(expr) \\\n    do { \\\n        if (!(expr)) { \\\n            assert_fail(#expr, __FILE__, __LINE__, __FUNCTION__); \\\n        } \\\n    } while(0)\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/util\/src\/util.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2022, UNSW (ABN 57 195 873 179)\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\/\n\n#include \"util.h\"\n\n\/* This is required to use the printf library we brought in, it is\n   simply for convenience since there's a lot of logging\/debug printing\n   in the VMM. *\/\nvoid _putchar(char character)\n{\n    microkit_dbg_putc(character);\n}\n\n __attribute__ ((__noreturn__))\nvoid __assert_func(const char *file, int line, const char *function, const char *str)\n{\n    microkit_dbg_puts(\"assert failed: \");\n    microkit_dbg_puts(str);\n    microkit_dbg_puts(\" \");\n    microkit_dbg_puts(file);\n    microkit_dbg_puts(\" \");\n    microkit_dbg_puts(function);\n    microkit_dbg_puts(\"\\n\");\n    while (1) {}\n}\n\nvoid *memcpy(void *restrict dest, const void *restrict src, size_t n)\n{\n    unsigned char *d = dest;\n    const unsigned char *s = src;\n    for (; n; n--) *d++ = *s++;\n    return dest;\n}\n\nvoid *memset(void *dest, int c, size_t n)\n{\n    unsigned char *s = dest;\n    for (; n; n--, s++) *s = c;\n    return dest;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/ValueStatus.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum ValueStatus {\n    pub Valid = 0,\n    pub Invalid = 1,\n  }\n\n  impl Default for ValueStatus {\n    fn default() -> Self\n    {\n      ValueStatus::Valid\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/Regulator_Mode.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum Regulator_Mode {\n    pub Init_Regulator_Mode = 0,\n    pub Normal_Regulator_Mode = 1,\n    pub Failed_Regulator_Mode = 2,\n  }\n\n  impl Default for Regulator_Mode {\n    fn default() -> Self\n    {\n      Regulator_Mode::Init_Regulator_Mode\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/Status.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum Status {\n    pub Init_Status = 0,\n    pub On_Status = 1,\n    pub Failed_Status = 2,\n  }\n\n  impl Default for Status {\n    fn default() -> Self\n    {\n      Status::Init_Status\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/On_Off.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum On_Off {\n    pub Onn = 0,\n    pub Off = 1,\n  }\n\n  impl Default for On_Off {\n    fn default() -> Self\n    {\n      On_Off::Onn\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/Monitor_Mode.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum Monitor_Mode {\n    pub Init_Monitor_Mode = 0,\n    pub Normal_Monitor_Mode = 1,\n    pub Failed_Monitor_Mode = 2,\n  }\n\n  impl Default for Monitor_Mode {\n    fn default() -> Self\n    {\n      Monitor_Mode::Init_Monitor_Mode\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Environment\/Heat.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n  pub enum Heat {\n    pub Dummy_Head_Enum = 0,\n  }\n\n  impl Default for Heat {\n    fn default() -> Self\n    {\n      Heat::Dummy_Head_Enum\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/Temp_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct Temp_i {\n    pub degrees: i32\n  }\n\n  impl Default for Temp_i {\n    fn default() -> Self\n    {\n      Self { degrees: 0 }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/PhysicalTemp_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct PhysicalTemp_i {\n    pub degrees: i32\n  }\n\n  impl Default for PhysicalTemp_i {\n    fn default() -> Self\n    {\n      Self { degrees: 0 }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/TempWstatus_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct TempWstatus_i {\n    pub degrees: i32,\n    pub status: ValueStatus\n  }\n\n  impl Default for TempWstatus_i {\n    fn default() -> Self\n    {\n      Self { degrees: 0, status: Isolette_Data_Model::ValueStatus::default() }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/Failure_Flag_i.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\n\nuse super::*;\n\nverus! {\n  #[repr(C)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n  pub struct Failure_Flag_i {\n    pub flag: bool\n  }\n\n  impl Default for Failure_Flag_i {\n    fn default() -> Self\n    {\n      Self { flag: false }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Data_Model\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ninclude!(\"ValueStatus.rs\");\ninclude!(\"Regulator_Mode.rs\");\ninclude!(\"Status.rs\");\ninclude!(\"On_Off.rs\");\ninclude!(\"Monitor_Mode.rs\");\ninclude!(\"Temp_i.rs\");\ninclude!(\"PhysicalTemp_i.rs\");\ninclude!(\"TempWstatus_i.rs\");\ninclude!(\"Failure_Flag_i.rs\");\n\n\/*\nNOTE: the include!(\"xx.rs\") inlines the file contents directly so a module for\nxx is not created.  An alternative would be to do\n\npub mod xx.rs;\npub use xx::*;\n\nhowever this would create a module out of xx.rs so to refer to the datatype\nit contains you'd have to do something like \"use data::xx::xx\"\nin lib.rs. A workaround is to rename the file, e.g. xx_STRUCT.rs but leave the\nfile contents unchanged.  Then in this file do\n\npub mod xx_STRUCT;\npub use xx_STRUCT::*;\n\nthen xx would be imported in lib.rs via \"use data::Isolette_Data_Model::*\"\n*\/\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/Isolette_Environment\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\ninclude!(\"Heat.rs\");\n\n\/*\nNOTE: the include!(\"xx.rs\") inlines the file contents directly so a module for\nxx is not created.  An alternative would be to do\n\npub mod xx.rs;\npub use xx::*;\n\nhowever this would create a module out of xx.rs so to refer to the datatype\nit contains you'd have to do something like \"use data::xx::xx\"\nin lib.rs. A workaround is to rename the file, e.g. xx_STRUCT.rs but leave the\nfile contents unchanged.  Then in this file do\n\npub mod xx_STRUCT;\npub use xx_STRUCT::*;\n\nthen xx would be imported in lib.rs via \"use data::Isolette_Environment::*\"\n*\/\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/sb_event_counter.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub type sb_event_counter_t = usize;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/sb_microkit_types.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub type microkit_channel = u32;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod Isolette_Data_Model;\npub mod Isolette_Environment;\n\ninclude!(\"sb_event_counter.rs\");\ninclude!(\"sb_microkit_types.rs\");\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"data\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/data\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool;\n  fn put_upper_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn put_lower_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn put_displayed_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn put_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool;\n  fn put_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n}\n\npub fn unsafe_get_upper_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_upper_desired_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_lower_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_lower_desired_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_regulator_mode() -> Isolette_Data_Model::Regulator_Mode\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Regulator_Mode = &mut Isolette_Data_Model::Regulator_Mode::default();\n    get_regulator_mode(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_upper_desired_temp(value: &Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    return put_upper_desired_temp(value as *const Isolette_Data_Model::Temp_i as *mut Isolette_Data_Model::Temp_i);\n  }\n}\n\npub fn unsafe_put_lower_desired_temp(value: &Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    return put_lower_desired_temp(value as *const Isolette_Data_Model::Temp_i as *mut Isolette_Data_Model::Temp_i);\n  }\n}\n\npub fn unsafe_put_displayed_temp(value: &Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    return put_displayed_temp(value as *const Isolette_Data_Model::Temp_i as *mut Isolette_Data_Model::Temp_i);\n  }\n}\n\npub fn unsafe_put_regulator_status(value: &Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    return put_regulator_status(value as *const Isolette_Data_Model::Status as *mut Isolette_Data_Model::Status);\n  }\n}\n\npub fn unsafe_put_interface_failure(value: &Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    return put_interface_failure(value as *const Isolette_Data_Model::Failure_Flag_i as *mut Isolette_Data_Model::Failure_Flag_i);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_upper_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_lower_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_regulator_mode: Mutex<Option<Isolette_Data_Model::Regulator_Mode>> = Mutex::new(None);\n  pub static ref OUT_upper_desired_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref OUT_lower_desired_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref OUT_displayed_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref OUT_regulator_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);\n  pub static ref OUT_interface_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_upper_desired_tempWstatus.lock().unwrap() = None;\n    *IN_lower_desired_tempWstatus.lock().unwrap() = None;\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_regulator_mode.lock().unwrap() = None;\n    *OUT_upper_desired_temp.lock().unwrap() = None;\n    *OUT_lower_desired_temp.lock().unwrap() = None;\n    *OUT_displayed_temp.lock().unwrap() = None;\n    *OUT_regulator_status.lock().unwrap() = None;\n    *OUT_interface_failure.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_upper_desired_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_lower_desired_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  unsafe {\n    *value = IN_regulator_mode.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_upper_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *OUT_upper_desired_temp.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_lower_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *OUT_lower_desired_temp.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_displayed_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *OUT_displayed_temp.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    *OUT_regulator_status.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *OUT_interface_failure.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/bridge\/thermostat_rt_mri_mri_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_rt_mri_mri_Api {}\n\n  pub trait thermostat_rt_mri_mri_Put_Api: thermostat_rt_mri_mri_Api {\n    #[verifier::external_body]\n    fn unverified_put_upper_desired_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n    {\n      extern_api::unsafe_put_upper_desired_temp(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_lower_desired_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n    {\n      extern_api::unsafe_put_lower_desired_temp(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_displayed_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n    {\n      extern_api::unsafe_put_displayed_temp(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_regulator_status(\n      &mut self,\n      value: Isolette_Data_Model::Status)\n    {\n      extern_api::unsafe_put_regulator_status(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_interface_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n    {\n      extern_api::unsafe_put_interface_failure(&value);\n    }\n  }\n\n  pub trait thermostat_rt_mri_mri_Get_Api: thermostat_rt_mri_mri_Api {\n    #[verifier::external_body]\n    fn unverified_get_upper_desired_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_upper_desired_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_lower_desired_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_lower_desired_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_regulator_mode(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Regulator_Mode>) -> (res : Isolette_Data_Model::Regulator_Mode)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_regulator_mode();\n    }\n  }\n\n  pub trait thermostat_rt_mri_mri_Full_Api: thermostat_rt_mri_mri_Put_Api + thermostat_rt_mri_mri_Get_Api {}\n\n  pub struct thermostat_rt_mri_mri_Application_Api<API: thermostat_rt_mri_mri_Api> {\n    pub api: API,\n\n    pub ghost upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost regulator_mode: Isolette_Data_Model::Regulator_Mode,\n    pub ghost upper_desired_temp: Isolette_Data_Model::Temp_i,\n    pub ghost lower_desired_temp: Isolette_Data_Model::Temp_i,\n    pub ghost displayed_temp: Isolette_Data_Model::Temp_i,\n    pub ghost regulator_status: Isolette_Data_Model::Status,\n    pub ghost interface_failure: Isolette_Data_Model::Failure_Flag_i\n  }\n\n  impl<API: thermostat_rt_mri_mri_Put_Api> thermostat_rt_mri_mri_Application_Api<API> {\n    pub fn put_upper_desired_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        self.upper_desired_temp == value,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_upper_desired_temp(value);\n      self.upper_desired_temp = value;\n    }\n    pub fn put_lower_desired_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        self.lower_desired_temp == value,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_lower_desired_temp(value);\n      self.lower_desired_temp = value;\n    }\n    pub fn put_displayed_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        self.displayed_temp == value,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_displayed_temp(value);\n      self.displayed_temp = value;\n    }\n    pub fn put_regulator_status(\n      &mut self,\n      value: Isolette_Data_Model::Status)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        self.regulator_status == value,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_regulator_status(value);\n      self.regulator_status = value;\n    }\n    pub fn put_interface_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        self.interface_failure == value,\n    {\n      self.api.unverified_put_interface_failure(value);\n      self.interface_failure = value;\n    }\n  }\n\n  impl<API: thermostat_rt_mri_mri_Get_Api> thermostat_rt_mri_mri_Application_Api<API> {\n    pub fn get_upper_desired_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        res == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_upper_desired_tempWstatus(&Ghost(self.upper_desired_tempWstatus))\n    }\n    pub fn get_lower_desired_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        res == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_lower_desired_tempWstatus(&Ghost(self.lower_desired_tempWstatus))\n    }\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_regulator_mode(&mut self) -> (res : Isolette_Data_Model::Regulator_Mode)\n      ensures\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).regulator_mode == self.regulator_mode,\n        res == self.regulator_mode,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).displayed_temp == self.displayed_temp,\n        old(self).regulator_status == self.regulator_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_regulator_mode(&Ghost(self.regulator_mode))\n    }\n  }\n\n  pub struct thermostat_rt_mri_mri_Initialization_Api;\n  impl thermostat_rt_mri_mri_Api for thermostat_rt_mri_mri_Initialization_Api {}\n  impl thermostat_rt_mri_mri_Put_Api for thermostat_rt_mri_mri_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_rt_mri_mri_Application_Api<thermostat_rt_mri_mri_Initialization_Api> {\n    return thermostat_rt_mri_mri_Application_Api {\n      api: thermostat_rt_mri_mri_Initialization_Api {},\n\n      upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n      upper_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      lower_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      displayed_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      regulator_status: Isolette_Data_Model::Status::Init_Status,\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n\n  pub struct thermostat_rt_mri_mri_Compute_Api;\n  impl thermostat_rt_mri_mri_Api for thermostat_rt_mri_mri_Compute_Api {}\n  impl thermostat_rt_mri_mri_Put_Api for thermostat_rt_mri_mri_Compute_Api {}\n  impl thermostat_rt_mri_mri_Get_Api for thermostat_rt_mri_mri_Compute_Api {}\n  impl thermostat_rt_mri_mri_Full_Api for thermostat_rt_mri_mri_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_rt_mri_mri_Application_Api<thermostat_rt_mri_mri_Compute_Api> {\n    return thermostat_rt_mri_mri_Application_Api {\n      api: thermostat_rt_mri_mri_Compute_Api {},\n\n      upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n      upper_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      lower_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      displayed_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      regulator_status: Isolette_Data_Model::Status::Init_Status,\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_rt_mri_mri_api;\npub mod thermostat_rt_mri_mri_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_lower_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn get_upper_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool;\n  fn put_heat_control(value: *mut Isolette_Data_Model::On_Off) -> bool;\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_lower_desired_temp() -> Isolette_Data_Model::Temp_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();\n    get_lower_desired_temp(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_upper_desired_temp() -> Isolette_Data_Model::Temp_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();\n    get_upper_desired_temp(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_regulator_mode() -> Isolette_Data_Model::Regulator_Mode\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Regulator_Mode = &mut Isolette_Data_Model::Regulator_Mode::default();\n    get_regulator_mode(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_heat_control(value: &Isolette_Data_Model::On_Off) -> bool\n{\n  unsafe {\n    return put_heat_control(value as *const Isolette_Data_Model::On_Off as *mut Isolette_Data_Model::On_Off);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_lower_desired_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref IN_upper_desired_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref IN_regulator_mode: Mutex<Option<Isolette_Data_Model::Regulator_Mode>> = Mutex::new(None);\n  pub static ref OUT_heat_control: Mutex<Option<Isolette_Data_Model::On_Off>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_lower_desired_temp.lock().unwrap() = None;\n    *IN_upper_desired_temp.lock().unwrap() = None;\n    *IN_regulator_mode.lock().unwrap() = None;\n    *OUT_heat_control.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_lower_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *value = IN_lower_desired_temp.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_upper_desired_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *value = IN_upper_desired_temp.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  unsafe {\n    *value = IN_regulator_mode.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_heat_control(value: *mut Isolette_Data_Model::On_Off) -> bool\n{\n  unsafe {\n    *OUT_heat_control.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/bridge\/thermostat_rt_mhs_mhs_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_rt_mhs_mhs_Api {}\n\n  pub trait thermostat_rt_mhs_mhs_Put_Api: thermostat_rt_mhs_mhs_Api {\n    #[verifier::external_body]\n    fn unverified_put_heat_control(\n      &mut self,\n      value: Isolette_Data_Model::On_Off)\n    {\n      extern_api::unsafe_put_heat_control(&value);\n    }\n  }\n\n  pub trait thermostat_rt_mhs_mhs_Get_Api: thermostat_rt_mhs_mhs_Api {\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_lower_desired_temp(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Temp_i>) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_lower_desired_temp();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_upper_desired_temp(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Temp_i>) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_upper_desired_temp();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_regulator_mode(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Regulator_Mode>) -> (res : Isolette_Data_Model::Regulator_Mode)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_regulator_mode();\n    }\n  }\n\n  pub trait thermostat_rt_mhs_mhs_Full_Api: thermostat_rt_mhs_mhs_Put_Api + thermostat_rt_mhs_mhs_Get_Api {}\n\n  pub struct thermostat_rt_mhs_mhs_Application_Api<API: thermostat_rt_mhs_mhs_Api> {\n    pub api: API,\n\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost lower_desired_temp: Isolette_Data_Model::Temp_i,\n    pub ghost upper_desired_temp: Isolette_Data_Model::Temp_i,\n    pub ghost regulator_mode: Isolette_Data_Model::Regulator_Mode,\n    pub ghost heat_control: Isolette_Data_Model::On_Off\n  }\n\n  impl<API: thermostat_rt_mhs_mhs_Put_Api> thermostat_rt_mhs_mhs_Application_Api<API> {\n    pub fn put_heat_control(\n      &mut self,\n      value: Isolette_Data_Model::On_Off)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).regulator_mode == self.regulator_mode,\n        self.heat_control == value,\n    {\n      self.api.unverified_put_heat_control(value);\n      self.heat_control = value;\n    }\n  }\n\n  impl<API: thermostat_rt_mhs_mhs_Get_Api> thermostat_rt_mhs_mhs_Application_Api<API> {\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).heat_control == self.heat_control,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_lower_desired_temp(&mut self) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        res == self.lower_desired_temp,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).heat_control == self.heat_control,\n    {\n      self.api.unverified_get_lower_desired_temp(&Ghost(self.lower_desired_temp))\n    }\n    pub fn get_upper_desired_temp(&mut self) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        res == self.upper_desired_temp,\n        old(self).regulator_mode == self.regulator_mode,\n        old(self).heat_control == self.heat_control,\n    {\n      self.api.unverified_get_upper_desired_temp(&Ghost(self.upper_desired_temp))\n    }\n    pub fn get_regulator_mode(&mut self) -> (res : Isolette_Data_Model::Regulator_Mode)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_desired_temp == self.lower_desired_temp,\n        old(self).upper_desired_temp == self.upper_desired_temp,\n        old(self).regulator_mode == self.regulator_mode,\n        res == self.regulator_mode,\n        old(self).heat_control == self.heat_control,\n    {\n      self.api.unverified_get_regulator_mode(&Ghost(self.regulator_mode))\n    }\n  }\n\n  pub struct thermostat_rt_mhs_mhs_Initialization_Api;\n  impl thermostat_rt_mhs_mhs_Api for thermostat_rt_mhs_mhs_Initialization_Api {}\n  impl thermostat_rt_mhs_mhs_Put_Api for thermostat_rt_mhs_mhs_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_rt_mhs_mhs_Application_Api<thermostat_rt_mhs_mhs_Initialization_Api> {\n    return thermostat_rt_mhs_mhs_Application_Api {\n      api: thermostat_rt_mhs_mhs_Initialization_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      upper_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n      heat_control: Isolette_Data_Model::On_Off::Onn\n    }\n  }\n\n  pub struct thermostat_rt_mhs_mhs_Compute_Api;\n  impl thermostat_rt_mhs_mhs_Api for thermostat_rt_mhs_mhs_Compute_Api {}\n  impl thermostat_rt_mhs_mhs_Put_Api for thermostat_rt_mhs_mhs_Compute_Api {}\n  impl thermostat_rt_mhs_mhs_Get_Api for thermostat_rt_mhs_mhs_Compute_Api {}\n  impl thermostat_rt_mhs_mhs_Full_Api for thermostat_rt_mhs_mhs_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_rt_mhs_mhs_Application_Api<thermostat_rt_mhs_mhs_Compute_Api> {\n    return thermostat_rt_mhs_mhs_Application_Api {\n      api: thermostat_rt_mhs_mhs_Compute_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      upper_desired_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n      heat_control: Isolette_Data_Model::On_Off::Onn\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_rt_mhs_mhs_api;\npub mod thermostat_rt_mhs_mhs_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n  fn get_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n  fn put_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool;\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_interface_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();\n    get_interface_failure(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_internal_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();\n    get_internal_failure(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_regulator_mode(value: &Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  unsafe {\n    return put_regulator_mode(value as *const Isolette_Data_Model::Regulator_Mode as *mut Isolette_Data_Model::Regulator_Mode);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_interface_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n  pub static ref IN_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n  pub static ref OUT_regulator_mode: Mutex<Option<Isolette_Data_Model::Regulator_Mode>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_interface_failure.lock().unwrap() = None;\n    *IN_internal_failure.lock().unwrap() = None;\n    *OUT_regulator_mode.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *value = IN_interface_failure.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *value = IN_internal_failure.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  unsafe {\n    *OUT_regulator_mode.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/bridge\/thermostat_rt_mrm_mrm_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_rt_mrm_mrm_Api {}\n\n  pub trait thermostat_rt_mrm_mrm_Put_Api: thermostat_rt_mrm_mrm_Api {\n    #[verifier::external_body]\n    fn unverified_put_regulator_mode(\n      &mut self,\n      value: Isolette_Data_Model::Regulator_Mode)\n    {\n      extern_api::unsafe_put_regulator_mode(&value);\n    }\n  }\n\n  pub trait thermostat_rt_mrm_mrm_Get_Api: thermostat_rt_mrm_mrm_Api {\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_interface_failure(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Failure_Flag_i>) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_interface_failure();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_internal_failure(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Failure_Flag_i>) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_internal_failure();\n    }\n  }\n\n  pub trait thermostat_rt_mrm_mrm_Full_Api: thermostat_rt_mrm_mrm_Put_Api + thermostat_rt_mrm_mrm_Get_Api {}\n\n  pub struct thermostat_rt_mrm_mrm_Application_Api<API: thermostat_rt_mrm_mrm_Api> {\n    pub api: API,\n\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost interface_failure: Isolette_Data_Model::Failure_Flag_i,\n    pub ghost internal_failure: Isolette_Data_Model::Failure_Flag_i,\n    pub ghost regulator_mode: Isolette_Data_Model::Regulator_Mode\n  }\n\n  impl<API: thermostat_rt_mrm_mrm_Put_Api> thermostat_rt_mrm_mrm_Application_Api<API> {\n    pub fn put_regulator_mode(\n      &mut self,\n      value: Isolette_Data_Model::Regulator_Mode)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        self.regulator_mode == value,\n    {\n      self.api.unverified_put_regulator_mode(value);\n      self.regulator_mode = value;\n    }\n  }\n\n  impl<API: thermostat_rt_mrm_mrm_Get_Api> thermostat_rt_mrm_mrm_Application_Api<API> {\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        old(self).regulator_mode == self.regulator_mode,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_interface_failure(&mut self) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        res == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        old(self).regulator_mode == self.regulator_mode,\n    {\n      self.api.unverified_get_interface_failure(&Ghost(self.interface_failure))\n    }\n    pub fn get_internal_failure(&mut self) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        res == self.internal_failure,\n        old(self).regulator_mode == self.regulator_mode,\n    {\n      self.api.unverified_get_internal_failure(&Ghost(self.internal_failure))\n    }\n  }\n\n  pub struct thermostat_rt_mrm_mrm_Initialization_Api;\n  impl thermostat_rt_mrm_mrm_Api for thermostat_rt_mrm_mrm_Initialization_Api {}\n  impl thermostat_rt_mrm_mrm_Put_Api for thermostat_rt_mrm_mrm_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_rt_mrm_mrm_Application_Api<thermostat_rt_mrm_mrm_Initialization_Api> {\n    return thermostat_rt_mrm_mrm_Application_Api {\n      api: thermostat_rt_mrm_mrm_Initialization_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode\n    }\n  }\n\n  pub struct thermostat_rt_mrm_mrm_Compute_Api;\n  impl thermostat_rt_mrm_mrm_Api for thermostat_rt_mrm_mrm_Compute_Api {}\n  impl thermostat_rt_mrm_mrm_Put_Api for thermostat_rt_mrm_mrm_Compute_Api {}\n  impl thermostat_rt_mrm_mrm_Get_Api for thermostat_rt_mrm_mrm_Compute_Api {}\n  impl thermostat_rt_mrm_mrm_Full_Api for thermostat_rt_mrm_mrm_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_rt_mrm_mrm_Application_Api<thermostat_rt_mrm_mrm_Compute_Api> {\n    return thermostat_rt_mrm_mrm_Application_Api {\n      api: thermostat_rt_mrm_mrm_Compute_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      regulator_mode: Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_rt_mrm_mrm_api;\npub mod thermostat_rt_mrm_mrm_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn put_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n}\n\npub fn unsafe_put_internal_failure(value: &Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    return put_internal_failure(value as *const Isolette_Data_Model::Failure_Flag_i as *mut Isolette_Data_Model::Failure_Flag_i);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref OUT_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *OUT_internal_failure.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn put_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *OUT_internal_failure.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/bridge\/thermostat_rt_drf_drf_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_rt_drf_drf_Api {}\n\n  pub trait thermostat_rt_drf_drf_Put_Api: thermostat_rt_drf_drf_Api {\n    #[verifier::external_body]\n    fn unverified_put_internal_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n    {\n      extern_api::unsafe_put_internal_failure(&value);\n    }\n  }\n\n  pub trait thermostat_rt_drf_drf_Get_Api: thermostat_rt_drf_drf_Api {\n  }\n\n  pub trait thermostat_rt_drf_drf_Full_Api: thermostat_rt_drf_drf_Put_Api + thermostat_rt_drf_drf_Get_Api {}\n\n  pub struct thermostat_rt_drf_drf_Application_Api<API: thermostat_rt_drf_drf_Api> {\n    pub api: API,\n\n    pub ghost internal_failure: Isolette_Data_Model::Failure_Flag_i\n  }\n\n  impl<API: thermostat_rt_drf_drf_Put_Api> thermostat_rt_drf_drf_Application_Api<API> {\n    pub fn put_internal_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        self.internal_failure == value,\n    {\n      self.api.unverified_put_internal_failure(value);\n      self.internal_failure = value;\n    }\n  }\n\n  impl<API: thermostat_rt_drf_drf_Get_Api> thermostat_rt_drf_drf_Application_Api<API> {\n  }\n\n  pub struct thermostat_rt_drf_drf_Initialization_Api;\n  impl thermostat_rt_drf_drf_Api for thermostat_rt_drf_drf_Initialization_Api {}\n  impl thermostat_rt_drf_drf_Put_Api for thermostat_rt_drf_drf_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_rt_drf_drf_Application_Api<thermostat_rt_drf_drf_Initialization_Api> {\n    return thermostat_rt_drf_drf_Application_Api {\n      api: thermostat_rt_drf_drf_Initialization_Api {},\n\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n\n  pub struct thermostat_rt_drf_drf_Compute_Api;\n  impl thermostat_rt_drf_drf_Api for thermostat_rt_drf_drf_Compute_Api {}\n  impl thermostat_rt_drf_drf_Put_Api for thermostat_rt_drf_drf_Compute_Api {}\n  impl thermostat_rt_drf_drf_Get_Api for thermostat_rt_drf_drf_Compute_Api {}\n  impl thermostat_rt_drf_drf_Full_Api for thermostat_rt_drf_drf_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_rt_drf_drf_Application_Api<thermostat_rt_drf_drf_Compute_Api> {\n    return thermostat_rt_drf_drf_Application_Api {\n      api: thermostat_rt_drf_drf_Compute_Api {},\n\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_rt_drf_drf_api;\npub mod thermostat_rt_drf_drf_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool;\n  fn put_upper_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn put_lower_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn put_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool;\n  fn put_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n}\n\npub fn unsafe_get_upper_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_upper_alarm_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_lower_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_lower_alarm_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_monitor_mode() -> Isolette_Data_Model::Monitor_Mode\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Monitor_Mode = &mut Isolette_Data_Model::Monitor_Mode::default();\n    get_monitor_mode(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_upper_alarm_temp(value: &Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    return put_upper_alarm_temp(value as *const Isolette_Data_Model::Temp_i as *mut Isolette_Data_Model::Temp_i);\n  }\n}\n\npub fn unsafe_put_lower_alarm_temp(value: &Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    return put_lower_alarm_temp(value as *const Isolette_Data_Model::Temp_i as *mut Isolette_Data_Model::Temp_i);\n  }\n}\n\npub fn unsafe_put_monitor_status(value: &Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    return put_monitor_status(value as *const Isolette_Data_Model::Status as *mut Isolette_Data_Model::Status);\n  }\n}\n\npub fn unsafe_put_interface_failure(value: &Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    return put_interface_failure(value as *const Isolette_Data_Model::Failure_Flag_i as *mut Isolette_Data_Model::Failure_Flag_i);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_upper_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_lower_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_monitor_mode: Mutex<Option<Isolette_Data_Model::Monitor_Mode>> = Mutex::new(None);\n  pub static ref OUT_upper_alarm_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref OUT_lower_alarm_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref OUT_monitor_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);\n  pub static ref OUT_interface_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_upper_alarm_tempWstatus.lock().unwrap() = None;\n    *IN_lower_alarm_tempWstatus.lock().unwrap() = None;\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_monitor_mode.lock().unwrap() = None;\n    *OUT_upper_alarm_temp.lock().unwrap() = None;\n    *OUT_lower_alarm_temp.lock().unwrap() = None;\n    *OUT_monitor_status.lock().unwrap() = None;\n    *OUT_interface_failure.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_upper_alarm_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_lower_alarm_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  unsafe {\n    *value = IN_monitor_mode.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_upper_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *OUT_upper_alarm_temp.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_lower_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *OUT_lower_alarm_temp.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    *OUT_monitor_status.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *OUT_interface_failure.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/bridge\/thermostat_mt_mmi_mmi_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_mt_mmi_mmi_Api {}\n\n  pub trait thermostat_mt_mmi_mmi_Put_Api: thermostat_mt_mmi_mmi_Api {\n    #[verifier::external_body]\n    fn unverified_put_upper_alarm_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n    {\n      extern_api::unsafe_put_upper_alarm_temp(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_lower_alarm_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n    {\n      extern_api::unsafe_put_lower_alarm_temp(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_monitor_status(\n      &mut self,\n      value: Isolette_Data_Model::Status)\n    {\n      extern_api::unsafe_put_monitor_status(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_interface_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n    {\n      extern_api::unsafe_put_interface_failure(&value);\n    }\n  }\n\n  pub trait thermostat_mt_mmi_mmi_Get_Api: thermostat_mt_mmi_mmi_Api {\n    #[verifier::external_body]\n    fn unverified_get_upper_alarm_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n        \/\/ assume Allowed_UpperAlarmTemp\n        GUMBO_Library::Allowed_UpperAlarmTempWStatus_spec(res),\n    {\n      return extern_api::unsafe_get_upper_alarm_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_lower_alarm_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n        \/\/ assume Allowed_LowerAlarmTemp\n        GUMBO_Library::Allowed_LowerAlarmTempWStatus_spec(res),\n    {\n      return extern_api::unsafe_get_lower_alarm_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_monitor_mode(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Monitor_Mode>) -> (res : Isolette_Data_Model::Monitor_Mode)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_monitor_mode();\n    }\n  }\n\n  pub trait thermostat_mt_mmi_mmi_Full_Api: thermostat_mt_mmi_mmi_Put_Api + thermostat_mt_mmi_mmi_Get_Api {}\n\n  pub struct thermostat_mt_mmi_mmi_Application_Api<API: thermostat_mt_mmi_mmi_Api> {\n    pub api: API,\n\n    pub ghost upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost monitor_mode: Isolette_Data_Model::Monitor_Mode,\n    pub ghost upper_alarm_temp: Isolette_Data_Model::Temp_i,\n    pub ghost lower_alarm_temp: Isolette_Data_Model::Temp_i,\n    pub ghost monitor_status: Isolette_Data_Model::Status,\n    pub ghost interface_failure: Isolette_Data_Model::Failure_Flag_i\n  }\n\n  impl<API: thermostat_mt_mmi_mmi_Put_Api> thermostat_mt_mmi_mmi_Application_Api<API> {\n    pub fn put_upper_alarm_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        self.upper_alarm_temp == value,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_upper_alarm_temp(value);\n      self.upper_alarm_temp = value;\n    }\n    pub fn put_lower_alarm_temp(\n      &mut self,\n      value: Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        self.lower_alarm_temp == value,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_lower_alarm_temp(value);\n      self.lower_alarm_temp = value;\n    }\n    pub fn put_monitor_status(\n      &mut self,\n      value: Isolette_Data_Model::Status)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        self.monitor_status == value,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_put_monitor_status(value);\n      self.monitor_status = value;\n    }\n    pub fn put_interface_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        self.interface_failure == value,\n    {\n      self.api.unverified_put_interface_failure(value);\n      self.interface_failure = value;\n    }\n  }\n\n  impl<API: thermostat_mt_mmi_mmi_Get_Api> thermostat_mt_mmi_mmi_Application_Api<API> {\n    pub fn get_upper_alarm_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        res == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n        \/\/ assume Allowed_UpperAlarmTemp\n        GUMBO_Library::Allowed_UpperAlarmTempWStatus_spec(res),\n    {\n      self.api.unverified_get_upper_alarm_tempWstatus(&Ghost(self.upper_alarm_tempWstatus))\n    }\n    pub fn get_lower_alarm_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        res == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n        \/\/ assume Allowed_LowerAlarmTemp\n        GUMBO_Library::Allowed_LowerAlarmTempWStatus_spec(res),\n    {\n      self.api.unverified_get_lower_alarm_tempWstatus(&Ghost(self.lower_alarm_tempWstatus))\n    }\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_monitor_mode(&mut self) -> (res : Isolette_Data_Model::Monitor_Mode)\n      ensures\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).monitor_mode == self.monitor_mode,\n        res == self.monitor_mode,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).monitor_status == self.monitor_status,\n        old(self).interface_failure == self.interface_failure,\n    {\n      self.api.unverified_get_monitor_mode(&Ghost(self.monitor_mode))\n    }\n  }\n\n  pub struct thermostat_mt_mmi_mmi_Initialization_Api;\n  impl thermostat_mt_mmi_mmi_Api for thermostat_mt_mmi_mmi_Initialization_Api {}\n  impl thermostat_mt_mmi_mmi_Put_Api for thermostat_mt_mmi_mmi_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_mt_mmi_mmi_Application_Api<thermostat_mt_mmi_mmi_Initialization_Api> {\n    return thermostat_mt_mmi_mmi_Application_Api {\n      api: thermostat_mt_mmi_mmi_Initialization_Api {},\n\n      upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n      upper_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      lower_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      monitor_status: Isolette_Data_Model::Status::Init_Status,\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n\n  pub struct thermostat_mt_mmi_mmi_Compute_Api;\n  impl thermostat_mt_mmi_mmi_Api for thermostat_mt_mmi_mmi_Compute_Api {}\n  impl thermostat_mt_mmi_mmi_Put_Api for thermostat_mt_mmi_mmi_Compute_Api {}\n  impl thermostat_mt_mmi_mmi_Get_Api for thermostat_mt_mmi_mmi_Compute_Api {}\n  impl thermostat_mt_mmi_mmi_Full_Api for thermostat_mt_mmi_mmi_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_mt_mmi_mmi_Application_Api<thermostat_mt_mmi_mmi_Compute_Api> {\n    return thermostat_mt_mmi_mmi_Application_Api {\n      api: thermostat_mt_mmi_mmi_Compute_Api {},\n\n      upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n      upper_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      lower_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      monitor_status: Isolette_Data_Model::Status::Init_Status,\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_mt_mmi_mmi_api;\npub mod thermostat_mt_mmi_mmi_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_lower_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn get_upper_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool;\n  fn put_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool;\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_lower_alarm_temp() -> Isolette_Data_Model::Temp_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();\n    get_lower_alarm_temp(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_upper_alarm_temp() -> Isolette_Data_Model::Temp_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();\n    get_upper_alarm_temp(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_monitor_mode() -> Isolette_Data_Model::Monitor_Mode\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Monitor_Mode = &mut Isolette_Data_Model::Monitor_Mode::default();\n    get_monitor_mode(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_alarm_control(value: &Isolette_Data_Model::On_Off) -> bool\n{\n  unsafe {\n    return put_alarm_control(value as *const Isolette_Data_Model::On_Off as *mut Isolette_Data_Model::On_Off);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_lower_alarm_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref IN_upper_alarm_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref IN_monitor_mode: Mutex<Option<Isolette_Data_Model::Monitor_Mode>> = Mutex::new(None);\n  pub static ref OUT_alarm_control: Mutex<Option<Isolette_Data_Model::On_Off>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_lower_alarm_temp.lock().unwrap() = None;\n    *IN_upper_alarm_temp.lock().unwrap() = None;\n    *IN_monitor_mode.lock().unwrap() = None;\n    *OUT_alarm_control.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_lower_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *value = IN_lower_alarm_temp.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_upper_alarm_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *value = IN_upper_alarm_temp.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  unsafe {\n    *value = IN_monitor_mode.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool\n{\n  unsafe {\n    *OUT_alarm_control.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/bridge\/thermostat_mt_ma_ma_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_mt_ma_ma_Api {}\n\n  pub trait thermostat_mt_ma_ma_Put_Api: thermostat_mt_ma_ma_Api {\n    #[verifier::external_body]\n    fn unverified_put_alarm_control(\n      &mut self,\n      value: Isolette_Data_Model::On_Off)\n    {\n      extern_api::unsafe_put_alarm_control(&value);\n    }\n  }\n\n  pub trait thermostat_mt_ma_ma_Get_Api: thermostat_mt_ma_ma_Api {\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_lower_alarm_temp(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Temp_i>) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_lower_alarm_temp();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_upper_alarm_temp(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Temp_i>) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_upper_alarm_temp();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_monitor_mode(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Monitor_Mode>) -> (res : Isolette_Data_Model::Monitor_Mode)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_monitor_mode();\n    }\n  }\n\n  pub trait thermostat_mt_ma_ma_Full_Api: thermostat_mt_ma_ma_Put_Api + thermostat_mt_ma_ma_Get_Api {}\n\n  pub struct thermostat_mt_ma_ma_Application_Api<API: thermostat_mt_ma_ma_Api> {\n    pub api: API,\n\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost lower_alarm_temp: Isolette_Data_Model::Temp_i,\n    pub ghost upper_alarm_temp: Isolette_Data_Model::Temp_i,\n    pub ghost monitor_mode: Isolette_Data_Model::Monitor_Mode,\n    pub ghost alarm_control: Isolette_Data_Model::On_Off\n  }\n\n  impl<API: thermostat_mt_ma_ma_Put_Api> thermostat_mt_ma_ma_Application_Api<API> {\n    pub fn put_alarm_control(\n      &mut self,\n      value: Isolette_Data_Model::On_Off)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).monitor_mode == self.monitor_mode,\n        self.alarm_control == value,\n    {\n      self.api.unverified_put_alarm_control(value);\n      self.alarm_control = value;\n    }\n  }\n\n  impl<API: thermostat_mt_ma_ma_Get_Api> thermostat_mt_ma_ma_Application_Api<API> {\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).alarm_control == self.alarm_control,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_lower_alarm_temp(&mut self) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        res == self.lower_alarm_temp,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).alarm_control == self.alarm_control,\n    {\n      self.api.unverified_get_lower_alarm_temp(&Ghost(self.lower_alarm_temp))\n    }\n    pub fn get_upper_alarm_temp(&mut self) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        res == self.upper_alarm_temp,\n        old(self).monitor_mode == self.monitor_mode,\n        old(self).alarm_control == self.alarm_control,\n    {\n      self.api.unverified_get_upper_alarm_temp(&Ghost(self.upper_alarm_temp))\n    }\n    pub fn get_monitor_mode(&mut self) -> (res : Isolette_Data_Model::Monitor_Mode)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).lower_alarm_temp == self.lower_alarm_temp,\n        old(self).upper_alarm_temp == self.upper_alarm_temp,\n        old(self).monitor_mode == self.monitor_mode,\n        res == self.monitor_mode,\n        old(self).alarm_control == self.alarm_control,\n    {\n      self.api.unverified_get_monitor_mode(&Ghost(self.monitor_mode))\n    }\n  }\n\n  pub struct thermostat_mt_ma_ma_Initialization_Api;\n  impl thermostat_mt_ma_ma_Api for thermostat_mt_ma_ma_Initialization_Api {}\n  impl thermostat_mt_ma_ma_Put_Api for thermostat_mt_ma_ma_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_mt_ma_ma_Application_Api<thermostat_mt_ma_ma_Initialization_Api> {\n    return thermostat_mt_ma_ma_Application_Api {\n      api: thermostat_mt_ma_ma_Initialization_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      upper_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n      alarm_control: Isolette_Data_Model::On_Off::Onn\n    }\n  }\n\n  pub struct thermostat_mt_ma_ma_Compute_Api;\n  impl thermostat_mt_ma_ma_Api for thermostat_mt_ma_ma_Compute_Api {}\n  impl thermostat_mt_ma_ma_Put_Api for thermostat_mt_ma_ma_Compute_Api {}\n  impl thermostat_mt_ma_ma_Get_Api for thermostat_mt_ma_ma_Compute_Api {}\n  impl thermostat_mt_ma_ma_Full_Api for thermostat_mt_ma_ma_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_mt_ma_ma_Application_Api<thermostat_mt_ma_ma_Compute_Api> {\n    return thermostat_mt_ma_ma_Application_Api {\n      api: thermostat_mt_ma_ma_Compute_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      upper_alarm_temp: Isolette_Data_Model::Temp_i { degrees: 0 },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n      alarm_control: Isolette_Data_Model::On_Off::Onn\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_mt_ma_ma_api;\npub mod thermostat_mt_ma_ma_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn get_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n  fn get_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n  fn put_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool;\n}\n\npub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();\n    get_current_tempWstatus(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_interface_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();\n    get_interface_failure(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_internal_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();\n    get_internal_failure(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_monitor_mode(value: &Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  unsafe {\n    return put_monitor_mode(value as *const Isolette_Data_Model::Monitor_Mode as *mut Isolette_Data_Model::Monitor_Mode);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref IN_interface_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n  pub static ref IN_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n  pub static ref OUT_monitor_mode: Mutex<Option<Isolette_Data_Model::Monitor_Mode>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_current_tempWstatus.lock().unwrap() = None;\n    *IN_interface_failure.lock().unwrap() = None;\n    *IN_internal_failure.lock().unwrap() = None;\n    *OUT_monitor_mode.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *value = IN_current_tempWstatus.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_interface_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *value = IN_interface_failure.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *value = IN_internal_failure.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  unsafe {\n    *OUT_monitor_mode.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/bridge\/thermostat_mt_mmm_mmm_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_mt_mmm_mmm_Api {}\n\n  pub trait thermostat_mt_mmm_mmm_Put_Api: thermostat_mt_mmm_mmm_Api {\n    #[verifier::external_body]\n    fn unverified_put_monitor_mode(\n      &mut self,\n      value: Isolette_Data_Model::Monitor_Mode)\n    {\n      extern_api::unsafe_put_monitor_mode(&value);\n    }\n  }\n\n  pub trait thermostat_mt_mmm_mmm_Get_Api: thermostat_mt_mmm_mmm_Api {\n    #[verifier::external_body]\n    fn unverified_get_current_tempWstatus(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::TempWstatus_i>) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_current_tempWstatus();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_interface_failure(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Failure_Flag_i>) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_interface_failure();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_internal_failure(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Failure_Flag_i>) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_internal_failure();\n    }\n  }\n\n  pub trait thermostat_mt_mmm_mmm_Full_Api: thermostat_mt_mmm_mmm_Put_Api + thermostat_mt_mmm_mmm_Get_Api {}\n\n  pub struct thermostat_mt_mmm_mmm_Application_Api<API: thermostat_mt_mmm_mmm_Api> {\n    pub api: API,\n\n    pub ghost current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost interface_failure: Isolette_Data_Model::Failure_Flag_i,\n    pub ghost internal_failure: Isolette_Data_Model::Failure_Flag_i,\n    pub ghost monitor_mode: Isolette_Data_Model::Monitor_Mode\n  }\n\n  impl<API: thermostat_mt_mmm_mmm_Put_Api> thermostat_mt_mmm_mmm_Application_Api<API> {\n    pub fn put_monitor_mode(\n      &mut self,\n      value: Isolette_Data_Model::Monitor_Mode)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        self.monitor_mode == value,\n    {\n      self.api.unverified_put_monitor_mode(value);\n      self.monitor_mode = value;\n    }\n  }\n\n  impl<API: thermostat_mt_mmm_mmm_Get_Api> thermostat_mt_mmm_mmm_Application_Api<API> {\n    pub fn get_current_tempWstatus(&mut self) -> (res : Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        res == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        old(self).monitor_mode == self.monitor_mode,\n    {\n      self.api.unverified_get_current_tempWstatus(&Ghost(self.current_tempWstatus))\n    }\n    pub fn get_interface_failure(&mut self) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        res == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        old(self).monitor_mode == self.monitor_mode,\n    {\n      self.api.unverified_get_interface_failure(&Ghost(self.interface_failure))\n    }\n    pub fn get_internal_failure(&mut self) -> (res : Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        old(self).current_tempWstatus == self.current_tempWstatus,\n        old(self).interface_failure == self.interface_failure,\n        old(self).internal_failure == self.internal_failure,\n        res == self.internal_failure,\n        old(self).monitor_mode == self.monitor_mode,\n    {\n      self.api.unverified_get_internal_failure(&Ghost(self.internal_failure))\n    }\n  }\n\n  pub struct thermostat_mt_mmm_mmm_Initialization_Api;\n  impl thermostat_mt_mmm_mmm_Api for thermostat_mt_mmm_mmm_Initialization_Api {}\n  impl thermostat_mt_mmm_mmm_Put_Api for thermostat_mt_mmm_mmm_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_mt_mmm_mmm_Application_Api<thermostat_mt_mmm_mmm_Initialization_Api> {\n    return thermostat_mt_mmm_mmm_Application_Api {\n      api: thermostat_mt_mmm_mmm_Initialization_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode\n    }\n  }\n\n  pub struct thermostat_mt_mmm_mmm_Compute_Api;\n  impl thermostat_mt_mmm_mmm_Api for thermostat_mt_mmm_mmm_Compute_Api {}\n  impl thermostat_mt_mmm_mmm_Put_Api for thermostat_mt_mmm_mmm_Compute_Api {}\n  impl thermostat_mt_mmm_mmm_Get_Api for thermostat_mt_mmm_mmm_Compute_Api {}\n  impl thermostat_mt_mmm_mmm_Full_Api for thermostat_mt_mmm_mmm_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_mt_mmm_mmm_Application_Api<thermostat_mt_mmm_mmm_Compute_Api> {\n    return thermostat_mt_mmm_mmm_Application_Api {\n      api: thermostat_mt_mmm_mmm_Compute_Api {},\n\n      current_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      interface_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false },\n      monitor_mode: Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_mt_mmm_mmm_api;\npub mod thermostat_mt_mmm_mmm_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn put_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;\n}\n\npub fn unsafe_put_internal_failure(value: &Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    return put_internal_failure(value as *const Isolette_Data_Model::Failure_Flag_i as *mut Isolette_Data_Model::Failure_Flag_i);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref OUT_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *OUT_internal_failure.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn put_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  unsafe {\n    *OUT_internal_failure.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/bridge\/thermostat_mt_dmf_dmf_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait thermostat_mt_dmf_dmf_Api {}\n\n  pub trait thermostat_mt_dmf_dmf_Put_Api: thermostat_mt_dmf_dmf_Api {\n    #[verifier::external_body]\n    fn unverified_put_internal_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n    {\n      extern_api::unsafe_put_internal_failure(&value);\n    }\n  }\n\n  pub trait thermostat_mt_dmf_dmf_Get_Api: thermostat_mt_dmf_dmf_Api {\n  }\n\n  pub trait thermostat_mt_dmf_dmf_Full_Api: thermostat_mt_dmf_dmf_Put_Api + thermostat_mt_dmf_dmf_Get_Api {}\n\n  pub struct thermostat_mt_dmf_dmf_Application_Api<API: thermostat_mt_dmf_dmf_Api> {\n    pub api: API,\n\n    pub ghost internal_failure: Isolette_Data_Model::Failure_Flag_i\n  }\n\n  impl<API: thermostat_mt_dmf_dmf_Put_Api> thermostat_mt_dmf_dmf_Application_Api<API> {\n    pub fn put_internal_failure(\n      &mut self,\n      value: Isolette_Data_Model::Failure_Flag_i)\n      ensures\n        self.internal_failure == value,\n    {\n      self.api.unverified_put_internal_failure(value);\n      self.internal_failure = value;\n    }\n  }\n\n  impl<API: thermostat_mt_dmf_dmf_Get_Api> thermostat_mt_dmf_dmf_Application_Api<API> {\n  }\n\n  pub struct thermostat_mt_dmf_dmf_Initialization_Api;\n  impl thermostat_mt_dmf_dmf_Api for thermostat_mt_dmf_dmf_Initialization_Api {}\n  impl thermostat_mt_dmf_dmf_Put_Api for thermostat_mt_dmf_dmf_Initialization_Api {}\n\n  pub const fn init_api() -> thermostat_mt_dmf_dmf_Application_Api<thermostat_mt_dmf_dmf_Initialization_Api> {\n    return thermostat_mt_dmf_dmf_Application_Api {\n      api: thermostat_mt_dmf_dmf_Initialization_Api {},\n\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n\n  pub struct thermostat_mt_dmf_dmf_Compute_Api;\n  impl thermostat_mt_dmf_dmf_Api for thermostat_mt_dmf_dmf_Compute_Api {}\n  impl thermostat_mt_dmf_dmf_Put_Api for thermostat_mt_dmf_dmf_Compute_Api {}\n  impl thermostat_mt_dmf_dmf_Get_Api for thermostat_mt_dmf_dmf_Compute_Api {}\n  impl thermostat_mt_dmf_dmf_Full_Api for thermostat_mt_dmf_dmf_Compute_Api {}\n\n  pub const fn compute_api() -> thermostat_mt_dmf_dmf_Application_Api<thermostat_mt_dmf_dmf_Compute_Api> {\n    return thermostat_mt_dmf_dmf_Application_Api {\n      api: thermostat_mt_dmf_dmf_Compute_Api {},\n\n      internal_failure: Isolette_Data_Model::Failure_Flag_i { flag: false }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod thermostat_mt_dmf_dmf_api;\npub mod thermostat_mt_dmf_dmf_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/bridge\/extern_c_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\n\/\/! C-interface for the component.\n\/\/! This code must be unsafe.\n\/\/! Assumptions about correctness are introduced and need to be verified by other means.\n\nuse data::*;\n\n#[cfg(test)]\nuse std::sync::Mutex;\n\n#[cfg(not(test))]\nextern \"C\" {\n  fn get_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool;\n  fn get_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool;\n  fn get_display_temperature(value: *mut Isolette_Data_Model::Temp_i) -> bool;\n  fn get_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool;\n  fn put_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn put_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn put_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n  fn put_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;\n}\n\npub fn unsafe_get_regulator_status() -> Isolette_Data_Model::Status\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Status = &mut Isolette_Data_Model::Status::default();\n    get_regulator_status(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_monitor_status() -> Isolette_Data_Model::Status\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Status = &mut Isolette_Data_Model::Status::default();\n    get_monitor_status(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_display_temperature() -> Isolette_Data_Model::Temp_i\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();\n    get_display_temperature(value);\n    return *value;\n  }\n}\n\npub fn unsafe_get_alarm_control() -> Isolette_Data_Model::On_Off\n{\n  unsafe {\n    let value: *mut Isolette_Data_Model::On_Off = &mut Isolette_Data_Model::On_Off::default();\n    get_alarm_control(value);\n    return *value;\n  }\n}\n\npub fn unsafe_put_lower_desired_tempWstatus(value: &Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    return put_lower_desired_tempWstatus(value as *const Isolette_Data_Model::TempWstatus_i as *mut Isolette_Data_Model::TempWstatus_i);\n  }\n}\n\npub fn unsafe_put_upper_desired_tempWstatus(value: &Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    return put_upper_desired_tempWstatus(value as *const Isolette_Data_Model::TempWstatus_i as *mut Isolette_Data_Model::TempWstatus_i);\n  }\n}\n\npub fn unsafe_put_lower_alarm_tempWstatus(value: &Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    return put_lower_alarm_tempWstatus(value as *const Isolette_Data_Model::TempWstatus_i as *mut Isolette_Data_Model::TempWstatus_i);\n  }\n}\n\npub fn unsafe_put_upper_alarm_tempWstatus(value: &Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    return put_upper_alarm_tempWstatus(value as *const Isolette_Data_Model::TempWstatus_i as *mut Isolette_Data_Model::TempWstatus_i);\n  }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Testing Versions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#[cfg(test)]\nlazy_static::lazy_static! {\n  \/\/ simulate the global C variables that point to the microkit shared memory regions.  In a full\n  \/\/ microkit system we would be able to mutate the shared memory for out ports since they're r\/w,\n  \/\/ but we couldn't do that for in ports since they are read-only\n  pub static ref IN_regulator_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);\n  pub static ref IN_monitor_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);\n  pub static ref IN_display_temperature: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);\n  pub static ref IN_alarm_control: Mutex<Option<Isolette_Data_Model::On_Off>> = Mutex::new(None);\n  pub static ref OUT_lower_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref OUT_upper_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref OUT_lower_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n  pub static ref OUT_upper_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);\n}\n\n#[cfg(test)]\npub fn initialize_test_globals() {\n  unsafe {\n    *IN_regulator_status.lock().unwrap() = None;\n    *IN_monitor_status.lock().unwrap() = None;\n    *IN_display_temperature.lock().unwrap() = None;\n    *IN_alarm_control.lock().unwrap() = None;\n    *OUT_lower_desired_tempWstatus.lock().unwrap() = None;\n    *OUT_upper_desired_tempWstatus.lock().unwrap() = None;\n    *OUT_lower_alarm_tempWstatus.lock().unwrap() = None;\n    *OUT_upper_alarm_tempWstatus.lock().unwrap() = None;\n  }\n}\n\n#[cfg(test)]\npub fn get_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    *value = IN_regulator_status.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool\n{\n  unsafe {\n    *value = IN_monitor_status.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_display_temperature(value: *mut Isolette_Data_Model::Temp_i) -> bool\n{\n  unsafe {\n    *value = IN_display_temperature.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn get_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool\n{\n  unsafe {\n    *value = IN_alarm_control.lock().unwrap().expect(\"Not expecting None\");\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *OUT_lower_desired_tempWstatus.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *OUT_upper_desired_tempWstatus.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *OUT_lower_alarm_tempWstatus.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n\n#[cfg(test)]\npub fn put_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  unsafe {\n    *OUT_upper_alarm_tempWstatus.lock().unwrap() = Some(*value);\n    return true;\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/bridge\/operator_interface_oip_oit_api.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse vstd::prelude::*;\nuse data::*;\nuse super::extern_c_api as extern_api;\n\nverus! {\n  pub trait operator_interface_oip_oit_Api {}\n\n  pub trait operator_interface_oip_oit_Put_Api: operator_interface_oip_oit_Api {\n    #[verifier::external_body]\n    fn unverified_put_lower_desired_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n    {\n      extern_api::unsafe_put_lower_desired_tempWstatus(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_upper_desired_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n    {\n      extern_api::unsafe_put_upper_desired_tempWstatus(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_lower_alarm_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n    {\n      extern_api::unsafe_put_lower_alarm_tempWstatus(&value);\n    }\n\n    #[verifier::external_body]\n    fn unverified_put_upper_alarm_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n    {\n      extern_api::unsafe_put_upper_alarm_tempWstatus(&value);\n    }\n  }\n\n  pub trait operator_interface_oip_oit_Get_Api: operator_interface_oip_oit_Api {\n    #[verifier::external_body]\n    fn unverified_get_regulator_status(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Status>) -> (res : Isolette_Data_Model::Status)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_regulator_status();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_monitor_status(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Status>) -> (res : Isolette_Data_Model::Status)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_monitor_status();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_display_temperature(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::Temp_i>) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_display_temperature();\n    }\n\n    #[verifier::external_body]\n    fn unverified_get_alarm_control(\n      &mut self,\n      value: &Ghost<Isolette_Data_Model::On_Off>) -> (res : Isolette_Data_Model::On_Off)\n      ensures\n        res == value@,\n    {\n      return extern_api::unsafe_get_alarm_control();\n    }\n  }\n\n  pub trait operator_interface_oip_oit_Full_Api: operator_interface_oip_oit_Put_Api + operator_interface_oip_oit_Get_Api {}\n\n  pub struct operator_interface_oip_oit_Application_Api<API: operator_interface_oip_oit_Api> {\n    pub api: API,\n\n    pub ghost regulator_status: Isolette_Data_Model::Status,\n    pub ghost monitor_status: Isolette_Data_Model::Status,\n    pub ghost display_temperature: Isolette_Data_Model::Temp_i,\n    pub ghost alarm_control: Isolette_Data_Model::On_Off,\n    pub ghost lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n    pub ghost upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i\n  }\n\n  impl<API: operator_interface_oip_oit_Put_Api> operator_interface_oip_oit_Application_Api<API> {\n    pub fn put_lower_desired_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        self.lower_desired_tempWstatus == value,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_put_lower_desired_tempWstatus(value);\n      self.lower_desired_tempWstatus = value;\n    }\n    pub fn put_upper_desired_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        self.upper_desired_tempWstatus == value,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_put_upper_desired_tempWstatus(value);\n      self.upper_desired_tempWstatus = value;\n    }\n    pub fn put_lower_alarm_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n      requires\n        \/\/ guarantee Allowed_LowerAlarmTempWstatus\n        \/\/   Table_A_12_LowerAlarmTemp: Range [96..101]:\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n        GUMBO_Library::Allowed_LowerAlarmTempWStatus_spec(value),\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        self.lower_alarm_tempWstatus == value,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_put_lower_alarm_tempWstatus(value);\n      self.lower_alarm_tempWstatus = value;\n    }\n    pub fn put_upper_alarm_tempWstatus(\n      &mut self,\n      value: Isolette_Data_Model::TempWstatus_i)\n      requires\n        \/\/ guarantee Allowed_UpperAlarmTempWstatus\n        \/\/   Table_A_12_UpperAlarmTemp: Range [97..102]\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n        crate::component::operator_interface_oip_oit_app::Allowed_UpperAlarmTempWStatus(value),\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        self.upper_alarm_tempWstatus == value,\n    {\n      self.api.unverified_put_upper_alarm_tempWstatus(value);\n      self.upper_alarm_tempWstatus = value;\n    }\n  }\n\n  impl<API: operator_interface_oip_oit_Get_Api> operator_interface_oip_oit_Application_Api<API> {\n    pub fn get_regulator_status(&mut self) -> (res : Isolette_Data_Model::Status)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        res == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_get_regulator_status(&Ghost(self.regulator_status))\n    }\n    pub fn get_monitor_status(&mut self) -> (res : Isolette_Data_Model::Status)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        res == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_get_monitor_status(&Ghost(self.monitor_status))\n    }\n    pub fn get_display_temperature(&mut self) -> (res : Isolette_Data_Model::Temp_i)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        res == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_get_display_temperature(&Ghost(self.display_temperature))\n    }\n    pub fn get_alarm_control(&mut self) -> (res : Isolette_Data_Model::On_Off)\n      ensures\n        old(self).regulator_status == self.regulator_status,\n        old(self).monitor_status == self.monitor_status,\n        old(self).display_temperature == self.display_temperature,\n        old(self).alarm_control == self.alarm_control,\n        res == self.alarm_control,\n        old(self).lower_desired_tempWstatus == self.lower_desired_tempWstatus,\n        old(self).upper_desired_tempWstatus == self.upper_desired_tempWstatus,\n        old(self).lower_alarm_tempWstatus == self.lower_alarm_tempWstatus,\n        old(self).upper_alarm_tempWstatus == self.upper_alarm_tempWstatus,\n    {\n      self.api.unverified_get_alarm_control(&Ghost(self.alarm_control))\n    }\n  }\n\n  pub struct operator_interface_oip_oit_Initialization_Api;\n  impl operator_interface_oip_oit_Api for operator_interface_oip_oit_Initialization_Api {}\n  impl operator_interface_oip_oit_Put_Api for operator_interface_oip_oit_Initialization_Api {}\n\n  pub const fn init_api() -> operator_interface_oip_oit_Application_Api<operator_interface_oip_oit_Initialization_Api> {\n    return operator_interface_oip_oit_Application_Api {\n      api: operator_interface_oip_oit_Initialization_Api {},\n\n      regulator_status: Isolette_Data_Model::Status::Init_Status,\n      monitor_status: Isolette_Data_Model::Status::Init_Status,\n      display_temperature: Isolette_Data_Model::Temp_i { degrees: 0 },\n      alarm_control: Isolette_Data_Model::On_Off::Onn,\n      lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid }\n    }\n  }\n\n  pub struct operator_interface_oip_oit_Compute_Api;\n  impl operator_interface_oip_oit_Api for operator_interface_oip_oit_Compute_Api {}\n  impl operator_interface_oip_oit_Put_Api for operator_interface_oip_oit_Compute_Api {}\n  impl operator_interface_oip_oit_Get_Api for operator_interface_oip_oit_Compute_Api {}\n  impl operator_interface_oip_oit_Full_Api for operator_interface_oip_oit_Compute_Api {}\n\n  pub const fn compute_api() -> operator_interface_oip_oit_Application_Api<operator_interface_oip_oit_Compute_Api> {\n    return operator_interface_oip_oit_Application_Api {\n      api: operator_interface_oip_oit_Compute_Api {},\n\n      regulator_status: Isolette_Data_Model::Status::Init_Status,\n      monitor_status: Isolette_Data_Model::Status::Init_Status,\n      display_temperature: Isolette_Data_Model::Temp_i { degrees: 0 },\n      alarm_control: Isolette_Data_Model::On_Off::Onn,\n      lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid },\n      upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i { degrees: 0, status: Isolette_Data_Model::ValueStatus::Valid }\n    }\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/bridge\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod extern_c_api;\npub mod operator_interface_oip_oit_api;\npub mod operator_interface_oip_oit_GUMBOX;",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_rt_mri_mri_api::{self as api, *};\nuse crate::component::thermostat_rt_mri_mri_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_rt_mri_mri> = None;\nstatic mut init_api: thermostat_rt_mri_mri_Application_Api<thermostat_rt_mri_mri_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_rt_mri_mri_Application_Api<thermostat_rt_mri_mri_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mri_mri_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_rt_mri_mri::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mri_mri_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mri_mri_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/component\/thermostat_rt_mri_mri_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_rt_mri_mri_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_rt_mri_mri {\n    \/\/ PLACEHOLDER MARKER STATE VARS\n  }\n\n  impl thermostat_rt_mri_mri {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ PLACEHOLDER MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_rt_mri_mri_Put_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mri_mri_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee RegulatorStatusIsInitiallyInit\n        api.regulator_status == Isolette_Data_Model::Status::Init_Status,\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_rt_mri_mri_Full_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mri_mri_Application_Api<API>)\n      requires\n        \/\/ BEGIN MARKER TIME TRIGGERED REQUIRES\n        \/\/ assume lower_is_not_higher_than_upper\n        old(api).lower_desired_tempWstatus.degrees <= old(api).upper_desired_tempWstatus.degrees,\n        \/\/ END MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ case REQ_MRI_1\n        \/\/   If the Regulator Mode is INIT,\n        \/\/   the Regulator Status shall be set to Init.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode) ==>\n          (api.regulator_status == Isolette_Data_Model::Status::Init_Status),\n        \/\/ case REQ_MRI_2\n        \/\/   If the Regulator Mode is NORMAL,\n        \/\/   the Regulator Status shall be set to On\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) ==>\n          (api.regulator_status == Isolette_Data_Model::Status::On_Status),\n        \/\/ case REQ_MRI_3\n        \/\/   If the Regulator Mode is FAILED,\n        \/\/   the Regulator Status shall be set to Failed.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) ==>\n          (api.regulator_status == Isolette_Data_Model::Status::Failed_Status),\n        \/\/ case REQ_MRI_4\n        \/\/   If the Regulator Mode is NORMAL, the\n        \/\/   Display Temperature shall be set to the value of the\n        \/\/   Current Temperature rounded to the nearest integer.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) ==>\n          (api.displayed_temp.degrees == ROUND(api.current_tempWstatus.degrees)),\n        \/\/ case REQ_MRI_5\n        \/\/   If the Regulator Mode is not NORMAL,\n        \/\/   the value of the Display Temperature is UNSPECIFIED.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        true,\n        \/\/ case REQ_MRI_6\n        \/\/   If the Status attribute of the Lower Desired Temperature\n        \/\/   or the Upper Desired Temperature is Invalid,\n        \/\/   the Regulator Interface Failure shall be set to True.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        ((old(api).upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) ||\n          (old(api).upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid)) ==>\n          (api.interface_failure.flag),\n        \/\/ case REQ_MRI_7\n        \/\/   If the Status attribute of the Lower Desired Temperature\n        \/\/   and the Upper Desired Temperature is Valid,\n        \/\/   the Regulator Interface Failure shall be set to False.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        api.interface_failure.flag == !((api.upper_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) &&\n          (api.lower_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid)),\n        \/\/ case REQ_MRI_8\n        \/\/   If the Regulator Interface Failure is False,\n        \/\/   the Desired Range shall be set to the Desired Temperature Range.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        !(api.interface_failure.flag) ==>\n          ((api.lower_desired_temp.degrees == api.lower_desired_tempWstatus.degrees) &&\n            (api.upper_desired_temp.degrees == api.upper_desired_tempWstatus.degrees)),\n        \/\/ case REQ_MRI_9\n        \/\/   If the Regulator Interface Failure is True,\n        \/\/   the Desired Range is UNSPECIFIED.\n        \/\/   the Desired Range shall be set to the Desired Temperature Range.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n        true,\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ BEGIN MARKER GUMBO METHODS\n  pub open spec fn ROUND(num: i32) -> i32\n  {\n    num\n  }\n  \/\/ END MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER GUMBO METHODS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED REQUIRES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_rt_mri_mri_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_rt_mri_mri\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_rt_mhs_mhs_api::{self as api, *};\nuse crate::component::thermostat_rt_mhs_mhs_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_rt_mhs_mhs> = None;\nstatic mut init_api: thermostat_rt_mhs_mhs_Application_Api<thermostat_rt_mhs_mhs_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_rt_mhs_mhs_Application_Api<thermostat_rt_mhs_mhs_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mhs_mhs_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_rt_mhs_mhs::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mhs_mhs_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mhs_mhs_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/component\/thermostat_rt_mhs_mhs_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_rt_mhs_mhs_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_rt_mhs_mhs {\n    \/\/ BEGIN MARKER STATE VARS\n    pub lastCmd: Isolette_Data_Model::On_Off\n    \/\/ END MARKER STATE VARS\n  }\n\n  impl thermostat_rt_mhs_mhs {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ BEGIN MARKER STATE VAR INIT\n        lastCmd: Isolette_Data_Model::On_Off::default()\n        \/\/ END MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_rt_mhs_mhs_Put_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mhs_mhs_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee initlastCmd\n        self.lastCmd == Isolette_Data_Model::On_Off::Off,\n        \/\/ guarantee REQ_MHS_1\n        \/\/   If the Regulator Mode is INIT, the Heat Control shall be\n        \/\/   set to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n        api.heat_control == Isolette_Data_Model::On_Off::Off,\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_rt_mhs_mhs_Full_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mhs_mhs_Application_Api<API>)\n      requires\n        \/\/ BEGIN MARKER TIME TRIGGERED REQUIRES\n        \/\/ assume lower_is_lower_temp\n        old(api).lower_desired_temp.degrees <= old(api).upper_desired_temp.degrees,\n        \/\/ END MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ guarantee lastCmd\n        \/\/   Set lastCmd to value of output Cmd port\n        self.lastCmd == api.heat_control,\n        \/\/ case REQ_MHS_1\n        \/\/   If the Regulator Mode is INIT, the Heat Control shall be\n        \/\/   set to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode) ==>\n          (api.heat_control == Isolette_Data_Model::On_Off::Off),\n        \/\/ case REQ_MHS_2\n        \/\/   If the Regulator Mode is NORMAL and the Current Temperature is less than\n        \/\/   the Lower Desired Temperature, the Heat Control shall be set to On.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n        ((old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n          (old(api).current_tempWstatus.degrees < old(api).lower_desired_temp.degrees)) ==>\n          (api.heat_control == Isolette_Data_Model::On_Off::Onn),\n        \/\/ case REQ_MHS_3\n        \/\/   If the Regulator Mode is NORMAL and the Current Temperature is greater than\n        \/\/   the Upper Desired Temperature, the Heat Control shall be set to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n        ((old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n          (old(api).current_tempWstatus.degrees > old(api).upper_desired_temp.degrees)) ==>\n          (api.heat_control == Isolette_Data_Model::On_Off::Off),\n        \/\/ case REQ_MHS_4\n        \/\/   If the Regulator Mode is NORMAL and the Current\n        \/\/   Temperature is greater than or equal to the Lower Desired Temperature\n        \/\/   and less than or equal to the Upper Desired Temperature, the value of\n        \/\/   the Heat Control shall not be changed.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n        ((old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n          ((old(api).current_tempWstatus.degrees >= old(api).lower_desired_temp.degrees) &&\n            (old(api).current_tempWstatus.degrees <= old(api).upper_desired_temp.degrees))) ==>\n          (api.heat_control == old(self).lastCmd),\n        \/\/ case REQ_MHS_5\n        \/\/   If the Regulator Mode is FAILED, the Heat Control shall be\n        \/\/   set to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=111 \n        (old(api).regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) ==>\n          (api.heat_control == Isolette_Data_Model::On_Off::Off),\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ PLACEHOLDER MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VARS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VAR INIT",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED REQUIRES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_rt_mhs_mhs_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_rt_mhs_mhs\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_rt_mrm_mrm_api::{self as api, *};\nuse crate::component::thermostat_rt_mrm_mrm_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_rt_mrm_mrm> = None;\nstatic mut init_api: thermostat_rt_mrm_mrm_Application_Api<thermostat_rt_mrm_mrm_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_rt_mrm_mrm_Application_Api<thermostat_rt_mrm_mrm_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mrm_mrm_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_rt_mrm_mrm::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mrm_mrm_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_mrm_mrm_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/component\/thermostat_rt_mrm_mrm_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_rt_mrm_mrm_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_rt_mrm_mrm {\n    \/\/ BEGIN MARKER STATE VARS\n    pub lastRegulatorMode: Isolette_Data_Model::Regulator_Mode\n    \/\/ END MARKER STATE VARS\n  }\n\n  impl thermostat_rt_mrm_mrm {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ BEGIN MARKER STATE VAR INIT\n        lastRegulatorMode: Isolette_Data_Model::Regulator_Mode::default()\n        \/\/ END MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_rt_mrm_mrm_Put_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mrm_mrm_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee REQ_MRM_1\n        \/\/   The initial mode of the regular is INIT\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n        api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_rt_mrm_mrm_Full_Api> (\n      &mut self,\n      api: &mut thermostat_rt_mrm_mrm_Application_Api<API>)\n      requires\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ case REQ_MRM_2\n        \/\/   'transition from Init to Normal'\n        \/\/   If the current regulator mode is Init, then\n        \/\/   the regulator mode is set to NORMAL iff the regulator status is valid (see Table A-10), i.e.,\n        \/\/     if NOT (Regulator Interface Failure OR Regulator Internal Failure)\n        \/\/        AND Current Temperature.Status = Valid\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n        (old(self).lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode) ==>\n          (!(api.interface_failure.flag || api.internal_failure.flag) &&\n             (api.current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n               (self.lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)),\n        \/\/ case REQ_MRM_Maintain_Normal\n        \/\/   'maintaining NORMAL, NORMAL to NORMAL'\n        \/\/   If the current regulator mode is Normal, then\n        \/\/   the regulator mode is stays normal iff\n        \/\/   the regulaor status is not false i.e.,\n        \/\/          if NOT(\n        \/\/              (Regulator Interface Failure OR Regulator Internal Failure)\n        \/\/              OR NOT(Current Temperature.Status = Valid)\n        \/\/          )\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n        (old(self).lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) ==>\n          (!(api.interface_failure.flag || api.internal_failure.flag) &&\n             (api.current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n               (self.lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)),\n        \/\/ case REQ_MRM_3\n        \/\/   'transition for NORMAL to FAILED'\n        \/\/   If the current regulator mode is Normal, then\n        \/\/   the regulator mode is set to Failed iff\n        \/\/   the regulator status is false, i.e.,\n        \/\/      if  (Regulator Interface Failure OR Regulator Internal Failure)\n        \/\/          OR NOT(Current Temperature.Status = Valid)\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n        (old(self).lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) ==>\n          ((api.interface_failure.flag || api.internal_failure.flag) &&\n             (api.current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n               (self.lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)),\n        \/\/ case REQ_MRM_4\n        \/\/   'transition from INIT to FAILED' \n        \/\/   If the current regulator mode is Init, then\n        \/\/   the regulator mode and lastRegulatorMode state value is set to Failed iff\n        \/\/   the regulator status is false, i.e.,\n        \/\/          if  (Regulator Interface Failure OR Regulator Internal Failure)\n        \/\/          OR NOT(Current Temperature.Status = Valid)\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109\n        (old(self).lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode) ==>\n          ((api.interface_failure.flag || api.internal_failure.flag) &&\n             (api.current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n               (self.lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)),\n        \/\/ case REQ_MRM_MaintainFailed\n        \/\/   'maintaining FAIL, FAIL to FAIL'\n        \/\/   If the current regulator mode is Failed, then\n        \/\/   the regulator mode remains in the Failed state and the LastRegulator mode remains Failed.REQ-MRM-Maintain-Failed\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109\n        (old(self).lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) ==>\n          ((api.regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n             (self.lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)),\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ PLACEHOLDER MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VARS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VAR INIT",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_rt_mrm_mrm_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_rt_mrm_mrm\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_rt_drf_drf_api::{self as api, *};\nuse crate::component::thermostat_rt_drf_drf_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_rt_drf_drf> = None;\nstatic mut init_api: thermostat_rt_drf_drf_Application_Api<thermostat_rt_drf_drf_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_rt_drf_drf_Application_Api<thermostat_rt_drf_drf_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_drf_drf_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_rt_drf_drf::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_drf_drf_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_rt_drf_drf_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/component\/thermostat_rt_drf_drf_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_rt_drf_drf_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_rt_drf_drf {\n    \/\/ PLACEHOLDER MARKER STATE VARS\n  }\n\n  impl thermostat_rt_drf_drf {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ PLACEHOLDER MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_rt_drf_drf_Put_Api> (\n      &mut self,\n      api: &mut thermostat_rt_drf_drf_Application_Api<API>)\n      ensures\n        \/\/ PLACEHOLDER MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_rt_drf_drf_Full_Api> (\n      &mut self,\n      api: &mut thermostat_rt_drf_drf_Application_Api<API>)\n      requires\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ PLACEHOLDER MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_rt_drf_drf_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_rt_drf_drf\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_mt_mmi_mmi_api::{self as api, *};\nuse crate::component::thermostat_mt_mmi_mmi_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_mt_mmi_mmi> = None;\nstatic mut init_api: thermostat_mt_mmi_mmi_Application_Api<thermostat_mt_mmi_mmi_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_mt_mmi_mmi_Application_Api<thermostat_mt_mmi_mmi_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmi_mmi_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_mt_mmi_mmi::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmi_mmi_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmi_mmi_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/component\/thermostat_mt_mmi_mmi_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_mt_mmi_mmi_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_mt_mmi_mmi {\n    \/\/ BEGIN MARKER STATE VARS\n    pub lastCmd: Isolette_Data_Model::On_Off\n    \/\/ END MARKER STATE VARS\n  }\n\n  impl thermostat_mt_mmi_mmi {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ BEGIN MARKER STATE VAR INIT\n        lastCmd: Isolette_Data_Model::On_Off::default()\n        \/\/ END MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_mt_mmi_mmi_Put_Api> (\n      &mut self,\n      api: &mut thermostat_mt_mmi_mmi_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee monitorStatusInitiallyInit\n        api.monitor_status == Isolette_Data_Model::Status::Init_Status,\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_mt_mmi_mmi_Full_Api> (\n      &mut self,\n      api: &mut thermostat_mt_mmi_mmi_Application_Api<API>)\n      requires\n        \/\/ BEGIN MARKER TIME TRIGGERED REQUIRES\n        \/\/ assume Allowed_AlarmTempWstatus_Ranges\n        \/\/   An integration constraint can only refer to a single port, so need a general assume clause\n        \/\/   in order to relate the lower and uper temps\n        GUMBO_Library::Allowed_AlarmTempWStatus_Ranges_spec(old(api).lower_alarm_tempWstatus, old(api).upper_alarm_tempWstatus),\n        \/\/ END MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ case REQ_MMI_1\n        \/\/   If the Manage Monitor Interface mode is INIT,\n        \/\/   the Monitor Status shall be set to Init.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        (old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode) ==>\n          (api.monitor_status == Isolette_Data_Model::Status::Init_Status),\n        \/\/ case REQ_MMI_2\n        \/\/   If the Manage Monitor Interface mode is NORMAL,\n        \/\/   the Monitor Status shall be set to On\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        (old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) ==>\n          (api.monitor_status == Isolette_Data_Model::Status::On_Status),\n        \/\/ case REQ_MMI_3\n        \/\/   If the Manage Monitor Interface mode is FAILED,\n        \/\/   the Monitor Status shall be set to Failed.\n        \/\/   Latency: < Max Operator Response Time\n        \/\/   Tolerance: N\/A\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        (old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode) ==>\n          (api.monitor_status == Isolette_Data_Model::Status::Failed_Status),\n        \/\/ case REQ_MMI_4\n        \/\/   If the Status attribute of the Lower Alarm Temperature\n        \/\/   or the Upper Alarm Temperature is Invalid,\n        \/\/   the Monitor Interface Failure shall be set to True\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        ((old(api).lower_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Invalid) ||\n          (old(api).upper_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Invalid)) ==>\n          (api.interface_failure.flag),\n        \/\/ case REQ_MMI_5\n        \/\/   If the Status attribute of the Lower Alarm Temperature\n        \/\/   and the Upper Alarm Temperature is Valid,\n        \/\/   the Monitor Interface Failure shall be set to False\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        ((old(api).lower_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) &&\n          (old(api).upper_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid)) ==>\n          (!(api.interface_failure.flag)),\n        \/\/ case REQ_MMI_6\n        \/\/   If the Monitor Interface Failure is False,\n        \/\/   the Alarm Range variable shall be set to the Desired Temperature Range\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        !(api.interface_failure.flag) ==>\n          ((api.lower_alarm_temp.degrees == api.lower_alarm_tempWstatus.degrees) &&\n            (api.upper_alarm_temp.degrees == api.upper_alarm_tempWstatus.degrees)),\n        \/\/ case REQ_MMI_7\n        \/\/   If the Monitor Interface Failure is True,\n        \/\/   the Alarm Range variable is UNSPECIFIED\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n        api.interface_failure.flag ==> true,\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ BEGIN MARKER GUMBO METHODS\n  pub open spec fn timeout_condition_satisfied() -> bool\n  {\n    true\n  }\n  \/\/ END MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VARS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER GUMBO METHODS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VAR INIT",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED REQUIRES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_mt_mmi_mmi_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_mt_mmi_mmi\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_mt_ma_ma_api::{self as api, *};\nuse crate::component::thermostat_mt_ma_ma_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_mt_ma_ma> = None;\nstatic mut init_api: thermostat_mt_ma_ma_Application_Api<thermostat_mt_ma_ma_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_mt_ma_ma_Application_Api<thermostat_mt_ma_ma_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_ma_ma_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_mt_ma_ma::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_ma_ma_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_ma_ma_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/component\/thermostat_mt_ma_ma_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_mt_ma_ma_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_mt_ma_ma {\n    \/\/ BEGIN MARKER STATE VARS\n    pub lastCmd: Isolette_Data_Model::On_Off\n    \/\/ END MARKER STATE VARS\n  }\n\n  impl thermostat_mt_ma_ma {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ BEGIN MARKER STATE VAR INIT\n        lastCmd: Isolette_Data_Model::On_Off::default()\n        \/\/ END MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_mt_ma_ma_Put_Api> (\n      &mut self,\n      api: &mut thermostat_mt_ma_ma_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee REQ_MA_1\n        \/\/   If the Monitor Mode is INIT, the Alarm Control shall be set\n        \/\/   to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        (api.alarm_control == Isolette_Data_Model::On_Off::Off) &&\n          (self.lastCmd == Isolette_Data_Model::On_Off::Off),\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_mt_ma_ma_Full_Api> (\n      &mut self,\n      api: &mut thermostat_mt_ma_ma_Application_Api<API>)\n      requires\n        \/\/ BEGIN MARKER TIME TRIGGERED REQUIRES\n        \/\/ assume Figure_A_7\n        \/\/   This is not explicitly stated in the requirements, but a reasonable\n        \/\/   assumption is that the lower alarm must be at least 1.0f less than\n        \/\/   the upper alarm in order to account for the 0.5f tolerance\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        old(api).upper_alarm_temp.degrees - old(api).lower_alarm_temp.degrees >= 1i32,\n        \/\/ assume Table_A_12_LowerAlarmTemp\n        \/\/   Range [96..101]\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n        GUMBO_Library::Allowed_LowerAlarmTemp_spec(old(api).lower_alarm_temp.degrees),\n        \/\/ assume Table_A_12_UpperAlarmTemp\n        \/\/   Range [97..102]\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n        GUMBO_Library::Allowed_UpperAlarmTemp_spec(old(api).upper_alarm_temp.degrees),\n        \/\/ END MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ case REQ_MA_1\n        \/\/   If the Monitor Mode is INIT, the Alarm Control shall be set\n        \/\/   to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        (old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode) ==>\n          ((api.alarm_control == Isolette_Data_Model::On_Off::Off) &&\n             (self.lastCmd == Isolette_Data_Model::On_Off::Off)),\n        \/\/ case REQ_MA_2\n        \/\/   If the Monitor Mode is NORMAL and the Current Temperature is\n        \/\/   less than the Lower Alarm Temperature or greater than the Upper Alarm\n        \/\/   Temperature, the Alarm Control shall be set to On.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        ((old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &&\n          ((old(api).current_tempWstatus.degrees < old(api).lower_alarm_temp.degrees) ||\n            (old(api).current_tempWstatus.degrees > old(api).upper_alarm_temp.degrees))) ==>\n          ((api.alarm_control == Isolette_Data_Model::On_Off::Onn) &&\n             (self.lastCmd == Isolette_Data_Model::On_Off::Onn)),\n        \/\/ case REQ_MA_3\n        \/\/   If the Monitor Mode is NORMAL and the Current Temperature\n        \/\/   is greater than or equal to the Lower Alarm Temperature and less than\n        \/\/   the Lower Alarm Temperature +0.5 degrees, or the Current Temperature is\n        \/\/   greater than the Upper Alarm Temperature -0.5 degrees and less than or equal\n        \/\/   to the Upper Alarm Temperature, the value of the Alarm Control shall\n        \/\/   not be changed.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        ((old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &&\n          ((old(api).current_tempWstatus.degrees >= old(api).lower_alarm_temp.degrees) &&\n            (old(api).current_tempWstatus.degrees < old(api).lower_alarm_temp.degrees + 1i32) ||\n            (old(api).current_tempWstatus.degrees > old(api).upper_alarm_temp.degrees - 1i32) &&\n              (old(api).current_tempWstatus.degrees <= old(api).upper_alarm_temp.degrees))) ==>\n          ((api.alarm_control == old(self).lastCmd) &&\n             (self.lastCmd == old(self).lastCmd)),\n        \/\/ case REQ_MA_4\n        \/\/   If the Monitor Mode is NORMAL and the value of the Current\n        \/\/   Temperature is greater than or equal to the Lower Alarm Temperature\n        \/\/   +0.5 degrees and less than or equal to the Upper Alarm Temperature\n        \/\/   -0.5 degrees, the Alarm Control shall be set to Off.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n        ((old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &&\n          ((old(api).current_tempWstatus.degrees >= old(api).lower_alarm_temp.degrees + 1i32) &&\n            (old(api).current_tempWstatus.degrees <= old(api).upper_alarm_temp.degrees - 1i32))) ==>\n          ((api.alarm_control == Isolette_Data_Model::On_Off::Off) &&\n             (self.lastCmd == Isolette_Data_Model::On_Off::Off)),\n        \/\/ case REQ_MA_5\n        \/\/   If the Monitor Mode is FAILED, the Alarm Control shall be\n        \/\/   set to On.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=116 \n        (old(api).monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode) ==>\n          ((api.alarm_control == Isolette_Data_Model::On_Off::Onn) &&\n             (self.lastCmd == Isolette_Data_Model::On_Off::Onn)),\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ BEGIN MARKER GUMBO METHODS\n  pub open spec fn timeout_condition_satisfied() -> bool\n  {\n    true\n  }\n  \/\/ END MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VARS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER GUMBO METHODS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VAR INIT",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED REQUIRES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_mt_ma_ma_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_mt_ma_ma\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_mt_mmm_mmm_api::{self as api, *};\nuse crate::component::thermostat_mt_mmm_mmm_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_mt_mmm_mmm> = None;\nstatic mut init_api: thermostat_mt_mmm_mmm_Application_Api<thermostat_mt_mmm_mmm_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_mt_mmm_mmm_Application_Api<thermostat_mt_mmm_mmm_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmm_mmm_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_mt_mmm_mmm::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmm_mmm_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_mmm_mmm_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/component\/thermostat_mt_mmm_mmm_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_mt_mmm_mmm_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_mt_mmm_mmm {\n    \/\/ BEGIN MARKER STATE VARS\n    pub lastMonitorMode: Isolette_Data_Model::Monitor_Mode\n    \/\/ END MARKER STATE VARS\n  }\n\n  impl thermostat_mt_mmm_mmm {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ BEGIN MARKER STATE VAR INIT\n        lastMonitorMode: Isolette_Data_Model::Monitor_Mode::default()\n        \/\/ END MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_mt_mmm_mmm_Put_Api> (\n      &mut self,\n      api: &mut thermostat_mt_mmm_mmm_Application_Api<API>)\n      ensures\n        \/\/ BEGIN MARKER INITIALIZATION ENSURES\n        \/\/ guarantee REQ_MMM_1\n        \/\/   Upon the first dispatch of the thread, the monitor mode is Init.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n        api.monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n        \/\/ END MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_mt_mmm_mmm_Full_Api> (\n      &mut self,\n      api: &mut thermostat_mt_mmm_mmm_Application_Api<API>)\n      requires\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ case REQ_MMM_2\n        \/\/   If the current mode is Init, then\n        \/\/   the mode is set to NORMAL iff the monitor status is true (valid) (see Table A-15), i.e.,\n        \/\/   if  NOT (Monitor Interface Failure OR Monitor Internal Failure)\n        \/\/   AND Current Temperature.Status = Valid\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n        (old(self).lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode) ==>\n          (!(api.interface_failure.flag || api.internal_failure.flag) &&\n             (api.current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode)),\n        \/\/ case REQ_MMM_3\n        \/\/   If the current Monitor mode is Normal, then\n        \/\/   the Monitor mode is set to Failed iff\n        \/\/   the Monitor status is false, i.e.,\n        \/\/   if  (Monitor Interface Failure OR Monitor Internal Failure)\n        \/\/   OR NOT(Current Temperature.Status = Valid)\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n        (old(self).lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) ==>\n          (api.interface_failure.flag || api.internal_failure.flag ||\n             (api.current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) ==>\n             (api.monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)),\n        \/\/ case REQ_MMM_4\n        \/\/   If the current mode is Init, then\n        \/\/   the mode is set to Failed iff the time during\n        \/\/   which the thread has been in Init mode exceeds the\n        \/\/   Monitor Init Timeout value.\n        \/\/   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n        (old(self).lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode) ==>\n          (timeout_condition_satisfied() == (api.monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)),\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ BEGIN MARKER GUMBO METHODS\n  pub open spec fn timeout_condition_satisfied() -> bool\n  {\n    false\n  }\n  \/\/ END MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VARS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER GUMBO METHODS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER STATE VAR INIT",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER INITIALIZATION ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_mt_mmm_mmm_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_mt_mmm_mmm\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::thermostat_mt_dmf_dmf_api::{self as api, *};\nuse crate::component::thermostat_mt_dmf_dmf_app::*;\nuse data::*;\n\nstatic mut app: Option<thermostat_mt_dmf_dmf> = None;\nstatic mut init_api: thermostat_mt_dmf_dmf_Application_Api<thermostat_mt_dmf_dmf_Initialization_Api> = api::init_api();\nstatic mut compute_api: thermostat_mt_dmf_dmf_Application_Api<thermostat_mt_dmf_dmf_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_dmf_dmf_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = thermostat_mt_dmf_dmf::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_dmf_dmf_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn thermostat_mt_dmf_dmf_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/component\/thermostat_mt_dmf_dmf_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::thermostat_mt_dmf_dmf_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct thermostat_mt_dmf_dmf {\n    \/\/ PLACEHOLDER MARKER STATE VARS\n  }\n\n  impl thermostat_mt_dmf_dmf {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ PLACEHOLDER MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: thermostat_mt_dmf_dmf_Put_Api> (\n      &mut self,\n      api: &mut thermostat_mt_dmf_dmf_Application_Api<API>)\n      ensures\n        \/\/ PLACEHOLDER MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: thermostat_mt_dmf_dmf_Full_Api> (\n      &mut self,\n      api: &mut thermostat_mt_dmf_dmf_Application_Api<API>)\n      requires\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ PLACEHOLDER MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod thermostat_mt_dmf_dmf_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"thermostat_mt_dmf_dmf\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nmod bridge;\nmod component;\nmod logging;\n\n#[cfg(test)]\nmod test;\n\nuse crate::bridge::operator_interface_oip_oit_api::{self as api, *};\nuse crate::component::operator_interface_oip_oit_app::*;\nuse data::*;\n\nstatic mut app: Option<operator_interface_oip_oit> = None;\nstatic mut init_api: operator_interface_oip_oit_Application_Api<operator_interface_oip_oit_Initialization_Api> = api::init_api();\nstatic mut compute_api: operator_interface_oip_oit_Application_Api<operator_interface_oip_oit_Compute_Api> = api::compute_api();\n\n#[no_mangle]\npub extern \"C\" fn operator_interface_oip_oit_initialize() {\n  logging::init_logging();\n\n  unsafe {\n    #[cfg(test)]\n    crate::bridge::extern_c_api::initialize_test_globals();\n\n    let mut _app = operator_interface_oip_oit::new();\n    _app.initialize(&mut init_api);\n    app = Some(_app);\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn operator_interface_oip_oit_timeTriggered() {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.timeTriggered(&mut compute_api);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n#[no_mangle]\npub extern \"C\" fn operator_interface_oip_oit_notify(channel: microkit_channel) {\n  unsafe {\n    if let Some(_app) = app.as_mut() {\n      _app.notify(channel);\n    } else {\n      panic!(\"Unexpected: app is None\");\n    }\n  }\n}\n\n\/\/ Need a Panic handler in a no_std environment\n#[panic_handler]\n#[cfg(not(test))]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n  log::error!(\"PANIC: {info:#?}\");\n  loop {}\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/logging.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse log::LevelFilter;\n\n#[cfg(feature = \"sel4\")]\nuse sel4::debug_print;\n\n#[cfg(feature = \"sel4\")]\nuse sel4_logging::{Logger, LoggerBuilder};\n\n#[cfg(test)]\nuse std::sync::Once;\n\nconst LOG_LEVEL: LevelFilter = {\n  \/\/ LevelFilter::Off \/\/ lowest level of logging\n  \/\/ LevelFilter::Error\n  \/\/ LevelFilter::Warn\n  \/\/ LevelFilter::Info\n  \/\/ LevelFilter::Debug\n  LevelFilter::Trace \/\/ highest level of logging\n};\n\n#[cfg(feature = \"sel4\")]\npub static LOGGER: Logger = LoggerBuilder::const_default()\n    .level_filter(LOG_LEVEL)\n    .write(|s| debug_print!(\"{}\", s))\n    .build();\n\n#[cfg(test)]\nstatic INIT: Once = Once::new();\n\npub fn init_logging() {\n    #[cfg(all(feature = \"sel4\", not(test)))]\n    {\n        LOGGER.set().unwrap();\n    }\n\n    #[cfg(test)]\n    {\n        INIT.call_once(|| {\n            let _ = env_logger::builder()\n                .is_test(cfg!(test))\n                .filter_level(LOG_LEVEL)\n                .try_init();\n        });\n    }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/component\/operator_interface_oip_oit_app.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nuse data::*;\nuse crate::bridge::operator_interface_oip_oit_api::*;\nuse vstd::prelude::*;\n\nverus! {\n\n  pub struct operator_interface_oip_oit {\n    \/\/ PLACEHOLDER MARKER STATE VARS\n  }\n\n  impl operator_interface_oip_oit {\n    pub fn new() -> Self\n    {\n      Self {\n        \/\/ PLACEHOLDER MARKER STATE VAR INIT\n      }\n    }\n\n    pub fn initialize<API: operator_interface_oip_oit_Put_Api> (\n      &mut self,\n      api: &mut operator_interface_oip_oit_Application_Api<API>)\n      ensures\n        \/\/ PLACEHOLDER MARKER INITIALIZATION ENSURES\n    {\n      log_info(\"initialize entrypoint invoked\");\n    }\n\n    pub fn timeTriggered<API: operator_interface_oip_oit_Full_Api> (\n      &mut self,\n      api: &mut operator_interface_oip_oit_Application_Api<API>)\n      requires\n        \/\/ PLACEHOLDER MARKER TIME TRIGGERED REQUIRES\n      ensures\n        \/\/ BEGIN MARKER TIME TRIGGERED ENSURES\n        \/\/ guarantee Allowed_AlarmTempWStatus_Ranges\n        \/\/   An integration constraint can only refer to a single port, so need a general requires\n        \/\/   clause to relate the lower and upper temps\n        GUMBO_Library::Allowed_AlarmTempWStatus_Ranges_spec(api.lower_alarm_tempWstatus, api.upper_alarm_tempWstatus),\n        \/\/ END MARKER TIME TRIGGERED ENSURES\n    {\n      log_info(\"compute entrypoint invoked\");\n    }\n\n    pub fn notify(\n      &mut self,\n      channel: microkit_channel)\n    {\n      \/\/ this method is called when the monitor does not handle the passed in channel\n      match channel {\n        _ => {\n          log_warn_channel(channel)\n        }\n      }\n    }\n  }\n\n  #[verifier::external_body]\n  pub fn log_info(msg: &str)\n  {\n    log::info!(\"{0}\", msg);\n  }\n\n  #[verifier::external_body]\n  pub fn log_warn_channel(channel: u32)\n  {\n    log::warn!(\"Unexpected channel: {0}\", channel);\n  }\n\n  \/\/ BEGIN MARKER GUMBO METHODS\n  pub open spec fn Allowed_UpperAlarmTempWStatus(upper: Isolette_Data_Model::TempWstatus_i) -> bool\n  {\n    GUMBO_Library::Allowed_UpperAlarmTempWStatus_spec(upper)\n  }\n  \/\/ END MARKER GUMBO METHODS\n\n}\n",
          "markers" : [
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER GUMBO METHODS",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            },
            {
              "type" : "TestBlockMarker",
              "id" : "MARKER TIME TRIGGERED ENSURES",
              "beginPrefix" : "\/\/ BEGIN",
              "optBeginSuffix" : {
                "type" : "None"
              },
              "endPrefix" : "\/\/ END",
              "optEndSuffix" : {
                "type" : "None"
              }
            }
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/component\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod operator_interface_oip_oit_app;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"operator_interface_oip_oit\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path = \"..\/data\" }\nlinux-raw-sys = { version = \"0.12.0\", default-features = false }\nlog = \"0.4.28\"\nsel4 = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", features = [\"single-threaded\"], optional = true, tag=\"v2.0.0\" }\nsel4-logging = { git = \"https:\/\/github.com\/seL4\/rust-sel4\", optional = true, tag=\"v2.0.0\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nGUMBO_Library = { path = \"..\/GUMBO_Library\" }\n\n[dev-dependencies]\nlazy_static = \"1.5.0\"\nonce_cell = \"1.21.3\"\nserial_test = \"3.2.0\"\nproptest = \"1.8.0\"\nenv_logger = \"0.11.8\"\n\n[lib]\npath = \"src\/lib.rs\"\ncrate-type = [\"staticlib\"]\n\n[features]\nsel4 = [\"dep:sel4\", \"dep:sel4-logging\" ]\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/Makefile",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\nmicrokit_sdk_config_dir := $(MICROKIT_SDK)\/board\/$(MICROKIT_BOARD)\/$(MICROKIT_CONFIG)\n\nsel4_include_dirs := $(firstword $(wildcard $(microkit_sdk_config_dir)\/include \\\n                                            $(microkit_sdk_config_dir)\/debug\/include))\n\nENV_VARS = RUSTC_BOOTSTRAP=1\n\nBUILD_ENV_VARS = $(ENV_VARS) \\\n                 SEL4_INCLUDE_DIRS=$(abspath $(sel4_include_dirs))\n\nCARGO_FLAGS = -Z build-std=core,alloc,compiler_builtins \\\n              -Z build-std-features=compiler-builtins-mem \\\n              --target aarch64-unknown-none\n\nall: build-verus-release\n\nbuild-verus-release:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS) --release\n\nbuild-verus:\n\t$(BUILD_ENV_VARS) cargo-verus build --features sel4 $(CARGO_FLAGS)\n\nbuild-release:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS) --release\n\nbuild:\n\t$(BUILD_ENV_VARS) cargo build --features sel4 $(CARGO_FLAGS)\n\nverus:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS)\n\nverus-json:\n\t$(ENV_VARS) cargo-verus verify $(CARGO_FLAGS) -- --output-json --time > verus_results.json\n\n# Test Example:\n#   Run all unit tests\n#   Usage: make test\n#\n#   Run only unit tests whose name contains 'proptest'\n#   Usage: make test args=proptest\n\ntest-release:\n\tcargo test $(args) --release\n\ntest:\n\tcargo test $(args)\n\n# Coverage Example:\n#   Generate a test coverage report combining the results of all unit tests\n#   Usage: make coverage\n#\n#   Generate a test coverage report for unit tests whose name contains 'proptest'\n#   Usage: make coverage args=proptest\n\ncoverage:\n\tcargo install grcov\n\t@exists=0; if [ -f target\/coverage\/report\/index.html ]; then exists=1; fi; \\\n\trm -rf target\/coverage; \\\n\tCARGO_INCREMENTAL=0 RUSTFLAGS='-Cinstrument-coverage' LLVM_PROFILE_FILE='target\/coverage\/cargo-test-%p-%m.profraw' \\\n\tcargo test $(args); \\\n\tgrcov . --binary-path .\/target\/debug\/deps\/ -s . -t html --branch --ignore-not-existing -o target\/coverage\/report; \\\n\tif [ $$exists -eq 0 ]; then open target\/coverage\/report\/index.html; fi\n\nclean:\n\tcargo clean\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_rt_mri_mri_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_rt_mri_mri_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_upper_desired_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_lower_desired_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_regulator_mode(Isolette_Data_Model::Regulator_Mode::default());\n\n    crate::thermostat_rt_mri_mri_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_desired_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_regulator_mode: generators::Isolette_Data_Model_Regulator_Mode_strategy_default(),\n    api_upper_desired_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_regulator_mode: Isolette_Data_Model::Regulator_Mode\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_upper_desired_tempWstatus(container.api_upper_desired_tempWstatus);\n  put_lower_desired_tempWstatus(container.api_lower_desired_tempWstatus);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_regulator_mode(container.api_regulator_mode);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  regulator_mode: Isolette_Data_Model::Regulator_Mode)\n{\n  put_upper_desired_tempWstatus(upper_desired_tempWstatus);\n  put_lower_desired_tempWstatus(lower_desired_tempWstatus);\n  put_current_tempWstatus(current_tempWstatus);\n  put_regulator_mode(regulator_mode);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_upper_desired_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_upper_desired_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_lower_desired_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_lower_desired_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_regulator_mode(value: Isolette_Data_Model::Regulator_Mode)\n{\n  *extern_api::IN_regulator_mode.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_upper_desired_temp() -> Isolette_Data_Model::Temp_i\n{\n  return extern_api::OUT_upper_desired_temp.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_lower_desired_temp() -> Isolette_Data_Model::Temp_i\n{\n  return extern_api::OUT_lower_desired_temp.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_displayed_temp() -> Isolette_Data_Model::Temp_i\n{\n  return extern_api::OUT_displayed_temp.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_regulator_status() -> Isolette_Data_Model::Status\n{\n  return extern_api::OUT_regulator_status.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_interface_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  return extern_api::OUT_interface_failure.lock().unwrap().expect(\"Not expecting None\")\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_rt_mhs_mhs_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_rt_mhs_mhs_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_lower_desired_temp(Isolette_Data_Model::Temp_i::default());\n    test_apis::put_upper_desired_temp(Isolette_Data_Model::Temp_i::default());\n    test_apis::put_regulator_mode(Isolette_Data_Model::Regulator_Mode::default());\n\n    crate::thermostat_rt_mhs_mhs_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n    use crate::testComputeCBwGSV_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_desired_temp: generators::Isolette_Data_Model_Temp_i_strategy_default(),\n    api_regulator_mode: generators::Isolette_Data_Model_Regulator_Mode_strategy_default(),\n    api_upper_desired_temp: generators::Isolette_Data_Model_Temp_i_strategy_default()\n  }\n\n  testComputeCBwGSV_macro! {\n    prop_testComputeCBwGSV_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    In_lastCmd: generators::Isolette_Data_Model_On_Off_strategy_default(),\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_desired_temp: generators::Isolette_Data_Model_Temp_i_strategy_default(),\n    api_regulator_mode: generators::Isolette_Data_Model_Regulator_Mode_strategy_default(),\n    api_upper_desired_temp: generators::Isolette_Data_Model_Temp_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  pub api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  pub api_regulator_mode: Isolette_Data_Model::Regulator_Mode\n}\n\n\/\/\/ container for component's incoming port values and GUMBO state variables\npub struct PreStateContainer_wGSV {\n  pub In_lastCmd: Isolette_Data_Model::On_Off,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  pub api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  pub api_regulator_mode: Isolette_Data_Model::Regulator_Mode\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_lower_desired_temp(container.api_lower_desired_temp);\n  put_upper_desired_temp(container.api_upper_desired_temp);\n  put_regulator_mode(container.api_regulator_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_container_wGSV(container: PreStateContainer_wGSV)\n{\n  put_lastCmd(container.In_lastCmd);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_lower_desired_temp(container.api_lower_desired_temp);\n  put_upper_desired_temp(container.api_upper_desired_temp);\n  put_regulator_mode(container.api_regulator_mode);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_desired_temp: Isolette_Data_Model::Temp_i,\n  upper_desired_temp: Isolette_Data_Model::Temp_i,\n  regulator_mode: Isolette_Data_Model::Regulator_Mode)\n{\n  put_current_tempWstatus(current_tempWstatus);\n  put_lower_desired_temp(lower_desired_temp);\n  put_upper_desired_temp(upper_desired_temp);\n  put_regulator_mode(regulator_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_wGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_desired_temp: Isolette_Data_Model::Temp_i,\n  upper_desired_temp: Isolette_Data_Model::Temp_i,\n  regulator_mode: Isolette_Data_Model::Regulator_Mode)\n{\n  put_lastCmd(In_lastCmd);\n  put_current_tempWstatus(current_tempWstatus);\n  put_lower_desired_temp(lower_desired_temp);\n  put_upper_desired_temp(upper_desired_temp);\n  put_regulator_mode(regulator_mode);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_lower_desired_temp(value: Isolette_Data_Model::Temp_i)\n{\n  *extern_api::IN_lower_desired_temp.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_upper_desired_temp(value: Isolette_Data_Model::Temp_i)\n{\n  *extern_api::IN_upper_desired_temp.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_regulator_mode(value: Isolette_Data_Model::Regulator_Mode)\n{\n  *extern_api::IN_regulator_mode.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_heat_control() -> Isolette_Data_Model::On_Off\n{\n  return extern_api::OUT_heat_control.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for GUMBO State Variable\npub fn get_lastCmd() -> Isolette_Data_Model::On_Off\n{\n  unsafe {\n    match &crate::app {\n      Some(inner) => inner.lastCmd,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n\n\/\/\/ setter for GUMBO State Variable\npub fn put_lastCmd(value: Isolette_Data_Model::On_Off)\n{\n  unsafe {\n    match &mut crate::app {\n      Some(inner) => inner.lastCmd = value,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_rt_mrm_mrm_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_rt_mrm_mrm_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_interface_failure(Isolette_Data_Model::Failure_Flag_i::default());\n    test_apis::put_internal_failure(Isolette_Data_Model::Failure_Flag_i::default());\n\n    crate::thermostat_rt_mrm_mrm_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n    use crate::testComputeCBwGSV_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_interface_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default(),\n    api_internal_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default()\n  }\n\n  testComputeCBwGSV_macro! {\n    prop_testComputeCBwGSV_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    In_lastRegulatorMode: generators::Isolette_Data_Model_Regulator_Mode_strategy_default(),\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_interface_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default(),\n    api_internal_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  pub api_internal_failure: Isolette_Data_Model::Failure_Flag_i\n}\n\n\/\/\/ container for component's incoming port values and GUMBO state variables\npub struct PreStateContainer_wGSV {\n  pub In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  pub api_internal_failure: Isolette_Data_Model::Failure_Flag_i\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_interface_failure(container.api_interface_failure);\n  put_internal_failure(container.api_internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_container_wGSV(container: PreStateContainer_wGSV)\n{\n  put_lastRegulatorMode(container.In_lastRegulatorMode);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_interface_failure(container.api_interface_failure);\n  put_internal_failure(container.api_internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  internal_failure: Isolette_Data_Model::Failure_Flag_i)\n{\n  put_current_tempWstatus(current_tempWstatus);\n  put_interface_failure(interface_failure);\n  put_internal_failure(internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_wGSV(\n  In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  internal_failure: Isolette_Data_Model::Failure_Flag_i)\n{\n  put_lastRegulatorMode(In_lastRegulatorMode);\n  put_current_tempWstatus(current_tempWstatus);\n  put_interface_failure(interface_failure);\n  put_internal_failure(internal_failure);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_interface_failure(value: Isolette_Data_Model::Failure_Flag_i)\n{\n  *extern_api::IN_interface_failure.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_internal_failure(value: Isolette_Data_Model::Failure_Flag_i)\n{\n  *extern_api::IN_internal_failure.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_regulator_mode() -> Isolette_Data_Model::Regulator_Mode\n{\n  return extern_api::OUT_regulator_mode.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for GUMBO State Variable\npub fn get_lastRegulatorMode() -> Isolette_Data_Model::Regulator_Mode\n{\n  unsafe {\n    match &crate::app {\n      Some(inner) => inner.lastRegulatorMode,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n\n\/\/\/ setter for GUMBO State Variable\npub fn put_lastRegulatorMode(value: Isolette_Data_Model::Regulator_Mode)\n{\n  unsafe {\n    match &mut crate::app {\n      Some(inner) => inner.lastRegulatorMode = value,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_rt_drf_drf_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_rt_drf_drf_initialize();\n    crate::thermostat_rt_drf_drf_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs()\n{\n\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_internal_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  return extern_api::OUT_internal_failure.lock().unwrap().expect(\"Not expecting None\")\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_mt_mmi_mmi_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_mt_mmi_mmi_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_upper_alarm_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_lower_alarm_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_monitor_mode(Isolette_Data_Model::Monitor_Mode::default());\n\n    crate::thermostat_mt_mmi_mmi_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n    use crate::testComputeCBwGSV_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_alarm_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_monitor_mode: generators::Isolette_Data_Model_Monitor_Mode_strategy_default(),\n    api_upper_alarm_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default()\n  }\n\n  testComputeCBwGSV_macro! {\n    prop_testComputeCBwGSV_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    In_lastCmd: generators::Isolette_Data_Model_On_Off_strategy_default(),\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_alarm_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_monitor_mode: generators::Isolette_Data_Model_Monitor_Mode_strategy_default(),\n    api_upper_alarm_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_monitor_mode: Isolette_Data_Model::Monitor_Mode\n}\n\n\/\/\/ container for component's incoming port values and GUMBO state variables\npub struct PreStateContainer_wGSV {\n  pub In_lastCmd: Isolette_Data_Model::On_Off,\n  pub api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_monitor_mode: Isolette_Data_Model::Monitor_Mode\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_upper_alarm_tempWstatus(container.api_upper_alarm_tempWstatus);\n  put_lower_alarm_tempWstatus(container.api_lower_alarm_tempWstatus);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_monitor_mode(container.api_monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_container_wGSV(container: PreStateContainer_wGSV)\n{\n  put_lastCmd(container.In_lastCmd);\n  put_upper_alarm_tempWstatus(container.api_upper_alarm_tempWstatus);\n  put_lower_alarm_tempWstatus(container.api_lower_alarm_tempWstatus);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_monitor_mode(container.api_monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  monitor_mode: Isolette_Data_Model::Monitor_Mode)\n{\n  put_upper_alarm_tempWstatus(upper_alarm_tempWstatus);\n  put_lower_alarm_tempWstatus(lower_alarm_tempWstatus);\n  put_current_tempWstatus(current_tempWstatus);\n  put_monitor_mode(monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_wGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  monitor_mode: Isolette_Data_Model::Monitor_Mode)\n{\n  put_lastCmd(In_lastCmd);\n  put_upper_alarm_tempWstatus(upper_alarm_tempWstatus);\n  put_lower_alarm_tempWstatus(lower_alarm_tempWstatus);\n  put_current_tempWstatus(current_tempWstatus);\n  put_monitor_mode(monitor_mode);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_upper_alarm_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_upper_alarm_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_lower_alarm_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_lower_alarm_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_monitor_mode(value: Isolette_Data_Model::Monitor_Mode)\n{\n  *extern_api::IN_monitor_mode.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_upper_alarm_temp() -> Isolette_Data_Model::Temp_i\n{\n  return extern_api::OUT_upper_alarm_temp.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_lower_alarm_temp() -> Isolette_Data_Model::Temp_i\n{\n  return extern_api::OUT_lower_alarm_temp.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_monitor_status() -> Isolette_Data_Model::Status\n{\n  return extern_api::OUT_monitor_status.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_interface_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  return extern_api::OUT_interface_failure.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for GUMBO State Variable\npub fn get_lastCmd() -> Isolette_Data_Model::On_Off\n{\n  unsafe {\n    match &crate::app {\n      Some(inner) => inner.lastCmd,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n\n\/\/\/ setter for GUMBO State Variable\npub fn put_lastCmd(value: Isolette_Data_Model::On_Off)\n{\n  unsafe {\n    match &mut crate::app {\n      Some(inner) => inner.lastCmd = value,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_mt_ma_ma_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_mt_ma_ma_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_lower_alarm_temp(Isolette_Data_Model::Temp_i::default());\n    test_apis::put_upper_alarm_temp(Isolette_Data_Model::Temp_i::default());\n    test_apis::put_monitor_mode(Isolette_Data_Model::Monitor_Mode::default());\n\n    crate::thermostat_mt_ma_ma_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n    use crate::testComputeCBwGSV_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_alarm_temp: generators::Isolette_Data_Model_Temp_i_strategy_default(),\n    api_monitor_mode: generators::Isolette_Data_Model_Monitor_Mode_strategy_default(),\n    api_upper_alarm_temp: generators::Isolette_Data_Model_Temp_i_strategy_default()\n  }\n\n  testComputeCBwGSV_macro! {\n    prop_testComputeCBwGSV_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    In_lastCmd: generators::Isolette_Data_Model_On_Off_strategy_default(),\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_lower_alarm_temp: generators::Isolette_Data_Model_Temp_i_strategy_default(),\n    api_monitor_mode: generators::Isolette_Data_Model_Monitor_Mode_strategy_default(),\n    api_upper_alarm_temp: generators::Isolette_Data_Model_Temp_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  pub api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  pub api_monitor_mode: Isolette_Data_Model::Monitor_Mode\n}\n\n\/\/\/ container for component's incoming port values and GUMBO state variables\npub struct PreStateContainer_wGSV {\n  pub In_lastCmd: Isolette_Data_Model::On_Off,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  pub api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  pub api_monitor_mode: Isolette_Data_Model::Monitor_Mode\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_lower_alarm_temp(container.api_lower_alarm_temp);\n  put_upper_alarm_temp(container.api_upper_alarm_temp);\n  put_monitor_mode(container.api_monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_container_wGSV(container: PreStateContainer_wGSV)\n{\n  put_lastCmd(container.In_lastCmd);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_lower_alarm_temp(container.api_lower_alarm_temp);\n  put_upper_alarm_temp(container.api_upper_alarm_temp);\n  put_monitor_mode(container.api_monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  monitor_mode: Isolette_Data_Model::Monitor_Mode)\n{\n  put_current_tempWstatus(current_tempWstatus);\n  put_lower_alarm_temp(lower_alarm_temp);\n  put_upper_alarm_temp(upper_alarm_temp);\n  put_monitor_mode(monitor_mode);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_wGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  monitor_mode: Isolette_Data_Model::Monitor_Mode)\n{\n  put_lastCmd(In_lastCmd);\n  put_current_tempWstatus(current_tempWstatus);\n  put_lower_alarm_temp(lower_alarm_temp);\n  put_upper_alarm_temp(upper_alarm_temp);\n  put_monitor_mode(monitor_mode);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_lower_alarm_temp(value: Isolette_Data_Model::Temp_i)\n{\n  *extern_api::IN_lower_alarm_temp.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_upper_alarm_temp(value: Isolette_Data_Model::Temp_i)\n{\n  *extern_api::IN_upper_alarm_temp.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_monitor_mode(value: Isolette_Data_Model::Monitor_Mode)\n{\n  *extern_api::IN_monitor_mode.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_alarm_control() -> Isolette_Data_Model::On_Off\n{\n  return extern_api::OUT_alarm_control.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for GUMBO State Variable\npub fn get_lastCmd() -> Isolette_Data_Model::On_Off\n{\n  unsafe {\n    match &crate::app {\n      Some(inner) => inner.lastCmd,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n\n\/\/\/ setter for GUMBO State Variable\npub fn put_lastCmd(value: Isolette_Data_Model::On_Off)\n{\n  unsafe {\n    match &mut crate::app {\n      Some(inner) => inner.lastCmd = value,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_mt_mmm_mmm_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_mt_mmm_mmm_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_current_tempWstatus(Isolette_Data_Model::TempWstatus_i::default());\n    test_apis::put_interface_failure(Isolette_Data_Model::Failure_Flag_i::default());\n    test_apis::put_internal_failure(Isolette_Data_Model::Failure_Flag_i::default());\n\n    crate::thermostat_mt_mmm_mmm_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n    use crate::testComputeCBwGSV_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_interface_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default(),\n    api_internal_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default()\n  }\n\n  testComputeCBwGSV_macro! {\n    prop_testComputeCBwGSV_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    In_lastMonitorMode: generators::Isolette_Data_Model_Monitor_Mode_strategy_default(),\n    api_current_tempWstatus: generators::Isolette_Data_Model_TempWstatus_i_strategy_default(),\n    api_interface_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default(),\n    api_internal_failure: generators::Isolette_Data_Model_Failure_Flag_i_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  pub api_internal_failure: Isolette_Data_Model::Failure_Flag_i\n}\n\n\/\/\/ container for component's incoming port values and GUMBO state variables\npub struct PreStateContainer_wGSV {\n  pub In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  pub api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  pub api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  pub api_internal_failure: Isolette_Data_Model::Failure_Flag_i\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_interface_failure(container.api_interface_failure);\n  put_internal_failure(container.api_internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_container_wGSV(container: PreStateContainer_wGSV)\n{\n  put_lastMonitorMode(container.In_lastMonitorMode);\n  put_current_tempWstatus(container.api_current_tempWstatus);\n  put_interface_failure(container.api_interface_failure);\n  put_internal_failure(container.api_internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  internal_failure: Isolette_Data_Model::Failure_Flag_i)\n{\n  put_current_tempWstatus(current_tempWstatus);\n  put_interface_failure(interface_failure);\n  put_internal_failure(internal_failure);\n}\n\n\/\/\/ setter for component's incoming port values and GUMBO state variables\npub fn put_concrete_inputs_wGSV(\n  In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  internal_failure: Isolette_Data_Model::Failure_Flag_i)\n{\n  put_lastMonitorMode(In_lastMonitorMode);\n  put_current_tempWstatus(current_tempWstatus);\n  put_interface_failure(interface_failure);\n  put_internal_failure(internal_failure);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_current_tempWstatus(value: Isolette_Data_Model::TempWstatus_i)\n{\n  *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_interface_failure(value: Isolette_Data_Model::Failure_Flag_i)\n{\n  *extern_api::IN_interface_failure.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_internal_failure(value: Isolette_Data_Model::Failure_Flag_i)\n{\n  *extern_api::IN_internal_failure.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_monitor_mode() -> Isolette_Data_Model::Monitor_Mode\n{\n  return extern_api::OUT_monitor_mode.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for GUMBO State Variable\npub fn get_lastMonitorMode() -> Isolette_Data_Model::Monitor_Mode\n{\n  unsafe {\n    match &crate::app {\n      Some(inner) => inner.lastMonitorMode,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n\n\/\/\/ setter for GUMBO State Variable\npub fn put_lastMonitorMode(value: Isolette_Data_Model::Monitor_Mode)\n{\n  unsafe {\n    match &mut crate::app {\n      Some(inner) => inner.lastMonitorMode = value,\n      None => panic!(\"The app is None\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::thermostat_mt_dmf_dmf_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::thermostat_mt_dmf_dmf_initialize();\n    crate::thermostat_mt_dmf_dmf_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs()\n{\n\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_internal_failure() -> Isolette_Data_Model::Failure_Flag_i\n{\n  return extern_api::OUT_internal_failure.lock().unwrap().expect(\"Not expecting None\")\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\npub mod util;\n\npub mod tests;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/tests.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten if codegen is rerun\n\nmod tests {\n  \/\/ NOTE: need to run tests sequentially to prevent race conditions\n  \/\/       on the app and the testing apis which are static\n  use serial_test::serial;\n\n  use crate::test::util::*;\n  use data::*;\n\n  #[test]\n  #[serial]\n  fn test_initialization() {\n    crate::operator_interface_oip_oit_initialize();\n}\n\n  #[test]\n  #[serial]\n  fn test_compute() {\n    crate::operator_interface_oip_oit_initialize();\n\n    \/\/ populate incoming data ports\n    test_apis::put_regulator_status(Isolette_Data_Model::Status::default());\n    test_apis::put_monitor_status(Isolette_Data_Model::Status::default());\n    test_apis::put_display_temperature(Isolette_Data_Model::Temp_i::default());\n    test_apis::put_alarm_control(Isolette_Data_Model::On_Off::default());\n\n    crate::operator_interface_oip_oit_timeTriggered();\n  }\n}\n\nmod GUMBOX_tests {\n  use serial_test::serial;\n  use proptest::prelude::*;\n\n  use crate::test::util::*;\n  use crate::testInitializeCB_macro;\n  use crate::testComputeCB_macro;\n\n  \/\/ number of valid (i.e., non-rejected) test cases that must be executed for the compute method.\n  const numValidComputeTestCases: u32 = 100;\n\n  \/\/ how many total test cases (valid + rejected) that may be attempted.\n  \/\/   0 means all inputs must satisfy the precondition (if present),\n  \/\/   5 means at most 5 rejected inputs are allowed per valid test case\n  const computeRejectRatio: u32 = 5;\n\n  const verbosity: u32 = 2;\n\n  testInitializeCB_macro! {\n    prop_testInitializeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    }\n  }\n\n  testComputeCB_macro! {\n    prop_testComputeCB_macro, \/\/ test name\n    config: ProptestConfig { \/\/ proptest configuration, built by overriding fields from default config\n      cases: numValidComputeTestCases,\n      max_global_rejects: numValidComputeTestCases * computeRejectRatio,\n      verbose: verbosity,\n      ..ProptestConfig::default()\n    },\n    \/\/ strategies for generating each component input\n    api_alarm_control: generators::Isolette_Data_Model_On_Off_strategy_default(),\n    api_display_temperature: generators::Isolette_Data_Model_Temp_i_strategy_default(),\n    api_monitor_status: generators::Isolette_Data_Model_Status_strategy_default(),\n    api_regulator_status: generators::Isolette_Data_Model_Status_strategy_default()\n  }\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/util\/mod.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\npub mod test_apis;\n\npub mod cb_apis;\n\npub mod generators;\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/util\/generators.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\npub fn option_strategy_default\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>\n{\n  option_strategy_bias(1, base)\n}\n\npub fn option_strategy_bias\n  <T: Clone + std::fmt::Debug, \n   S:  Strategy<Value = T>> (\n  bias: u32,\n  base: S) -> impl Strategy<Value = Option<T>>\n{\n  prop_oneof![\n    bias => base.prop_map(Some),\n    1 => Just(None),\n  ]\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  Isolette_Data_Model_ValueStatus_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_ValueStatus_strategy_cust(\n  Valid_bias: u32,\n  Invalid_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::ValueStatus>\n{\n  prop_oneof![\n    Valid_bias => Just(Isolette_Data_Model::ValueStatus::Valid),\n    Invalid_bias => Just(Isolette_Data_Model::ValueStatus::Invalid)\n  ]\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  Isolette_Data_Model_Regulator_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Regulator_Mode_strategy_cust(\n  Init_Regulator_Mode_bias: u32,\n  Normal_Regulator_Mode_bias: u32,\n  Failed_Regulator_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Regulator_Mode>\n{\n  prop_oneof![\n    Init_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode),\n    Normal_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode),\n    Failed_Regulator_Mode_bias => Just(Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)\n  ]\n}\n\npub fn Isolette_Data_Model_Status_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  Isolette_Data_Model_Status_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Status_strategy_cust(\n  Init_Status_bias: u32,\n  On_Status_bias: u32,\n  Failed_Status_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Status>\n{\n  prop_oneof![\n    Init_Status_bias => Just(Isolette_Data_Model::Status::Init_Status),\n    On_Status_bias => Just(Isolette_Data_Model::Status::On_Status),\n    Failed_Status_bias => Just(Isolette_Data_Model::Status::Failed_Status)\n  ]\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  Isolette_Data_Model_On_Off_strategy_cust(1, 1)\n}\n\npub fn Isolette_Data_Model_On_Off_strategy_cust(\n  Onn_bias: u32,\n  Off_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::On_Off>\n{\n  prop_oneof![\n    Onn_bias => Just(Isolette_Data_Model::On_Off::Onn),\n    Off_bias => Just(Isolette_Data_Model::On_Off::Off)\n  ]\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  Isolette_Data_Model_Monitor_Mode_strategy_cust(1, 1, 1)\n}\n\npub fn Isolette_Data_Model_Monitor_Mode_strategy_cust(\n  Init_Monitor_Mode_bias: u32,\n  Normal_Monitor_Mode_bias: u32,\n  Failed_Monitor_Mode_bias: u32) -> impl Strategy<Value = Isolette_Data_Model::Monitor_Mode>\n{\n  prop_oneof![\n    Init_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode),\n    Normal_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode),\n    Failed_Monitor_Mode_bias => Just(Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)\n  ]\n}\n\npub fn Isolette_Environment_Heat_strategy_default() -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  Isolette_Environment_Heat_strategy_cust(1)\n}\n\npub fn Isolette_Environment_Heat_strategy_cust(Dummy_Head_Enum_bias: u32) -> impl Strategy<Value = Isolette_Environment::Heat>\n{\n  prop_oneof![\n    Dummy_Head_Enum_bias => Just(Isolette_Environment::Heat::Dummy_Head_Enum)\n  ]\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  Isolette_Data_Model_Temp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_Temp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::Temp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::Temp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  Isolette_Data_Model_PhysicalTemp_i_strategy_cust(\n    any::<i32>()\n  )\n}\n\npub fn Isolette_Data_Model_PhysicalTemp_i_strategy_cust<degrees_i32_strategy: Strategy<Value = i32>> (degrees_strategy: degrees_i32_strategy) -> impl Strategy<Value = Isolette_Data_Model::PhysicalTemp_i>\n{\n  (degrees_strategy).prop_map(|(degrees)| {\n    Isolette_Data_Model::PhysicalTemp_i { degrees }\n  })\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  Isolette_Data_Model_TempWstatus_i_strategy_cust(\n    any::<i32>(),\n    Isolette_Data_Model_ValueStatus_strategy_default()\n  )\n}\n\npub fn Isolette_Data_Model_TempWstatus_i_strategy_cust\n  <degrees_i32_strategy: Strategy<Value = i32>, \n   status_Isolette_Data_Model_ValueStatus_strategy: Strategy<Value = Isolette_Data_Model::ValueStatus>> (\n  degrees_strategy: degrees_i32_strategy,\n  status_strategy: status_Isolette_Data_Model_ValueStatus_strategy) -> impl Strategy<Value = Isolette_Data_Model::TempWstatus_i>\n{\n  (degrees_strategy, status_strategy).prop_map(|(degrees, status)| {\n    Isolette_Data_Model::TempWstatus_i { degrees, status }\n  })\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_default() -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  Isolette_Data_Model_Failure_Flag_i_strategy_cust(\n    any::<bool>()\n  )\n}\n\npub fn Isolette_Data_Model_Failure_Flag_i_strategy_cust<flag_bool_strategy: Strategy<Value = bool>> (flag_strategy: flag_bool_strategy) -> impl Strategy<Value = Isolette_Data_Model::Failure_Flag_i>\n{\n  (flag_strategy).prop_map(|(flag)| {\n    Isolette_Data_Model::Failure_Flag_i { flag }\n  })\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/util\/test_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse crate::bridge::extern_c_api as extern_api;\nuse data::*;\n\nuse proptest::prelude::*;\n\n\/\/\/ container for component's incoming port values\npub struct PreStateContainer {\n  pub api_regulator_status: Isolette_Data_Model::Status,\n  pub api_monitor_status: Isolette_Data_Model::Status,\n  pub api_display_temperature: Isolette_Data_Model::Temp_i,\n  pub api_alarm_control: Isolette_Data_Model::On_Off\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs_container(container: PreStateContainer)\n{\n  put_regulator_status(container.api_regulator_status);\n  put_monitor_status(container.api_monitor_status);\n  put_display_temperature(container.api_display_temperature);\n  put_alarm_control(container.api_alarm_control);\n}\n\n\/\/\/ setter for component's incoming port values\npub fn put_concrete_inputs(\n  regulator_status: Isolette_Data_Model::Status,\n  monitor_status: Isolette_Data_Model::Status,\n  display_temperature: Isolette_Data_Model::Temp_i,\n  alarm_control: Isolette_Data_Model::On_Off)\n{\n  put_regulator_status(regulator_status);\n  put_monitor_status(monitor_status);\n  put_display_temperature(display_temperature);\n  put_alarm_control(alarm_control);\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_regulator_status(value: Isolette_Data_Model::Status)\n{\n  *extern_api::IN_regulator_status.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_monitor_status(value: Isolette_Data_Model::Status)\n{\n  *extern_api::IN_monitor_status.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_display_temperature(value: Isolette_Data_Model::Temp_i)\n{\n  *extern_api::IN_display_temperature.lock().unwrap() = Some(value)\n}\n\n\/\/\/ setter for IN DataPort\npub fn put_alarm_control(value: Isolette_Data_Model::On_Off)\n{\n  *extern_api::IN_alarm_control.lock().unwrap() = Some(value)\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_lower_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  return extern_api::OUT_lower_desired_tempWstatus.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_upper_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  return extern_api::OUT_upper_desired_tempWstatus.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_lower_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  return extern_api::OUT_lower_alarm_tempWstatus.lock().unwrap().expect(\"Not expecting None\")\n}\n\n\/\/\/ getter for OUT DataPort\npub fn get_upper_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i\n{\n  return extern_api::OUT_upper_alarm_tempWstatus.lock().unwrap().expect(\"Not expecting None\")\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/GUMBO_Library\/src\/lib.rs",
        {
          "type" : "ITestResource",
          "content" : "#![cfg_attr(not(test), no_std)]\n\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n#![allow(non_upper_case_globals)]\n\n#![allow(dead_code)]\n#![allow(static_mut_refs)]\n#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(unused_parens)]\n#![allow(unused_unsafe)]\n#![allow(unused_variables)]\n\n\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\nuse vstd::prelude::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn LowerAlarmTemp_lower() -> i32\n{\n  96i32\n}\n\npub fn LowerAlarmTemp_upper() -> i32\n{\n  101i32\n}\n\npub fn UpperAlarmTemp_lower() -> i32\n{\n  97i32\n}\n\npub fn UpperAlarmTemp_upper() -> i32\n{\n  102i32\n}\n\npub fn Allowed_LowerAlarmTemp(lower: i32) -> bool\n{\n  (LowerAlarmTemp_lower() <= lower) &\n    (lower <= LowerAlarmTemp_upper())\n}\n\npub fn Allowed_UpperAlarmTemp(upper: i32) -> bool\n{\n  (UpperAlarmTemp_lower() <= upper) &\n    (upper <= UpperAlarmTemp_upper())\n}\n\npub fn Allowed_LowerAlarmTempWStatus(lower: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  impliesL!(\n    isValidTempWstatus(lower),\n    Allowed_LowerAlarmTemp(lower.degrees))\n}\n\npub fn Allowed_UpperAlarmTempWStatus(upper: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  impliesL!(\n    isValidTempWstatus(upper),\n    Allowed_UpperAlarmTemp(upper.degrees))\n}\n\npub fn Allowed_AlarmTemp_Ranges(\n  lower: i32,\n  upper: i32) -> bool\n{\n  (lower <= upper) &\n    Allowed_LowerAlarmTemp(lower) &\n    Allowed_UpperAlarmTemp(upper)\n}\n\npub fn Allowed_AlarmTempWStatus_Ranges(\n  lower: Isolette_Data_Model::TempWstatus_i,\n  upper: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  impliesL!(\n    isValidTempWstatus(lower) & isValidTempWstatus(upper),\n    Allowed_AlarmTemp_Ranges(lower.degrees, upper.degrees))\n}\n\npub fn isValidTempWstatus(value: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  value.status == Isolette_Data_Model::ValueStatus::Valid\n}\n\nverus! {\n  pub open spec fn LowerAlarmTemp_lower_spec() -> i32\n  {\n    96i32\n  }\n\n  pub open spec fn LowerAlarmTemp_upper_spec() -> i32\n  {\n    101i32\n  }\n\n  pub open spec fn UpperAlarmTemp_lower_spec() -> i32\n  {\n    97i32\n  }\n\n  pub open spec fn UpperAlarmTemp_upper_spec() -> i32\n  {\n    102i32\n  }\n\n  pub open spec fn Allowed_LowerAlarmTemp_spec(lower: i32) -> bool\n  {\n    (LowerAlarmTemp_lower_spec() <= lower) &&\n      (lower <= LowerAlarmTemp_upper_spec())\n  }\n\n  pub open spec fn Allowed_UpperAlarmTemp_spec(upper: i32) -> bool\n  {\n    (UpperAlarmTemp_lower_spec() <= upper) &&\n      (upper <= UpperAlarmTemp_upper_spec())\n  }\n\n  pub open spec fn Allowed_LowerAlarmTempWStatus_spec(lower: Isolette_Data_Model::TempWstatus_i) -> bool\n  {\n    isValidTempWstatus_spec(lower) ==> Allowed_LowerAlarmTemp_spec(lower.degrees)\n  }\n\n  pub open spec fn Allowed_UpperAlarmTempWStatus_spec(upper: Isolette_Data_Model::TempWstatus_i) -> bool\n  {\n    isValidTempWstatus_spec(upper) ==> Allowed_UpperAlarmTemp_spec(upper.degrees)\n  }\n\n  pub open spec fn Allowed_AlarmTemp_Ranges_spec(\n    lower: i32,\n    upper: i32) -> bool\n  {\n    ((lower <= upper) &&\n      Allowed_LowerAlarmTemp_spec(lower)) &&\n      Allowed_UpperAlarmTemp_spec(upper)\n  }\n\n  pub open spec fn Allowed_AlarmTempWStatus_Ranges_spec(\n    lower: Isolette_Data_Model::TempWstatus_i,\n    upper: Isolette_Data_Model::TempWstatus_i) -> bool\n  {\n    (isValidTempWstatus_spec(lower) && isValidTempWstatus_spec(upper)) ==>\n      Allowed_AlarmTemp_Ranges_spec(lower.degrees, upper.degrees)\n  }\n\n  pub open spec fn isValidTempWstatus_spec(value: Isolette_Data_Model::TempWstatus_i) -> bool\n  {\n    value.status == Isolette_Data_Model::ValueStatus::Valid\n  }\n}",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/GUMBO_Library\/Cargo.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[package]\nname = \"GUMBO_Library\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ndata = { path=\"..\/data\" }\nvstd = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", default-features=false, tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\nverus_builtin_macros = { git = \"https:\/\/github.com\/verus-lang\/verus.git\", tag=\"release\/0.2026.01.02.6f52890\" }\n\n[package.metadata.verus]\nverify = true\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/GUMBO_Library\/rust-toolchain.toml",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten if codegen is rerun\n\n[toolchain]\nchannel = \"nightly\"\ncomponents = [ \"rustfmt\", \"rust-src\", \"rustc-dev\", \"llvm-tools-preview\", \"rust-analyzer\" ]\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/bridge\/thermostat_rt_mri_mri_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn ROUND(num: i32) -> i32\n{\n  num\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee RegulatorStatusIsInitiallyInit\n  * @param api_regulator_status outgoing data port\n  *\/\npub fn initialize_RegulatorStatusIsInitiallyInit(api_regulator_status: Isolette_Data_Model::Status) -> bool\n{\n  api_regulator_status == Isolette_Data_Model::Status::Init_Status\n}\n\n\/** IEP-Guar: Initialize Entrypoint for mri\n  *\n  * @param api_displayed_temp outgoing data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_desired_temp outgoing data port\n  * @param api_regulator_status outgoing data port\n  * @param api_upper_desired_temp outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  api_displayed_temp: Isolette_Data_Model::Temp_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_status: Isolette_Data_Model::Status,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  initialize_RegulatorStatusIsInitiallyInit(api_regulator_status)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param api_displayed_temp outgoing data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_desired_temp outgoing data port\n  * @param api_regulator_status outgoing data port\n  * @param api_upper_desired_temp outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  api_displayed_temp: Isolette_Data_Model::Temp_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_status: Isolette_Data_Model::Status,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  initialize_IEP_Guar(api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes lower_is_not_higher_than_upper\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  *\/\npub fn compute_spec_lower_is_not_higher_than_upper_assume(\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  api_lower_desired_tempWstatus.degrees <= api_upper_desired_tempWstatus.degrees\n}\n\n\/** CEP-T-Assm: Top-level assume contracts for mri's compute entrypoint\n  *\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  *\/\npub fn compute_CEP_T_Assm(\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  let r0: bool = compute_spec_lower_is_not_higher_than_upper_assume(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus);\n\n  return r0;\n}\n\n\/** CEP-Pre: Compute Entrypoint Pre-Condition for mri\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  *\/\npub fn compute_CEP_Pre(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  \/\/ CEP-Assm: assume clauses of mri's compute entrypoint\n  let r0: bool = compute_CEP_T_Assm(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus);\n\n  return r0;\n}\n\n\/** guarantee REQ_MRI_1\n  *   If the Regulator Mode is INIT,\n  *   the Regulator Status shall be set to Init.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n  * @param api_regulator_mode incoming data port\n  * @param api_regulator_status outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_1(\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n    api_regulator_status == Isolette_Data_Model::Status::Init_Status)\n}\n\n\/** guarantee REQ_MRI_2\n  *   If the Regulator Mode is NORMAL,\n  *   the Regulator Status shall be set to On\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n  * @param api_regulator_mode incoming data port\n  * @param api_regulator_status outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_2(\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,\n    api_regulator_status == Isolette_Data_Model::Status::On_Status)\n}\n\n\/** guarantee REQ_MRI_3\n  *   If the Regulator Mode is FAILED,\n  *   the Regulator Status shall be set to Failed.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=107 \n  * @param api_regulator_mode incoming data port\n  * @param api_regulator_status outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_3(\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,\n    api_regulator_status == Isolette_Data_Model::Status::Failed_Status)\n}\n\n\/** guarantee REQ_MRI_4\n  *   If the Regulator Mode is NORMAL, the\n  *   Display Temperature shall be set to the value of the\n  *   Current Temperature rounded to the nearest integer.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  * @param api_current_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_displayed_temp outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_4(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_displayed_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,\n    api_displayed_temp.degrees == ROUND(api_current_tempWstatus.degrees))\n}\n\n\/** guarantee REQ_MRI_5\n  *   If the Regulator Mode is not NORMAL,\n  *   the value of the Display Temperature is UNSPECIFIED.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  *\/\npub fn compute_case_REQ_MRI_5() -> bool\n{\n  true\n}\n\n\/** guarantee REQ_MRI_6\n  *   If the Status attribute of the Lower Desired Temperature\n  *   or the Upper Desired Temperature is Invalid,\n  *   the Regulator Interface Failure shall be set to True.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  * @param api_upper_desired_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_6(\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  implies!(\n    (api_upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) |\n      (api_upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),\n    api_interface_failure.flag)\n}\n\n\/** guarantee REQ_MRI_7\n  *   If the Status attribute of the Lower Desired Temperature\n  *   and the Upper Desired Temperature is Valid,\n  *   the Regulator Interface Failure shall be set to False.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_7(\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  api_interface_failure.flag == !((api_upper_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) &\n    (api_lower_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid))\n}\n\n\/** guarantee REQ_MRI_8\n  *   If the Regulator Interface Failure is False,\n  *   the Desired Range shall be set to the Desired Temperature Range.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_desired_temp outgoing data port\n  * @param api_upper_desired_temp outgoing data port\n  *\/\npub fn compute_case_REQ_MRI_8(\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  impliesL!(\n    !(api_interface_failure.flag),\n    (api_lower_desired_temp.degrees == api_lower_desired_tempWstatus.degrees) &\n      (api_upper_desired_temp.degrees == api_upper_desired_tempWstatus.degrees))\n}\n\n\/** guarantee REQ_MRI_9\n  *   If the Regulator Interface Failure is True,\n  *   the Desired Range is UNSPECIFIED.\n  *   the Desired Range shall be set to the Desired Temperature Range.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=108 \n  *\/\npub fn compute_case_REQ_MRI_9() -> bool\n{\n  true\n}\n\n\/** CEP-T-Case: Top-Level case contracts for mri's compute entrypoint\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  * @param api_displayed_temp outgoing data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_desired_temp outgoing data port\n  * @param api_regulator_status outgoing data port\n  * @param api_upper_desired_temp outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_displayed_temp: Isolette_Data_Model::Temp_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_status: Isolette_Data_Model::Status,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  let r0: bool = compute_case_REQ_MRI_1(api_regulator_mode, api_regulator_status);\n  let r1: bool = compute_case_REQ_MRI_2(api_regulator_mode, api_regulator_status);\n  let r2: bool = compute_case_REQ_MRI_3(api_regulator_mode, api_regulator_status);\n  let r3: bool = compute_case_REQ_MRI_4(api_current_tempWstatus, api_regulator_mode, api_displayed_temp);\n  let r4: bool = compute_case_REQ_MRI_5();\n  let r5: bool = compute_case_REQ_MRI_6(api_upper_desired_tempWstatus, api_interface_failure);\n  let r6: bool = compute_case_REQ_MRI_7(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus, api_interface_failure);\n  let r7: bool = compute_case_REQ_MRI_8(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus, api_interface_failure, api_lower_desired_temp, api_upper_desired_temp);\n  let r8: bool = compute_case_REQ_MRI_9();\n\n  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for mri\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  * @param api_displayed_temp outgoing data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_desired_temp outgoing data port\n  * @param api_regulator_status outgoing data port\n  * @param api_upper_desired_temp outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_displayed_temp: Isolette_Data_Model::Temp_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_status: Isolette_Data_Model::Status,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  \/\/ CEP-T-Case: case clauses of mri's compute entrypoint\n  let r0: bool = compute_CEP_T_Case(api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus, api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp);\n\n  return r0;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mri_mri\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_rt_mri_mri_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mri_mri_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let api_displayed_temp = get_displayed_temp();\n  let api_interface_failure = get_interface_failure();\n  let api_lower_desired_temp = get_lower_desired_temp();\n  let api_regulator_status = get_regulator_status();\n  let api_upper_desired_temp = get_upper_desired_temp();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_tempWstatus incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_mri_mri_initialize();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_desired_tempWstatus(api_lower_desired_tempWstatus);\n  put_regulator_mode(api_regulator_mode);\n  put_upper_desired_tempWstatus(api_upper_desired_tempWstatus);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mri_mri_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let api_displayed_temp = get_displayed_temp();\n  let api_interface_failure = get_interface_failure();\n  let api_lower_desired_temp = get_lower_desired_temp();\n  let api_regulator_status = get_regulator_status();\n  let api_upper_desired_temp = get_upper_desired_temp();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus, api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_lower_desired_tempWstatus, container.api_regulator_mode, container.api_upper_desired_tempWstatus)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_desired_tempWstatus: $api_lower_desired_tempWstatus_strat:expr,\n    api_regulator_mode: $api_regulator_mode_strat:expr,\n    api_upper_desired_tempWstatus: $api_upper_desired_tempWstatus_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus)\n            in ($api_current_tempWstatus_strat, $api_lower_desired_tempWstatus_strat, $api_regulator_mode_strat, $api_upper_desired_tempWstatus_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/bridge\/thermostat_rt_mhs_mhs_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee initlastCmd\n  * @param lastCmd post-state state variable\n  *\/\npub fn initialize_initlastCmd(lastCmd: Isolette_Data_Model::On_Off) -> bool\n{\n  lastCmd == Isolette_Data_Model::On_Off::Off\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee REQ_MHS_1\n  *   If the Regulator Mode is INIT, the Heat Control shall be\n  *   set to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n  * @param api_heat_control outgoing data port\n  *\/\npub fn initialize_REQ_MHS_1(api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  api_heat_control == Isolette_Data_Model::On_Off::Off\n}\n\n\/** IEP-Guar: Initialize Entrypoint for mhs\n  *\n  * @param lastCmd post-state state variable\n  * @param api_heat_control outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  initialize_initlastCmd(lastCmd) &&\n  initialize_REQ_MHS_1(api_heat_control)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param lastCmd post-state state variable\n  * @param api_heat_control outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  initialize_IEP_Guar(lastCmd, api_heat_control)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes lower_is_lower_temp\n  * @param api_lower_desired_temp incoming data port\n  * @param api_upper_desired_temp incoming data port\n  *\/\npub fn compute_spec_lower_is_lower_temp_assume(\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  api_lower_desired_temp.degrees <= api_upper_desired_temp.degrees\n}\n\n\/** CEP-T-Assm: Top-level assume contracts for mhs's compute entrypoint\n  *\n  * @param api_lower_desired_temp incoming data port\n  * @param api_upper_desired_temp incoming data port\n  *\/\npub fn compute_CEP_T_Assm(\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  let r0: bool = compute_spec_lower_is_lower_temp_assume(api_lower_desired_temp, api_upper_desired_temp);\n\n  return r0;\n}\n\n\/** CEP-Pre: Compute Entrypoint Pre-Condition for mhs\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  *\/\npub fn compute_CEP_Pre(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  \/\/ CEP-Assm: assume clauses of mhs's compute entrypoint\n  let r0: bool = compute_CEP_T_Assm(api_lower_desired_temp, api_upper_desired_temp);\n\n  return r0;\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * guarantee lastCmd\n  *   Set lastCmd to value of output Cmd port\n  * @param lastCmd post-state state variable\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_spec_lastCmd_guarantee(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  lastCmd == api_heat_control\n}\n\n\/** CEP-T-Guar: Top-level guarantee contracts for mhs's compute entrypoint\n  *\n  * @param lastCmd post-state state variable\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_CEP_T_Guar(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  let r0: bool = compute_spec_lastCmd_guarantee(lastCmd, api_heat_control);\n\n  return r0;\n}\n\n\/** guarantee REQ_MHS_1\n  *   If the Regulator Mode is INIT, the Heat Control shall be\n  *   set to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n  * @param api_regulator_mode incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_case_REQ_MHS_1(\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n    api_heat_control == Isolette_Data_Model::On_Off::Off)\n}\n\n\/** guarantee REQ_MHS_2\n  *   If the Regulator Mode is NORMAL and the Current Temperature is less than\n  *   the Lower Desired Temperature, the Heat Control shall be set to On.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_case_REQ_MHS_2(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &\n      (api_current_tempWstatus.degrees < api_lower_desired_temp.degrees),\n    api_heat_control == Isolette_Data_Model::On_Off::Onn)\n}\n\n\/** guarantee REQ_MHS_3\n  *   If the Regulator Mode is NORMAL and the Current Temperature is greater than\n  *   the Upper Desired Temperature, the Heat Control shall be set to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n  * @param api_current_tempWstatus incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_case_REQ_MHS_3(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &\n      (api_current_tempWstatus.degrees > api_upper_desired_temp.degrees),\n    api_heat_control == Isolette_Data_Model::On_Off::Off)\n}\n\n\/** guarantee REQ_MHS_4\n  *   If the Regulator Mode is NORMAL and the Current\n  *   Temperature is greater than or equal to the Lower Desired Temperature\n  *   and less than or equal to the Upper Desired Temperature, the value of\n  *   the Heat Control shall not be changed.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=110 \n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_case_REQ_MHS_4(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &\n      ((api_current_tempWstatus.degrees >= api_lower_desired_temp.degrees) &\n        (api_current_tempWstatus.degrees <= api_upper_desired_temp.degrees)),\n    api_heat_control == In_lastCmd)\n}\n\n\/** guarantee REQ_MHS_5\n  *   If the Regulator Mode is FAILED, the Heat Control shall be\n  *   set to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=111 \n  * @param api_regulator_mode incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_case_REQ_MHS_5(\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,\n    api_heat_control == Isolette_Data_Model::On_Off::Off)\n}\n\n\/** CEP-T-Case: Top-Level case contracts for mhs's compute entrypoint\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  let r0: bool = compute_case_REQ_MHS_1(api_regulator_mode, api_heat_control);\n  let r1: bool = compute_case_REQ_MHS_2(api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_heat_control);\n  let r2: bool = compute_case_REQ_MHS_3(api_current_tempWstatus, api_regulator_mode, api_upper_desired_temp, api_heat_control);\n  let r3: bool = compute_case_REQ_MHS_4(In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp, api_heat_control);\n  let r4: bool = compute_case_REQ_MHS_5(api_regulator_mode, api_heat_control);\n\n  return r0 && r1 && r2 && r3 && r4;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for mhs\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  * @param api_heat_control outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i,\n  api_heat_control: Isolette_Data_Model::On_Off) -> bool\n{\n  \/\/ CEP-Guar: guarantee clauses of mhs's compute entrypoint\n  let r0: bool = compute_CEP_T_Guar(lastCmd, api_heat_control);\n\n  \/\/ CEP-T-Case: case clauses of mhs's compute entrypoint\n  let r1: bool = compute_CEP_T_Case(In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp, api_heat_control);\n\n  return r0 && r1;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mhs_mhs\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_rt_mhs_mhs_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mhs_mhs_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_heat_control = get_heat_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (lastCmd, api_heat_control) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_mhs_mhs_initialize();\n\n  \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved\n  \/\/                from the component state\n  let In_lastCmd: Isolette_Data_Model::On_Off = get_lastCmd();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_desired_temp(api_lower_desired_temp);\n  put_regulator_mode(api_regulator_mode);\n  put_upper_desired_temp(api_upper_desired_temp);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mhs_mhs_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_heat_control = get_heat_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp, api_heat_control) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_lower_desired_temp, container.api_regulator_mode, container.api_upper_desired_temp)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_desired_temp: $api_lower_desired_temp_strat:expr,\n    api_regulator_mode: $api_regulator_mode_strat:expr,\n    api_upper_desired_temp: $api_upper_desired_temp_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp)\n            in ($api_current_tempWstatus_strat, $api_lower_desired_temp_strat, $api_regulator_mode_strat, $api_upper_desired_temp_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_desired_temp incoming data port\n  * @param api_regulator_mode incoming data port\n  * @param api_upper_desired_temp incoming data port\n  *\/\npub fn testComputeCBwGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_temp: Isolette_Data_Model::Temp_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,\n  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_mhs_mhs_initialize();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_desired_temp(api_lower_desired_temp);\n  put_regulator_mode(api_regulator_mode);\n  put_upper_desired_temp(api_upper_desired_temp);\n\n  \/\/ [SetInStateVars]: set the pre-state values of state variables\n  put_lastCmd(In_lastCmd);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mhs_mhs_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_heat_control = get_heat_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp, api_heat_control) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCBwGSV_container(container: PreStateContainer_wGSV) -> HarnessResult\n{\n  return testComputeCBwGSV(container.In_lastCmd, container.api_current_tempWstatus, container.api_lower_desired_temp, container.api_regulator_mode, container.api_upper_desired_temp)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCBwGSV_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    In_lastCmd: $In_lastCmd_strat:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_desired_temp: $api_lower_desired_temp_strat:expr,\n    api_regulator_mode: $api_regulator_mode_strat:expr,\n    api_upper_desired_temp: $api_upper_desired_temp_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp)\n            in ($In_lastCmd_strat, $api_current_tempWstatus_strat, $api_lower_desired_temp_strat, $api_regulator_mode_strat, $api_upper_desired_temp_strat)\n      ) {\n        match $crate::test::util::cb_apis::testComputeCBwGSV(In_lastCmd, api_current_tempWstatus, api_lower_desired_temp, api_regulator_mode, api_upper_desired_temp) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/bridge\/thermostat_rt_mrm_mrm_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee REQ_MRM_1\n  *   The initial mode of the regular is INIT\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn initialize_REQ_MRM_1(api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode\n}\n\n\/** IEP-Guar: Initialize Entrypoint for mrm\n  *\n  * @param lastRegulatorMode post-state state variable\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  initialize_REQ_MRM_1(api_regulator_mode)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param lastRegulatorMode post-state state variable\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  initialize_IEP_Guar(lastRegulatorMode, api_regulator_mode)\n}\n\n\/** guarantee REQ_MRM_2\n  *   'transition from Init to Normal'\n  *   If the current regulator mode is Init, then\n  *   the regulator mode is set to NORMAL iff the regulator status is valid (see Table A-10), i.e.,\n  *     if NOT (Regulator Interface Failure OR Regulator Internal Failure)\n  *        AND Current Temperature.Status = Valid\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MRM_2(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  implies!(\n    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n    implies!(\n      !(api_interface_failure.flag || api_internal_failure.flag) &&\n        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),\n      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)))\n}\n\n\/** guarantee REQ_MRM_Maintain_Normal\n  *   'maintaining NORMAL, NORMAL to NORMAL'\n  *   If the current regulator mode is Normal, then\n  *   the regulator mode is stays normal iff\n  *   the regulaor status is not false i.e.,\n  *          if NOT(\n  *              (Regulator Interface Failure OR Regulator Internal Failure)\n  *              OR NOT(Current Temperature.Status = Valid)\n  *          )\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MRM_Maintain_Normal(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  implies!(\n    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,\n    implies!(\n      !(api_interface_failure.flag || api_internal_failure.flag) &&\n        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),\n      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&\n        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)))\n}\n\n\/** guarantee REQ_MRM_3\n  *   'transition for NORMAL to FAILED'\n  *   If the current regulator mode is Normal, then\n  *   the regulator mode is set to Failed iff\n  *   the regulator status is false, i.e.,\n  *      if  (Regulator Interface Failure OR Regulator Internal Failure)\n  *          OR NOT(Current Temperature.Status = Valid)\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109 \n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MRM_3(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  implies!(\n    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,\n    implies!(\n      (api_interface_failure.flag || api_internal_failure.flag) &&\n        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),\n      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)))\n}\n\n\/** guarantee REQ_MRM_4\n  *   'transition from INIT to FAILED' \n  *   If the current regulator mode is Init, then\n  *   the regulator mode and lastRegulatorMode state value is set to Failed iff\n  *   the regulator status is false, i.e.,\n  *          if  (Regulator Interface Failure OR Regulator Internal Failure)\n  *          OR NOT(Current Temperature.Status = Valid)\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109\n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MRM_4(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  implies!(\n    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,\n    implies!(\n      (api_interface_failure.flag || api_internal_failure.flag) &&\n        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),\n      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)))\n}\n\n\/** guarantee REQ_MRM_MaintainFailed\n  *   'maintaining FAIL, FAIL to FAIL'\n  *   If the current regulator mode is Failed, then\n  *   the regulator mode remains in the Failed state and the LastRegulator mode remains Failed.REQ-MRM-Maintain-Failed\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=109\n  * @param lastRegulatorMode post-state state variable\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MRM_MaintainFailed(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  implies!(\n    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,\n    (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&\n      (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode))\n}\n\n\/** CEP-T-Case: Top-Level case contracts for mrm's compute entrypoint\n  *\n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  let r0: bool = compute_case_REQ_MRM_2(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);\n  let r1: bool = compute_case_REQ_MRM_Maintain_Normal(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);\n  let r2: bool = compute_case_REQ_MRM_3(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);\n  let r3: bool = compute_case_REQ_MRM_4(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);\n  let r4: bool = compute_case_REQ_MRM_MaintainFailed(lastRegulatorMode, api_regulator_mode);\n\n  return r0 && r1 && r2 && r3 && r4;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for mrm\n  *\n  * @param In_lastRegulatorMode pre-state state variable\n  * @param lastRegulatorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_regulator_mode outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool\n{\n  \/\/ CEP-T-Case: case clauses of mrm's compute entrypoint\n  let r0: bool = compute_CEP_T_Case(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);\n\n  return r0;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_mrm_mrm\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_rt_mrm_mrm_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mrm_mrm_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastRegulatorMode = get_lastRegulatorMode();\n  let api_regulator_mode = get_regulator_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (lastRegulatorMode, api_regulator_mode) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_mrm_mrm_initialize();\n\n  \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved\n  \/\/                from the component state\n  let In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode = get_lastRegulatorMode();\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_interface_failure(api_interface_failure);\n  put_internal_failure(api_internal_failure);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mrm_mrm_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastRegulatorMode = get_lastRegulatorMode();\n  let api_regulator_mode = get_regulator_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastRegulatorMode, lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_interface_failure, container.api_internal_failure)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_interface_failure: $api_interface_failure_strat:expr,\n    api_internal_failure: $api_internal_failure_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_interface_failure, api_internal_failure)\n            in ($api_current_tempWstatus_strat, $api_interface_failure_strat, $api_internal_failure_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_interface_failure, api_internal_failure) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param In_lastRegulatorMode pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  *\/\npub fn testComputeCBwGSV(\n  In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_mrm_mrm_initialize();\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_interface_failure(api_interface_failure);\n  put_internal_failure(api_internal_failure);\n\n  \/\/ [SetInStateVars]: set the pre-state values of state variables\n  put_lastRegulatorMode(In_lastRegulatorMode);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_mrm_mrm_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastRegulatorMode = get_lastRegulatorMode();\n  let api_regulator_mode = get_regulator_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastRegulatorMode, lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCBwGSV_container(container: PreStateContainer_wGSV) -> HarnessResult\n{\n  return testComputeCBwGSV(container.In_lastRegulatorMode, container.api_current_tempWstatus, container.api_interface_failure, container.api_internal_failure)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCBwGSV_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    In_lastRegulatorMode: $In_lastRegulatorMode_strat:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_interface_failure: $api_interface_failure_strat:expr,\n    api_internal_failure: $api_internal_failure_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (In_lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure)\n            in ($In_lastRegulatorMode_strat, $api_current_tempWstatus_strat, $api_interface_failure_strat, $api_internal_failure_strat)\n      ) {\n        match $crate::test::util::cb_apis::testComputeCBwGSV(In_lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/bridge\/thermostat_rt_drf_drf_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_rt_drf_drf\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_rt_drf_drf_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_drf_drf_initialize();\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  *\/\npub fn testComputeCB() -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_rt_drf_drf_initialize();\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_rt_drf_drf_timeTriggered();\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB()\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        empty in ::proptest::strategy::Just(())\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/bridge\/thermostat_mt_mmi_mmi_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn timeout_condition_satisfied() -> bool\n{\n  true\n}\n\n\/** I-Assm: Integration constraint on mmi's incoming data port upper_alarm_tempWstatus\n  *\n  * assume Allowed_UpperAlarmTemp\n  *\/\npub fn I_Assm_upper_alarm_tempWstatus(upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_UpperAlarmTempWStatus(upper_alarm_tempWstatus)\n}\n\n\/** I-Assm: Integration constraint on mmi's incoming data port lower_alarm_tempWstatus\n  *\n  * assume Allowed_LowerAlarmTemp\n  *\/\npub fn I_Assm_lower_alarm_tempWstatus(lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_LowerAlarmTempWStatus(lower_alarm_tempWstatus)\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee monitorStatusInitiallyInit\n  * @param api_monitor_status outgoing data port\n  *\/\npub fn initialize_monitorStatusInitiallyInit(api_monitor_status: Isolette_Data_Model::Status) -> bool\n{\n  api_monitor_status == Isolette_Data_Model::Status::Init_Status\n}\n\n\/** IEP-Guar: Initialize Entrypoint for mmi\n  *\n  * @param lastCmd post-state state variable\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_alarm_temp outgoing data port\n  * @param api_monitor_status outgoing data port\n  * @param api_upper_alarm_temp outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  initialize_monitorStatusInitiallyInit(api_monitor_status)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param lastCmd post-state state variable\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_alarm_temp outgoing data port\n  * @param api_monitor_status outgoing data port\n  * @param api_upper_alarm_temp outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  initialize_IEP_Guar(lastCmd, api_interface_failure, api_lower_alarm_temp, api_monitor_status, api_upper_alarm_temp)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes Allowed_AlarmTempWstatus_Ranges\n  *   An integration constraint can only refer to a single port, so need a general assume clause\n  *   in order to relate the lower and uper temps\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  *\/\npub fn compute_spec_Allowed_AlarmTempWstatus_Ranges_assume(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_AlarmTempWStatus_Ranges(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus)\n}\n\n\/** CEP-T-Assm: Top-level assume contracts for mmi's compute entrypoint\n  *\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  *\/\npub fn compute_CEP_T_Assm(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  let r0: bool = compute_spec_Allowed_AlarmTempWstatus_Ranges_assume(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus);\n\n  return r0;\n}\n\n\/** CEP-Pre: Compute Entrypoint Pre-Condition for mmi\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  *\/\npub fn compute_CEP_Pre(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  \/\/ I-Assm-Guard: Integration constraints for mmi's incoming ports\n  let r0: bool = I_Assm_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus);\n  let r1: bool = I_Assm_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus);\n\n  \/\/ CEP-Assm: assume clauses of mmi's compute entrypoint\n  let r2: bool = compute_CEP_T_Assm(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus);\n\n  return r0 && r1 && r2;\n}\n\n\/** guarantee REQ_MMI_1\n  *   If the Manage Monitor Interface mode is INIT,\n  *   the Monitor Status shall be set to Init.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_monitor_mode incoming data port\n  * @param api_monitor_status outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_1(\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n    api_monitor_status == Isolette_Data_Model::Status::Init_Status)\n}\n\n\/** guarantee REQ_MMI_2\n  *   If the Manage Monitor Interface mode is NORMAL,\n  *   the Monitor Status shall be set to On\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_monitor_mode incoming data port\n  * @param api_monitor_status outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_2(\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode,\n    api_monitor_status == Isolette_Data_Model::Status::On_Status)\n}\n\n\/** guarantee REQ_MMI_3\n  *   If the Manage Monitor Interface mode is FAILED,\n  *   the Monitor Status shall be set to Failed.\n  *   Latency: < Max Operator Response Time\n  *   Tolerance: N\/A\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_monitor_mode incoming data port\n  * @param api_monitor_status outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_3(\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_status: Isolette_Data_Model::Status) -> bool\n{\n  implies!(\n    api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode,\n    api_monitor_status == Isolette_Data_Model::Status::Failed_Status)\n}\n\n\/** guarantee REQ_MMI_4\n  *   If the Status attribute of the Lower Alarm Temperature\n  *   or the Upper Alarm Temperature is Invalid,\n  *   the Monitor Interface Failure shall be set to True\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_4(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  implies!(\n    (api_lower_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Invalid) |\n      (api_upper_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Invalid),\n    api_interface_failure.flag)\n}\n\n\/** guarantee REQ_MMI_5\n  *   If the Status attribute of the Lower Alarm Temperature\n  *   and the Upper Alarm Temperature is Valid,\n  *   the Monitor Interface Failure shall be set to False\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_5(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  implies!(\n    (api_lower_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) &\n      (api_upper_alarm_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),\n    !(api_interface_failure.flag))\n}\n\n\/** guarantee REQ_MMI_6\n  *   If the Monitor Interface Failure is False,\n  *   the Alarm Range variable shall be set to the Desired Temperature Range\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_alarm_temp outgoing data port\n  * @param api_upper_alarm_temp outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_6(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  implies!(\n    !(api_interface_failure.flag),\n    (api_lower_alarm_temp.degrees == api_lower_alarm_tempWstatus.degrees) &\n      (api_upper_alarm_temp.degrees == api_upper_alarm_tempWstatus.degrees))\n}\n\n\/** guarantee REQ_MMI_7\n  *   If the Monitor Interface Failure is True,\n  *   the Alarm Range variable is UNSPECIFIED\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=113 \n  * @param api_interface_failure outgoing data port\n  *\/\npub fn compute_case_REQ_MMI_7(api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool\n{\n  implies!(\n    api_interface_failure.flag,\n    true)\n}\n\n\/** CEP-T-Case: Top-Level case contracts for mmi's compute entrypoint\n  *\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_alarm_temp outgoing data port\n  * @param api_monitor_status outgoing data port\n  * @param api_upper_alarm_temp outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  let r0: bool = compute_case_REQ_MMI_1(api_monitor_mode, api_monitor_status);\n  let r1: bool = compute_case_REQ_MMI_2(api_monitor_mode, api_monitor_status);\n  let r2: bool = compute_case_REQ_MMI_3(api_monitor_mode, api_monitor_status);\n  let r3: bool = compute_case_REQ_MMI_4(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus, api_interface_failure);\n  let r4: bool = compute_case_REQ_MMI_5(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus, api_interface_failure);\n  let r5: bool = compute_case_REQ_MMI_6(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus, api_interface_failure, api_lower_alarm_temp, api_upper_alarm_temp);\n  let r6: bool = compute_case_REQ_MMI_7(api_interface_failure);\n\n  return r0 && r1 && r2 && r3 && r4 && r5 && r6;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for mmi\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  * @param api_interface_failure outgoing data port\n  * @param api_lower_alarm_temp outgoing data port\n  * @param api_monitor_status outgoing data port\n  * @param api_upper_alarm_temp outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  \/\/ I-Guar-Guard: Integration constraints for mmi's outgoing ports\n  let r0: bool = I_Assm_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus);\n  let r1: bool = I_Assm_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus);\n\n  \/\/ CEP-T-Case: case clauses of mmi's compute entrypoint\n  let r2: bool = compute_CEP_T_Case(api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus, api_interface_failure, api_lower_alarm_temp, api_monitor_status, api_upper_alarm_temp);\n\n  return r0 && r1 && r2;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmi_mmi\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_mt_mmi_mmi_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmi_mmi_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_interface_failure = get_interface_failure();\n  let api_lower_alarm_temp = get_lower_alarm_temp();\n  let api_monitor_status = get_monitor_status();\n  let api_upper_alarm_temp = get_upper_alarm_temp();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (lastCmd, api_interface_failure, api_lower_alarm_temp, api_monitor_status, api_upper_alarm_temp) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_mmi_mmi_initialize();\n\n  \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved\n  \/\/                from the component state\n  let In_lastCmd: Isolette_Data_Model::On_Off = get_lastCmd();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus);\n  put_monitor_mode(api_monitor_mode);\n  put_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmi_mmi_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_interface_failure = get_interface_failure();\n  let api_lower_alarm_temp = get_lower_alarm_temp();\n  let api_monitor_status = get_monitor_status();\n  let api_upper_alarm_temp = get_upper_alarm_temp();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus, api_interface_failure, api_lower_alarm_temp, api_monitor_status, api_upper_alarm_temp) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_lower_alarm_tempWstatus, container.api_monitor_mode, container.api_upper_alarm_tempWstatus)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_alarm_tempWstatus: $api_lower_alarm_tempWstatus_strat:expr,\n    api_monitor_mode: $api_monitor_mode_strat:expr,\n    api_upper_alarm_tempWstatus: $api_upper_alarm_tempWstatus_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus)\n            in ($api_current_tempWstatus_strat, $api_lower_alarm_tempWstatus_strat, $api_monitor_mode_strat, $api_upper_alarm_tempWstatus_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_tempWstatus incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_tempWstatus incoming data port\n  *\/\npub fn testComputeCBwGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_mmi_mmi_initialize();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus);\n  put_monitor_mode(api_monitor_mode);\n  put_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus);\n\n  \/\/ [SetInStateVars]: set the pre-state values of state variables\n  put_lastCmd(In_lastCmd);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmi_mmi_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_interface_failure = get_interface_failure();\n  let api_lower_alarm_temp = get_lower_alarm_temp();\n  let api_monitor_status = get_monitor_status();\n  let api_upper_alarm_temp = get_upper_alarm_temp();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus, api_interface_failure, api_lower_alarm_temp, api_monitor_status, api_upper_alarm_temp) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCBwGSV_container(container: PreStateContainer_wGSV) -> HarnessResult\n{\n  return testComputeCBwGSV(container.In_lastCmd, container.api_current_tempWstatus, container.api_lower_alarm_tempWstatus, container.api_monitor_mode, container.api_upper_alarm_tempWstatus)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCBwGSV_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    In_lastCmd: $In_lastCmd_strat:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_alarm_tempWstatus: $api_lower_alarm_tempWstatus_strat:expr,\n    api_monitor_mode: $api_monitor_mode_strat:expr,\n    api_upper_alarm_tempWstatus: $api_upper_alarm_tempWstatus_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (In_lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus)\n            in ($In_lastCmd_strat, $api_current_tempWstatus_strat, $api_lower_alarm_tempWstatus_strat, $api_monitor_mode_strat, $api_upper_alarm_tempWstatus_strat)\n      ) {\n        match $crate::test::util::cb_apis::testComputeCBwGSV(In_lastCmd, api_current_tempWstatus, api_lower_alarm_tempWstatus, api_monitor_mode, api_upper_alarm_tempWstatus) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/bridge\/thermostat_mt_ma_ma_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn timeout_condition_satisfied() -> bool\n{\n  true\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee REQ_MA_1\n  *   If the Monitor Mode is INIT, the Alarm Control shall be set\n  *   to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param lastCmd post-state state variable\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn initialize_REQ_MA_1(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  (api_alarm_control == Isolette_Data_Model::On_Off::Off) &\n    (lastCmd == Isolette_Data_Model::On_Off::Off)\n}\n\n\/** IEP-Guar: Initialize Entrypoint for ma\n  *\n  * @param lastCmd post-state state variable\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  initialize_REQ_MA_1(lastCmd, api_alarm_control)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param lastCmd post-state state variable\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  initialize_IEP_Guar(lastCmd, api_alarm_control)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes Figure_A_7\n  *   This is not explicitly stated in the requirements, but a reasonable\n  *   assumption is that the lower alarm must be at least 1.0f less than\n  *   the upper alarm in order to account for the 0.5f tolerance\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param api_lower_alarm_temp incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn compute_spec_Figure_A_7_assume(\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  api_upper_alarm_temp.degrees - api_lower_alarm_temp.degrees >= 1i32\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes Table_A_12_LowerAlarmTemp\n  *   Range [96..101]\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n  * @param api_lower_alarm_temp incoming data port\n  *\/\npub fn compute_spec_Table_A_12_LowerAlarmTemp_assume(api_lower_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  GUMBO_Library::Allowed_LowerAlarmTemp(api_lower_alarm_temp.degrees)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * assumes Table_A_12_UpperAlarmTemp\n  *   Range [97..102]\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn compute_spec_Table_A_12_UpperAlarmTemp_assume(api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  GUMBO_Library::Allowed_UpperAlarmTemp(api_upper_alarm_temp.degrees)\n}\n\n\/** CEP-T-Assm: Top-level assume contracts for ma's compute entrypoint\n  *\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn compute_CEP_T_Assm(\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  let r0: bool = compute_spec_Figure_A_7_assume(api_lower_alarm_temp, api_upper_alarm_temp);\n  let r1: bool = compute_spec_Table_A_12_LowerAlarmTemp_assume(api_lower_alarm_temp);\n  let r2: bool = compute_spec_Table_A_12_UpperAlarmTemp_assume(api_upper_alarm_temp);\n\n  return r0 && r1 && r2;\n}\n\n\/** CEP-Pre: Compute Entrypoint Pre-Condition for ma\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn compute_CEP_Pre(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> bool\n{\n  \/\/ CEP-Assm: assume clauses of ma's compute entrypoint\n  let r0: bool = compute_CEP_T_Assm(api_lower_alarm_temp, api_upper_alarm_temp);\n\n  return r0;\n}\n\n\/** guarantee REQ_MA_1\n  *   If the Monitor Mode is INIT, the Alarm Control shall be set\n  *   to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param lastCmd post-state state variable\n  * @param api_monitor_mode incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_case_REQ_MA_1(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n    (api_alarm_control == Isolette_Data_Model::On_Off::Off) &\n      (lastCmd == Isolette_Data_Model::On_Off::Off))\n}\n\n\/** guarantee REQ_MA_2\n  *   If the Monitor Mode is NORMAL and the Current Temperature is\n  *   less than the Lower Alarm Temperature or greater than the Upper Alarm\n  *   Temperature, the Alarm Control shall be set to On.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_case_REQ_MA_2(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &\n      ((api_current_tempWstatus.degrees < api_lower_alarm_temp.degrees) ||\n        (api_current_tempWstatus.degrees > api_upper_alarm_temp.degrees)),\n    (api_alarm_control == Isolette_Data_Model::On_Off::Onn) &\n      (lastCmd == Isolette_Data_Model::On_Off::Onn))\n}\n\n\/** guarantee REQ_MA_3\n  *   If the Monitor Mode is NORMAL and the Current Temperature\n  *   is greater than or equal to the Lower Alarm Temperature and less than\n  *   the Lower Alarm Temperature +0.5 degrees, or the Current Temperature is\n  *   greater than the Upper Alarm Temperature -0.5 degrees and less than or equal\n  *   to the Upper Alarm Temperature, the value of the Alarm Control shall\n  *   not be changed.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param In_lastCmd pre-state state variable\n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_case_REQ_MA_3(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &\n      ((api_current_tempWstatus.degrees >= api_lower_alarm_temp.degrees) &&\n        (api_current_tempWstatus.degrees < api_lower_alarm_temp.degrees + 1i32) ||\n        (api_current_tempWstatus.degrees > api_upper_alarm_temp.degrees - 1i32) &&\n          (api_current_tempWstatus.degrees <= api_upper_alarm_temp.degrees)),\n    (api_alarm_control == In_lastCmd) &\n      (lastCmd == In_lastCmd))\n}\n\n\/** guarantee REQ_MA_4\n  *   If the Monitor Mode is NORMAL and the value of the Current\n  *   Temperature is greater than or equal to the Lower Alarm Temperature\n  *   +0.5 degrees and less than or equal to the Upper Alarm Temperature\n  *   -0.5 degrees, the Alarm Control shall be set to Off.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=115 \n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_case_REQ_MA_4(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode) &\n      ((api_current_tempWstatus.degrees >= api_lower_alarm_temp.degrees + 1i32) &\n        (api_current_tempWstatus.degrees <= api_upper_alarm_temp.degrees - 1i32)),\n    (api_alarm_control == Isolette_Data_Model::On_Off::Off) &\n      (lastCmd == Isolette_Data_Model::On_Off::Off))\n}\n\n\/** guarantee REQ_MA_5\n  *   If the Monitor Mode is FAILED, the Alarm Control shall be\n  *   set to On.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=116 \n  * @param lastCmd post-state state variable\n  * @param api_monitor_mode incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_case_REQ_MA_5(\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  implies!(\n    api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode,\n    (api_alarm_control == Isolette_Data_Model::On_Off::Onn) &\n      (lastCmd == Isolette_Data_Model::On_Off::Onn))\n}\n\n\/** CEP-T-Case: Top-Level case contracts for ma's compute entrypoint\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  let r0: bool = compute_case_REQ_MA_1(lastCmd, api_monitor_mode, api_alarm_control);\n  let r1: bool = compute_case_REQ_MA_2(lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control);\n  let r2: bool = compute_case_REQ_MA_3(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control);\n  let r3: bool = compute_case_REQ_MA_4(lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control);\n  let r4: bool = compute_case_REQ_MA_5(lastCmd, api_monitor_mode, api_alarm_control);\n\n  return r0 && r1 && r2 && r3 && r4;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for ma\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param lastCmd post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  * @param api_alarm_control outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_alarm_control: Isolette_Data_Model::On_Off) -> bool\n{\n  \/\/ CEP-T-Case: case clauses of ma's compute entrypoint\n  let r0: bool = compute_CEP_T_Case(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control);\n\n  return r0;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_ma_ma\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_mt_ma_ma_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_ma_ma_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_alarm_control = get_alarm_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (lastCmd, api_alarm_control) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_ma_ma_initialize();\n\n  \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved\n  \/\/                from the component state\n  let In_lastCmd: Isolette_Data_Model::On_Off = get_lastCmd();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_alarm_temp(api_lower_alarm_temp);\n  put_monitor_mode(api_monitor_mode);\n  put_upper_alarm_temp(api_upper_alarm_temp);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_ma_ma_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_alarm_control = get_alarm_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_lower_alarm_temp, container.api_monitor_mode, container.api_upper_alarm_temp)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_alarm_temp: $api_lower_alarm_temp_strat:expr,\n    api_monitor_mode: $api_monitor_mode_strat:expr,\n    api_upper_alarm_temp: $api_upper_alarm_temp_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp)\n            in ($api_current_tempWstatus_strat, $api_lower_alarm_temp_strat, $api_monitor_mode_strat, $api_upper_alarm_temp_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param In_lastCmd pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_lower_alarm_temp incoming data port\n  * @param api_monitor_mode incoming data port\n  * @param api_upper_alarm_temp incoming data port\n  *\/\npub fn testComputeCBwGSV(\n  In_lastCmd: Isolette_Data_Model::On_Off,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_alarm_temp: Isolette_Data_Model::Temp_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode,\n  api_upper_alarm_temp: Isolette_Data_Model::Temp_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_ma_ma_initialize();\n\n  \/\/ [CheckPre]: check\/filter based on pre-condition.\n  if !GUMBOX::compute_CEP_Pre (In_lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp) {\n    return HarnessResult::RejectedPrecondition;\n  }\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_lower_alarm_temp(api_lower_alarm_temp);\n  put_monitor_mode(api_monitor_mode);\n  put_upper_alarm_temp(api_upper_alarm_temp);\n\n  \/\/ [SetInStateVars]: set the pre-state values of state variables\n  put_lastCmd(In_lastCmd);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_ma_ma_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastCmd = get_lastCmd();\n  let api_alarm_control = get_alarm_control();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastCmd, lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp, api_alarm_control) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCBwGSV_container(container: PreStateContainer_wGSV) -> HarnessResult\n{\n  return testComputeCBwGSV(container.In_lastCmd, container.api_current_tempWstatus, container.api_lower_alarm_temp, container.api_monitor_mode, container.api_upper_alarm_temp)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCBwGSV_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    In_lastCmd: $In_lastCmd_strat:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_lower_alarm_temp: $api_lower_alarm_temp_strat:expr,\n    api_monitor_mode: $api_monitor_mode_strat:expr,\n    api_upper_alarm_temp: $api_upper_alarm_temp_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (In_lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp)\n            in ($In_lastCmd_strat, $api_current_tempWstatus_strat, $api_lower_alarm_temp_strat, $api_monitor_mode_strat, $api_upper_alarm_temp_strat)\n      ) {\n        match $crate::test::util::cb_apis::testComputeCBwGSV(In_lastCmd, api_current_tempWstatus, api_lower_alarm_temp, api_monitor_mode, api_upper_alarm_temp) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/bridge\/thermostat_mt_mmm_mmm_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn timeout_condition_satisfied() -> bool\n{\n  false\n}\n\n\/** Initialize EntryPointContract\n  *\n  * guarantee REQ_MMM_1\n  *   Upon the first dispatch of the thread, the monitor mode is Init.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn initialize_REQ_MMM_1(api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode\n}\n\n\/** IEP-Guar: Initialize Entrypoint for mmm\n  *\n  * @param lastMonitorMode post-state state variable\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn initialize_IEP_Guar(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  initialize_REQ_MMM_1(api_monitor_mode)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param lastMonitorMode post-state state variable\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  initialize_IEP_Guar(lastMonitorMode, api_monitor_mode)\n}\n\n\/** guarantee REQ_MMM_2\n  *   If the current mode is Init, then\n  *   the mode is set to NORMAL iff the monitor status is true (valid) (see Table A-15), i.e.,\n  *   if  NOT (Monitor Interface Failure OR Monitor Internal Failure)\n  *   AND Current Temperature.Status = Valid\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n  * @param lastMonitorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MMM_2(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  implies!(\n    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n    implies!(\n      !(api_interface_failure.flag || api_internal_failure.flag) &&\n        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),\n      (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode)))\n}\n\n\/** guarantee REQ_MMM_3\n  *   If the current Monitor mode is Normal, then\n  *   the Monitor mode is set to Failed iff\n  *   the Monitor status is false, i.e.,\n  *   if  (Monitor Interface Failure OR Monitor Internal Failure)\n  *   OR NOT(Current Temperature.Status = Valid)\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n  * @param lastMonitorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MMM_3(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  implies!(\n    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode,\n    implies!(\n      api_interface_failure.flag || api_internal_failure.flag ||\n        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),\n      (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)))\n}\n\n\/** guarantee REQ_MMM_4\n  *   If the current mode is Init, then\n  *   the mode is set to Failed iff the time during\n  *   which the thread has been in Init mode exceeds the\n  *   Monitor Init Timeout value.\n  *   http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=114 \n  * @param lastMonitorMode post-state state variable\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn compute_case_REQ_MMM_4(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  implies!(\n    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,\n    timeout_condition_satisfied() == (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode))\n}\n\n\/** CEP-T-Case: Top-Level case contracts for mmm's compute entrypoint\n  *\n  * @param lastMonitorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn compute_CEP_T_Case(\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  let r0: bool = compute_case_REQ_MMM_2(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);\n  let r1: bool = compute_case_REQ_MMM_3(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);\n  let r2: bool = compute_case_REQ_MMM_4(lastMonitorMode, api_monitor_mode);\n\n  return r0 && r1 && r2;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for mmm\n  *\n  * @param In_lastMonitorMode pre-state state variable\n  * @param lastMonitorMode post-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  * @param api_monitor_mode outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool\n{\n  \/\/ CEP-T-Case: case clauses of mmm's compute entrypoint\n  let r0: bool = compute_CEP_T_Case(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);\n\n  return r0;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_mmm_mmm\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_mt_mmm_mmm_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmm_mmm_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastMonitorMode = get_lastMonitorMode();\n  let api_monitor_mode = get_monitor_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (lastMonitorMode, api_monitor_mode) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  *\/\npub fn testComputeCB(\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_mmm_mmm_initialize();\n\n  \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved\n  \/\/                from the component state\n  let In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode = get_lastMonitorMode();\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_interface_failure(api_interface_failure);\n  put_internal_failure(api_internal_failure);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmm_mmm_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastMonitorMode = get_lastMonitorMode();\n  let api_monitor_mode = get_monitor_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastMonitorMode, lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_current_tempWstatus, container.api_interface_failure, container.api_internal_failure)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_interface_failure: $api_interface_failure_strat:expr,\n    api_internal_failure: $api_internal_failure_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_current_tempWstatus, api_interface_failure, api_internal_failure)\n            in ($api_current_tempWstatus_strat, $api_interface_failure_strat, $api_internal_failure_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_current_tempWstatus, api_interface_failure, api_internal_failure) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param In_lastMonitorMode pre-state state variable\n  * @param api_current_tempWstatus incoming data port\n  * @param api_interface_failure incoming data port\n  * @param api_internal_failure incoming data port\n  *\/\npub fn testComputeCBwGSV(\n  In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,\n  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,\n  api_internal_failure: Isolette_Data_Model::Failure_Flag_i) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_mmm_mmm_initialize();\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_current_tempWstatus(api_current_tempWstatus);\n  put_interface_failure(api_interface_failure);\n  put_internal_failure(api_internal_failure);\n\n  \/\/ [SetInStateVars]: set the pre-state values of state variables\n  put_lastMonitorMode(In_lastMonitorMode);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_mmm_mmm_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let lastMonitorMode = get_lastMonitorMode();\n  let api_monitor_mode = get_monitor_mode();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(In_lastMonitorMode, lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCBwGSV_container(container: PreStateContainer_wGSV) -> HarnessResult\n{\n  return testComputeCBwGSV(container.In_lastMonitorMode, container.api_current_tempWstatus, container.api_interface_failure, container.api_internal_failure)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCBwGSV_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    In_lastMonitorMode: $In_lastMonitorMode_strat:expr,\n    api_current_tempWstatus: $api_current_tempWstatus_strat:expr,\n    api_interface_failure: $api_interface_failure_strat:expr,\n    api_internal_failure: $api_internal_failure_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (In_lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure)\n            in ($In_lastMonitorMode_strat, $api_current_tempWstatus_strat, $api_interface_failure_strat, $api_internal_failure_strat)\n      ) {\n        match $crate::test::util::cb_apis::testComputeCBwGSV(In_lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/bridge\/thermostat_mt_dmf_dmf_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/thermostat_mt_dmf_dmf\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::thermostat_mt_dmf_dmf_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_dmf_dmf_initialize();\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  *\/\npub fn testComputeCB() -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::thermostat_mt_dmf_dmf_initialize();\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::thermostat_mt_dmf_dmf_timeTriggered();\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB()\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        empty in ::proptest::strategy::Just(())\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/bridge\/operator_interface_oip_oit_GUMBOX.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nmacro_rules! implies {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs || $rhs\n  };\n}\n\nmacro_rules! impliesL {\n  ($lhs: expr, $rhs: expr) => {\n    !$lhs | $rhs\n  };\n}\n\npub fn Allowed_UpperAlarmTempWStatus(upper: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_UpperAlarmTempWStatus(upper)\n}\n\n\/** I-Guar: Integration constraint on oit's outgoing data port lower_alarm_tempWstatus\n  *\n  * guarantee Allowed_LowerAlarmTempWstatus\n  *  Table_A_12_LowerAlarmTemp: Range [96..101]:\n  *  http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n  *\/\npub fn I_Guar_lower_alarm_tempWstatus(lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_LowerAlarmTempWStatus(lower_alarm_tempWstatus)\n}\n\n\/** I-Guar: Integration constraint on oit's outgoing data port upper_alarm_tempWstatus\n  *\n  * guarantee Allowed_UpperAlarmTempWstatus\n  *  Table_A_12_UpperAlarmTemp: Range [97..102]\n  *  http:\/\/pub.santoslab.org\/high-assurance\/module-requirements\/reading\/FAA-DoT-Requirements-AR-08-32.pdf#page=112 \n  *\/\npub fn I_Guar_upper_alarm_tempWstatus(upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  Allowed_UpperAlarmTempWStatus(upper_alarm_tempWstatus)\n}\n\n\/** IEP-Post: Initialize Entrypoint Post-Condition\n  *\n  * @param api_lower_alarm_tempWstatus outgoing data port\n  * @param api_lower_desired_tempWstatus outgoing data port\n  * @param api_upper_alarm_tempWstatus outgoing data port\n  * @param api_upper_desired_tempWstatus outgoing data port\n  *\/\npub fn initialize_IEP_Post(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  \/\/ I-Guar-Guard: Integration constraints for oit's outgoing ports\"\n  I_Guar_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus) &\n  I_Guar_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus)\n}\n\n\/** Compute Entrypoint Contract\n  *\n  * guarantee Allowed_AlarmTempWStatus_Ranges\n  *   An integration constraint can only refer to a single port, so need a general requires\n  *   clause to relate the lower and upper temps\n  * @param api_lower_alarm_tempWstatus outgoing data port\n  * @param api_upper_alarm_tempWstatus outgoing data port\n  *\/\npub fn compute_spec_Allowed_AlarmTempWStatus_Ranges_guarantee(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  GUMBO_Library::Allowed_AlarmTempWStatus_Ranges(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus)\n}\n\n\/** CEP-T-Guar: Top-level guarantee contracts for oit's compute entrypoint\n  *\n  * @param api_lower_alarm_tempWstatus outgoing data port\n  * @param api_upper_alarm_tempWstatus outgoing data port\n  *\/\npub fn compute_CEP_T_Guar(\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  let r0: bool = compute_spec_Allowed_AlarmTempWStatus_Ranges_guarantee(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus);\n\n  return r0;\n}\n\n\/** CEP-Post: Compute Entrypoint Post-Condition for oit\n  *\n  * @param api_alarm_control incoming data port\n  * @param api_display_temperature incoming data port\n  * @param api_monitor_status incoming data port\n  * @param api_regulator_status incoming data port\n  * @param api_lower_alarm_tempWstatus outgoing data port\n  * @param api_lower_desired_tempWstatus outgoing data port\n  * @param api_upper_alarm_tempWstatus outgoing data port\n  * @param api_upper_desired_tempWstatus outgoing data port\n  *\/\npub fn compute_CEP_Post(\n  api_alarm_control: Isolette_Data_Model::On_Off,\n  api_display_temperature: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_regulator_status: Isolette_Data_Model::Status,\n  api_lower_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_alarm_tempWstatus: Isolette_Data_Model::TempWstatus_i,\n  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool\n{\n  \/\/ I-Guar-Guard: Integration constraints for oit's outgoing ports\n  let r0: bool = I_Guar_lower_alarm_tempWstatus(api_lower_alarm_tempWstatus);\n  let r1: bool = I_Guar_upper_alarm_tempWstatus(api_upper_alarm_tempWstatus);\n\n  \/\/ CEP-Guar: guarantee clauses of oit's compute entrypoint\n  let r2: bool = compute_CEP_T_Guar(api_lower_alarm_tempWstatus, api_upper_alarm_tempWstatus);\n\n  return r0 && r1 && r2;\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "microkit\/crates\/operator_interface_oip_oit\/src\/test\/util\/cb_apis.rs",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if codegen is rerun\n\nuse data::*;\n\nuse proptest::prelude::*;\n\nuse super::test_apis::*;\n\nuse crate::bridge::operator_interface_oip_oit_GUMBOX as GUMBOX;\n\npub enum HarnessResult {\n  RejectedPrecondition,\n  FailedPostcondition(TestCaseError),\n  Passed,\n}\n\n\/** Contract-based test harness for the initialize entry point\n  *\/\npub fn testInitializeCB() -> HarnessResult\n{\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::operator_interface_oip_oit_initialize();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let api_lower_alarm_tempWstatus = get_lower_alarm_tempWstatus();\n  let api_lower_desired_tempWstatus = get_lower_desired_tempWstatus();\n  let api_upper_alarm_tempWstatus = get_upper_alarm_tempWstatus();\n  let api_upper_desired_tempWstatus = get_upper_desired_tempWstatus();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::initialize_IEP_Post (api_lower_alarm_tempWstatus, api_lower_desired_tempWstatus, api_upper_alarm_tempWstatus, api_upper_desired_tempWstatus) {\n    return HarnessResult::FailedPostcondition(\n      TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into())\n    );\n  }\n\n  return HarnessResult::Passed\n}\n\n#[macro_export]\nmacro_rules!\ntestInitializeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(empty in ::proptest::strategy::Just(())) {\n        match $crate::test::util::cb_apis::testInitializeCB() {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            unreachable!(\"This branch is infeasible\")\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\n  * @param api_alarm_control incoming data port\n  * @param api_display_temperature incoming data port\n  * @param api_monitor_status incoming data port\n  * @param api_regulator_status incoming data port\n  *\/\npub fn testComputeCB(\n  api_alarm_control: Isolette_Data_Model::On_Off,\n  api_display_temperature: Isolette_Data_Model::Temp_i,\n  api_monitor_status: Isolette_Data_Model::Status,\n  api_regulator_status: Isolette_Data_Model::Status) -> HarnessResult\n{\n  \/\/ Initialize the app\n  crate::operator_interface_oip_oit_initialize();\n\n  \/\/ [PutInPorts]: Set values on the input ports\n  put_alarm_control(api_alarm_control);\n  put_display_temperature(api_display_temperature);\n  put_monitor_status(api_monitor_status);\n  put_regulator_status(api_regulator_status);\n\n  \/\/ [InvokeEntryPoint]: Invoke the entry point\n  crate::operator_interface_oip_oit_timeTriggered();\n\n  \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n  let api_lower_alarm_tempWstatus = get_lower_alarm_tempWstatus();\n  let api_lower_desired_tempWstatus = get_lower_desired_tempWstatus();\n  let api_upper_alarm_tempWstatus = get_upper_alarm_tempWstatus();\n  let api_upper_desired_tempWstatus = get_upper_desired_tempWstatus();\n\n  \/\/ [CheckPost]: invoke the oracle function\n  if !GUMBOX::compute_CEP_Post(api_alarm_control, api_display_temperature, api_monitor_status, api_regulator_status, api_lower_alarm_tempWstatus, api_lower_desired_tempWstatus, api_upper_alarm_tempWstatus, api_upper_desired_tempWstatus) {\n    return HarnessResult::FailedPostcondition(TestCaseError::Fail(\"Postcondition failed: incorrect output behavior\".into()));\n  }\n\n  return HarnessResult::Passed\n}\n\n\/** Contract-based test harness for the compute entry point\n  *\/\npub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult\n{\n  return testComputeCB(container.api_alarm_control, container.api_display_temperature, container.api_monitor_status, container.api_regulator_status)\n}\n\n#[macro_export]\nmacro_rules!\ntestComputeCB_macro {\n  (\n    $test_name: ident,\n    config: $config:expr,\n    api_alarm_control: $api_alarm_control_strat:expr,\n    api_display_temperature: $api_display_temperature_strat:expr,\n    api_monitor_status: $api_monitor_status_strat:expr,\n    api_regulator_status: $api_regulator_status_strat:expr\n  ) => {\n    proptest!{\n      #![proptest_config($config)]\n      #[test]\n      #[serial]\n      fn $test_name(\n        (api_alarm_control, api_display_temperature, api_monitor_status, api_regulator_status)\n            in ($api_alarm_control_strat, $api_display_temperature_strat, $api_monitor_status_strat, $api_regulator_status_strat)\n      ) {\n        match$crate::test::util::cb_apis::testComputeCB(api_alarm_control, api_display_temperature, api_monitor_status, api_regulator_status) {\n          $crate::test::util::cb_apis::HarnessResult::RejectedPrecondition => {\n            return Err(proptest::test_runner::TestCaseError::reject(\n              \"Precondition failed: invalid input combination\",\n            ))\n          }\n          $crate::test::util::cb_apis::HarnessResult::FailedPostcondition(e) => {\n            return Err(e)\n          }\n          $crate::test::util::cb_apis::HarnessResult::Passed => { }\n        }\n      }\n    }\n  };\n}\n",
          "markers" : [
          ],
          "invertMarkers" : false,
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ]
    ]
  }
}