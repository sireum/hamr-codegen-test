{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = {\n    Contract(Ensures(Res == F))\n    return F\n  }\n\n\n  def Integer_example(): Integer = {\n    Contract(Ensures(Res == z\"0\"))\n    return z\"0\"\n  }\n\n  def Integer_8_example(): Integer_8 = {\n    Contract(Ensures(Res == s8\"0\"))\n    return s8\"0\"\n  }\n\n  def Integer_16_example(): Integer_16 = {\n    Contract(Ensures(Res == s16\"0\"))\n    return s16\"0\"\n  }\n\n  def Integer_32_example(): Integer_32 = {\n    Contract(Ensures(Res == s32\"0\"))\n    return s32\"0\"\n  }\n\n  def Integer_64_example(): Integer_64 = {\n    Contract(Ensures(Res == s64\"0\"))\n    return s64\"0\"\n  }\n\n\n  def Unsigned_8_example(): Unsigned_8 = {\n    Contract(Ensures(Res == u8\"0\"))\n    return u8\"0\"\n  }\n\n  def Unsigned_16_example(): Unsigned_16 = {\n    Contract(Ensures(Res == u16\"0\"))\n    return u16\"0\"\n  }\n\n  def Unsigned_32_example(): Unsigned_32 = {\n    Contract(Ensures(Res == u32\"0\"))\n    return u32\"0\"\n  }\n\n  def Unsigned_64_example(): Unsigned_64 = {\n    Contract(Ensures(Res == u64\"0\"))\n    return u64\"0\"\n  }\n\n\n  def Float_example(): Float = {\n    Contract(Ensures(Res == r\"0\"))\n    return r\"0\"\n  }\n\n  def Float_32_example(): Float_32 = {\n    Contract(Ensures(Res == f32\"0\"))\n    return f32\"0\"\n  }\n\n  def Float_64_example(): Float_64 = {\n    Contract(Ensures(Res == f64\"0\"))\n    return f64\"0\"\n  }\n\n\n  def Character_example(): Character = {\n    Contract(Ensures(Res == ' '))\n    return ' '\n  }\n\n  def String_example(): String = {\n    Contract(Ensures(Res == \"\"))\n    return \"\"\n  }\n\n\n  def Bits_example(): Bits = {\n    Contract(Ensures(Res == ISZ[B]()))\n    return ISZ[B]()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/architecture\/RTS_aadl__JVM\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Arch {\n  val RTS_i_Instance_instrumentationMock_instrumentationMockThread : RTS_aadl__JVM.Instrumentation.InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge = {\n    val unit1_temperatureLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"0\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_temperatureLogic_channel1\", mode = DataOut)\n    val unit1_temperatureLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"1\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_temperatureLogic_channel2\", mode = DataOut)\n    val unit1_temperatureLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"2\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_temperatureLogic_channel3\", mode = DataOut)\n    val unit1_temperatureLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"3\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_temperatureLogic_channel4\", mode = DataOut)\n    val unit1_pressureLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"4\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_pressureLogic_channel1\", mode = DataOut)\n    val unit1_pressureLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"5\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_pressureLogic_channel2\", mode = DataOut)\n    val unit1_pressureLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"6\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_pressureLogic_channel3\", mode = DataOut)\n    val unit1_pressureLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"7\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_pressureLogic_channel4\", mode = DataOut)\n    val unit1_saturationLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"8\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_saturationLogic_channel1\", mode = DataOut)\n    val unit1_saturationLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"9\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_saturationLogic_channel2\", mode = DataOut)\n    val unit1_saturationLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"10\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_saturationLogic_channel3\", mode = DataOut)\n    val unit1_saturationLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"11\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit1_saturationLogic_channel4\", mode = DataOut)\n    val unit2_temperatureLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"12\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_temperatureLogic_channel1\", mode = DataOut)\n    val unit2_temperatureLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"13\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_temperatureLogic_channel2\", mode = DataOut)\n    val unit2_temperatureLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"14\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_temperatureLogic_channel3\", mode = DataOut)\n    val unit2_temperatureLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"15\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_temperatureLogic_channel4\", mode = DataOut)\n    val unit2_pressureLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"16\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_pressureLogic_channel1\", mode = DataOut)\n    val unit2_pressureLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"17\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_pressureLogic_channel2\", mode = DataOut)\n    val unit2_pressureLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"18\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_pressureLogic_channel3\", mode = DataOut)\n    val unit2_pressureLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"19\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_pressureLogic_channel4\", mode = DataOut)\n    val unit2_saturationLogic_channel1 = Port[Base_Types.Boolean] (id = portId\"20\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_saturationLogic_channel1\", mode = DataOut)\n    val unit2_saturationLogic_channel2 = Port[Base_Types.Boolean] (id = portId\"21\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_saturationLogic_channel2\", mode = DataOut)\n    val unit2_saturationLogic_channel3 = Port[Base_Types.Boolean] (id = portId\"22\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_saturationLogic_channel3\", mode = DataOut)\n    val unit2_saturationLogic_channel4 = Port[Base_Types.Boolean] (id = portId\"23\", name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread_unit2_saturationLogic_channel4\", mode = DataOut)\n\n    RTS_aadl__JVM.Instrumentation.InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge(\n      id = bridgeId\"0\",\n      name = \"RTS_i_Instance_instrumentationMock_instrumentationMockThread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      unit1_temperatureLogic_channel1 = unit1_temperatureLogic_channel1,\n      unit1_temperatureLogic_channel2 = unit1_temperatureLogic_channel2,\n      unit1_temperatureLogic_channel3 = unit1_temperatureLogic_channel3,\n      unit1_temperatureLogic_channel4 = unit1_temperatureLogic_channel4,\n      unit1_pressureLogic_channel1 = unit1_pressureLogic_channel1,\n      unit1_pressureLogic_channel2 = unit1_pressureLogic_channel2,\n      unit1_pressureLogic_channel3 = unit1_pressureLogic_channel3,\n      unit1_pressureLogic_channel4 = unit1_pressureLogic_channel4,\n      unit1_saturationLogic_channel1 = unit1_saturationLogic_channel1,\n      unit1_saturationLogic_channel2 = unit1_saturationLogic_channel2,\n      unit1_saturationLogic_channel3 = unit1_saturationLogic_channel3,\n      unit1_saturationLogic_channel4 = unit1_saturationLogic_channel4,\n      unit2_temperatureLogic_channel1 = unit2_temperatureLogic_channel1,\n      unit2_temperatureLogic_channel2 = unit2_temperatureLogic_channel2,\n      unit2_temperatureLogic_channel3 = unit2_temperatureLogic_channel3,\n      unit2_temperatureLogic_channel4 = unit2_temperatureLogic_channel4,\n      unit2_pressureLogic_channel1 = unit2_pressureLogic_channel1,\n      unit2_pressureLogic_channel2 = unit2_pressureLogic_channel2,\n      unit2_pressureLogic_channel3 = unit2_pressureLogic_channel3,\n      unit2_pressureLogic_channel4 = unit2_pressureLogic_channel4,\n      unit2_saturationLogic_channel1 = unit2_saturationLogic_channel1,\n      unit2_saturationLogic_channel2 = unit2_saturationLogic_channel2,\n      unit2_saturationLogic_channel3 = unit2_saturationLogic_channel3,\n      unit2_saturationLogic_channel4 = unit2_saturationLogic_channel4\n    )\n  }\n  val RTS_i_Instance_eventControlMock_eventControlMockThread : RTS_aadl__JVM.EventControl.EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge = {\n    val manualActuatorInput1 = Port[Base_Types.Boolean] (id = portId\"24\", name = \"RTS_i_Instance_eventControlMock_eventControlMockThread_manualActuatorInput1\", mode = DataOut)\n    val manualActuatorInput2 = Port[Base_Types.Boolean] (id = portId\"25\", name = \"RTS_i_Instance_eventControlMock_eventControlMockThread_manualActuatorInput2\", mode = DataOut)\n\n    RTS_aadl__JVM.EventControl.EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge(\n      id = bridgeId\"1\",\n      name = \"RTS_i_Instance_eventControlMock_eventControlMockThread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      manualActuatorInput1 = manualActuatorInput1,\n      manualActuatorInput2 = manualActuatorInput2\n    )\n  }\n  val RTS_i_Instance_actuatorsMock_actuatorsMockThread : RTS_aadl__JVM.Actuators.ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge = {\n    val tempPressureActuate = Port[Base_Types.Boolean] (id = portId\"26\", name = \"RTS_i_Instance_actuatorsMock_actuatorsMockThread_tempPressureActuate\", mode = DataIn)\n    val saturationActuate = Port[Base_Types.Boolean] (id = portId\"27\", name = \"RTS_i_Instance_actuatorsMock_actuatorsMockThread_saturationActuate\", mode = DataIn)\n\n    RTS_aadl__JVM.Actuators.ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge(\n      id = bridgeId\"2\",\n      name = \"RTS_i_Instance_actuatorsMock_actuatorsMockThread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      tempPressureActuate = tempPressureActuate,\n      saturationActuate = saturationActuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"28\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"29\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"30\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"31\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"32\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"3\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"33\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"34\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"35\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"36\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"37\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"4\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"38\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"39\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"40\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"41\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"42\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"5\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic : RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"43\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"44\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_channel2\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"45\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge(\n      id = bridgeId\"6\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"46\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"47\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"48\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"49\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"50\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"7\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"51\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"52\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"53\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"54\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"55\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"8\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic : RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"56\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"57\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_channel2\", mode = DataIn)\n    val channel3 = Port[Base_Types.Boolean] (id = portId\"58\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_channel3\", mode = DataIn)\n    val channel4 = Port[Base_Types.Boolean] (id = portId\"59\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_channel4\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"60\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge(\n      id = bridgeId\"9\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      channel3 = channel3,\n      channel4 = channel4,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic : RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"61\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"62\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_channel2\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"63\", name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge(\n      id = bridgeId\"10\",\n      name = \"RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic : RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"64\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"65\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_channel2\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"66\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge(\n      id = bridgeId\"11\",\n      name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator : RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge = {\n    val input = Port[Base_Types.Boolean] (id = portId\"67\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_input\", mode = DataIn)\n    val manualActuatorInput = Port[Base_Types.Boolean] (id = portId\"68\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_manualActuatorInput\", mode = DataIn)\n    val output = Port[Base_Types.Boolean] (id = portId\"69\", name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_output\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge(\n      id = bridgeId\"12\",\n      name = \"RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      input = input,\n      manualActuatorInput = manualActuatorInput,\n      output = output\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic : RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge = {\n    val channel1 = Port[Base_Types.Boolean] (id = portId\"70\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_channel1\", mode = DataIn)\n    val channel2 = Port[Base_Types.Boolean] (id = portId\"71\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_channel2\", mode = DataIn)\n    val actuate = Port[Base_Types.Boolean] (id = portId\"72\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_actuate\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge(\n      id = bridgeId\"13\",\n      name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      channel1 = channel1,\n      channel2 = channel2,\n      actuate = actuate\n    )\n  }\n  val RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator : RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge = {\n    val input = Port[Base_Types.Boolean] (id = portId\"73\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_input\", mode = DataIn)\n    val manualActuatorInput = Port[Base_Types.Boolean] (id = portId\"74\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_manualActuatorInput\", mode = DataIn)\n    val output = Port[Base_Types.Boolean] (id = portId\"75\", name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_output\", mode = DataOut)\n\n    RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge(\n      id = bridgeId\"14\",\n      name = \"RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      input = input,\n      manualActuatorInput = manualActuatorInput,\n      output = output\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = IS[Art.BridgeId, Bridge] (RTS_i_Instance_instrumentationMock_instrumentationMockThread, RTS_i_Instance_eventControlMock_eventControlMockThread, RTS_i_Instance_actuatorsMock_actuatorsMockThread, RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic, RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic, RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic, RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic, RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator, RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic, RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator),\n\n      connections = IS[Art.ConnectionId, UConnection] (Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.actuate, to = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.input),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.actuate, to = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.input),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.actuate, to = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.actuate, to = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.actuate, to = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_temperatureLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_temperatureLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_temperatureLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_temperatureLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_pressureLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_pressureLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_pressureLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_pressureLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_saturationLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_saturationLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_saturationLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit1_saturationLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_temperatureLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_temperatureLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_temperatureLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_temperatureLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_pressureLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_pressureLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_pressureLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_pressureLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_saturationLogic_channel1, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.channel1),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_saturationLogic_channel2, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.channel2),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_saturationLogic_channel3, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.channel3),\n                                                       Connection(from = RTS_i_Instance_instrumentationMock_instrumentationMockThread.unit2_saturationLogic_channel4, to = RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.channel4),\n                                                       Connection(from = RTS_i_Instance_eventControlMock_eventControlMockThread.manualActuatorInput1, to = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.manualActuatorInput),\n                                                       Connection(from = RTS_i_Instance_eventControlMock_eventControlMockThread.manualActuatorInput2, to = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.manualActuatorInput),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.output, to = RTS_i_Instance_actuatorsMock_actuatorsMockThread.tempPressureActuate),\n                                                       Connection(from = RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.output, to = RTS_i_Instance_actuatorsMock_actuatorsMockThread.saturationActuate))\n    )\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/architecture\/RTS_aadl__JVM\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticScheduler(None())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n\n        Platform.setup()\n\n        art.Art.run(Arch.ad, scheduler)\n\n        Platform.tearDown()\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/architecture\/RTS_aadl__JVM\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage RTS_aadl__JVM\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec, Slot}\nimport art.scheduling.static.StaticScheduler\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val RTS_i_Instance_rts_processor_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = Some(2),\n    framePeriod = Some(1000),\n    maxDomain = Some(16),\n    slotTime = None())\n\n  val RTS_i_Instance_instrumentationMock_instrumentationMockThread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(2))\n\n  val RTS_i_Instance_eventControlMock_eventControlMockThread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(3))\n\n  val RTS_i_Instance_actuatorsMock_actuatorsMockThread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(4))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(5))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(6))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(7))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(8))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(9))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(10))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(11))\n\n  val RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(12))\n\n  val RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(13))\n\n  val RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(14))\n\n  val RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(15))\n\n  val RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(16))\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[Art.BridgeId] = {\n    \/\/ convert IS[Art.BridgeId, art.Bridge] to an IS[Z, Art.BridgeId] to allow bridges to be dispatched\n    \/\/ multiple times during a hyper-period\n    var ret: ISZ[Art.BridgeId] = ISZ()\n    for(e <- Arch.ad.components) {\n      ret = ret :+ e.id\n    }\n    ret\n  }\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ staticSchedule represents the component dispatch order\n  val staticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Slot(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.id, maxExecutionTime),\n    Slot(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.id, maxExecutionTime)\n  )))\n\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[Art.BridgeId]]): RoundRobin = {\n    if(roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  def getStaticScheduler(schedule: Option[DScheduleSpec]): StaticScheduler = {\n    if(staticSchedule.schedule.slots.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return StaticScheduler(Arch.ad.components, s)\n      case _ => return StaticScheduler(Arch.ad.components, ScheduleProviderI.getStaticSchedule())\n    }\n  }\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n\/\/ the purpose of this extension is to allow users to provide custom schedules\n\/\/ at the C level after transpiling\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = $\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/architecture\/RTS_aadl__JVM\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.staticSchedule\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/inspector\/RTS_aadl__JVM\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Instrumentation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread)\n  }\n\n  \/** helper function to check InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param unit1_temperatureLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit1_temperatureLogic_channel1'.\n   * @param unit1_temperatureLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit1_temperatureLogic_channel2'.\n   * @param unit1_temperatureLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit1_temperatureLogic_channel3'.\n   * @param unit1_temperatureLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit1_temperatureLogic_channel4'.\n   * @param unit1_pressureLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit1_pressureLogic_channel1'.\n   * @param unit1_pressureLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit1_pressureLogic_channel2'.\n   * @param unit1_pressureLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit1_pressureLogic_channel3'.\n   * @param unit1_pressureLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit1_pressureLogic_channel4'.\n   * @param unit1_saturationLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit1_saturationLogic_channel1'.\n   * @param unit1_saturationLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit1_saturationLogic_channel2'.\n   * @param unit1_saturationLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit1_saturationLogic_channel3'.\n   * @param unit1_saturationLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit1_saturationLogic_channel4'.\n   * @param unit2_temperatureLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit2_temperatureLogic_channel1'.\n   * @param unit2_temperatureLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit2_temperatureLogic_channel2'.\n   * @param unit2_temperatureLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit2_temperatureLogic_channel3'.\n   * @param unit2_temperatureLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit2_temperatureLogic_channel4'.\n   * @param unit2_pressureLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit2_pressureLogic_channel1'.\n   * @param unit2_pressureLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit2_pressureLogic_channel2'.\n   * @param unit2_pressureLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit2_pressureLogic_channel3'.\n   * @param unit2_pressureLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit2_pressureLogic_channel4'.\n   * @param unit2_saturationLogic_channel1 method that will be called with the value of the outgoing data\n   *        port 'unit2_saturationLogic_channel1'.\n   * @param unit2_saturationLogic_channel2 method that will be called with the value of the outgoing data\n   *        port 'unit2_saturationLogic_channel2'.\n   * @param unit2_saturationLogic_channel3 method that will be called with the value of the outgoing data\n   *        port 'unit2_saturationLogic_channel3'.\n   * @param unit2_saturationLogic_channel4 method that will be called with the value of the outgoing data\n   *        port 'unit2_saturationLogic_channel4'.\n   *\/\n  def check_concrete_output(unit1_temperatureLogic_channel1: Base_Types.Boolean => B,\n                            unit1_temperatureLogic_channel2: Base_Types.Boolean => B,\n                            unit1_temperatureLogic_channel3: Base_Types.Boolean => B,\n                            unit1_temperatureLogic_channel4: Base_Types.Boolean => B,\n                            unit1_pressureLogic_channel1: Base_Types.Boolean => B,\n                            unit1_pressureLogic_channel2: Base_Types.Boolean => B,\n                            unit1_pressureLogic_channel3: Base_Types.Boolean => B,\n                            unit1_pressureLogic_channel4: Base_Types.Boolean => B,\n                            unit1_saturationLogic_channel1: Base_Types.Boolean => B,\n                            unit1_saturationLogic_channel2: Base_Types.Boolean => B,\n                            unit1_saturationLogic_channel3: Base_Types.Boolean => B,\n                            unit1_saturationLogic_channel4: Base_Types.Boolean => B,\n                            unit2_temperatureLogic_channel1: Base_Types.Boolean => B,\n                            unit2_temperatureLogic_channel2: Base_Types.Boolean => B,\n                            unit2_temperatureLogic_channel3: Base_Types.Boolean => B,\n                            unit2_temperatureLogic_channel4: Base_Types.Boolean => B,\n                            unit2_pressureLogic_channel1: Base_Types.Boolean => B,\n                            unit2_pressureLogic_channel2: Base_Types.Boolean => B,\n                            unit2_pressureLogic_channel3: Base_Types.Boolean => B,\n                            unit2_pressureLogic_channel4: Base_Types.Boolean => B,\n                            unit2_saturationLogic_channel1: Base_Types.Boolean => B,\n                            unit2_saturationLogic_channel2: Base_Types.Boolean => B,\n                            unit2_saturationLogic_channel3: Base_Types.Boolean => B,\n                            unit2_saturationLogic_channel4: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val unit1_temperatureLogic_channel1Value: Base_Types.Boolean = get_unit1_temperatureLogic_channel1().get\n    if(!unit1_temperatureLogic_channel1(unit1_temperatureLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit1_temperatureLogic_channel1' did not match expected: value of the outgoing data port is ${unit1_temperatureLogic_channel1Value}\"\n    }\n    val unit1_temperatureLogic_channel2Value: Base_Types.Boolean = get_unit1_temperatureLogic_channel2().get\n    if(!unit1_temperatureLogic_channel2(unit1_temperatureLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit1_temperatureLogic_channel2' did not match expected: value of the outgoing data port is ${unit1_temperatureLogic_channel2Value}\"\n    }\n    val unit1_temperatureLogic_channel3Value: Base_Types.Boolean = get_unit1_temperatureLogic_channel3().get\n    if(!unit1_temperatureLogic_channel3(unit1_temperatureLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit1_temperatureLogic_channel3' did not match expected: value of the outgoing data port is ${unit1_temperatureLogic_channel3Value}\"\n    }\n    val unit1_temperatureLogic_channel4Value: Base_Types.Boolean = get_unit1_temperatureLogic_channel4().get\n    if(!unit1_temperatureLogic_channel4(unit1_temperatureLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit1_temperatureLogic_channel4' did not match expected: value of the outgoing data port is ${unit1_temperatureLogic_channel4Value}\"\n    }\n    val unit1_pressureLogic_channel1Value: Base_Types.Boolean = get_unit1_pressureLogic_channel1().get\n    if(!unit1_pressureLogic_channel1(unit1_pressureLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit1_pressureLogic_channel1' did not match expected: value of the outgoing data port is ${unit1_pressureLogic_channel1Value}\"\n    }\n    val unit1_pressureLogic_channel2Value: Base_Types.Boolean = get_unit1_pressureLogic_channel2().get\n    if(!unit1_pressureLogic_channel2(unit1_pressureLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit1_pressureLogic_channel2' did not match expected: value of the outgoing data port is ${unit1_pressureLogic_channel2Value}\"\n    }\n    val unit1_pressureLogic_channel3Value: Base_Types.Boolean = get_unit1_pressureLogic_channel3().get\n    if(!unit1_pressureLogic_channel3(unit1_pressureLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit1_pressureLogic_channel3' did not match expected: value of the outgoing data port is ${unit1_pressureLogic_channel3Value}\"\n    }\n    val unit1_pressureLogic_channel4Value: Base_Types.Boolean = get_unit1_pressureLogic_channel4().get\n    if(!unit1_pressureLogic_channel4(unit1_pressureLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit1_pressureLogic_channel4' did not match expected: value of the outgoing data port is ${unit1_pressureLogic_channel4Value}\"\n    }\n    val unit1_saturationLogic_channel1Value: Base_Types.Boolean = get_unit1_saturationLogic_channel1().get\n    if(!unit1_saturationLogic_channel1(unit1_saturationLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit1_saturationLogic_channel1' did not match expected: value of the outgoing data port is ${unit1_saturationLogic_channel1Value}\"\n    }\n    val unit1_saturationLogic_channel2Value: Base_Types.Boolean = get_unit1_saturationLogic_channel2().get\n    if(!unit1_saturationLogic_channel2(unit1_saturationLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit1_saturationLogic_channel2' did not match expected: value of the outgoing data port is ${unit1_saturationLogic_channel2Value}\"\n    }\n    val unit1_saturationLogic_channel3Value: Base_Types.Boolean = get_unit1_saturationLogic_channel3().get\n    if(!unit1_saturationLogic_channel3(unit1_saturationLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit1_saturationLogic_channel3' did not match expected: value of the outgoing data port is ${unit1_saturationLogic_channel3Value}\"\n    }\n    val unit1_saturationLogic_channel4Value: Base_Types.Boolean = get_unit1_saturationLogic_channel4().get\n    if(!unit1_saturationLogic_channel4(unit1_saturationLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit1_saturationLogic_channel4' did not match expected: value of the outgoing data port is ${unit1_saturationLogic_channel4Value}\"\n    }\n    val unit2_temperatureLogic_channel1Value: Base_Types.Boolean = get_unit2_temperatureLogic_channel1().get\n    if(!unit2_temperatureLogic_channel1(unit2_temperatureLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit2_temperatureLogic_channel1' did not match expected: value of the outgoing data port is ${unit2_temperatureLogic_channel1Value}\"\n    }\n    val unit2_temperatureLogic_channel2Value: Base_Types.Boolean = get_unit2_temperatureLogic_channel2().get\n    if(!unit2_temperatureLogic_channel2(unit2_temperatureLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit2_temperatureLogic_channel2' did not match expected: value of the outgoing data port is ${unit2_temperatureLogic_channel2Value}\"\n    }\n    val unit2_temperatureLogic_channel3Value: Base_Types.Boolean = get_unit2_temperatureLogic_channel3().get\n    if(!unit2_temperatureLogic_channel3(unit2_temperatureLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit2_temperatureLogic_channel3' did not match expected: value of the outgoing data port is ${unit2_temperatureLogic_channel3Value}\"\n    }\n    val unit2_temperatureLogic_channel4Value: Base_Types.Boolean = get_unit2_temperatureLogic_channel4().get\n    if(!unit2_temperatureLogic_channel4(unit2_temperatureLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit2_temperatureLogic_channel4' did not match expected: value of the outgoing data port is ${unit2_temperatureLogic_channel4Value}\"\n    }\n    val unit2_pressureLogic_channel1Value: Base_Types.Boolean = get_unit2_pressureLogic_channel1().get\n    if(!unit2_pressureLogic_channel1(unit2_pressureLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit2_pressureLogic_channel1' did not match expected: value of the outgoing data port is ${unit2_pressureLogic_channel1Value}\"\n    }\n    val unit2_pressureLogic_channel2Value: Base_Types.Boolean = get_unit2_pressureLogic_channel2().get\n    if(!unit2_pressureLogic_channel2(unit2_pressureLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit2_pressureLogic_channel2' did not match expected: value of the outgoing data port is ${unit2_pressureLogic_channel2Value}\"\n    }\n    val unit2_pressureLogic_channel3Value: Base_Types.Boolean = get_unit2_pressureLogic_channel3().get\n    if(!unit2_pressureLogic_channel3(unit2_pressureLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit2_pressureLogic_channel3' did not match expected: value of the outgoing data port is ${unit2_pressureLogic_channel3Value}\"\n    }\n    val unit2_pressureLogic_channel4Value: Base_Types.Boolean = get_unit2_pressureLogic_channel4().get\n    if(!unit2_pressureLogic_channel4(unit2_pressureLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit2_pressureLogic_channel4' did not match expected: value of the outgoing data port is ${unit2_pressureLogic_channel4Value}\"\n    }\n    val unit2_saturationLogic_channel1Value: Base_Types.Boolean = get_unit2_saturationLogic_channel1().get\n    if(!unit2_saturationLogic_channel1(unit2_saturationLogic_channel1Value)) {\n      testFailures = testFailures :+ st\"'unit2_saturationLogic_channel1' did not match expected: value of the outgoing data port is ${unit2_saturationLogic_channel1Value}\"\n    }\n    val unit2_saturationLogic_channel2Value: Base_Types.Boolean = get_unit2_saturationLogic_channel2().get\n    if(!unit2_saturationLogic_channel2(unit2_saturationLogic_channel2Value)) {\n      testFailures = testFailures :+ st\"'unit2_saturationLogic_channel2' did not match expected: value of the outgoing data port is ${unit2_saturationLogic_channel2Value}\"\n    }\n    val unit2_saturationLogic_channel3Value: Base_Types.Boolean = get_unit2_saturationLogic_channel3().get\n    if(!unit2_saturationLogic_channel3(unit2_saturationLogic_channel3Value)) {\n      testFailures = testFailures :+ st\"'unit2_saturationLogic_channel3' did not match expected: value of the outgoing data port is ${unit2_saturationLogic_channel3Value}\"\n    }\n    val unit2_saturationLogic_channel4Value: Base_Types.Boolean = get_unit2_saturationLogic_channel4().get\n    if(!unit2_saturationLogic_channel4(unit2_saturationLogic_channel4Value)) {\n      testFailures = testFailures :+ st\"'unit2_saturationLogic_channel4' did not match expected: value of the outgoing data port is ${unit2_saturationLogic_channel4Value}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_unit1_temperatureLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_temperatureLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_temperatureLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_temperatureLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_temperatureLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_temperatureLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_temperatureLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_temperatureLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_temperatureLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_temperatureLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_temperatureLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_temperatureLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_temperatureLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_temperatureLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_temperatureLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_temperatureLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_temperatureLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_temperatureLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_temperatureLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_temperatureLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_pressureLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_pressureLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_pressureLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_pressureLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_pressureLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_pressureLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_pressureLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_pressureLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_pressureLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_pressureLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_pressureLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_pressureLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_pressureLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_pressureLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_pressureLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_pressureLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_pressureLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_pressureLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_pressureLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_pressureLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_saturationLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_saturationLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_saturationLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_saturationLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_saturationLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_saturationLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_saturationLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_saturationLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_saturationLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_saturationLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_saturationLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_saturationLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_saturationLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_saturationLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_saturationLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit1_saturationLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit1_saturationLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit1_saturationLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit1_saturationLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit1_saturationLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_temperatureLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_temperatureLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_temperatureLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_temperatureLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_temperatureLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_temperatureLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_temperatureLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_temperatureLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_temperatureLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_temperatureLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_temperatureLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_temperatureLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_temperatureLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_temperatureLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_temperatureLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_temperatureLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_temperatureLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_temperatureLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_temperatureLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_temperatureLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_pressureLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_pressureLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_pressureLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_pressureLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_pressureLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_pressureLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_pressureLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_pressureLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_pressureLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_pressureLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_pressureLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_pressureLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_pressureLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_pressureLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_pressureLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_pressureLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_pressureLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_pressureLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_pressureLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_pressureLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_saturationLogic_channel1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_saturationLogic_channel1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_saturationLogic_channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_saturationLogic_channel1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_saturationLogic_channel1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_saturationLogic_channel2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_saturationLogic_channel2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_saturationLogic_channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_saturationLogic_channel2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_saturationLogic_channel2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_saturationLogic_channel3(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_saturationLogic_channel3_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_saturationLogic_channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_saturationLogic_channel3_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_saturationLogic_channel3_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_unit2_saturationLogic_channel4(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_unit2_saturationLogic_channel4_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port unit2_saturationLogic_channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_unit2_saturationLogic_channel4_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_instrumentationMock_instrumentationMockThread.initialization_api.unit2_saturationLogic_channel4_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Instrumentation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Instrumentation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Instrumentation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Test extends InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Instrumentation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Instrumentation.{InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  unit1_temperatureLogic_channel1: Port[Base_Types.Boolean],\n  unit1_temperatureLogic_channel2: Port[Base_Types.Boolean],\n  unit1_temperatureLogic_channel3: Port[Base_Types.Boolean],\n  unit1_temperatureLogic_channel4: Port[Base_Types.Boolean],\n  unit1_pressureLogic_channel1: Port[Base_Types.Boolean],\n  unit1_pressureLogic_channel2: Port[Base_Types.Boolean],\n  unit1_pressureLogic_channel3: Port[Base_Types.Boolean],\n  unit1_pressureLogic_channel4: Port[Base_Types.Boolean],\n  unit1_saturationLogic_channel1: Port[Base_Types.Boolean],\n  unit1_saturationLogic_channel2: Port[Base_Types.Boolean],\n  unit1_saturationLogic_channel3: Port[Base_Types.Boolean],\n  unit1_saturationLogic_channel4: Port[Base_Types.Boolean],\n  unit2_temperatureLogic_channel1: Port[Base_Types.Boolean],\n  unit2_temperatureLogic_channel2: Port[Base_Types.Boolean],\n  unit2_temperatureLogic_channel3: Port[Base_Types.Boolean],\n  unit2_temperatureLogic_channel4: Port[Base_Types.Boolean],\n  unit2_pressureLogic_channel1: Port[Base_Types.Boolean],\n  unit2_pressureLogic_channel2: Port[Base_Types.Boolean],\n  unit2_pressureLogic_channel3: Port[Base_Types.Boolean],\n  unit2_pressureLogic_channel4: Port[Base_Types.Boolean],\n  unit2_saturationLogic_channel1: Port[Base_Types.Boolean],\n  unit2_saturationLogic_channel2: Port[Base_Types.Boolean],\n  unit2_saturationLogic_channel3: Port[Base_Types.Boolean],\n  unit2_saturationLogic_channel4: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](unit1_temperatureLogic_channel1,\n                              unit1_temperatureLogic_channel2,\n                              unit1_temperatureLogic_channel3,\n                              unit1_temperatureLogic_channel4,\n                              unit1_pressureLogic_channel1,\n                              unit1_pressureLogic_channel2,\n                              unit1_pressureLogic_channel3,\n                              unit1_pressureLogic_channel4,\n                              unit1_saturationLogic_channel1,\n                              unit1_saturationLogic_channel2,\n                              unit1_saturationLogic_channel3,\n                              unit1_saturationLogic_channel4,\n                              unit2_temperatureLogic_channel1,\n                              unit2_temperatureLogic_channel2,\n                              unit2_temperatureLogic_channel3,\n                              unit2_temperatureLogic_channel4,\n                              unit2_pressureLogic_channel1,\n                              unit2_pressureLogic_channel2,\n                              unit2_pressureLogic_channel3,\n                              unit2_pressureLogic_channel4,\n                              unit2_saturationLogic_channel1,\n                              unit2_saturationLogic_channel2,\n                              unit2_saturationLogic_channel3,\n                              unit2_saturationLogic_channel4),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : InstrumentationMockThread_i_Initialization_Api = {\n    val api = InstrumentationMockThread_i_Initialization_Api(\n      id,\n      unit1_temperatureLogic_channel1.id,\n      unit1_temperatureLogic_channel2.id,\n      unit1_temperatureLogic_channel3.id,\n      unit1_temperatureLogic_channel4.id,\n      unit1_pressureLogic_channel1.id,\n      unit1_pressureLogic_channel2.id,\n      unit1_pressureLogic_channel3.id,\n      unit1_pressureLogic_channel4.id,\n      unit1_saturationLogic_channel1.id,\n      unit1_saturationLogic_channel2.id,\n      unit1_saturationLogic_channel3.id,\n      unit1_saturationLogic_channel4.id,\n      unit2_temperatureLogic_channel1.id,\n      unit2_temperatureLogic_channel2.id,\n      unit2_temperatureLogic_channel3.id,\n      unit2_temperatureLogic_channel4.id,\n      unit2_pressureLogic_channel1.id,\n      unit2_pressureLogic_channel2.id,\n      unit2_pressureLogic_channel3.id,\n      unit2_pressureLogic_channel4.id,\n      unit2_saturationLogic_channel1.id,\n      unit2_saturationLogic_channel2.id,\n      unit2_saturationLogic_channel3.id,\n      unit2_saturationLogic_channel4.id\n    )\n    InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : InstrumentationMockThread_i_Operational_Api = {\n    val api = InstrumentationMockThread_i_Operational_Api(\n      id,\n      unit1_temperatureLogic_channel1.id,\n      unit1_temperatureLogic_channel2.id,\n      unit1_temperatureLogic_channel3.id,\n      unit1_temperatureLogic_channel4.id,\n      unit1_pressureLogic_channel1.id,\n      unit1_pressureLogic_channel2.id,\n      unit1_pressureLogic_channel3.id,\n      unit1_pressureLogic_channel4.id,\n      unit1_saturationLogic_channel1.id,\n      unit1_saturationLogic_channel2.id,\n      unit1_saturationLogic_channel3.id,\n      unit1_saturationLogic_channel4.id,\n      unit2_temperatureLogic_channel1.id,\n      unit2_temperatureLogic_channel2.id,\n      unit2_temperatureLogic_channel3.id,\n      unit2_temperatureLogic_channel4.id,\n      unit2_pressureLogic_channel1.id,\n      unit2_pressureLogic_channel2.id,\n      unit2_pressureLogic_channel3.id,\n      unit2_pressureLogic_channel4.id,\n      unit2_saturationLogic_channel1.id,\n      unit2_saturationLogic_channel2.id,\n      unit2_saturationLogic_channel3.id,\n      unit2_saturationLogic_channel4.id\n    )\n    InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge.EntryPoints(\n      id,\n\n      unit1_temperatureLogic_channel1.id,\n      unit1_temperatureLogic_channel2.id,\n      unit1_temperatureLogic_channel3.id,\n      unit1_temperatureLogic_channel4.id,\n      unit1_pressureLogic_channel1.id,\n      unit1_pressureLogic_channel2.id,\n      unit1_pressureLogic_channel3.id,\n      unit1_pressureLogic_channel4.id,\n      unit1_saturationLogic_channel1.id,\n      unit1_saturationLogic_channel2.id,\n      unit1_saturationLogic_channel3.id,\n      unit1_saturationLogic_channel4.id,\n      unit2_temperatureLogic_channel1.id,\n      unit2_temperatureLogic_channel2.id,\n      unit2_temperatureLogic_channel3.id,\n      unit2_temperatureLogic_channel4.id,\n      unit2_pressureLogic_channel1.id,\n      unit2_pressureLogic_channel2.id,\n      unit2_pressureLogic_channel3.id,\n      unit2_pressureLogic_channel4.id,\n      unit2_saturationLogic_channel1.id,\n      unit2_saturationLogic_channel2.id,\n      unit2_saturationLogic_channel3.id,\n      unit2_saturationLogic_channel4.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_Bridge {\n\n  var c_initialization_api: Option[InstrumentationMockThread_i_Initialization_Api] = None()\n  var c_operational_api: Option[InstrumentationMockThread_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread_BridgeId : Art.BridgeId,\n    unit1_temperatureLogic_channel1_Id : Art.PortId,\n    unit1_temperatureLogic_channel2_Id : Art.PortId,\n    unit1_temperatureLogic_channel3_Id : Art.PortId,\n    unit1_temperatureLogic_channel4_Id : Art.PortId,\n    unit1_pressureLogic_channel1_Id : Art.PortId,\n    unit1_pressureLogic_channel2_Id : Art.PortId,\n    unit1_pressureLogic_channel3_Id : Art.PortId,\n    unit1_pressureLogic_channel4_Id : Art.PortId,\n    unit1_saturationLogic_channel1_Id : Art.PortId,\n    unit1_saturationLogic_channel2_Id : Art.PortId,\n    unit1_saturationLogic_channel3_Id : Art.PortId,\n    unit1_saturationLogic_channel4_Id : Art.PortId,\n    unit2_temperatureLogic_channel1_Id : Art.PortId,\n    unit2_temperatureLogic_channel2_Id : Art.PortId,\n    unit2_temperatureLogic_channel3_Id : Art.PortId,\n    unit2_temperatureLogic_channel4_Id : Art.PortId,\n    unit2_pressureLogic_channel1_Id : Art.PortId,\n    unit2_pressureLogic_channel2_Id : Art.PortId,\n    unit2_pressureLogic_channel3_Id : Art.PortId,\n    unit2_pressureLogic_channel4_Id : Art.PortId,\n    unit2_saturationLogic_channel1_Id : Art.PortId,\n    unit2_saturationLogic_channel2_Id : Art.PortId,\n    unit2_saturationLogic_channel3_Id : Art.PortId,\n    unit2_saturationLogic_channel4_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: InstrumentationMockThread_i_Initialization_Api,\n    operational_api: InstrumentationMockThread_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(unit1_temperatureLogic_channel1_Id,\n                                             unit1_temperatureLogic_channel2_Id,\n                                             unit1_temperatureLogic_channel3_Id,\n                                             unit1_temperatureLogic_channel4_Id,\n                                             unit1_pressureLogic_channel1_Id,\n                                             unit1_pressureLogic_channel2_Id,\n                                             unit1_pressureLogic_channel3_Id,\n                                             unit1_pressureLogic_channel4_Id,\n                                             unit1_saturationLogic_channel1_Id,\n                                             unit1_saturationLogic_channel2_Id,\n                                             unit1_saturationLogic_channel3_Id,\n                                             unit1_saturationLogic_channel4_Id,\n                                             unit2_temperatureLogic_channel1_Id,\n                                             unit2_temperatureLogic_channel2_Id,\n                                             unit2_temperatureLogic_channel3_Id,\n                                             unit2_temperatureLogic_channel4_Id,\n                                             unit2_pressureLogic_channel1_Id,\n                                             unit2_pressureLogic_channel2_Id,\n                                             unit2_pressureLogic_channel3_Id,\n                                             unit2_pressureLogic_channel4_Id,\n                                             unit2_saturationLogic_channel1_Id,\n                                             unit2_saturationLogic_channel2_Id,\n                                             unit2_saturationLogic_channel3_Id,\n                                             unit2_saturationLogic_channel4_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: InstrumentationMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: InstrumentationMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: InstrumentationMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Instrumentation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait InstrumentationMockThread_i_Api {\n  def id: Art.BridgeId\n  def unit1_temperatureLogic_channel1_Id : Art.PortId\n  def unit1_temperatureLogic_channel2_Id : Art.PortId\n  def unit1_temperatureLogic_channel3_Id : Art.PortId\n  def unit1_temperatureLogic_channel4_Id : Art.PortId\n  def unit1_pressureLogic_channel1_Id : Art.PortId\n  def unit1_pressureLogic_channel2_Id : Art.PortId\n  def unit1_pressureLogic_channel3_Id : Art.PortId\n  def unit1_pressureLogic_channel4_Id : Art.PortId\n  def unit1_saturationLogic_channel1_Id : Art.PortId\n  def unit1_saturationLogic_channel2_Id : Art.PortId\n  def unit1_saturationLogic_channel3_Id : Art.PortId\n  def unit1_saturationLogic_channel4_Id : Art.PortId\n  def unit2_temperatureLogic_channel1_Id : Art.PortId\n  def unit2_temperatureLogic_channel2_Id : Art.PortId\n  def unit2_temperatureLogic_channel3_Id : Art.PortId\n  def unit2_temperatureLogic_channel4_Id : Art.PortId\n  def unit2_pressureLogic_channel1_Id : Art.PortId\n  def unit2_pressureLogic_channel2_Id : Art.PortId\n  def unit2_pressureLogic_channel3_Id : Art.PortId\n  def unit2_pressureLogic_channel4_Id : Art.PortId\n  def unit2_saturationLogic_channel1_Id : Art.PortId\n  def unit2_saturationLogic_channel2_Id : Art.PortId\n  def unit2_saturationLogic_channel3_Id : Art.PortId\n  def unit2_saturationLogic_channel4_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_temperatureLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit1_temperatureLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_temperatureLogic_channel1),\n      Ensures(\n        unit1_temperatureLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit1_temperatureLogic_channel1 = value\n    }\n\n    Art.putValue(unit1_temperatureLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_temperatureLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit1_temperatureLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_temperatureLogic_channel2),\n      Ensures(\n        unit1_temperatureLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit1_temperatureLogic_channel2 = value\n    }\n\n    Art.putValue(unit1_temperatureLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_temperatureLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit1_temperatureLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_temperatureLogic_channel3),\n      Ensures(\n        unit1_temperatureLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit1_temperatureLogic_channel3 = value\n    }\n\n    Art.putValue(unit1_temperatureLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_temperatureLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit1_temperatureLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_temperatureLogic_channel4),\n      Ensures(\n        unit1_temperatureLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit1_temperatureLogic_channel4 = value\n    }\n\n    Art.putValue(unit1_temperatureLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_pressureLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit1_pressureLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_pressureLogic_channel1),\n      Ensures(\n        unit1_pressureLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit1_pressureLogic_channel1 = value\n    }\n\n    Art.putValue(unit1_pressureLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_pressureLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit1_pressureLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_pressureLogic_channel2),\n      Ensures(\n        unit1_pressureLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit1_pressureLogic_channel2 = value\n    }\n\n    Art.putValue(unit1_pressureLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_pressureLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit1_pressureLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_pressureLogic_channel3),\n      Ensures(\n        unit1_pressureLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit1_pressureLogic_channel3 = value\n    }\n\n    Art.putValue(unit1_pressureLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_pressureLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit1_pressureLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_pressureLogic_channel4),\n      Ensures(\n        unit1_pressureLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit1_pressureLogic_channel4 = value\n    }\n\n    Art.putValue(unit1_pressureLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_saturationLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit1_saturationLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_saturationLogic_channel1),\n      Ensures(\n        unit1_saturationLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit1_saturationLogic_channel1 = value\n    }\n\n    Art.putValue(unit1_saturationLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_saturationLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit1_saturationLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_saturationLogic_channel2),\n      Ensures(\n        unit1_saturationLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit1_saturationLogic_channel2 = value\n    }\n\n    Art.putValue(unit1_saturationLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_saturationLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit1_saturationLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_saturationLogic_channel3),\n      Ensures(\n        unit1_saturationLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit1_saturationLogic_channel3 = value\n    }\n\n    Art.putValue(unit1_saturationLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit1_saturationLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit1_saturationLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit1_saturationLogic_channel4),\n      Ensures(\n        unit1_saturationLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit1_saturationLogic_channel4 = value\n    }\n\n    Art.putValue(unit1_saturationLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_temperatureLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit2_temperatureLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_temperatureLogic_channel1),\n      Ensures(\n        unit2_temperatureLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit2_temperatureLogic_channel1 = value\n    }\n\n    Art.putValue(unit2_temperatureLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_temperatureLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit2_temperatureLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_temperatureLogic_channel2),\n      Ensures(\n        unit2_temperatureLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit2_temperatureLogic_channel2 = value\n    }\n\n    Art.putValue(unit2_temperatureLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_temperatureLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit2_temperatureLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_temperatureLogic_channel3),\n      Ensures(\n        unit2_temperatureLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit2_temperatureLogic_channel3 = value\n    }\n\n    Art.putValue(unit2_temperatureLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_temperatureLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit2_temperatureLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_temperatureLogic_channel4),\n      Ensures(\n        unit2_temperatureLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit2_temperatureLogic_channel4 = value\n    }\n\n    Art.putValue(unit2_temperatureLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_pressureLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit2_pressureLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_pressureLogic_channel1),\n      Ensures(\n        unit2_pressureLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit2_pressureLogic_channel1 = value\n    }\n\n    Art.putValue(unit2_pressureLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_pressureLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit2_pressureLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_pressureLogic_channel2),\n      Ensures(\n        unit2_pressureLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit2_pressureLogic_channel2 = value\n    }\n\n    Art.putValue(unit2_pressureLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_pressureLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit2_pressureLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_pressureLogic_channel3),\n      Ensures(\n        unit2_pressureLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit2_pressureLogic_channel3 = value\n    }\n\n    Art.putValue(unit2_pressureLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_pressureLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit2_pressureLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_pressureLogic_channel4),\n      Ensures(\n        unit2_pressureLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit2_pressureLogic_channel4 = value\n    }\n\n    Art.putValue(unit2_pressureLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_saturationLogic_channel1: Base_Types.Boolean = $\n\n  def put_unit2_saturationLogic_channel1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_saturationLogic_channel1),\n      Ensures(\n        unit2_saturationLogic_channel1 == value\n      )\n    )\n    Spec {\n      unit2_saturationLogic_channel1 = value\n    }\n\n    Art.putValue(unit2_saturationLogic_channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_saturationLogic_channel2: Base_Types.Boolean = $\n\n  def put_unit2_saturationLogic_channel2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_saturationLogic_channel2),\n      Ensures(\n        unit2_saturationLogic_channel2 == value\n      )\n    )\n    Spec {\n      unit2_saturationLogic_channel2 = value\n    }\n\n    Art.putValue(unit2_saturationLogic_channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_saturationLogic_channel3: Base_Types.Boolean = $\n\n  def put_unit2_saturationLogic_channel3(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_saturationLogic_channel3),\n      Ensures(\n        unit2_saturationLogic_channel3 == value\n      )\n    )\n    Spec {\n      unit2_saturationLogic_channel3 = value\n    }\n\n    Art.putValue(unit2_saturationLogic_channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var unit2_saturationLogic_channel4: Base_Types.Boolean = $\n\n  def put_unit2_saturationLogic_channel4(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(unit2_saturationLogic_channel4),\n      Ensures(\n        unit2_saturationLogic_channel4 == value\n      )\n    )\n    Spec {\n      unit2_saturationLogic_channel4 = value\n    }\n\n    Art.putValue(unit2_saturationLogic_channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class InstrumentationMockThread_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val unit1_temperatureLogic_channel1_Id : Art.PortId,\n  val unit1_temperatureLogic_channel2_Id : Art.PortId,\n  val unit1_temperatureLogic_channel3_Id : Art.PortId,\n  val unit1_temperatureLogic_channel4_Id : Art.PortId,\n  val unit1_pressureLogic_channel1_Id : Art.PortId,\n  val unit1_pressureLogic_channel2_Id : Art.PortId,\n  val unit1_pressureLogic_channel3_Id : Art.PortId,\n  val unit1_pressureLogic_channel4_Id : Art.PortId,\n  val unit1_saturationLogic_channel1_Id : Art.PortId,\n  val unit1_saturationLogic_channel2_Id : Art.PortId,\n  val unit1_saturationLogic_channel3_Id : Art.PortId,\n  val unit1_saturationLogic_channel4_Id : Art.PortId,\n  val unit2_temperatureLogic_channel1_Id : Art.PortId,\n  val unit2_temperatureLogic_channel2_Id : Art.PortId,\n  val unit2_temperatureLogic_channel3_Id : Art.PortId,\n  val unit2_temperatureLogic_channel4_Id : Art.PortId,\n  val unit2_pressureLogic_channel1_Id : Art.PortId,\n  val unit2_pressureLogic_channel2_Id : Art.PortId,\n  val unit2_pressureLogic_channel3_Id : Art.PortId,\n  val unit2_pressureLogic_channel4_Id : Art.PortId,\n  val unit2_saturationLogic_channel1_Id : Art.PortId,\n  val unit2_saturationLogic_channel2_Id : Art.PortId,\n  val unit2_saturationLogic_channel3_Id : Art.PortId,\n  val unit2_saturationLogic_channel4_Id : Art.PortId) extends InstrumentationMockThread_i_Api\n\n@datatype class InstrumentationMockThread_i_Operational_Api (\n  val id: Art.BridgeId,\n  val unit1_temperatureLogic_channel1_Id : Art.PortId,\n  val unit1_temperatureLogic_channel2_Id : Art.PortId,\n  val unit1_temperatureLogic_channel3_Id : Art.PortId,\n  val unit1_temperatureLogic_channel4_Id : Art.PortId,\n  val unit1_pressureLogic_channel1_Id : Art.PortId,\n  val unit1_pressureLogic_channel2_Id : Art.PortId,\n  val unit1_pressureLogic_channel3_Id : Art.PortId,\n  val unit1_pressureLogic_channel4_Id : Art.PortId,\n  val unit1_saturationLogic_channel1_Id : Art.PortId,\n  val unit1_saturationLogic_channel2_Id : Art.PortId,\n  val unit1_saturationLogic_channel3_Id : Art.PortId,\n  val unit1_saturationLogic_channel4_Id : Art.PortId,\n  val unit2_temperatureLogic_channel1_Id : Art.PortId,\n  val unit2_temperatureLogic_channel2_Id : Art.PortId,\n  val unit2_temperatureLogic_channel3_Id : Art.PortId,\n  val unit2_temperatureLogic_channel4_Id : Art.PortId,\n  val unit2_pressureLogic_channel1_Id : Art.PortId,\n  val unit2_pressureLogic_channel2_Id : Art.PortId,\n  val unit2_pressureLogic_channel3_Id : Art.PortId,\n  val unit2_pressureLogic_channel4_Id : Art.PortId,\n  val unit2_saturationLogic_channel1_Id : Art.PortId,\n  val unit2_saturationLogic_channel2_Id : Art.PortId,\n  val unit2_saturationLogic_channel3_Id : Art.PortId,\n  val unit2_saturationLogic_channel4_Id : Art.PortId) extends InstrumentationMockThread_i_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Instrumentation\/InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Instrumentation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject InstrumentationMockThread_i_instrumentationMock_instrumentationMockThread {\n\n  def initialise(api: InstrumentationMockThread_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_unit1_temperatureLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit1_temperatureLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit1_temperatureLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit1_temperatureLogic_channel4(Base_Types.Boolean_example())\n    api.put_unit1_pressureLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit1_pressureLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit1_pressureLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit1_pressureLogic_channel4(Base_Types.Boolean_example())\n    api.put_unit1_saturationLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit1_saturationLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit1_saturationLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit1_saturationLogic_channel4(Base_Types.Boolean_example())\n    api.put_unit2_temperatureLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit2_temperatureLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit2_temperatureLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit2_temperatureLogic_channel4(Base_Types.Boolean_example())\n    api.put_unit2_pressureLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit2_pressureLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit2_pressureLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit2_pressureLogic_channel4(Base_Types.Boolean_example())\n    api.put_unit2_saturationLogic_channel1(Base_Types.Boolean_example())\n    api.put_unit2_saturationLogic_channel2(Base_Types.Boolean_example())\n    api.put_unit2_saturationLogic_channel3(Base_Types.Boolean_example())\n    api.put_unit2_saturationLogic_channel4(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: InstrumentationMockThread_i_Operational_Api): Unit = {\n    \/\/ example api usage\n\n\n  }\n\n  def activate(api: InstrumentationMockThread_i_Operational_Api): Unit = { }\n\n  def deactivate(api: InstrumentationMockThread_i_Operational_Api): Unit = { }\n\n  def finalise(api: InstrumentationMockThread_i_Operational_Api): Unit = { }\n\n  def recover(api: InstrumentationMockThread_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_eventControlMock_eventControlMockThread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.EventControl\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait EventControlMockThread_i_eventControlMock_eventControlMockThread_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread)\n  }\n\n  \/** helper function to check EventControlMockThread_i_eventControlMock_eventControlMockThread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param manualActuatorInput1 method that will be called with the value of the outgoing data\n   *        port 'manualActuatorInput1'.\n   * @param manualActuatorInput2 method that will be called with the value of the outgoing data\n   *        port 'manualActuatorInput2'.\n   *\/\n  def check_concrete_output(manualActuatorInput1: Base_Types.Boolean => B,\n                            manualActuatorInput2: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val manualActuatorInput1Value: Base_Types.Boolean = get_manualActuatorInput1().get\n    if(!manualActuatorInput1(manualActuatorInput1Value)) {\n      testFailures = testFailures :+ st\"'manualActuatorInput1' did not match expected: value of the outgoing data port is ${manualActuatorInput1Value}\"\n    }\n    val manualActuatorInput2Value: Base_Types.Boolean = get_manualActuatorInput2().get\n    if(!manualActuatorInput2(manualActuatorInput2Value)) {\n      testFailures = testFailures :+ st\"'manualActuatorInput2' did not match expected: value of the outgoing data port is ${manualActuatorInput2Value}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_manualActuatorInput1(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_manualActuatorInput1_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port manualActuatorInput1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_manualActuatorInput1_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread.initialization_api.manualActuatorInput1_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_manualActuatorInput2(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_manualActuatorInput2_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port manualActuatorInput2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_manualActuatorInput2_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_eventControlMock_eventControlMockThread.initialization_api.manualActuatorInput2_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_eventControlMock_eventControlMockThread_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.EventControl\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class EventControlMockThread_i_eventControlMock_eventControlMockThread_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  EventControlMockThread_i_eventControlMock_eventControlMockThread_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_eventControlMock_eventControlMockThread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.EventControl\n\nimport org.sireum._\nimport RTS_aadl__JVM.EventControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass EventControlMockThread_i_eventControlMock_eventControlMockThread_Test extends EventControlMockThread_i_eventControlMock_eventControlMockThread_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.EventControl\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.EventControl.{EventControlMockThread_i_eventControlMock_eventControlMockThread => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  manualActuatorInput1: Port[Base_Types.Boolean],\n  manualActuatorInput2: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](manualActuatorInput1,\n                              manualActuatorInput2),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : EventControlMockThread_i_Initialization_Api = {\n    val api = EventControlMockThread_i_Initialization_Api(\n      id,\n      manualActuatorInput1.id,\n      manualActuatorInput2.id\n    )\n    EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : EventControlMockThread_i_Operational_Api = {\n    val api = EventControlMockThread_i_Operational_Api(\n      id,\n      manualActuatorInput1.id,\n      manualActuatorInput2.id\n    )\n    EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge.EntryPoints(\n      id,\n\n      manualActuatorInput1.id,\n      manualActuatorInput2.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject EventControlMockThread_i_eventControlMock_eventControlMockThread_Bridge {\n\n  var c_initialization_api: Option[EventControlMockThread_i_Initialization_Api] = None()\n  var c_operational_api: Option[EventControlMockThread_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    EventControlMockThread_i_eventControlMock_eventControlMockThread_BridgeId : Art.BridgeId,\n    manualActuatorInput1_Id : Art.PortId,\n    manualActuatorInput2_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: EventControlMockThread_i_Initialization_Api,\n    operational_api: EventControlMockThread_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(manualActuatorInput1_Id,\n                                             manualActuatorInput2_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: EventControlMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: EventControlMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: EventControlMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.EventControl\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait EventControlMockThread_i_Api {\n  def id: Art.BridgeId\n  def manualActuatorInput1_Id : Art.PortId\n  def manualActuatorInput2_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var manualActuatorInput1: Base_Types.Boolean = $\n\n  def put_manualActuatorInput1(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(manualActuatorInput1),\n      Ensures(\n        manualActuatorInput1 == value\n      )\n    )\n    Spec {\n      manualActuatorInput1 = value\n    }\n\n    Art.putValue(manualActuatorInput1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var manualActuatorInput2: Base_Types.Boolean = $\n\n  def put_manualActuatorInput2(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(manualActuatorInput2),\n      Ensures(\n        manualActuatorInput2 == value\n      )\n    )\n    Spec {\n      manualActuatorInput2 = value\n    }\n\n    Art.putValue(manualActuatorInput2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class EventControlMockThread_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val manualActuatorInput1_Id : Art.PortId,\n  val manualActuatorInput2_Id : Art.PortId) extends EventControlMockThread_i_Api\n\n@datatype class EventControlMockThread_i_Operational_Api (\n  val id: Art.BridgeId,\n  val manualActuatorInput1_Id : Art.PortId,\n  val manualActuatorInput2_Id : Art.PortId) extends EventControlMockThread_i_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/EventControl\/EventControlMockThread_i_eventControlMock_eventControlMockThread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.EventControl\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject EventControlMockThread_i_eventControlMock_eventControlMockThread {\n\n  def initialise(api: EventControlMockThread_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_manualActuatorInput1(Base_Types.Boolean_example())\n    api.put_manualActuatorInput2(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: EventControlMockThread_i_Operational_Api): Unit = {\n    \/\/ example api usage\n\n\n  }\n\n  def activate(api: EventControlMockThread_i_Operational_Api): Unit = { }\n\n  def deactivate(api: EventControlMockThread_i_Operational_Api): Unit = { }\n\n  def finalise(api: EventControlMockThread_i_Operational_Api): Unit = { }\n\n  def recover(api: EventControlMockThread_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuators\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param tempPressureActuate payload for data port tempPressureActuate\n   * @param saturationActuate payload for data port saturationActuate\n   *\/\n  def put_concrete_inputs(tempPressureActuate : Base_Types.Boolean,\n                          saturationActuate : Base_Types.Boolean): Unit = {\n    put_tempPressureActuate(tempPressureActuate)\n    put_saturationActuate(saturationActuate)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_tempPressureActuate(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread.operational_api.tempPressureActuate_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_saturationActuate(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuatorsMock_actuatorsMockThread.operational_api.saturationActuate_Id, Base_Types.Boolean_Payload(value))\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuators\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuators\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuators._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Test extends ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuators\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuators.{ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  tempPressureActuate: Port[Base_Types.Boolean],\n  saturationActuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](tempPressureActuate,\n                             saturationActuate),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : ActuatorsMockThread_i_Initialization_Api = {\n    val api = ActuatorsMockThread_i_Initialization_Api(\n      id,\n      tempPressureActuate.id,\n      saturationActuate.id\n    )\n    ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : ActuatorsMockThread_i_Operational_Api = {\n    val api = ActuatorsMockThread_i_Operational_Api(\n      id,\n      tempPressureActuate.id,\n      saturationActuate.id\n    )\n    ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge.EntryPoints(\n      id,\n\n      tempPressureActuate.id,\n      saturationActuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_Bridge {\n\n  var c_initialization_api: Option[ActuatorsMockThread_i_Initialization_Api] = None()\n  var c_operational_api: Option[ActuatorsMockThread_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread_BridgeId : Art.BridgeId,\n    tempPressureActuate_Id : Art.PortId,\n    saturationActuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: ActuatorsMockThread_i_Initialization_Api,\n    operational_api: ActuatorsMockThread_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(tempPressureActuate_Id,\n                                            saturationActuate_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: ActuatorsMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: ActuatorsMockThread_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: ActuatorsMockThread_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuators\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait ActuatorsMockThread_i_Api {\n  def id: Art.BridgeId\n  def tempPressureActuate_Id : Art.PortId\n  def saturationActuate_Id : Art.PortId\n\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class ActuatorsMockThread_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val tempPressureActuate_Id : Art.PortId,\n  val saturationActuate_Id : Art.PortId) extends ActuatorsMockThread_i_Api\n\n@datatype class ActuatorsMockThread_i_Operational_Api (\n  val id: Art.BridgeId,\n  val tempPressureActuate_Id : Art.PortId,\n  val saturationActuate_Id : Art.PortId) extends ActuatorsMockThread_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var tempPressureActuate: Base_Types.Boolean = $\n\n  def get_tempPressureActuate() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(tempPressureActuate)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(tempPressureActuate_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port tempPressureActuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var saturationActuate: Base_Types.Boolean = $\n\n  def get_saturationActuate() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(saturationActuate)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(saturationActuate_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port saturationActuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuators\/ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuators\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject ActuatorsMockThread_i_actuatorsMock_actuatorsMockThread {\n\n  def initialise(api: ActuatorsMockThread_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n  }\n\n  def timeTriggered(api: ActuatorsMockThread_i_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_tempPressureActuate: Option[Base_Types.Boolean] = api.get_tempPressureActuate()\n    api.logInfo(s\"Received on data port tempPressureActuate: ${apiUsage_tempPressureActuate}\")\n    val apiUsage_saturationActuate: Option[Base_Types.Boolean] = api.get_saturationActuate()\n    api.logInfo(s\"Received on data port saturationActuate: ${apiUsage_saturationActuate}\")\n  }\n\n  def activate(api: ActuatorsMockThread_i_Operational_Api): Unit = { }\n\n  def deactivate(api: ActuatorsMockThread_i_Operational_Api): Unit = { }\n\n  def finalise(api: ActuatorsMockThread_i_Operational_Api): Unit = { }\n\n  def recover(api: ActuatorsMockThread_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait CoincidenceLogic_i_Api {\n  def id: Art.BridgeId\n  def channel1_Id : Art.PortId\n  def channel2_Id : Art.PortId\n  def channel3_Id : Art.PortId\n  def channel4_Id : Art.PortId\n  def actuate_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var actuate: Base_Types.Boolean = $\n\n  def put_actuate(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(actuate),\n      Ensures(\n        actuate == value\n      )\n    )\n    Spec {\n      actuate = value\n    }\n\n    Art.putValue(actuate_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CoincidenceLogic_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val channel1_Id : Art.PortId,\n  val channel2_Id : Art.PortId,\n  val channel3_Id : Art.PortId,\n  val channel4_Id : Art.PortId,\n  val actuate_Id : Art.PortId) extends CoincidenceLogic_i_Api\n\n@datatype class CoincidenceLogic_i_Operational_Api (\n  val id: Art.BridgeId,\n  val channel1_Id : Art.PortId,\n  val channel2_Id : Art.PortId,\n  val channel3_Id : Art.PortId,\n  val channel4_Id : Art.PortId,\n  val actuate_Id : Art.PortId) extends CoincidenceLogic_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel1: Base_Types.Boolean = $\n\n  def get_channel1() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel1)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel1_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel2: Base_Types.Boolean = $\n\n  def get_channel2() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel2)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel2_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel3: Base_Types.Boolean = $\n\n  def get_channel3() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel3)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel3_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel3.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel4: Base_Types.Boolean = $\n\n  def get_channel4() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel4)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel4_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel4.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/GumboXUtil.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage RTS_aadl__JVM\n\nimport org.sireum._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject GumboXUtil {\n\n  var numTestVectorGenRetries: Z = 100\n\n  @enum object GumboXResult {\n    \"Pre_Condition_Unsat\"\n    \"Post_Condition_Pass\"\n    \"Post_Condition_Fail\"\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/DSC_RecordUnsatPre.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject DSC_RecordUnsatPre {\n\n  \/** report will be called when a test vector generated by Distributed Slang Check does\n    * not satisfy an entry point's assume\/require clauses.  The test vector could, e.g.,\n    * be written out to a file as DSC does for the passing and failing vectors\n    *\n    * @param testVector the JSON serialized test vector\n    *\/\n  def report(testVector: String): Unit = {\n\n  }\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n  }\n\n\n  \/** helper function to check OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Test extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : OrLogic_i_Initialization_Api = {\n    val api = OrLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : OrLogic_i_Operational_Api = {\n    val api = OrLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Bridge {\n\n  var c_initialization_api: Option[OrLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[OrLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: OrLogic_i_Initialization_Api,\n    operational_api: OrLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: OrLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: OrLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait OrLogic_i_Api {\n  def id: Art.BridgeId\n  def channel1_Id : Art.PortId\n  def channel2_Id : Art.PortId\n  def actuate_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var actuate: Base_Types.Boolean = $\n\n  def put_actuate(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(actuate),\n      Ensures(\n        actuate == value\n      )\n    )\n    Spec {\n      actuate = value\n    }\n\n    Art.putValue(actuate_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class OrLogic_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val channel1_Id : Art.PortId,\n  val channel2_Id : Art.PortId,\n  val actuate_Id : Art.PortId) extends OrLogic_i_Api\n\n@datatype class OrLogic_i_Operational_Api (\n  val id: Art.BridgeId,\n  val channel1_Id : Art.PortId,\n  val channel2_Id : Art.PortId,\n  val actuate_Id : Art.PortId) extends OrLogic_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel1: Base_Types.Boolean = $\n\n  def get_channel1() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel1)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel1_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel1.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var channel2: Base_Types.Boolean = $\n\n  def get_channel2() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(channel2)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(channel2_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port channel2.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic {\n\n  def initialise(api: OrLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee orOutput\n        api.actuate == (api.channel1 | api.channel2)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n  }\n\n  def activate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: OrLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee orOutput\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_orOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 | api_channel2)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for orLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_orOutput_guarantee(api_channel1, api_channel2, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of orLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_PS,\n      post: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   orLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   orLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P]\n\n  def getDefaultProfile_P: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P = {\n    return OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P): Option[OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n\n      return Some(OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(api_channel1,api_channel2))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_Tests extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P]\n  with OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    return OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(\n      api_channel1, api_channel2\n    )\n  }\n\n  override def toCompactJson(o: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n}\n\n\/\/ container for incoming ports\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PreState_Container\n\n@sig trait OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_P (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container_PS (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   * @param channel3 payload for data port channel3\n   * @param channel4 payload for data port channel4\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean,\n                          channel3 : Base_Types.Boolean,\n                          channel4 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n    put_channel3(channel3)\n    put_channel4(channel4)\n  }\n\n\n  \/** helper function to check CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel3(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.operational_api.channel3_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel4(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.operational_api.channel4_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Test extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  channel3: Port[Base_Types.Boolean],\n  channel4: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2,\n                             channel3,\n                             channel4),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CoincidenceLogic_i_Initialization_Api = {\n    val api = CoincidenceLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CoincidenceLogic_i_Operational_Api = {\n    val api = CoincidenceLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id\n    )\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      channel3.id,\n      channel4.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Bridge {\n\n  var c_initialization_api: Option[CoincidenceLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[CoincidenceLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    channel3_Id : Art.PortId,\n    channel4_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CoincidenceLogic_i_Initialization_Api,\n    operational_api: CoincidenceLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id,\n                                            channel3_Id,\n                                            channel4_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic {\n\n  def initialise(api: CoincidenceLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: CoincidenceLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee coincidenceOutput\n        \/\/   from actuationUnit.cry\n        \/\/   Coincidence_2_4 : [4]TripPort -> Bit\n        \/\/   Coincidence_2_4 x =\n        \/\/       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n        \/\/   For specification redundancy, provide an alternate but equivalent specification\n        \/\/   of the concept 'at least two of the input channels are true.'\n        api.actuate == (api.channel1 & api.channel2 |\n           api.channel1 & api.channel3 |\n           api.channel1 & api.channel4 |\n           api.channel2 & api.channel3 |\n           api.channel2 & api.channel4 |\n           api.channel3 & api.channel4)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n    val apiUsage_channel3: Option[Base_Types.Boolean] = api.get_channel3()\n    api.logInfo(s\"Received on data port channel3: ${apiUsage_channel3}\")\n    val apiUsage_channel4: Option[Base_Types.Boolean] = api.get_channel4()\n    api.logInfo(s\"Received on data port channel4: ${apiUsage_channel4}\")\n  }\n\n  def activate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: CoincidenceLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee coincidenceOutput\n    *   from actuationUnit.cry\n    *   Coincidence_2_4 : [4]TripPort -> Bit\n    *   Coincidence_2_4 x =\n    *       (a&&b) || ((a||b) && (c||d)) || (c&&d)\n    *   For specification redundancy, provide an alternate but equivalent specification\n    *   of the concept 'at least two of the input channels are true.'\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_coincidenceOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 & api_channel2 |\n       api_channel1 & api_channel3 |\n       api_channel1 & api_channel4 |\n       api_channel2 & api_channel3 |\n       api_channel2 & api_channel4 |\n       api_channel3 & api_channel4)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for coincidenceLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_coincidenceOutput_guarantee(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of coincidenceLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_channel3, api_channel4, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for coincidenceLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_PS,\n      post: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_channel3 = pre.api_channel3,\n      api_channel4 = pre.api_channel4,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2, o.api_channel3, o.api_channel4)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_channel3 incoming data port\n    * @param api_channel4 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_channel3: Base_Types.Boolean,\n      api_channel4: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   coincidenceLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   coincidenceLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n    put_channel3(api_channel3)\n    put_channel4(api_channel4)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\n                  |  api_channel3 = ${api_channel3.string}\n                  |  api_channel4 = ${api_channel4.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_channel3, api_channel4, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P]\n\n  def getDefaultProfile_P: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P = {\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel3 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel4 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P): Option[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n      val api_channel3 = profile.api_channel3.nextB()\n      val api_channel4 = profile.api_channel4.nextB()\n\n      return Some(CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(api_channel1,api_channel2,api_channel3,api_channel4))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_Tests extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P]\n  with CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel3: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel4: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    val api_channel3 = ranLibchannel3.nextB()\n    val api_channel4 = ranLibchannel4.nextB()\n    return CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(\n      api_channel1, api_channel2, api_channel3, api_channel4\n    )\n  }\n\n  override def toCompactJson(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationCoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n  def api_channel3: B\n  def api_channel4: B\n}\n\n\/\/ container for incoming ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B,\n  val api_channel3: B,\n  val api_channel4: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PreState_Container\n\n@sig trait CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_P (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container_PS (\n  val api_actuate: B) extends CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib,\n  var api_channel3: RandomLib,\n  var api_channel4: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n  }\n\n\n  \/** helper function to check OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Test extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : OrLogic_i_Initialization_Api = {\n    val api = OrLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : OrLogic_i_Operational_Api = {\n    val api = OrLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Bridge {\n\n  var c_initialization_api: Option[OrLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[OrLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: OrLogic_i_Initialization_Api,\n    operational_api: OrLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: OrLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: OrLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic {\n\n  def initialise(api: OrLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee orOutput\n        api.actuate == (api.channel1 | api.channel2)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n  }\n\n  def activate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: OrLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee orOutput\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_orOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 | api_channel2)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for orLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_orOutput_guarantee(api_channel1, api_channel2, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of orLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_PS,\n      post: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   orLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   orLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P]\n\n  def getDefaultProfile_P: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P = {\n    return OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P): Option[OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n\n      return Some(OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(api_channel1,api_channel2))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_Tests extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P]\n  with OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    return OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(\n      api_channel1, api_channel2\n    )\n  }\n\n  override def toCompactJson(o: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n}\n\n\/\/ container for incoming ports\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PreState_Container\n\n@sig trait OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_P (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container_PS (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n  }\n\n\n  \/** helper function to check OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Test extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : OrLogic_i_Initialization_Api = {\n    val api = OrLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : OrLogic_i_Operational_Api = {\n    val api = OrLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Bridge {\n\n  var c_initialization_api: Option[OrLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[OrLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: OrLogic_i_Initialization_Api,\n    operational_api: OrLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: OrLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: OrLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic {\n\n  def initialise(api: OrLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee orOutput\n        api.actuate == (api.channel1 | api.channel2)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n  }\n\n  def activate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: OrLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee orOutput\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_orOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 | api_channel2)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for orLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_orOutput_guarantee(api_channel1, api_channel2, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of orLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_PS,\n      post: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   orLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   orLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P]\n\n  def getDefaultProfile_P: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P = {\n    return OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P): Option[OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n\n      return Some(OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(api_channel1,api_channel2))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_Tests extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P]\n  with OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    return OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(\n      api_channel1, api_channel2\n    )\n  }\n\n  override def toCompactJson(o: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n}\n\n\/\/ container for incoming ports\n@datatype class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PreState_Container\n\n@sig trait OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_P (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container_PS (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param input payload for data port input\n   * @param manualActuatorInput payload for data port manualActuatorInput\n   *\/\n  def put_concrete_inputs(input : Base_Types.Boolean,\n                          manualActuatorInput : Base_Types.Boolean): Unit = {\n    put_input(input)\n    put_manualActuatorInput(manualActuatorInput)\n  }\n\n\n  \/** helper function to check Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param output method that will be called with the value of the outgoing data\n   *        port 'output'.\n   *\/\n  def check_concrete_output(output: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val outputValue: Base_Types.Boolean = get_output().get\n    if(!output(outputValue)) {\n      testFailures = testFailures :+ st\"'output' did not match expected: value of the outgoing data port is ${outputValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_input(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.operational_api.input_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_manualActuatorInput(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.operational_api.manualActuatorInput_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_output(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_output_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port output.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_output_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.initialization_api.output_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Test extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  input: Port[Base_Types.Boolean],\n  manualActuatorInput: Port[Base_Types.Boolean],\n  output: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](input,\n                             manualActuatorInput),\n\n    dataOuts = ISZ[art.UPort](output),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : Actuator_i_Initialization_Api = {\n    val api = Actuator_i_Initialization_Api(\n      id,\n      input.id,\n      manualActuatorInput.id,\n      output.id\n    )\n    Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Actuator_i_Operational_Api = {\n    val api = Actuator_i_Operational_Api(\n      id,\n      input.id,\n      manualActuatorInput.id,\n      output.id\n    )\n    Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge.EntryPoints(\n      id,\n\n      input.id,\n      manualActuatorInput.id,\n      output.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Bridge {\n\n  var c_initialization_api: Option[Actuator_i_Initialization_Api] = None()\n  var c_operational_api: Option[Actuator_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_BridgeId : Art.BridgeId,\n    input_Id : Art.PortId,\n    manualActuatorInput_Id : Art.PortId,\n    output_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: Actuator_i_Initialization_Api,\n    operational_api: Actuator_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(input_Id,\n                                            manualActuatorInput_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(output_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Actuator_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Actuator_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Actuator_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Actuator_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Actuator_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Actuator_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\n\n@sig trait Actuator_i_Api {\n  def id: Art.BridgeId\n  def input_Id : Art.PortId\n  def manualActuatorInput_Id : Art.PortId\n  def output_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var output: Base_Types.Boolean = $\n\n  def put_output(value : Base_Types.Boolean) : Unit = {\n    Contract(\n      Modifies(output),\n      Ensures(\n        output == value\n      )\n    )\n    Spec {\n      output = value\n    }\n\n    Art.putValue(output_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Actuator_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val input_Id : Art.PortId,\n  val manualActuatorInput_Id : Art.PortId,\n  val output_Id : Art.PortId) extends Actuator_i_Api\n\n@datatype class Actuator_i_Operational_Api (\n  val id: Art.BridgeId,\n  val input_Id : Art.PortId,\n  val manualActuatorInput_Id : Art.PortId,\n  val output_Id : Art.PortId) extends Actuator_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var input: Base_Types.Boolean = $\n\n  def get_input() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(input)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(input_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port input.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var manualActuatorInput: Base_Types.Boolean = $\n\n  def get_manualActuatorInput() : Option[Base_Types.Boolean] = {\n    Contract(\n      Ensures(\n        Res == Some(manualActuatorInput)\n      )\n    )\n    val value : Option[Base_Types.Boolean] = Art.getValue(manualActuatorInput_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port manualActuatorInput.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator {\n\n  def initialise(api: Actuator_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_output(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee actuatorOutput\n        api.output == (api.input | api.manualActuatorInput)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_input: Option[Base_Types.Boolean] = api.get_input()\n    api.logInfo(s\"Received on data port input: ${apiUsage_input}\")\n    val apiUsage_manualActuatorInput: Option[Base_Types.Boolean] = api.get_manualActuatorInput()\n    api.logInfo(s\"Received on data port manualActuatorInput: ${apiUsage_manualActuatorInput}\")\n  }\n\n  def activate(api: Actuator_i_Operational_Api): Unit = { }\n\n  def deactivate(api: Actuator_i_Operational_Api): Unit = { }\n\n  def finalise(api: Actuator_i_Operational_Api): Unit = { }\n\n  def recover(api: Actuator_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee actuatorOutput\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_spec_actuatorOutput_guarantee(\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    api_output == (api_input | api_manualActuatorInput)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for actuator's compute entrypoint\n    *\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    compute_spec_actuatorOutput_guarantee(api_input, api_manualActuatorInput, api_output)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for actuator\n    *\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of actuator's compute entrypoint\n     compute_CEP_T_Guar (api_input, api_manualActuatorInput, api_output))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for actuator via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_PS,\n      post: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_input = pre.api_input,\n      api_manualActuatorInput = pre.api_manualActuatorInput,\n      api_output = post.api_output)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_input, o.api_manualActuatorInput)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    *\/\n  def testComputeCB(\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   actuator does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   actuator's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_input(api_input)\n    put_manualActuatorInput(api_manualActuatorInput)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_input = ${api_input.string}\n                  |  api_manualActuatorInput = ${api_manualActuatorInput.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_output: Base_Types.Boolean = get_output().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_output = ${api_output.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX.compute_CEP_Post(api_input, api_manualActuatorInput, api_output)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest_Generator extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P]\n\n  def getDefaultProfile_P: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P = {\n    return Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_input = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_manualActuatorInput = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P): Option[Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P] = {\n    try {\n      val api_input = profile.api_input.nextB()\n      val api_manualActuatorInput = profile.api_manualActuatorInput.nextB()\n\n      return Some(Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(api_input,api_manualActuatorInput))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_Tests extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P]\n  with Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibinput: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibmanualActuatorInput: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P = {\n    val api_input = ranLibinput.nextB()\n    val api_manualActuatorInput = ranLibmanualActuatorInput.nextB()\n    return Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(\n      api_input, api_manualActuatorInput\n    )\n  }\n\n  override def toCompactJson(o: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container extends art.DataContent {\n  def api_input: B\n  def api_manualActuatorInput: B\n}\n\n\/\/ container for incoming ports\n@datatype class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_P (\n  val api_input: B,\n  val api_manualActuatorInput: B) extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container_PS (\n  val api_input: B,\n  val api_manualActuatorInput: B) extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PreState_Container\n\n@sig trait Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container extends art.DataContent {\n  def api_output: B\n}\n\n\/\/ container for outgoing ports\n@datatype class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_P (\n  val api_output: B) extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container_PS (\n  val api_output: B) extends Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_input: RandomLib,\n  var api_manualActuatorInput: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_input: RandomLib,\n  var api_manualActuatorInput: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param channel1 payload for data port channel1\n   * @param channel2 payload for data port channel2\n   *\/\n  def put_concrete_inputs(channel1 : Base_Types.Boolean,\n                          channel2 : Base_Types.Boolean): Unit = {\n    put_channel1(channel1)\n    put_channel2(channel2)\n  }\n\n\n  \/** helper function to check OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param actuate method that will be called with the value of the outgoing data\n   *        port 'actuate'.\n   *\/\n  def check_concrete_output(actuate: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val actuateValue: Base_Types.Boolean = get_actuate().get\n    if(!actuate(actuateValue)) {\n      testFailures = testFailures :+ st\"'actuate' did not match expected: value of the outgoing data port is ${actuateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_channel1(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.operational_api.channel1_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_channel2(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.operational_api.channel2_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_actuate(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_actuate_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port actuate.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_actuate_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.initialization_api.actuate_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Test extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  channel1: Port[Base_Types.Boolean],\n  channel2: Port[Base_Types.Boolean],\n  actuate: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](channel1,\n                             channel2),\n\n    dataOuts = ISZ[art.UPort](actuate),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : OrLogic_i_Initialization_Api = {\n    val api = OrLogic_i_Initialization_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : OrLogic_i_Operational_Api = {\n    val api = OrLogic_i_Operational_Api(\n      id,\n      channel1.id,\n      channel2.id,\n      actuate.id\n    )\n    OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge.EntryPoints(\n      id,\n\n      channel1.id,\n      channel2.id,\n      actuate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Bridge {\n\n  var c_initialization_api: Option[OrLogic_i_Initialization_Api] = None()\n  var c_operational_api: Option[OrLogic_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_BridgeId : Art.BridgeId,\n    channel1_Id : Art.PortId,\n    channel2_Id : Art.PortId,\n    actuate_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: OrLogic_i_Initialization_Api,\n    operational_api: OrLogic_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(channel1_Id,\n                                            channel2_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(actuate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: OrLogic_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: OrLogic_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: OrLogic_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: OrLogic_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic {\n\n  def initialise(api: OrLogic_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_actuate(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: OrLogic_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee orOutput\n        api.actuate == (api.channel1 | api.channel2)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_channel1: Option[Base_Types.Boolean] = api.get_channel1()\n    api.logInfo(s\"Received on data port channel1: ${apiUsage_channel1}\")\n    val apiUsage_channel2: Option[Base_Types.Boolean] = api.get_channel2()\n    api.logInfo(s\"Received on data port channel2: ${apiUsage_channel2}\")\n  }\n\n  def activate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def deactivate(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def finalise(api: OrLogic_i_Operational_Api): Unit = { }\n\n  def recover(api: OrLogic_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee orOutput\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_spec_orOutput_guarantee(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    api_actuate == (api_channel1 | api_channel2)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for orLogic's compute entrypoint\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    compute_spec_orOutput_guarantee(api_channel1, api_channel2, api_actuate)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic\n    *\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    * @param api_actuate outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean,\n      api_actuate: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of orLogic's compute entrypoint\n     compute_CEP_T_Guar (api_channel1, api_channel2, api_actuate))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for orLogic via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_PS,\n      post: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_channel1 = pre.api_channel1,\n      api_channel2 = pre.api_channel2,\n      api_actuate = post.api_actuate)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_channel1, o.api_channel2)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_channel1 incoming data port\n    * @param api_channel2 incoming data port\n    *\/\n  def testComputeCB(\n      api_channel1: Base_Types.Boolean,\n      api_channel2: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   orLogic does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   orLogic's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_channel1(api_channel1)\n    put_channel2(api_channel2)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_channel1 = ${api_channel1.string}\n                  |  api_channel2 = ${api_channel2.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_actuate: Base_Types.Boolean = get_actuate().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_actuate = ${api_actuate.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX.compute_CEP_Post(api_channel1, api_channel2, api_actuate)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P]\n\n  def getDefaultProfile_P: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P = {\n    return OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_channel1 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_channel2 = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P): Option[OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P] = {\n    try {\n      val api_channel1 = profile.api_channel1.nextB()\n      val api_channel2 = profile.api_channel2.nextB()\n\n      return Some(OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(api_channel1,api_channel2))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_Tests extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P]\n  with OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibchannel1: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibchannel2: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P = {\n    val api_channel1 = ranLibchannel1.nextB()\n    val api_channel2 = ranLibchannel2.nextB()\n    return OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(\n      api_channel1, api_channel2\n    )\n  }\n\n  override def toCompactJson(o: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationOrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container extends art.DataContent {\n  def api_channel1: B\n  def api_channel2: B\n}\n\n\/\/ container for incoming ports\n@datatype class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_P (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container_PS (\n  val api_channel1: B,\n  val api_channel2: B) extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PreState_Container\n\n@sig trait OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container extends art.DataContent {\n  def api_actuate: B\n}\n\n\/\/ container for outgoing ports\n@datatype class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_P (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container_PS (\n  val api_actuate: B) extends OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_channel1: RandomLib,\n  var api_channel2: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art.{Art, ArtNative, Empty}\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param input payload for data port input\n   * @param manualActuatorInput payload for data port manualActuatorInput\n   *\/\n  def put_concrete_inputs(input : Base_Types.Boolean,\n                          manualActuatorInput : Base_Types.Boolean): Unit = {\n    put_input(input)\n    put_manualActuatorInput(manualActuatorInput)\n  }\n\n\n  \/** helper function to check Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param output method that will be called with the value of the outgoing data\n   *        port 'output'.\n   *\/\n  def check_concrete_output(output: Base_Types.Boolean => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val outputValue: Base_Types.Boolean = get_output().get\n    if(!output(outputValue)) {\n      testFailures = testFailures :+ st\"'output' did not match expected: value of the outgoing data port is ${outputValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_input(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.operational_api.input_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_manualActuatorInput(value : Base_Types.Boolean): Unit = {\n    ArtNative.insertInInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.operational_api.manualActuatorInput_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_output(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_output_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port output.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_output_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative.observeOutInfrastructurePort(Arch.RTS_i_Instance_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.initialization_api.output_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Test extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport art._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.Actuation.{Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  input: Port[Base_Types.Boolean],\n  manualActuatorInput: Port[Base_Types.Boolean],\n  output: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](input,\n                             manualActuatorInput),\n\n    dataOuts = ISZ[art.UPort](output),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : Actuator_i_Initialization_Api = {\n    val api = Actuator_i_Initialization_Api(\n      id,\n      input.id,\n      manualActuatorInput.id,\n      output.id\n    )\n    Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Actuator_i_Operational_Api = {\n    val api = Actuator_i_Operational_Api(\n      id,\n      input.id,\n      manualActuatorInput.id,\n      output.id\n    )\n    Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge.EntryPoints(\n      id,\n\n      input.id,\n      manualActuatorInput.id,\n      output.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Bridge {\n\n  var c_initialization_api: Option[Actuator_i_Initialization_Api] = None()\n  var c_operational_api: Option[Actuator_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_BridgeId : Art.BridgeId,\n    input_Id : Art.PortId,\n    manualActuatorInput_Id : Art.PortId,\n    output_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: Actuator_i_Initialization_Api,\n    operational_api: Actuator_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(input_Id,\n                                            manualActuatorInput_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(output_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Actuator_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Actuator_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Actuator_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Actuator_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Actuator_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Actuator_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/component\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator {\n\n  def initialise(api: Actuator_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_output(Base_Types.Boolean_example())\n  }\n\n  def timeTriggered(api: Actuator_i_Operational_Api): Unit = {\n    Contract(\n      Ensures(\n        \/\/ BEGIN COMPUTE ENSURES timeTriggered\n        \/\/ guarantee actuatorOutput\n        api.output == (api.input | api.manualActuatorInput)\n        \/\/ END COMPUTE ENSURES timeTriggered\n      )\n    )\n    \/\/ example api usage\n\n    val apiUsage_input: Option[Base_Types.Boolean] = api.get_input()\n    api.logInfo(s\"Received on data port input: ${apiUsage_input}\")\n    val apiUsage_manualActuatorInput: Option[Base_Types.Boolean] = api.get_manualActuatorInput()\n    api.logInfo(s\"Received on data port manualActuatorInput: ${apiUsage_manualActuatorInput}\")\n  }\n\n  def activate(api: Actuator_i_Operational_Api): Unit = { }\n\n  def deactivate(api: Actuator_i_Operational_Api): Unit = { }\n\n  def finalise(api: Actuator_i_Operational_Api): Unit = { }\n\n  def recover(api: Actuator_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN COMPUTE ENSURES timeTriggered",
              "endMarker" : "\/\/ END COMPUTE ENSURES timeTriggered"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nobject Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX {\n  \/** Compute Entrypoint Contract\n    *\n    * guarantee actuatorOutput\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_spec_actuatorOutput_guarantee(\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    api_output == (api_input | api_manualActuatorInput)\n\n  \/** CEP-T-Guar: Top-level guarantee contracts for actuator's compute entrypoint\n    *\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_CEP_T_Guar (\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    compute_spec_actuatorOutput_guarantee(api_input, api_manualActuatorInput, api_output)\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for actuator\n    *\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    * @param api_output outgoing data port\n    *\/\n  @strictpure def compute_CEP_Post (\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean,\n      api_output: Base_Types.Boolean): B =\n    (\/\/ CEP-Guar: guarantee clauses of actuator's compute entrypoint\n     compute_CEP_T_Guar (api_input, api_manualActuatorInput, api_output))\n\n  \/** CEP-Post: Compute Entrypoint Post-Condition for actuator via containers\n    *\n    * @param pre Container holding the values of incoming ports and the pre-state values of state variables\n    * @param post Container holding the values of outgoing ports and the post-state values of state variables\n    *\/\n  @strictpure def compute_CEP_Post_Container(\n      pre: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_PS,\n      post: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS): B =\n    compute_CEP_Post(\n      api_input = pre.api_input,\n      api_manualActuatorInput = pre.api_manualActuatorInput,\n      api_output = post.api_output)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_TestApi {\n  def verbose: B\n\n  def testComputeCBJ(json: String): GumboXResult.Type = {\n    RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container(json) match {\n      case Either.Left(o) => return testComputeCBV(o)\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  def testComputeCBV(o: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container): GumboXResult.Type = {\n    return testComputeCB(o.api_input, o.api_manualActuatorInput)\n  }\n\n  \/** Contract-based test harness for the compute entry point\n    * @param api_input incoming data port\n    * @param api_manualActuatorInput incoming data port\n    *\/\n  def testComputeCB(\n      api_input: Base_Types.Boolean,\n      api_manualActuatorInput: Base_Types.Boolean): GumboXResult.Type = {\n\n    \/\/ [SaveInLocal]: retrieve and save the current (input) values of GUMBO-declared local state variables as retrieved from the component state\n    \/\/   actuator does not have incoming ports or state variables\n\n    \/\/ [CheckPre]: check\/filter based on pre-condition.\n    \/\/   actuator's compute entry point does not have top level assume clauses\n\n    \/\/ [PutInPorts]: put values on the input ports\n    put_input(api_input)\n    put_manualActuatorInput(api_manualActuatorInput)\n\n    if (verbose) {\n      println(st\"\"\"Pre State Values:\n                  |  api_input = ${api_input.string}\n                  |  api_manualActuatorInput = ${api_manualActuatorInput.string}\"\"\".render)\n    }\n\n    \/\/ [InvokeEntryPoint]: invoke the entry point test method\n    testCompute()\n\n    \/\/ [RetrieveOutState]: retrieve values of the output ports via get operations and GUMBO declared local state variable\n    val api_output: Base_Types.Boolean = get_output().get\n\n    if (verbose) {\n      println(st\"\"\"Post State Values:\n                  |  api_output = ${api_output.string}\"\"\".render)\n    }\n\n    \/\/ [CheckPost]: invoke the oracle function\n    val postResult = RTS_aadl__JVM.Actuation.Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX.compute_CEP_Post(api_input, api_manualActuatorInput, api_output)\n    val result: GumboXResult.Type =\n      if (!postResult) GumboXResult.Post_Condition_Fail\n      else GumboXResult.Post_Condition_Pass\n\n    return result\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest_Generator.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM.GumboXUtil\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ntrait Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest_Generator extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest {\n\n  def failOnUnsatPreconditions: B = F\n\n  def seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n\n  def getProfiles_P: ISZ[Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P]\n\n  def getDefaultProfile_P: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P = {\n    return Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P (\n      name = \"Default Port Profile\", \n      numTests = 100, \n      api_input = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))), \n      api_manualActuatorInput = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64()))))\n  }\n\n  def next(profile: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P): Option[Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P] = {\n    try {\n      val api_input = profile.api_input.nextB()\n      val api_manualActuatorInput = profile.api_manualActuatorInput.nextB()\n\n      return Some(Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(api_input,api_manualActuatorInput))\n    } catch {\n      case e: AssertionError =>\n       \/\/ SlangCheck was unable to satisfy a datatype's filter\n       return None()\n    }\n  }\n\n  for (profile <- getProfiles_P) {\n    testComputeCB_Profile_P(profile)\n  }\n\n  def testComputeCB_Profile_P(profile: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P): Unit = {\n    for (i <- 0 to profile.numTests) {\n      this.registerTest(s\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n        var retry: B = T\n\n        var j: Z = 0\n        while (j < GumboXUtil.numTestVectorGenRetries && retry) {\n          next(profile) match {\n            case Some(o) =>\n\n              if (verbose && j > 0) {\n                println(s\"Retry $j:\")\n              }\n\n              val results = testComputeCBV(o)\n\n              if (verbose) {\n                val tq = \"\\\"\\\"\\\"\"\n                println(st\"\"\"Replay Unit Test:\n                            |  test(\"Profile \\\"${profile.name}\\\": testComputeCB_$i\") {\n                            |    val json = st${tq}${RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(o, T)}${tq}.render\n                            |    val testVector = RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(json).left\n                            |    assert (testComputeCBV(testVector) == RTS_aadl__JVM.GumboXUtil.GumboXResult.$results)\n                            |  }\"\"\".render)\n              }\n\n              results match {\n                case GumboXResult.Pre_Condition_Unsat =>\n                case GumboXResult.Post_Condition_Fail =>\n                  fail (\"Post condition did not hold\")\n                  retry = F\n                case GumboXResult.Post_Condition_Pass =>\n                  if (verbose) {\n                    println (\"Success!\")\n                  }\n                  retry = F\n              }\n            case _ =>\n          }\n          j = j + 1\n        }\n\n        if (retry) {\n          if (failOnUnsatPreconditions) {\n            fail (\"Unable to satisfy precondition\")\n          } else if (verbose) {\n            cprintln(T, \"Unable to satisfy precondition\")\n          }\n        }\n      }\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/bridge\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_Tests.scala",
        {
          "type" : "ITestResource",
          "content" : "package RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.Actuation._\nimport RTS_aadl__JVM._\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ This file will not be overwritten so is safe to edit\n\nclass Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_Tests extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness_ScalaTest_Generator {\n\n  \/\/ set verbose to T to see pre\/post state values and generated unit tests\n  \/\/ that can be copied\/pasted to replay a test\n  override val verbose: B = F\n\n  \/\/ set failOnUnsatPreconditions to T if the unit tests should fail when either\n  \/\/ SlangCheck is never able to satisfy a datatype's filter or the generated\n  \/\/ test vectors are never able to satisfy an entry point's assume pre-condition\n  override val failOnUnsatPreconditions: B = F\n\n  \/\/ profiles that will be used to generate the incoming port values\n  override def getProfiles_P: ISZ[Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P] = ISZ(getDefaultProfile_P)\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_DSC_TestRunners.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.GumboXUtil.GumboXResult\nimport RTS_aadl__JVM.RandomLib\nimport org.sireum.Random.Gen64\nimport org.sireum.Random.Impl.Xoshiro256\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Distribute SlangCheck test runners\n\n@record class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_DSC_TestRunner\n  extends Random.Gen.TestRunner[Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P]\n  with Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_GumboX_TestHarness {\n\n  val verbose: B = F\n\n  var seedGen: Gen64 = Random.Gen64Impl(Xoshiro256.create)\n  val ranLibinput: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n  val ranLibmanualActuatorInput: RandomLib = RandomLib(Random.Gen64Impl(Xoshiro256.createSeed(seedGen.genU64())))\n\n  override def next(): Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P = {\n    val api_input = ranLibinput.nextB()\n    val api_manualActuatorInput = ranLibmanualActuatorInput.nextB()\n    return Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(\n      api_input, api_manualActuatorInput\n    )\n  }\n\n  override def toCompactJson(o: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P): String = {\n    return RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(o, T)\n  }\n\n  override def fromJson(json: String): Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P = {\n    RTS_aadl__JVM.JSON.toActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(json) match {\n      case Either.Left(o) => return o\n      case Either.Right(msg) => halt(msg.string)\n    }\n  }\n\n  override def test(o: Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P): B = {\n    BeforeEntrypoint()\n    val r: B = testComputeCBV(o) match {\n      case GumboXResult.Pre_Condition_Unsat =>\n        RTS_aadl__JVM.DSC_RecordUnsatPre.report(RTS_aadl__JVM.JSON.fromActuationActuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P(o, T))\n        T\n      case GumboXResult.Post_Condition_Fail => F\n      case GumboXResult.Post_Condition_Pass => T\n    }\n    AfterEntrypoint()\n    return r\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator__Containers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ containers for the pre and post state values of ports and state variables\n\n@sig trait Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container extends art.DataContent {\n  def api_input: B\n  def api_manualActuatorInput: B\n}\n\n\/\/ container for incoming ports\n@datatype class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_P (\n  val api_input: B,\n  val api_manualActuatorInput: B) extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container\n\n\/\/ container for incoming ports and state variables\n@datatype class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container_PS (\n  val api_input: B,\n  val api_manualActuatorInput: B) extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PreState_Container\n\n@sig trait Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container extends art.DataContent {\n  def api_output: B\n}\n\n\/\/ container for outgoing ports\n@datatype class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_P (\n  val api_output: B) extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container\n\n\/\/ container for outgoing ports and state variables\n@datatype class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container_PS (\n  val api_output: B) extends Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_PostState_Container\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/test\/util\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator__Profiles.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM.Actuation\n\nimport org.sireum._\nimport RTS_aadl__JVM.RandomLib\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n\/\/ Profile with generators for incoming ports\n@record class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_P(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_input: RandomLib,\n  var api_manualActuatorInput: RandomLib)\n\n\/\/ Profile with generators for state variables and incoming ports\n@record class Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator_Profile_PS(\n  val name: String,\n  val numTests: Z, \/\/ number of tests to generate\n  var api_input: RandomLib,\n  var api_manualActuatorInput: RandomLib)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/architecture\/RTS_aadl__JVM\/Platform.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Platform {\n\n  def setup(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM SETUP\n    \/\/ END MARKER PLATFORM SETUP\n  }\n\n  def tearDown(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM TEARDOWN\n    \/\/ END MARKER PLATFORM TEARDOWN\n  }\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM SETUP",
              "endMarker" : "\/\/ END MARKER PLATFORM SETUP"
            },
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM TEARDOWN",
              "endMarker" : "\/\/ END MARKER PLATFORM TEARDOWN"
            }
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: IS[Art.BridgeId, Bridge],\n                                        connections: IS[Art.ConnectionId, UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = {\n      println(\"Default testCompute\")\n    }\n\n    def testInitialise(): Unit = {\n      println(\"Default testInitialise\")\n    }\n  }\n\n  @datatype class Ports(dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n\n  @range(min = 0, max = 14, index = T) class BridgeId\n\n  @range(min = 0, max = 75, index = T) class PortId\n\n  @range(min = 0, max = 37, index = T) class ConnectionId\n\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val numComponents: Z = 15\n  val numPorts: Z = 76\n  val numConnections: Z = 38\n\n  val logTitle: String = \"Art\"\n\n  val bridges: MSZ[Option[Bridge]] = MS.create(numComponents, None[Bridge]())\n  val ports: MS[Art.PortId, Option[UPort]] = MS.create[Art.PortId, Option[UPort]](numPorts, None[UPort]())\n  val connections: MS[Art.PortId, IS[Art.ConnectionId, Art.PortId]] = MS.create[Art.PortId, IS[Art.ConnectionId, Art.PortId]](numPorts, IS())\n\n  \/\/ Note on transpiling:\n  \/\/ ports and conenctions are not touched\/transpiled when targeting seL4. Bridges\n  \/\/ are isolated when transpiling so BridgeId.Max could be 0, but changing Min\/Max is\n  \/\/ not currently supported by the transpiler so instead bridges is defined as an MSZ\n  \/\/ so that that its size can be set to 1 and thus reduce stack space requirements\n\n\n  @pure def bridge(bridgeId: Art.BridgeId): Bridge = {\n    return bridges(bridgeId.toZ).get\n  }\n\n  @pure def port(p: Art.PortId): UPort = {\n    return ports(p).get\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id.toZ) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n\n    def r(uports: ISZ[UPort]): Unit = {\n      for (port <- uports) {\n        ports(port.id) = Some(port)\n        \/* transpiler does not emit an extractor for matches in nested functions\n        port.mode match {\n          case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n          case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n          case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n          case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n        }\n        *\/\n        val typ: String = if (port.mode == PortMode.DataIn) \"(data in)\" else if (port.mode == PortMode.DataOut) \"(data out)\" else if (port.mode == PortMode.EventOut) \"(event out)\" else if (port.mode == PortMode.EventIn) \"(event in)\" else \"(infeasible)\"\n        ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} $typ\")\n      }\n    }\n\n    r(bridge.ports.dataIns)\n    r(bridge.ports.dataOuts)\n    r(bridge.ports.eventIns)\n    r(bridge.ports.eventOuts)\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ call ArtNative to reset the state of the specific thread component\n    ArtNative.initTest(bridge)\n  }\n\n  \/**\n  * Executes a component (identified by bridge) Initialize Entry Point (application code)\n  * for the purposes of unit testing.\n  *\n  * This infrastructure method is called with automatically generated unit testing support code.\n  * The developer-facing version of this method (called by a developer unit test)\n  * provided by the unit testing support code hides the bridge argument.  The bridge\n  * value is retrieved from the testing infrastructure code before passing the call\n  * through to this method.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    ArtNative.testInitialise(bridge)\n  }\n\n  \/**\n   * Executes a component (identified by bridge) Compute Entry Point (application code)\n   * for the purposes of unit testing.\n   *\n   * This infrastructure method is called with automatically generated unit testing support code.\n   * The developer-facing version of this method (called by a developer unit test)\n   * provided by the unit testing support code hides the bridge argument.  The bridge\n   * value is retrieved from the testing infrastructure code before passing the call\n   * through to this method.\n   *\/\n  def testCompute(bridge: Bridge): Unit = {\n    ArtNative.testCompute(bridge)\n  }\n\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInInfrastructurePort(dstPortId, data)\n  }\n\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeInInfrastructurePort(portId)\n  }\n\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeOutInfrastructurePort(portId)\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeInPortVariable(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n\n    val bridge = Art.bridges(bridgeId.toZ).get\n\n    if (bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if (bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port.toZ) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port.toZ) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Initialize Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: testInit() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a postlude to each test.\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an infrastructure in port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n     * Returns the value of an application in port.\n     *\n     * @param portId the id of the INPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport org.sireum.S64._\n\nobject ArtSlangMessage {\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Option[Art.PortId],\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Z, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Z, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Z, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Z, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId.toZ).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId.toZ).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for (e <- eventIns) {\n          if (inInfrastructurePorts.contains(e.id.toZ)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  \/\/ transpiler friendly comparator\n  def lt(a: art.UPort, b: art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id.toZ).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id.toZ).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id.toZ).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id.toZ).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  \/\/ transpiler friendly sort\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if (sorted.isEmpty) {\n        return ISZ[UPort](p)\n      }\n      else {\n        if (lt(sorted(0), p)) {\n          return sorted(0) +: insert(p, ops.ISZOps(sorted).tail)\n        }\n        else {\n          return p +: sorted\n        }\n      }\n    }\n\n    if (ports.isEmpty) {\n      return ports\n    }\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val uports: ISZ[UPort] =\n          for (p <- Art.bridges(bridgeId.toZ).get.ports.eventIns if inInfrastructurePorts.get(p.id.toZ).nonEmpty) yield p\n\n        if (uports.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(uports)\n        EventTriggered(for (p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ remove any old events from previous dispatch\n    for (portId <- eventPortIds if inPortVariables.contains(portId.toZ)) {\n      inPortVariables = inPortVariables - ((portId.toZ, inPortVariables.get(portId.toZ).get))\n    }\n\n    \/\/ transfer received data\/events from the infrastructure ports to the port variables\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId.toZ, data))\n          inPortVariables = inPortVariables + (portId.toZ ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId.toZ ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId.toZ ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = None(), sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if (inPortVariables.contains(portId.toZ)) {\n      return Some(inPortVariables.get(portId.toZ).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId.toZ ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId.toZ, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for (dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = Some(dstPortId), sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId.toZ ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId.toZ, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        return None()\n      }\n    }\n  }\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outInfrastructurePorts.get(portId.toZ) match {\n      case Some(value) => return Some(value.data)\n      case _ => return None()\n    }\n  }\n\n  \/**\n   * Returns the value of an application in port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        return None()\n      }\n    }\n  }\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId.toZ) match {\n      case Some(value) => return Some(value.data)\n      case _ => return None()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage(data: DataContent,\n\n                      var srcPortId: Option[Art.PortId] = None(),\n                      var dstPortId: Option[Art.PortId] = None(),\n\n                      \/\/ when putValue was called by producer\n                      var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when sendOutput transferred message from out port var of producer\n                      var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when message arrived via transport layer\n                      var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when receiveInput transferred message to in port vars of consumer\n                      var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                     )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: IS[Art.BridgeId, Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = IS[Art.BridgeId, Art.BridgeId]()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Z, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Z, ArtMessage] = concMap()\n  val inPortVariables: MMap[Z, ArtMessage] = concMap()\n  val outPortVariables: MMap[Z, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ remove any old events from previous dispatch\n    for (portId <- eventPortIds if inPortVariables.contains(portId.toZ)) {\n      inPortVariables -= portId.toZ\n    }\n\n    \/\/ transfer received data\/events from the infrastructure ports to the port variables\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId.toZ \/\/ dequeue from infrastructure port\n          inPortVariables(portId.toZ) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId.toZ) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId.toZ) = ArtMessage(data = data, srcPortId = Some(portId), putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId.toZ) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId.toZ) = outPortVariables(srcPortId.toZ)\n          outPortVariables -= srcPortId.toZ\n\n          \/\/ simulate sending msg via transport middleware\n          for (dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = Some(dstPortId), sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId.toZ) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId.toZ) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId.toZ\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId.toZ).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId.toZ).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId.toZ;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId.toZ).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId.toZ).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId.toZ\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId.toZ).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId.toZ).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id.toZ))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId.toZ).get.ports.eventIns.map((u: UPort) => u.id).elements.filter((i: Art.PortId) => inInfrastructurePorts.get(i.toZ).nonEmpty): _*)\n        val urgentFifo: Seq[Art.PortId] = portIds.map((pid: Art.PortId) => Art.port(pid)).elements.sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) => Z\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id.toZ).dstArrivalTimestamp < inInfrastructurePorts(p2.id.toZ).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id.toZ).dstArrivalTimestamp < inInfrastructurePorts(p2.id.toZ).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(ISZ[Art.PortId](urgentFifo: _*))\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    Console.out.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Sets up the state of a thread component (identified by bridge) for the purpose of\n   * testing.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Executes the application code in the Initialize Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.  This is achieved by\n   * calling the testInitialise() method on given bridge.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    bridge.entryPoints.testInitialise()\n  }\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.  This is achieved by\n   * calling the testCompute() method on given bridge.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ cancel pending ArtTimer callbacks (also done before a test begins)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId.toZ) = outPortVariables(srcPortId.toZ)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = Some(dstPortId), dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId.toZ) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId.toZ) = artMessage\n    }\n  }\n\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outInfrastructurePorts.get(portId.toZ) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/**\n   * Returns the value of an application in port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId.toZ) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait TimerCallback {\n  def callback(): Unit\n}\n\n@ext object ArtTimer {\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = $\n\n  \/\/ if transpiling then use this version as transpiler does not support function passing\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = $\n\n  def cancel(id: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum.S64._\nimport org.sireum.{B, F, String, T}\n\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.{Executors, TimeUnit}\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtTimer_Ext {\n\n  protected[art] val scheduledCallbacks: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  private val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def cancel(id: String): Unit = {\n    scheduledCallbacks.get(id) match {\n      case Some(b) =>\n        val userRequested = b.get()\n        b.set(F)\n        scheduledCallbacks.remove(id)\n        if (userRequested) {\n          ArtNative.logInfo(Art.logTitle, s\"Callback cleared for $id\")\n        }\n      case _ =>\n    }\n  }\n\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = {\n    schedule(id, replaceExisting, delay, callback.callback _)\n  }\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = {\n    if (scheduledCallbacks.get(id).nonEmpty) {\n      if (!replaceExisting) {\n        ArtNative.logInfo(Art.logTitle, s\"Callback already scheduled for $id\")\n        return\n      } else {\n        cancel(id)\n      }\n    }\n\n    if (delay < s64\"0\") {\n      ArtNative.logInfo(Art.logTitle, s\"Invalid delay time: ${delay}.  Value must be non-negative.\")\n      return\n    }\n\n    val shouldInvokeCallback = new AtomicBoolean(T)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (shouldInvokeCallback.get()) {\n          shouldInvokeCallback.set(F)\n          cancel(id)\n\n          callback()\n        }\n      }\n    }\n\n    scheduledCallbacks.put(id, shouldInvokeCallback)\n\n    val adjusted = delay.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    ArtNative.logInfo(Art.logTitle, s\"Callback scheduled for $id\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: IS[Art.BridgeId, art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = {}\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: IS[Art.BridgeId, art.Bridge]): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: IS[Art.BridgeId, art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x: Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = {}\n\n  override def initializationPhase(): Unit = {}\n\n  override def computePhase(): Unit = {}\n\n  override def finalizePhase(): Unit = {}\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\nimport org.sireum.S64._\n\n@record class RoundRobin(schedule: ISZ[Art.BridgeId]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create[Art.BridgeId, Art.Time](schedule.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create[Art.BridgeId, Art.Time](schedule.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridgeId <- schedule) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.initialise()\n      Art.logInfo(bridgeId, s\"Initialized bridge: ${Art.bridges(bridgeId.toZ).get.name}\")\n    }\n  }\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if (Art.time() - lastDispatch(bridgeId) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridgeId) \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if (Art.time() - lastSporadic(bridgeId) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridgeId)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while (!RoundRobinExtensions.shouldStop()) {\n      for (bridgeId <- schedule) {\n        if (shouldDispatch(bridgeId)) {\n          lastDispatch(bridgeId) = Art.time()\n          Art.bridges(bridgeId.toZ).get.entryPoints.compute()\n\n          if (Art.bridges(bridgeId.toZ).get.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridgeId) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridgeId <- schedule) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.finalise()\n      Art.logInfo(bridgeId, s\"Finalized bridge: ${Art.bridges(bridgeId.toZ).get.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n\n  def shouldStop(): B = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec) : B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return  slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  \/\/ no overloading in Slang\n  \/\/def isHyperPeriodBoundary(): B = {\n  \/\/  return isHyperPeriodBoundary(scheduleState)\n  \/\/}\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState : ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    return ScheduleState(0,0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    \/\/val domainId: Z = slot.domain\n    \/\/val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId).get\n    val bridgeId: Art.BridgeId = slot.bridgeId\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if(ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState,dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum,nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState,dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1           \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) {  \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1  \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum,nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP() : Unit = {\n    scheduleState = nextState(scheduleState,dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      halt(\"TODO\")\n      \/\/Cli.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots :Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP : Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n    halt(\"TODO\")\n    \/\/Cli.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods:Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      \/\/ println(\"===== Hyperperiod \", scheduleState.hyperperiodNum, \" ============\")\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    halt(\"TODO\")\n    \/\/Cli.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    \/\/while (scheduleState.hyperperiodNum < hpNum) {\n    \/\/  stepSystemOneSlotIMP(F)\n    \/\/}\n    \/\/Cli.message(\"*********** Run to ... Completed *************\")\n    \/\/Cli.showState(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum:Z, slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    halt(\"TODO\")\n    \/*\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to domain $domainId\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n\n     *\/\n  }\n\n  \/*\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = art.StaticScheduling.bridgeIdToDomainMap(bridgeId)\n    Cli.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n  }\n   *\/\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    \/\/Cli.message (s\"...Running system according to static schedule\")\n    cprintln(F, \"...Running system according to static schedule\")\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(bridgeId: Art.BridgeId, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: IS[Art.BridgeId, Art.BridgeId] = IS[Art.BridgeId, Art.BridgeId]()\n\n  def setSchedule(spec: DScheduleSpec, bridgeMap: IS[Art.BridgeId, Art.BridgeId]): Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = bridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Art.BridgeId = {\n    \/\/val domainId = slot.domain\n    \/\/val bridgeId = domainToBridgeIdMap(domainId).get\n    val bridgeId = slot.bridgeId\n    return bridgeId\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Art.BridgeId = {\n    val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n    return getBridgeIdFromSlot(slot)\n  }\n\n  def getBridgeId(scheduleState: Explorer.ScheduleState): Art.BridgeId = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  \/\/def getDomain(slotNum: Z): Z = {\n  \/\/  val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n  \/\/  return slot.domain\n  \/\/}\n\n  \/\/def getDomain(scheduleState : Explorer.ScheduleState): Z = {\n  \/\/   return getDomain(scheduleState.slotNum)\n  \/\/}\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    halt(\"TODO\")\n    \/*\n    for (e <- StaticScheduling.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n     *\/\n  }\n\n  def threadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState): String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ --------- helper methods for contracts -------------\n\n  def mySome[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (pred(e)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  def myAll[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (!pred(e)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    return checkMaxDomain(dScheduleSpec) &&\n      checkNoMissingDomain(dScheduleSpec) &&\n      checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/\/myAll[Slot](dScheduleSpec.schedule.slots, s => s.domain <= dScheduleSpec.maxDomain)\n    \/\/  for (s <- dScheduleSpec.schedule.slots) {\n    \/\/    if (s.domain > dScheduleSpec.maxDomain) {\n    \/\/      return false\n    \/\/    }\n    \/\/  }\n    \/\/  return true\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    for (d <- 0 to dScheduleSpec.maxDomain) {\n      if (!mySome[Slot](dScheduleSpec.schedule.slots, s => s.domain == d)) {\n        return false\n      }\n    }\n    return true\n\n     *\/\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n\n     *\/\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec): (Z, Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks, remainingHPTicks)\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent }\n\nobject StateObserver {\n\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    return Art.observeInInfrastructurePort(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    return Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String, Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId.toZ).get\n    var portValues: ISZ[(String, Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInInfrastructurePort(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInInfrastructurePort(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String, Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId.toZ).get\n    var portValues: ISZ[(String, Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String, Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String, Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def generatePortContentsInputsCurrent(): String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsOutputsCurrent(): String = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState, Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        val result =\n          st\"\"\"****************************\n              |   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n              |****************************\n              | Output Ports\n              | ===============\n              |  ${formatPortInfo(outPortInfo)}\"\"\".render\n        return result\n      }\n      case None() => {\n        return \"(initial state - no previous state to show)\"\n      }\n    }\n  }\n\n  def formatPortInfo(portVals: ISZ[(String, Option[DataContent])]): String = {\n    var result: String = \"\" \/\/ ToDo: Ask Robby if I can do this with a repeating template\n    for (e <- portVals) {\n      result =\n        st\"\"\"$result\n            |${e._1} = ${e._2}\"\"\".render \/\/ how do I put in new line?\n    }\n    return result\n  }\n\n  def generatePortContents(bridgeId: Art.BridgeId): String = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\n          |\n          | Output Ports\n          | ================\n          |  ${formatPortInfo(outPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsByNickName(threadNickName: String): String = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return generatePortContents(bridgeId)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\n@record class StaticScheduler(bridges: IS[Art.BridgeId, art.Bridge],\n                              staticSchedule: DScheduleSpec) extends Scheduler {\n\n  override def initialize(): Unit = {\n    Schedule.dScheduleSpec = staticSchedule\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      art.Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    Explorer.runSystem()\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      art.Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/src\/main\/data\/RTS_aadl__JVM\/Aux_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage RTS_aadl__JVM\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ Any datatype definitions placed in this file will be processed by sergen and SlangCheck\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/bin\/sergen.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\nval sireum = Os.path(Os.env(\"SIREUM_HOME\").get) \/ \"bin\" \/ (if (Os.isWin) \"sireum.bat\" else \"sireum\")\r\n\r\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\r\n\r\n\/\/ create serializers\/deserializers for the Slang types used in the project\r\n\r\nval files: ISZ[String] = ISZ(\"..\/src\/main\/data\/RTS_aadl__JVM\/Base_Types.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator__Containers.scala\",\r\n                             \"..\/src\/main\/art\/art\/DataContent.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Aux_Types.scala\")\r\n\r\nval toolargs: String = st\"${(files, \" \")}\".render\r\n\r\nproc\"$sireum tools sergen -p RTS_aadl__JVM -m json,msgpack -o ${Os.slashDir.up}\/src\/main\/data\/RTS_aadl__JVM $toolargs\".at(Os.slashDir).console.runCheck()\r\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/bin\/slangcheck.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\nval sireum = Os.path(Os.env(\"SIREUM_HOME\").get) \/ \"bin\" \/ (if (Os.isWin) \"sireum.bat\" else \"sireum\")\r\n\r\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\r\n\r\n\/\/ create SlangCheck generators for the Slang types used in the project\r\n\r\nval files: ISZ[String] = ISZ(\"..\/src\/main\/data\/RTS_aadl__JVM\/Base_Types.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_temperatureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_pressureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit1_saturationLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit1_tempPressureTripOut_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_temperatureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_pressureLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/CoincidenceLogic_i_actuationSubsystem_actuationUnit2_saturationLogic_coincidenceLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_actuationUnit2_tempPressureTripOut_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_tempPressureActuatorUnit_actuateTempPressureActuator_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_tempPressureActuatorUnit_tempPressureActuator_actuator__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/OrLogic_i_actuationSubsystem_saturationActuatorUnit_actuateSaturationActuator_orLogic__Containers.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Actuation\/Actuator_i_actuationSubsystem_saturationActuatorUnit_saturationActuator_actuator__Containers.scala\",\r\n                             \"..\/src\/main\/art\/art\/DataContent.scala\",\r\n                             \"..\/src\/main\/data\/RTS_aadl__JVM\/Aux_Types.scala\")\r\n\r\nval toolargs: String = st\"${(files, \" \")}\".render\r\n\r\nproc\"$sireum tools slangcheck generator -p RTS_aadl__JVM -o ${Os.slashDir.up}\/src\/main\/data\/RTS_aadl__JVM $toolargs\".at(Os.slashDir).console.runCheck()\r\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/sireum.org\/getting-started\/\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . RTS_aadl__JVM.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . RTS_aadl__JVM.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main RTS_aadl__JVM.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   Create the IVE project if Codegen was not run locally or if its no-proyek-ive\r\n\/\/   option was used:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/RTS_aadl__JVM\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"RTS_i_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=03203d2\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20230828.9aebc14\n\norg.sireum.kekinian%%library%=5b462ddb00\n\norg.scala-lang%scala-library%=2.13.11\norg.scalatest%%scalatest%%=3.2.16\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ A custom mill build for Sireum can be obtained from https:\/\/github.com\/sireum\/rolling\/releases\/tag\/mill\n\/\/ On Windows, rename 'mill' to 'mill.bat'\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   mill RTS_aadl__JVM.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   mill RTS_aadl__JVM.tests\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w RTS_aadl__JVM.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `RTS_aadl__JVM` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.11\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.16\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20230828.9aebc14\n  val sireumScalacVersion = \"4.20230828.9aebc14\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/5b462ddb00\n  val kekinianVersion = \"5b462ddb00\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-release:8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"RTS_aadl__JVM.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"RTS_aadl__JVM.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(os.Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/RTS_aadl__JVM\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val RTS_i_Instance = slangEmbeddedProject(\"RTS_i_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.11\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.16\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20230828.9aebc14\nval sireumScalacVersion = \"4.20230828.9aebc14\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/5b462ddb00\nval kekinianVersion = \"5b462ddb00\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-release:8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Resolver.sonatypeOssRepos(\"public\") ++ Seq(\"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  ThisBuild \/ evictionErrorLevel := Level.Warn,\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"RTS_aadl__JVM.Demo\"),\n\n  mainClass in assembly := Some(\"RTS_aadl__JVM.Demo\"),\n  assemblyJarName in assembly := \"RTS_i_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"RTS_aadl__JVM.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.8.0\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "slang\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ]
    ]
  }
}