{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempUnit.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@enum object TempUnit {\n  \"Fahrenheit\"\n  \"Celsius\"\n  \"Kelvin\"\n}\n\nobject TempUnit_Payload {\n  def example(): TempUnit_Payload = {\n    return TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class TempUnit_Payload(value: BuildingControl.TempUnit.Type) extends art.DataContent\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Temperature_impl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Temperature_impl {\n  def example(): BuildingControl.Temperature_impl = {\n    return BuildingControl.Temperature_impl(\n      degrees = Base_Types.Float_32_example(),\n      unit = BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class Temperature_impl(\n  val degrees: F32,\n  val unit: BuildingControl.TempUnit.Type) {\n}\n\nobject Temperature_impl_Payload {\n  def example(): Temperature_impl_Payload = {\n    return Temperature_impl_Payload(BuildingControl.Temperature_impl.example())\n  }\n}\n\n@datatype class Temperature_impl_Payload(value: BuildingControl.Temperature_impl) extends art.DataContent\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/SetPoint_impl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject SetPoint_impl {\n  def example(): BuildingControl.SetPoint_impl = {\n    return BuildingControl.SetPoint_impl(\n      low = BuildingControl.Temperature_impl.example(),\n      high = BuildingControl.Temperature_impl.example())\n  }\n}\n\n@datatype class SetPoint_impl(\n  val low: BuildingControl.Temperature_impl,\n  val high: BuildingControl.Temperature_impl) {\n}\n\nobject SetPoint_impl_Payload {\n  def example(): SetPoint_impl_Payload = {\n    return SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example())\n  }\n}\n\n@datatype class SetPoint_impl_Payload(value: BuildingControl.SetPoint_impl) extends art.DataContent\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/FanAck.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@enum object FanAck {\n  \"Ok\"\n  \"Error\"\n}\n\nobject FanAck_Payload {\n  def example(): FanAck_Payload = {\n    return FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanAck_Payload(value: BuildingControl.FanAck.Type) extends art.DataContent\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/FanCmd.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@enum object FanCmd {\n  \"On\"\n  \"Off\"\n}\n\nobject FanCmd_Payload {\n  def example(): FanCmd_Payload = {\n    return FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanCmd_Payload(value: BuildingControl.FanCmd.Type) extends art.DataContent\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/data\/building_control_gen_mixed__JVM_Do_not_embed_art\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = {\n    Contract(Ensures(Res == F))\n    return F\n  }\n\n\n  def Integer_example(): Integer = {\n    Contract(Ensures(Res == z\"0\"))\n    return z\"0\"\n  }\n\n  def Integer_8_example(): Integer_8 = {\n    Contract(Ensures(Res == s8\"0\"))\n    return s8\"0\"\n  }\n\n  def Integer_16_example(): Integer_16 = {\n    Contract(Ensures(Res == s16\"0\"))\n    return s16\"0\"\n  }\n\n  def Integer_32_example(): Integer_32 = {\n    Contract(Ensures(Res == s32\"0\"))\n    return s32\"0\"\n  }\n\n  def Integer_64_example(): Integer_64 = {\n    Contract(Ensures(Res == s64\"0\"))\n    return s64\"0\"\n  }\n\n\n  def Unsigned_8_example(): Unsigned_8 = {\n    Contract(Ensures(Res == u8\"0\"))\n    return u8\"0\"\n  }\n\n  def Unsigned_16_example(): Unsigned_16 = {\n    Contract(Ensures(Res == u16\"0\"))\n    return u16\"0\"\n  }\n\n  def Unsigned_32_example(): Unsigned_32 = {\n    Contract(Ensures(Res == u32\"0\"))\n    return u32\"0\"\n  }\n\n  def Unsigned_64_example(): Unsigned_64 = {\n    Contract(Ensures(Res == u64\"0\"))\n    return u64\"0\"\n  }\n\n\n  def Float_example(): Float = {\n    Contract(Ensures(Res == r\"0\"))\n    return r\"0\"\n  }\n\n  def Float_32_example(): Float_32 = {\n    Contract(Ensures(Res == f32\"0\"))\n    return f32\"0\"\n  }\n\n  def Float_64_example(): Float_64 = {\n    Contract(Ensures(Res == f64\"0\"))\n    return f64\"0\"\n  }\n\n\n  def Character_example(): Character = {\n    Contract(Ensures(Res == ' '))\n    return ' '\n  }\n\n  def String_example(): String = {\n    Contract(Ensures(Res == \"\"))\n    return \"\"\n  }\n\n\n  def Bits_example(): Bits = {\n    Contract(Ensures(Res == ISZ[B]()))\n    return ISZ[B]()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Arch {\n  val BuildingControlDemo_i_Instance_tcp_tempSensor : building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = portId\"0\", name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp\", mode = DataOut)\n    val tempChanged = Port[art.Empty] (id = portId\"1\", name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged\", mode = EventOut)\n\n    building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge(\n      id = bridgeId\"0\",\n      name = \"BuildingControlDemo_i_Instance_tcp_tempSensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_tempControl : building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.TempControl_i_tcp_tempControl_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = portId\"2\", name = \"BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp\", mode = DataIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = portId\"3\", name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanAck\", mode = EventIn)\n    val setPoint = Port[BuildingControl.SetPoint_impl] (id = portId\"4\", name = \"BuildingControlDemo_i_Instance_tcp_tempControl_setPoint\", mode = EventIn)\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = portId\"5\", name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd\", mode = EventOut)\n    val tempChanged = Port[art.Empty] (id = portId\"6\", name = \"BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged\", mode = EventIn)\n\n    building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.TempControl_i_tcp_tempControl_Bridge(\n      id = bridgeId\"1\",\n      name = \"BuildingControlDemo_i_Instance_tcp_tempControl\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      fanAck = fanAck,\n      setPoint = setPoint,\n      fanCmd = fanCmd,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_fan : building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.Fan_i_tcp_fan_Bridge = {\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = portId\"7\", name = \"BuildingControlDemo_i_Instance_tcp_fan_fanCmd\", mode = EventIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = portId\"8\", name = \"BuildingControlDemo_i_Instance_tcp_fan_fanAck\", mode = EventOut)\n\n    building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.Fan_i_tcp_fan_Bridge(\n      id = bridgeId\"2\",\n      name = \"BuildingControlDemo_i_Instance_tcp_fan\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      fanCmd = fanCmd,\n      fanAck = fanAck\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = IS[Art.BridgeId, Bridge] (BuildingControlDemo_i_Instance_tcp_tempSensor, BuildingControlDemo_i_Instance_tcp_tempControl, BuildingControlDemo_i_Instance_tcp_fan),\n\n      connections = IS[Art.ConnectionId, UConnection] (Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.currentTemp, to = BuildingControlDemo_i_Instance_tcp_tempControl.currentTemp),\n                                                       Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.tempChanged, to = BuildingControlDemo_i_Instance_tcp_tempControl.tempChanged),\n                                                       Connection(from = BuildingControlDemo_i_Instance_tcp_tempControl.fanCmd, to = BuildingControlDemo_i_Instance_tcp_fan.fanCmd),\n                                                       Connection(from = BuildingControlDemo_i_Instance_tcp_fan.fanAck, to = BuildingControlDemo_i_Instance_tcp_tempControl.fanAck))\n    )\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticSchedulerH(MNone())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n\n        Platform.setup()\n\n        art.Art.run(Arch.ad, scheduler)\n\n        Platform.tearDown()\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec}\nimport art.scheduling.static._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val threadNickNames: Map[String, Art.BridgeId] = Map(\n    ISZ(\n      Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.name ~> Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.id,\n      Arch.BuildingControlDemo_i_Instance_tcp_tempControl.name ~> Arch.BuildingControlDemo_i_Instance_tcp_tempControl.id,\n      Arch.BuildingControlDemo_i_Instance_tcp_fan.name ~> Arch.BuildingControlDemo_i_Instance_tcp_fan.id)\n  )\n\n  val revThreadNickNames: Map[Art.BridgeId, String] = Map.empty[Art.BridgeId, String] ++ (for (e <- threadNickNames.entries) yield e._2 ~> e._1)\n\n  val BuildingControlDemo_i_Instance_proc_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = None(),\n    framePeriod = None(),\n    maxDomain = None(),\n    slotTime = None())\n\n  val BuildingControlDemo_i_Instance_tcp_tempSensor_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val BuildingControlDemo_i_Instance_tcp_tempControl_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val BuildingControlDemo_i_Instance_tcp_fan_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n\n  \/**********************************************************************\n   * Round Robin Scheduler\n   *********************************************************************\/\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[Art.BridgeId] = {\n    \/\/ convert IS[Art.BridgeId, art.Bridge] to an IS[Z, Art.BridgeId] to allow bridges to be dispatched\n    \/\/ multiple times during a hyper-period\n    var ret: ISZ[Art.BridgeId] = ISZ()\n    for (e <- Arch.ad.components) {\n      ret = ret :+ e.id\n    }\n    ret\n  }\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[Art.BridgeId]]): RoundRobin = {\n    if (roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  \/**********************************************************************\n   * Static Scheduler\n   *********************************************************************\/\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ defaultStaticSchedule represents the component dispatch order\n  val defaultStaticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Schedule.Slot(0, maxExecutionTime),\n    Schedule.Slot(1, maxExecutionTime),\n    Schedule.Slot(2, maxExecutionTime)\n  )))\n\n  val defaultDomainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ(\n    \/* domain 0 *\/ Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.id,\n    \/* domain 1 *\/ Arch.BuildingControlDemo_i_Instance_tcp_tempControl.id,\n    \/* domain 2 *\/ Arch.BuildingControlDemo_i_Instance_tcp_fan.id\n  )\n\n  def getStaticSchedulerH(userProvided: MOption[(DScheduleSpec, ISZ[Art.BridgeId], Map[String, Art.BridgeId], CommandProvider)]): StaticScheduler = {\n    if (defaultStaticSchedule.schedule.slots.isEmpty && defaultDomainToBridgeIdMap.isEmpty && threadNickNames.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    userProvided match {\n      case MSome((schedule_, domainToBridgeIdMap_, threadNickNames_, commandProvider)) =>\n        return getStaticScheduler(schedule_, domainToBridgeIdMap_, threadNickNames_, commandProvider)\n      case _ =>\n        return getStaticScheduler(\n          ScheduleProviderI.getStaticSchedule(),\n          \/\/ TODO: get the following from extension so they can be customized via C\n          defaultDomainToBridgeIdMap,\n          threadNickNames,\n          DefaultCommandProvider())\n    }\n  }\n\n  def getStaticScheduler(schedule: DScheduleSpec,\n                         domainToBridgeIdMap: ISZ[Art.BridgeId],\n                         threadNickNames: Map[String, Art.BridgeId],\n                         commandProvider: CommandProvider): StaticScheduler = {\n    return StaticScheduler(schedule, Arch.ad.components, domainToBridgeIdMap, threadNickNames,\n      if (commandProvider.isInstanceOf[InfoCommandProvider])\n        commandProvider.asInstanceOf[InfoCommandProvider].init(\n          threadNickNames,\n          schedule.schedule.slots.size,\n          domainToBridgeIdMap\n        )\n      else commandProvider)\n  }\n\n\n  \/**********************************************************************\n   * Legacy Scheduler\n   *********************************************************************\/\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n\/\/ the purpose of this extension is to allow users to provide custom schedules\n\/\/ at the C level after transpiling\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = $\n\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.defaultStaticSchedule\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/inspector\/building_control_gen_mixed__JVM_Do_not_embed_art\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_tcp_tempSensor_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art.Art\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait TempSensor_i_tcp_tempSensor_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor)\n  }\n\n  \/** helper function to check TempSensor_i_tcp_tempSensor's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param currentTemp method that will be called with the value of the outgoing data\n   *        port 'currentTemp'.\n   * @param tempChanged method that will be called with the number of events to be sent\n   *        on the outgoing event port 'tempChanged'.\n   *\/\n  def check_concrete_output(currentTemp: BuildingControl.Temperature_impl => B,\n                            tempChanged: Z => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val currentTempValue: BuildingControl.Temperature_impl = get_currentTemp().get\n    if(!currentTemp(currentTempValue)) {\n      testFailures = testFailures :+ st\"'currentTemp' did not match expected: value of the outgoing data port is ${currentTempValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val tempChangedValue: Z = if(get_tempChanged().nonEmpty) z\"1\" else z\"0\"\n    if(!tempChanged(tempChangedValue)) {\n      testFailures = testFailures :+ st\"'tempChanged' did not match expected: ${tempChangedValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_currentTemp(): Option[BuildingControl.Temperature_impl] = {\n    val value: Option[BuildingControl.Temperature_impl] = get_currentTemp_payload() match {\n      case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\")\n      case _ => None[BuildingControl.Temperature_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_currentTemp_payload(): Option[BuildingControl.Temperature_impl_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.initialization_api.currentTemp_Id).asInstanceOf[Option[BuildingControl.Temperature_impl_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_tempChanged(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_tempChanged_payload() match {\n      case Some(art.Empty()) => Some(art.Empty())\n      case Some(v) => halt(s\"Unexpected payload on port tempChanged.  Expecting 'art.Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_tempChanged_payload(): Option[art.Empty] = {\n    return Art.observeOutInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.initialization_api.tempChanged_Id).asInstanceOf[Option[art.Empty]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_tcp_tempSensor_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class TempSensor_i_tcp_tempSensor_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  TempSensor_i_tcp_tempSensor_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_tcp_tempSensor_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass TempSensor_i_tcp_tempSensor_Test extends TempSensor_i_tcp_tempSensor_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_tcp_tempSensor_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.{TempSensor_i_tcp_tempSensor => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class TempSensor_i_tcp_tempSensor_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](currentTemp),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort](tempChanged)\n  )\n\n  val initialization_api : TempSensor_i_Initialization_Api = {\n    val api = TempSensor_i_Initialization_Api(\n      id,\n      currentTemp.id,\n      tempChanged.id\n    )\n    TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : TempSensor_i_Operational_Api = {\n    val api = TempSensor_i_Operational_Api(\n      id,\n      currentTemp.id,\n      tempChanged.id\n    )\n    TempSensor_i_tcp_tempSensor_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    TempSensor_i_tcp_tempSensor_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject TempSensor_i_tcp_tempSensor_Bridge {\n\n  var c_initialization_api: Option[TempSensor_i_Initialization_Api] = None()\n  var c_operational_api: Option[TempSensor_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    TempSensor_i_tcp_tempSensor_BridgeId : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: TempSensor_i_Initialization_Api,\n    operational_api: TempSensor_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(currentTemp_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(tempChanged_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempSensor_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: TempSensor_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempSensor_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n@sig trait TempSensor_i_Api {\n  def id: Art.BridgeId\n  def currentTemp_Id : Art.PortId\n  def tempChanged_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var currentTemp: BuildingControl.Temperature_impl = $\n\n  def put_currentTemp(value : BuildingControl.Temperature_impl) : Unit = {\n    Contract(\n      Modifies(currentTemp),\n      Ensures(\n        currentTemp == value\n      )\n    )\n    Spec {\n      currentTemp = value\n    }\n\n    Art.putValue(currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event port\n  @spec var tempChanged: Option[art.Empty] = $\n\n  def put_tempChanged() : Unit = {\n    Contract(\n      Modifies(tempChanged),\n      Ensures(\n        tempChanged == Some(Empty())\n      )\n    )\n    Spec {\n      tempChanged = Some(Empty())\n    }\n\n    Art.putValue(tempChanged_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class TempSensor_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempSensor_i_Api\n\n@datatype class TempSensor_i_Operational_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempSensor_i_Api {\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempSensor_i_tcp_tempSensor.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject TempSensor_i_tcp_tempSensor {\n\n  def initialise(api: TempSensor_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_currentTemp(BuildingControl.Temperature_impl.example())\n    api.put_tempChanged()\n  }\n\n  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = {\n    \/\/ example api usage\n\n\n  }\n\n  def finalise(api: TempSensor_i_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_tcp_tempControl_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art.Art\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait TempControl_i_tcp_tempControl_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.BuildingControlDemo_i_Instance_tcp_tempControl)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.BuildingControlDemo_i_Instance_tcp_tempControl)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.BuildingControlDemo_i_Instance_tcp_tempControl)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.BuildingControlDemo_i_Instance_tcp_tempControl)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param currentTemp payload for data port currentTemp\n   * @param fanAck payloads for event data port fanAck.\n   *   ART currently supports single element event data queues so\n   *   only the last element of fanAck will be used\n   * @param setPoint payloads for event data port setPoint.\n   *   ART currently supports single element event data queues so\n   *   only the last element of setPoint will be used\n   * @param tempChanged the number of events to place in the tempChanged event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(currentTemp : BuildingControl.Temperature_impl,\n                          fanAck : ISZ[BuildingControl.FanAck.Type],\n                          setPoint : ISZ[BuildingControl.SetPoint_impl],\n                          tempChanged : Z): Unit = {\n    put_currentTemp(currentTemp)\n    for(v <- fanAck){\n      put_fanAck(v)\n    }\n    for(v <- setPoint){\n      put_setPoint(v)\n    }\n    for(i <- 0 until tempChanged) {\n      put_tempChanged()\n    }\n  }\n\n\n  \/** helper function to check TempControl_i_tcp_tempControl's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param fanCmd method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'fanCmd'.\n   *\/\n  def check_concrete_output(fanCmd: ISZ[BuildingControl.FanCmd.Type] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var fanCmdValue: ISZ[BuildingControl.FanCmd.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_fanCmd().nonEmpty) { fanCmdValue = fanCmdValue :+ get_fanCmd().get }\n    if(!fanCmd(fanCmdValue)) {\n      testFailures = testFailures :+ st\"'fanCmd' did not match expected: received ${fanCmdValue.size} events with the following payloads ${fanCmdValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_currentTemp(value : BuildingControl.Temperature_impl): Unit = {\n    Art.insertInInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.operational_api.currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_fanAck(value : BuildingControl.FanAck.Type): Unit = {\n    Art.insertInInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.operational_api.fanAck_Id, BuildingControl.FanAck_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_setPoint(value : BuildingControl.SetPoint_impl): Unit = {\n    Art.insertInInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.operational_api.setPoint_Id, BuildingControl.SetPoint_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_tempChanged(): Unit = {\n    Art.insertInInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.operational_api.tempChanged_Id, art.Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanCmd(): Option[BuildingControl.FanCmd.Type] = {\n    val value: Option[BuildingControl.FanCmd.Type] = get_fanCmd_payload() match {\n      case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\")\n      case _ => None[BuildingControl.FanCmd.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanCmd_payload(): Option[BuildingControl.FanCmd_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.initialization_api.fanCmd_Id).asInstanceOf[Option[BuildingControl.FanCmd_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_tcp_tempControl_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class TempControl_i_tcp_tempControl_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  TempControl_i_tcp_tempControl_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_tcp_tempControl_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass TempControl_i_tcp_tempControl_Test extends TempControl_i_tcp_tempControl_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_tcp_tempControl_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.{TempControl_i_tcp_tempControl => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class TempControl_i_tcp_tempControl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  fanAck: Port[BuildingControl.FanAck.Type],\n  setPoint: Port[BuildingControl.SetPoint_impl],\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](currentTemp),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](fanAck,\n                              setPoint,\n                              tempChanged),\n\n    eventOuts = ISZ[art.UPort](fanCmd)\n  )\n\n  val initialization_api : TempControl_i_Initialization_Api = {\n    val api = TempControl_i_Initialization_Api(\n      id,\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id\n    )\n    TempControl_i_tcp_tempControl_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : TempControl_i_Operational_Api = {\n    val api = TempControl_i_Operational_Api(\n      id,\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id\n    )\n    TempControl_i_tcp_tempControl_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    TempControl_i_tcp_tempControl_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject TempControl_i_tcp_tempControl_Bridge {\n\n  var c_initialization_api: Option[TempControl_i_Initialization_Api] = None()\n  var c_operational_api: Option[TempControl_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    TempControl_i_tcp_tempControl_BridgeId : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    setPoint_Id : Art.PortId,\n    fanCmd_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: TempControl_i_Initialization_Api,\n    operational_api: TempControl_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(currentTemp_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(fanAck_Id,\n                                             setPoint_Id,\n                                             tempChanged_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(fanCmd_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempControl_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_tcp_tempControl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanAck(api: TempControl_i_Operational_Api, value: BuildingControl.FanAck.Type): Unit = {}\n          component.handle_fanAck(operational_api, value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n\n          \/\/ implement the following in 'component':  def handle_setPoint(api: TempControl_i_Operational_Api, value: BuildingControl.SetPoint_impl): Unit = {}\n          component.handle_setPoint(operational_api, value)\n        }\n        else if(portId == tempChanged_Id) {\n          \/\/ implement the following in 'component':  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = {}\n          component.handle_tempChanged(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: TempControl_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempControl_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_tcp_tempControl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanAck(api: TempControl_i_Operational_Api, value: BuildingControl.FanAck.Type): Unit = {}\n          component.handle_fanAck(operational_api, value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n\n          \/\/ implement the following in 'component':  def handle_setPoint(api: TempControl_i_Operational_Api, value: BuildingControl.SetPoint_impl): Unit = {}\n          component.handle_setPoint(operational_api, value)\n        }\n        else if(portId == tempChanged_Id) {\n          \/\/ implement the following in 'component':  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = {}\n          component.handle_tempChanged(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n@sig trait TempControl_i_Api {\n  def id: Art.BridgeId\n  def currentTemp_Id : Art.PortId\n  def fanAck_Id : Art.PortId\n  def setPoint_Id : Art.PortId\n  def fanCmd_Id : Art.PortId\n  def tempChanged_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var fanCmd: Option[BuildingControl.FanCmd.Type] = $\n\n  def put_fanCmd(value : BuildingControl.FanCmd.Type) : Unit = {\n    Contract(\n      Modifies(fanCmd),\n      Ensures(\n        fanCmd == Some(value)\n      )\n    )\n    Spec {\n      fanCmd = Some(value)\n    }\n\n    Art.putValue(fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class TempControl_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val fanAck_Id : Art.PortId,\n  val setPoint_Id : Art.PortId,\n  val fanCmd_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempControl_i_Api\n\n@datatype class TempControl_i_Operational_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val fanAck_Id : Art.PortId,\n  val setPoint_Id : Art.PortId,\n  val fanCmd_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempControl_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var currentTemp: BuildingControl.Temperature_impl = $\n\n  def get_currentTemp() : Option[BuildingControl.Temperature_impl] = {\n    Contract(\n      Ensures(\n        Res == Some(currentTemp)\n      )\n    )\n    val value : Option[BuildingControl.Temperature_impl] = Art.getValue(currentTemp_Id) match {\n      case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\")\n        None[BuildingControl.Temperature_impl]()\n      case _ => None[BuildingControl.Temperature_impl]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var fanAck: Option[BuildingControl.FanAck.Type] = $\n\n  def get_fanAck() : Option[BuildingControl.FanAck.Type] = {\n    Contract(\n      Ensures(\n        Res == fanAck\n      )\n    )\n    val value : Option[BuildingControl.FanAck.Type] = Art.getValue(fanAck_Id) match {\n      case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\")\n        None[BuildingControl.FanAck.Type]()\n      case _ => None[BuildingControl.FanAck.Type]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var setPoint: Option[BuildingControl.SetPoint_impl] = $\n\n  def get_setPoint() : Option[BuildingControl.SetPoint_impl] = {\n    Contract(\n      Ensures(\n        Res == setPoint\n      )\n    )\n    val value : Option[BuildingControl.SetPoint_impl] = Art.getValue(setPoint_Id) match {\n      case Some(BuildingControl.SetPoint_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port setPoint.  Expecting 'BuildingControl.SetPoint_impl_Payload' but received ${v}\")\n        None[BuildingControl.SetPoint_impl]()\n      case _ => None[BuildingControl.SetPoint_impl]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event port\n  @spec var tempChanged: Option[art.Empty] = $\n\n  def get_tempChanged() : Option[art.Empty] = {\n    Contract(\n      Ensures(\n        Res == tempChanged\n      )\n    )\n    val value : Option[art.Empty] = Art.getValue(tempChanged_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port tempChanged.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/TempControl_i_tcp_tempControl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject TempControl_i_tcp_tempControl {\n\n  def initialise(api: TempControl_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_fanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n  }\n\n  def handle_fanAck(api: TempControl_i_Operational_Api, value: BuildingControl.FanAck.Type): Unit = {\n    api.logInfo(\"example handle_fanAck implementation\")\n    api.logInfo(s\"  received $value\")\n    \/\/ example api usage\n\n    val apiUsage_currentTemp: Option[BuildingControl.Temperature_impl] = api.get_currentTemp()\n    api.logInfo(s\"Received on data port currentTemp: ${apiUsage_currentTemp}\")\n    val apiUsage_fanAck: Option[BuildingControl.FanAck.Type] = api.get_fanAck()\n    api.logInfo(s\"Received on event data port fanAck: ${apiUsage_fanAck}\")\n    val apiUsage_setPoint: Option[BuildingControl.SetPoint_impl] = api.get_setPoint()\n    api.logInfo(s\"Received on event data port setPoint: ${apiUsage_setPoint}\")\n    val apiUsage_tempChanged: Option[art.Empty] = api.get_tempChanged()\n    api.logInfo(s\"Received on event port tempChanged: ${apiUsage_tempChanged}\")\n  }\n\n  def handle_setPoint(api: TempControl_i_Operational_Api, value: BuildingControl.SetPoint_impl): Unit = {\n    api.logInfo(\"example handle_setPoint implementation\")\n    api.logInfo(s\"  received $value\")\n  }\n\n  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = {\n    api.logInfo(\"example handle_tempChanged implementation\")\n    api.logInfo(\"  received event\")\n  }\n\n  def finalise(api: TempControl_i_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_tcp_fan_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art.Art\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait Fan_i_tcp_fan_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.BuildingControlDemo_i_Instance_tcp_fan)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.BuildingControlDemo_i_Instance_tcp_fan)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.BuildingControlDemo_i_Instance_tcp_fan)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.BuildingControlDemo_i_Instance_tcp_fan)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param fanCmd payloads for event data port fanCmd.\n   *   ART currently supports single element event data queues so\n   *   only the last element of fanCmd will be used\n   *\/\n  def put_concrete_inputs(fanCmd : ISZ[BuildingControl.FanCmd.Type]): Unit = {\n    for(v <- fanCmd){\n      put_fanCmd(v)\n    }\n  }\n\n\n  \/** helper function to check Fan_i_tcp_fan's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param fanAck method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'fanAck'.\n   *\/\n  def check_concrete_output(fanAck: ISZ[BuildingControl.FanAck.Type] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var fanAckValue: ISZ[BuildingControl.FanAck.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_fanAck().nonEmpty) { fanAckValue = fanAckValue :+ get_fanAck().get }\n    if(!fanAck(fanAckValue)) {\n      testFailures = testFailures :+ st\"'fanAck' did not match expected: received ${fanAckValue.size} events with the following payloads ${fanAckValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_fanCmd(value : BuildingControl.FanCmd.Type): Unit = {\n    Art.insertInInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_fan.operational_api.fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanAck(): Option[BuildingControl.FanAck.Type] = {\n    val value: Option[BuildingControl.FanAck.Type] = get_fanAck_payload() match {\n      case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\")\n      case _ => None[BuildingControl.FanAck.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanAck_payload(): Option[BuildingControl.FanAck_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.BuildingControlDemo_i_Instance_tcp_fan.initialization_api.fanAck_Id).asInstanceOf[Option[BuildingControl.FanAck_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_tcp_fan_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class Fan_i_tcp_fan_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  Fan_i_tcp_fan_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_tcp_fan_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Fan_i_tcp_fan_Test extends Fan_i_tcp_fan_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_tcp_fan_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl.{Fan_i_tcp_fan => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class Fan_i_tcp_fan_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  fanAck: Port[BuildingControl.FanAck.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](fanCmd),\n\n    eventOuts = ISZ[art.UPort](fanAck)\n  )\n\n  val initialization_api : Fan_i_Initialization_Api = {\n    val api = Fan_i_Initialization_Api(\n      id,\n      fanCmd.id,\n      fanAck.id\n    )\n    Fan_i_tcp_fan_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Fan_i_Operational_Api = {\n    val api = Fan_i_Operational_Api(\n      id,\n      fanCmd.id,\n      fanAck.id\n    )\n    Fan_i_tcp_fan_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Fan_i_tcp_fan_Bridge.EntryPoints(\n      id,\n\n      fanCmd.id,\n      fanAck.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Fan_i_tcp_fan_Bridge {\n\n  var c_initialization_api: Option[Fan_i_Initialization_Api] = None()\n  var c_operational_api: Option[Fan_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Fan_i_tcp_fan_BridgeId : Art.BridgeId,\n    fanCmd_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: Fan_i_Initialization_Api,\n    operational_api: Fan_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(fanCmd_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(fanAck_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Fan_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_tcp_fan_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanCmd(api: Fan_i_Operational_Api, value: BuildingControl.FanCmd.Type): Unit = {}\n          component.handle_fanCmd(operational_api, value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Fan_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Fan_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_tcp_fan_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanCmd(api: Fan_i_Operational_Api, value: BuildingControl.FanCmd.Type): Unit = {}\n          component.handle_fanCmd(operational_api, value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n@sig trait Fan_i_Api {\n  def id: Art.BridgeId\n  def fanCmd_Id : Art.PortId\n  def fanAck_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var fanAck: Option[BuildingControl.FanAck.Type] = $\n\n  def put_fanAck(value : BuildingControl.FanAck.Type) : Unit = {\n    Contract(\n      Modifies(fanAck),\n      Ensures(\n        fanAck == Some(value)\n      )\n    )\n    Spec {\n      fanAck = Some(value)\n    }\n\n    Art.putValue(fanAck_Id, BuildingControl.FanAck_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Fan_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val fanCmd_Id : Art.PortId,\n  val fanAck_Id : Art.PortId) extends Fan_i_Api\n\n@datatype class Fan_i_Operational_Api (\n  val id: Art.BridgeId,\n  val fanCmd_Id : Art.PortId,\n  val fanAck_Id : Art.PortId) extends Fan_i_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var fanCmd: Option[BuildingControl.FanCmd.Type] = $\n\n  def get_fanCmd() : Option[BuildingControl.FanCmd.Type] = {\n    Contract(\n      Ensures(\n        Res == fanCmd\n      )\n    )\n    val value : Option[BuildingControl.FanCmd.Type] = Art.getValue(fanCmd_Id) match {\n      case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\")\n        None[BuildingControl.FanCmd.Type]()\n      case _ => None[BuildingControl.FanCmd.Type]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/building_control_gen_mixed__JVM_Do_not_embed_art\/BuildingControl\/Fan_i_tcp_fan.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed__JVM_Do_not_embed_art._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Fan_i_tcp_fan {\n\n  def initialise(api: Fan_i_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_fanAck(BuildingControl.FanAck.byOrdinal(0).get)\n  }\n\n  def handle_fanCmd(api: Fan_i_Operational_Api, value: BuildingControl.FanCmd.Type): Unit = {\n    api.logInfo(\"example handle_fanCmd implementation\")\n    api.logInfo(s\"  received $value\")\n    \/\/ example api usage\n\n    val apiUsage_fanCmd: Option[BuildingControl.FanCmd.Type] = api.get_fanCmd()\n    api.logInfo(s\"Received on event data port fanCmd: ${apiUsage_fanCmd}\")\n  }\n\n  def finalise(api: Fan_i_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Platform.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed__JVM_Do_not_embed_art\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Platform {\n\n  def setup(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM SETUP\n    \/\/ END MARKER PLATFORM SETUP\n  }\n\n  def tearDown(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM TEARDOWN\n    \/\/ END MARKER PLATFORM TEARDOWN\n  }\n}",
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM SETUP",
              "endMarker" : "\/\/ END MARKER PLATFORM SETUP"
            },
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM TEARDOWN",
              "endMarker" : "\/\/ END MARKER PLATFORM TEARDOWN"
            }
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z "${SIREUM_HOME}" ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/sireum.org\/getting-started\/\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . building_control_gen_mixed__JVM_Do_not_embed_art.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . building_control_gen_mixed__JVM_Do_not_embed_art.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main building_control_gen_mixed__JVM_Do_not_embed_art.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   Create the IVE project if Codegen was not run locally or if its no-proyek-ive\r\n\/\/   option was used:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"BuildingControlDemo_i_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.slang-embedded-art::slang-embedded-art:\", \"org.sireum.kekinian::library:\",\r\n                \"org.sireum.kekinian::hamr-vision:\"),\r\n  sources = for(m <- ISZ(\"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\", \"util\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"system\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "isDatatype" : false
        }
      ],
      [
        "slang\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=94cf914\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\norg.sireum.kekinian%%hamr-vision%=e7e6a13468\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20240725.7f9e248\n\norg.sireum.kekinian%%library%=e7e6a13468\n\norg.scala-lang%scala-library%=2.13.14\norg.scalatest%%scalatest%%=3.2.19\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ A custom mill build for Sireum can be obtained from https:\/\/github.com\/sireum\/rolling\/releases\/tag\/mill\n\/\/ On Windows, rename 'mill' to 'mill.bat'\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   mill building_control_gen_mixed__JVM_Do_not_embed_art.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   mill building_control_gen_mixed__JVM_Do_not_embed_art.tests\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w building_control_gen_mixed__JVM_Do_not_embed_art.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `building_control_gen_mixed__JVM_Do_not_embed_art` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.14\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.19\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20240725.7f9e248\n  val sireumScalacVersion = \"4.20240725.7f9e248\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/e7e6a13468\n  val kekinianVersion = \"e7e6a13468\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n  \/\/ https:\/\/github.com\/sireum\/slang-embedded-art\/tree\/94cf914\n  val artVersion = \"94cf914\"\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-release:8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.slang-embedded-art::slang-embedded-art::${artVersion}\",\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n    ivy\"org.sireum.kekinian::hamr-vision::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"building_control_gen_mixed__JVM_Do_not_embed_art.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"util\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"system\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"building_control_gen_mixed__JVM_Do_not_embed_art.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(os.Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/building_control_gen_mixed__JVM_Do_not_embed_art\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val BuildingControlDemo_i_Instance = slangEmbeddedProject(\"BuildingControlDemo_i_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.14\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.19\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20240725.7f9e248\nval sireumScalacVersion = \"4.20240725.7f9e248\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/e7e6a13468\nval kekinianVersion = \"e7e6a13468\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\/\/ https:\/\/github.com\/sireum\/slang-embedded-art\/tree\/94cf914\nval artVersion = \"94cf914\"\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-release:8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Resolver.sonatypeOssRepos(\"public\") ++ Seq(\"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  ThisBuild \/ evictionErrorLevel := Level.Warn,\n  libraryDependencies ++= Seq(\n    \"org.sireum.slang-embedded-art\" %% \"slang-embedded-art\" % artVersion withSources(),\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources(),\n    \"org.sireum.kekinian\" %% \"hamr-vision\" % kekinianVersion withSources()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/util\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/system\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"building_control_gen_mixed__JVM_Do_not_embed_art.Demo\"),\n\n  mainClass in assembly := Some(\"building_control_gen_mixed__JVM_Do_not_embed_art.Demo\"),\n  assemblyJarName in assembly := \"BuildingControlDemo_i_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"building_control_gen_mixed__JVM_Do_not_embed_art.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.9.0\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ]
    ]
  }
}