{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/ICE_Types\/Alarm_Signal.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.ICE_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Alarm_Signal {\n  \"On\"\n  \"Alarm_Off\"\n  \"Alarm_Paused\"\n  \"Audio_Off\"\n  \"Audio_Paused\"\n}\n\nobject Alarm_Signal_Payload {\n  def example(): Alarm_Signal_Payload = {\n    return Alarm_Signal_Payload(ICE_Types.Alarm_Signal.byOrdinal(0).get)\n  }\n}\n\n@datatype class Alarm_Signal_Payload(value: ICE_Types.Alarm_Signal.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Alarm_Type.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Alarm_Type {\n  \"Basal_Overinfusion\"\n  \"Bolus_Overinfusion\"\n  \"Square_Bolus_Overinfusion\"\n  \"Air_In_Line\"\n  \"Empty_Reservoir\"\n  \"Pump_Overheated\"\n  \"Downstream_Occlusion\"\n  \"Upstream_Occlusion\"\n  \"POST_Failure\"\n  \"RAM_Failure\"\n  \"ROM_Failure\"\n  \"CPU_Failure\"\n  \"Thread_Monitor_Failure\"\n  \"Defective_Battery\"\n  \"Low_Battery\"\n  \"No_Alarm\"\n  \"Priming_Failure\"\n}\n\nobject Alarm_Type_Payload {\n  def example(): Alarm_Type_Payload = {\n    return Alarm_Type_Payload(PCA_Types.Alarm_Type.byOrdinal(0).get)\n  }\n}\n\n@datatype class Alarm_Type_Payload(value: PCA_Types.Alarm_Type.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Warning_Type.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Warning_Type {\n  \"Voltage_OOR\"\n  \"Over_Max_Drug_Per_Hour\"\n  \"Basal_Underinfusion\"\n  \"Bolus_Underinfusion\"\n  \"Square_Bolus_Underinfusion\"\n  \"Low_Reservoir\"\n  \"Long_Pause\"\n  \"Drug_Not_In_Library\"\n  \"Soft_Limit\"\n  \"Hard_Limit_Violated\"\n  \"Priming_Failure\"\n  \"Input_Needed\"\n  \"No_Warning\"\n  \"Low_Battery\"\n}\n\nobject Warning_Type_Payload {\n  def example(): Warning_Type_Payload = {\n    return Warning_Type_Payload(PCA_Types.Warning_Type.byOrdinal(0).get)\n  }\n}\n\n@datatype class Warning_Type_Payload(value: PCA_Types.Warning_Type.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Status_Type.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Status_Type {\n  \"Stopped\"\n  \"Priming\"\n  \"Paused\"\n  \"Bolus\"\n  \"Basal\"\n  \"KVO\"\n  \"Square_Bolus\"\n}\n\nobject Status_Type_Payload {\n  def example(): Status_Type_Payload = {\n    return Status_Type_Payload(PCA_Types.Status_Type.byOrdinal(0).get)\n  }\n}\n\n@datatype class Status_Type_Payload(value: PCA_Types.Status_Type.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/ICE_Types\/Milliliter_Per_Hour.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.ICE_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Milliliter_Per_Hour {\n  def example(): ICE_Types.Milliliter_Per_Hour = {\n    return ICE_Types.Milliliter_Per_Hour()\n  }\n}\n\n@datatype class Milliliter_Per_Hour() \/\/ type skeleton\n\nobject Milliliter_Per_Hour_Payload {\n  def example(): Milliliter_Per_Hour_Payload = {\n    return Milliliter_Per_Hour_Payload(ICE_Types.Milliliter_Per_Hour.example())\n  }\n}\n\n@datatype class Milliliter_Per_Hour_Payload(value: ICE_Types.Milliliter_Per_Hour) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/ICE_Types\/Milliliter.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.ICE_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Milliliter {\n  def example(): ICE_Types.Milliliter = {\n    return ICE_Types.Milliliter()\n  }\n}\n\n@datatype class Milliliter() \/\/ type skeleton\n\nobject Milliliter_Payload {\n  def example(): Milliliter_Payload = {\n    return Milliliter_Payload(ICE_Types.Milliliter.example())\n  }\n}\n\n@datatype class Milliliter_Payload(value: ICE_Types.Milliliter) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/ICE_Types\/Minute_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.ICE_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Minute_imp {\n  def example(): ICE_Types.Minute_imp = {\n    return ICE_Types.Minute_imp(Base_Types.Unsigned_16_example())\n  }\n}\n\n@datatype class Minute_imp(\n  value : U16) {\n}\n\nobject Minute_imp_Payload {\n  def example(): Minute_imp_Payload = {\n    return Minute_imp_Payload(ICE_Types.Minute_imp.example())\n  }\n}\n\n@datatype class Minute_imp_Payload(value: ICE_Types.Minute_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Code_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Code_imp {\n  def example(): PCA_Types.Drug_Code_imp = {\n    return PCA_Types.Drug_Code_imp(Base_Types.String_example())\n  }\n}\n\n@datatype class Drug_Code_imp(\n  code : String) {\n}\n\nobject Drug_Code_imp_Payload {\n  def example(): Drug_Code_imp_Payload = {\n    return Drug_Code_imp_Payload(PCA_Types.Drug_Code_imp.example())\n  }\n}\n\n@datatype class Drug_Code_imp_Payload(value: PCA_Types.Drug_Code_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Dose_Rate_Unit_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Dose_Rate_Unit_imp {\n  def example(): PCA_Types.Dose_Rate_Unit_imp = {\n    return PCA_Types.Dose_Rate_Unit_imp(Base_Types.String_example())\n  }\n}\n\n@datatype class Dose_Rate_Unit_imp(\n  value : String) {\n}\n\nobject Dose_Rate_Unit_imp_Payload {\n  def example(): Dose_Rate_Unit_imp_Payload = {\n    return Dose_Rate_Unit_imp_Payload(PCA_Types.Dose_Rate_Unit_imp.example())\n  }\n}\n\n@datatype class Dose_Rate_Unit_imp_Payload(value: PCA_Types.Dose_Rate_Unit_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Infusion_Unit_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Infusion_Unit_imp {\n  def example(): PCA_Types.Infusion_Unit_imp = {\n    return PCA_Types.Infusion_Unit_imp(Base_Types.String_example())\n  }\n}\n\n@datatype class Infusion_Unit_imp(\n  value : String) {\n}\n\nobject Infusion_Unit_imp_Payload {\n  def example(): Infusion_Unit_imp_Payload = {\n    return Infusion_Unit_imp_Payload(PCA_Types.Infusion_Unit_imp.example())\n  }\n}\n\n@datatype class Infusion_Unit_imp_Payload(value: PCA_Types.Infusion_Unit_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Weight_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Weight_imp {\n  def example(): PCA_Types.Drug_Weight_imp = {\n    return PCA_Types.Drug_Weight_imp(Base_Types.Integer_16_example())\n  }\n}\n\n@datatype class Drug_Weight_imp(\n  value : S16) {\n}\n\nobject Drug_Weight_imp_Payload {\n  def example(): Drug_Weight_imp_Payload = {\n    return Drug_Weight_imp_Payload(PCA_Types.Drug_Weight_imp.example())\n  }\n}\n\n@datatype class Drug_Weight_imp_Payload(value: PCA_Types.Drug_Weight_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Concentration_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Concentration_imp {\n  def example(): PCA_Types.Drug_Concentration_imp = {\n    return PCA_Types.Drug_Concentration_imp(Base_Types.Float_32_example())\n  }\n}\n\n@datatype class Drug_Concentration_imp(\n  value : F32) {\n}\n\nobject Drug_Concentration_imp_Payload {\n  def example(): Drug_Concentration_imp_Payload = {\n    return Drug_Concentration_imp_Payload(PCA_Types.Drug_Concentration_imp.example())\n  }\n}\n\n@datatype class Drug_Concentration_imp_Payload(value: PCA_Types.Drug_Concentration_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Volume_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Volume_imp {\n  def example(): PCA_Types.Drug_Volume_imp = {\n    return PCA_Types.Drug_Volume_imp(Base_Types.Integer_16_example())\n  }\n}\n\n@datatype class Drug_Volume_imp(\n  value : S16) {\n}\n\nobject Drug_Volume_imp_Payload {\n  def example(): Drug_Volume_imp_Payload = {\n    return Drug_Volume_imp_Payload(PCA_Types.Drug_Volume_imp.example())\n  }\n}\n\n@datatype class Drug_Volume_imp_Payload(value: PCA_Types.Drug_Volume_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Flow_Rate_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Flow_Rate_imp {\n  def example(): PCA_Types.Flow_Rate_imp = {\n    return PCA_Types.Flow_Rate_imp(Base_Types.Integer_16_example())\n  }\n}\n\n@datatype class Flow_Rate_imp(\n  value : S16) {\n}\n\nobject Flow_Rate_imp_Payload {\n  def example(): Flow_Rate_imp_Payload = {\n    return Flow_Rate_imp_Payload(PCA_Types.Flow_Rate_imp.example())\n  }\n}\n\n@datatype class Flow_Rate_imp_Payload(value: PCA_Types.Flow_Rate_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Record_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Record_imp {\n  def example(): PCA_Types.Drug_Record_imp = {\n    return PCA_Types.Drug_Record_imp(PCA_Types.Drug_Code_imp.example(), Base_Types.String_example(), Base_Types.String_example(), PCA_Types.Dose_Rate_Unit_imp.example(), PCA_Types.Infusion_Unit_imp.example(), PCA_Types.Drug_Weight_imp.example(), PCA_Types.Drug_Concentration_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Flow_Rate_imp.example())\n  }\n}\n\n@datatype class Drug_Record_imp(\n  code : PCA_Types.Drug_Code_imp,\n  name : String,\n  location : String,\n  dose_rate_unit : PCA_Types.Dose_Rate_Unit_imp,\n  vtbi_unit : PCA_Types.Infusion_Unit_imp,\n  amount : PCA_Types.Drug_Weight_imp,\n  concentration : PCA_Types.Drug_Concentration_imp,\n  vtbiLowerSoft : PCA_Types.Drug_Volume_imp,\n  vtbiLowerHard : PCA_Types.Drug_Volume_imp,\n  vtbiTypical : PCA_Types.Drug_Volume_imp,\n  vtbiUpperSoft : PCA_Types.Drug_Volume_imp,\n  vtbiUpperHard : PCA_Types.Drug_Volume_imp,\n  basalRateLowerSoft : PCA_Types.Flow_Rate_imp,\n  basalRateLowerHard : PCA_Types.Flow_Rate_imp,\n  basalRateTypical : PCA_Types.Flow_Rate_imp,\n  basalRateUpperSoft : PCA_Types.Flow_Rate_imp,\n  basalRateUpperHard : PCA_Types.Flow_Rate_imp,\n  bolusTypical : PCA_Types.Drug_Volume_imp,\n  squareBolusRateTypical : PCA_Types.Flow_Rate_imp) {\n}\n\nobject Drug_Record_imp_Payload {\n  def example(): Drug_Record_imp_Payload = {\n    return Drug_Record_imp_Payload(PCA_Types.Drug_Record_imp.example())\n  }\n}\n\n@datatype class Drug_Record_imp_Payload(value: PCA_Types.Drug_Record_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Drug_Library.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Drug_Library {\n  def example(): PCA_Types.Drug_Library = {\n    return PCA_Types.Drug_Library(ISZ.create(500, PCA_Types.Drug_Record_imp.example()))\n  }\n}\n\n@datatype class Drug_Library(\n  value : ISZ[PCA_Types.Drug_Record_imp]) {\n  \/\/{  assert (value.size == 500) }\n}\n\nobject Drug_Library_Payload {\n  def example(): Drug_Library_Payload = {\n    return Drug_Library_Payload(PCA_Types.Drug_Library.example())\n  }\n}\n\n@datatype class Drug_Library_Payload(value: PCA_Types.Drug_Library) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/BLESS_Types\/Time.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.BLESS_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Time {\n  def example(): BLESS_Types.Time = {\n    return BLESS_Types.Time()\n  }\n}\n\n@datatype class Time() \/\/ type skeleton\n\nobject Time_Payload {\n  def example(): Time_Payload = {\n    return Time_Payload(BLESS_Types.Time.example())\n  }\n}\n\n@datatype class Time_Payload(value: BLESS_Types.Time) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Fault_Record_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Fault_Record_imp {\n  def example(): PCA_Types.Fault_Record_imp = {\n    return PCA_Types.Fault_Record_imp(PCA_Types.Alarm_Type.byOrdinal(0).get, PCA_Types.Warning_Type.byOrdinal(0).get, Base_Types.Integer_example())\n  }\n}\n\n@datatype class Fault_Record_imp(\n  alarm : PCA_Types.Alarm_Type.Type,\n  warning : PCA_Types.Warning_Type.Type,\n  occurrence_time : Z) {\n}\n\nobject Fault_Record_imp_Payload {\n  def example(): Fault_Record_imp_Payload = {\n    return Fault_Record_imp_Payload(PCA_Types.Fault_Record_imp.example())\n  }\n}\n\n@datatype class Fault_Record_imp_Payload(value: PCA_Types.Fault_Record_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Fault_Log.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Fault_Log {\n  def example(): PCA_Types.Fault_Log = {\n    return PCA_Types.Fault_Log(ISZ.create(150, PCA_Types.Fault_Record_imp.example()))\n  }\n}\n\n@datatype class Fault_Log(\n  value : ISZ[PCA_Types.Fault_Record_imp]) {\n  \/\/{  assert (value.size == 150) }\n}\n\nobject Fault_Log_Payload {\n  def example(): Fault_Log_Payload = {\n    return Fault_Log_Payload(PCA_Types.Fault_Log.example())\n  }\n}\n\n@datatype class Fault_Log_Payload(value: PCA_Types.Fault_Log) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Start_Patient_Bolus_Event.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Start_Patient_Bolus_Event {\n  def example(): PCA_Types.Start_Patient_Bolus_Event = {\n    return PCA_Types.Start_Patient_Bolus_Event()\n  }\n}\n\n@datatype class Start_Patient_Bolus_Event() \/\/ type skeleton\n\nobject Start_Patient_Bolus_Event_Payload {\n  def example(): Start_Patient_Bolus_Event_Payload = {\n    return Start_Patient_Bolus_Event_Payload(PCA_Types.Start_Patient_Bolus_Event.example())\n  }\n}\n\n@datatype class Start_Patient_Bolus_Event_Payload(value: PCA_Types.Start_Patient_Bolus_Event) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Stop_Patient_Bolus_Event.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Stop_Patient_Bolus_Event {\n  def example(): PCA_Types.Stop_Patient_Bolus_Event = {\n    return PCA_Types.Stop_Patient_Bolus_Event()\n  }\n}\n\n@datatype class Stop_Patient_Bolus_Event() \/\/ type skeleton\n\nobject Stop_Patient_Bolus_Event_Payload {\n  def example(): Stop_Patient_Bolus_Event_Payload = {\n    return Stop_Patient_Bolus_Event_Payload(PCA_Types.Stop_Patient_Bolus_Event.example())\n  }\n}\n\n@datatype class Stop_Patient_Bolus_Event_Payload(value: PCA_Types.Stop_Patient_Bolus_Event) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Event_Record.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Event_Record {\n  def example(): PCA_Types.Event_Record = {\n    return PCA_Types.Event_Record()\n  }\n}\n\n@datatype class Event_Record() \/\/ type skeleton\n\nobject Event_Record_Payload {\n  def example(): Event_Record_Payload = {\n    return Event_Record_Payload(PCA_Types.Event_Record.example())\n  }\n}\n\n@datatype class Event_Record_Payload(value: PCA_Types.Event_Record) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Event_Log.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Event_Log {\n  def example(): PCA_Types.Event_Log = {\n    return PCA_Types.Event_Log(ISZ.create(1500, PCA_Types.Event_Record.example()))\n  }\n}\n\n@datatype class Event_Log(\n  value : ISZ[PCA_Types.Event_Record]) {\n  \/\/{  assert (value.size == 1500) }\n}\n\nobject Event_Log_Payload {\n  def example(): Event_Log_Payload = {\n    return Event_Log_Payload(PCA_Types.Event_Log.example())\n  }\n}\n\n@datatype class Event_Log_Payload(value: PCA_Types.Event_Log) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/Physical_Types\/Fluid_Flow_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.Physical_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Fluid_Flow_imp {\n  def example(): Physical_Types.Fluid_Flow_imp = {\n    return Physical_Types.Fluid_Flow_imp(Base_Types.Float_32_example())\n  }\n}\n\n@datatype class Fluid_Flow_imp(\n  value : F32) {\n}\n\nobject Fluid_Flow_imp_Payload {\n  def example(): Fluid_Flow_imp_Payload = {\n    return Fluid_Flow_imp_Payload(Physical_Types.Fluid_Flow_imp.example())\n  }\n}\n\n@datatype class Fluid_Flow_imp_Payload(value: Physical_Types.Fluid_Flow_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Sound.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Sound {\n  \"Silence\"\n  \"Beep\"\n}\n\nobject Sound_Payload {\n  def example(): Sound_Payload = {\n    return Sound_Payload(PCA_Types.Sound.byOrdinal(0).get)\n  }\n}\n\n@datatype class Sound_Payload(value: PCA_Types.Sound.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/Physical_Types\/Voltage_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.Physical_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Voltage_imp {\n  def example(): Physical_Types.Voltage_imp = {\n    return Physical_Types.Voltage_imp(Base_Types.Integer_16_example())\n  }\n}\n\n@datatype class Voltage_imp(\n  value : S16) {\n}\n\nobject Voltage_imp_Payload {\n  def example(): Voltage_imp_Payload = {\n    return Voltage_imp_Payload(Physical_Types.Voltage_imp.example())\n  }\n}\n\n@datatype class Voltage_imp_Payload(value: Physical_Types.Voltage_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/Physical_Types\/Current_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.Physical_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Current_imp {\n  def example(): Physical_Types.Current_imp = {\n    return Physical_Types.Current_imp(Base_Types.Integer_16_example())\n  }\n}\n\n@datatype class Current_imp(\n  value : S16) {\n}\n\nobject Current_imp_Payload {\n  def example(): Current_imp_Payload = {\n    return Current_imp_Payload(Physical_Types.Current_imp.example())\n  }\n}\n\n@datatype class Current_imp_Payload(value: Physical_Types.Current_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Scan_Data_Type.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Scan_Data_Type {\n  def example(): PCA_Types.Scan_Data_Type = {\n    return PCA_Types.Scan_Data_Type()\n  }\n}\n\n@datatype class Scan_Data_Type() \/\/ type skeleton\n\nobject Scan_Data_Type_Payload {\n  def example(): Scan_Data_Type_Payload = {\n    return Scan_Data_Type_Payload(PCA_Types.Scan_Data_Type.example())\n  }\n}\n\n@datatype class Scan_Data_Type_Payload(value: PCA_Types.Scan_Data_Type) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Prescription_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Prescription_imp {\n  def example(): PCA_Types.Prescription_imp = {\n    return PCA_Types.Prescription_imp(Base_Types.String_example(), Base_Types.String_example(), PCA_Types.Drug_Code_imp.example(), PCA_Types.Drug_Concentration_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Flow_Rate_imp.example(), PCA_Types.Drug_Volume_imp.example(), PCA_Types.Drug_Volume_imp.example(), ICE_Types.Minute_imp.example(), Base_Types.String_example(), Base_Types.String_example(), Base_Types.String_example())\n  }\n}\n\n@datatype class Prescription_imp(\n  patient : String,\n  drugName : String,\n  code : PCA_Types.Drug_Code_imp,\n  concentration : PCA_Types.Drug_Concentration_imp,\n  initialVolume : PCA_Types.Drug_Volume_imp,\n  basalFlowRate : PCA_Types.Flow_Rate_imp,\n  patientBolusRate : PCA_Types.Flow_Rate_imp,\n  vtbi : PCA_Types.Drug_Volume_imp,\n  maxDrugPerHour : PCA_Types.Drug_Volume_imp,\n  minimumTimeBetweenBolus : ICE_Types.Minute_imp,\n  dateRxFilled : String,\n  prescriber : String,\n  pharmacist : String) {\n}\n\nobject Prescription_imp_Payload {\n  def example(): Prescription_imp_Payload = {\n    return Prescription_imp_Payload(PCA_Types.Prescription_imp.example())\n  }\n}\n\n@datatype class Prescription_imp_Payload(value: PCA_Types.Prescription_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Message.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Message {\n  \"No_Message\"\n  \"POST_fail\"\n  \"Turn_Off\"\n  \"If_Beep_Press_Stop_Button\"\n  \"Scan_Badge\"\n  \"Scan_Wristband\"\n  \"Scan_Rx\"\n  \"Clinician_Not_Authenticated\"\n  \"Patient_Not_Authenticated\"\n  \"Prescription_Not_Authenticated\"\n  \"Hard_Limit_Violated\"\n  \"Soft_Limit_Rejected\"\n  \"Insert_Vial_and_Close_Door\"\n  \"Press_start_to_begin_priming\"\n  \"Press_stop_to_end_priming\"\n  \"Priming_Failure\"\n  \"Insert_Needle_Then_Press_Start\"\n  \"Press_Stop_Again_To_End_Infusion_Press_Start_To_Resume_Infusion\"\n  \"Drug_Not_In_Library\"\n  \"Sound_Failure\"\n}\n\nobject Message_Payload {\n  def example(): Message_Payload = {\n    return Message_Payload(PCA_Types.Message.byOrdinal(0).get)\n  }\n}\n\n@datatype class Message_Payload(value: PCA_Types.Message.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Image.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Image {\n  def example(): PCA_Types.Image = {\n    return PCA_Types.Image()\n  }\n}\n\n@datatype class Image() \/\/ type skeleton\n\nobject Image_Payload {\n  def example(): Image_Payload = {\n    return Image_Payload(PCA_Types.Image.example())\n  }\n}\n\n@datatype class Image_Payload(value: PCA_Types.Image) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/PCA_Types\/Touch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\nobject Touch {\n  def example(): PCA_Types.Touch = {\n    return PCA_Types.Touch()\n  }\n}\n\n@datatype class Touch() \/\/ type skeleton\n\nobject Touch_Payload {\n  def example(): Touch_Payload = {\n    return Touch_Payload(PCA_Types.Touch.example())\n  }\n}\n\n@datatype class Touch_Payload(value: PCA_Types.Touch) extends art.DataContent\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/Physical_Types\/Fluid_Volume_imp.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.Physical_Types\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Fluid_Volume_imp {\n  def example(): Physical_Types.Fluid_Volume_imp = {\n    return Physical_Types.Fluid_Volume_imp(Base_Types.Float_32_example())\n  }\n}\n\n@datatype class Fluid_Volume_imp(\n  value : F32) {\n}\n\nobject Fluid_Volume_imp_Payload {\n  def example(): Fluid_Volume_imp_Payload = {\n    return Fluid_Volume_imp_Payload(Physical_Types.Fluid_Volume_imp.example())\n  }\n}\n\n@datatype class Fluid_Volume_imp_Payload(value: Physical_Types.Fluid_Volume_imp) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = {\n    Contract(Ensures(Res == F))\n    return F\n  }\n\n\n  def Integer_example(): Integer = {\n    Contract(Ensures(Res == z\"0\"))\n    return z\"0\"\n  }\n\n  def Integer_8_example(): Integer_8 = {\n    Contract(Ensures(Res == s8\"0\"))\n    return s8\"0\"\n  }\n\n  def Integer_16_example(): Integer_16 = {\n    Contract(Ensures(Res == s16\"0\"))\n    return s16\"0\"\n  }\n\n  def Integer_32_example(): Integer_32 = {\n    Contract(Ensures(Res == s32\"0\"))\n    return s32\"0\"\n  }\n\n  def Integer_64_example(): Integer_64 = {\n    Contract(Ensures(Res == s64\"0\"))\n    return s64\"0\"\n  }\n\n\n  def Unsigned_8_example(): Unsigned_8 = {\n    Contract(Ensures(Res == u8\"0\"))\n    return u8\"0\"\n  }\n\n  def Unsigned_16_example(): Unsigned_16 = {\n    Contract(Ensures(Res == u16\"0\"))\n    return u16\"0\"\n  }\n\n  def Unsigned_32_example(): Unsigned_32 = {\n    Contract(Ensures(Res == u32\"0\"))\n    return u32\"0\"\n  }\n\n  def Unsigned_64_example(): Unsigned_64 = {\n    Contract(Ensures(Res == u64\"0\"))\n    return u64\"0\"\n  }\n\n\n  def Float_example(): Float = {\n    Contract(Ensures(Res == r\"0\"))\n    return r\"0\"\n  }\n\n  def Float_32_example(): Float_32 = {\n    Contract(Ensures(Res == f32\"0\"))\n    return f32\"0\"\n  }\n\n  def Float_64_example(): Float_64 = {\n    Contract(Ensures(Res == f64\"0\"))\n    return f64\"0\"\n  }\n\n\n  def Character_example(): Character = {\n    Contract(Ensures(Res == ' '))\n    return ' '\n  }\n\n  def String_example(): String = {\n    Contract(Ensures(Res == \"\"))\n    return \"\"\n  }\n\n\n  def Bits_example(): Bits = {\n    Contract(Ensures(Res == ISZ[B]()))\n    return ISZ[B]()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/architecture\/pca_pump__JVM\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val wrap_pca_imp_Instance_maint : pca_pump__JVM.PCA_System.maintenance_imp_maint_Bridge = {\n    val to_maintenance_processor_The_Fault_Log = Port[PCA_Types.Fault_Log] (id = 0, name = \"wrap_pca_imp_Instance_maint_to_maintenance_processor_The_Fault_Log\", mode = EventIn)\n    val to_maintenance_processor_The_Event_Log = Port[PCA_Types.Event_Log] (id = 1, name = \"wrap_pca_imp_Instance_maint_to_maintenance_processor_The_Event_Log\", mode = EventIn)\n    val to_maintenance_processor_Load_Drug_Library = Port[PCA_Types.Drug_Library] (id = 2, name = \"wrap_pca_imp_Instance_maint_to_maintenance_processor_Load_Drug_Library\", mode = EventOut)\n    val to_maintenance_processor_Get_Fault_Log = Port[art.Empty] (id = 3, name = \"wrap_pca_imp_Instance_maint_to_maintenance_processor_Get_Fault_Log\", mode = EventOut)\n    val to_maintenance_processor_Get_Event_Log = Port[art.Empty] (id = 4, name = \"wrap_pca_imp_Instance_maint_to_maintenance_processor_Get_Event_Log\", mode = EventOut)\n    val The_Fault_Log = Port[PCA_Types.Fault_Log] (id = 5, name = \"wrap_pca_imp_Instance_maint_The_Fault_Log\", mode = EventIn)\n    val The_Event_Log = Port[PCA_Types.Event_Log] (id = 6, name = \"wrap_pca_imp_Instance_maint_The_Event_Log\", mode = EventIn)\n    val Load_Drug_Library = Port[PCA_Types.Drug_Library] (id = 7, name = \"wrap_pca_imp_Instance_maint_Load_Drug_Library\", mode = EventOut)\n    val Get_Fault_Log = Port[art.Empty] (id = 8, name = \"wrap_pca_imp_Instance_maint_Get_Fault_Log\", mode = EventOut)\n    val Get_Event_Log = Port[art.Empty] (id = 9, name = \"wrap_pca_imp_Instance_maint_Get_Event_Log\", mode = EventOut)\n\n    pca_pump__JVM.PCA_System.maintenance_imp_maint_Bridge(\n      id = 0,\n      name = \"wrap_pca_imp_Instance_maint\",\n      dispatchProtocol = Periodic(period = 1),\n      dispatchTriggers = None(),\n\n      to_maintenance_processor_The_Fault_Log = to_maintenance_processor_The_Fault_Log,\n      to_maintenance_processor_The_Event_Log = to_maintenance_processor_The_Event_Log,\n      to_maintenance_processor_Load_Drug_Library = to_maintenance_processor_Load_Drug_Library,\n      to_maintenance_processor_Get_Fault_Log = to_maintenance_processor_Get_Fault_Log,\n      to_maintenance_processor_Get_Event_Log = to_maintenance_processor_Get_Event_Log,\n      The_Fault_Log = The_Fault_Log,\n      The_Event_Log = The_Event_Log,\n      Load_Drug_Library = Load_Drug_Library,\n      Get_Fault_Log = Get_Fault_Log,\n      Get_Event_Log = Get_Event_Log\n    )\n  }\n  val wrap_pca_imp_Instance_pump_safety_error_detect : pca_pump__JVM.PCA_Safety.error_detector_imp_pump_safety_error_detect_Bridge = {\n    val Software_Stop_Pump = Port[art.Empty] (id = 10, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_Software_Stop_Pump\", mode = EventIn)\n    val Stop_Pump_Completely = Port[art.Empty] (id = 11, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_Stop_Pump_Completely\", mode = EventOut)\n    val POST_Failure = Port[art.Empty] (id = 12, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_POST_Failure\", mode = EventOut)\n    val POST_Done = Port[art.Empty] (id = 13, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_POST_Done\", mode = EventOut)\n    val RAM_Failure = Port[art.Empty] (id = 14, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_RAM_Failure\", mode = EventOut)\n    val ROM_failure = Port[art.Empty] (id = 15, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_ROM_failure\", mode = EventOut)\n    val CPU_Failure = Port[art.Empty] (id = 16, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_CPU_Failure\", mode = EventOut)\n    val Thread_Monitor_Failure = Port[art.Empty] (id = 17, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_Thread_Monitor_Failure\", mode = EventOut)\n    val HW_Detected_Failure = Port[art.Empty] (id = 18, name = \"wrap_pca_imp_Instance_pump_safety_error_detect_HW_Detected_Failure\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Safety.error_detector_imp_pump_safety_error_detect_Bridge(\n      id = 1,\n      name = \"wrap_pca_imp_Instance_pump_safety_error_detect\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Software_Stop_Pump = Software_Stop_Pump,\n      Stop_Pump_Completely = Stop_Pump_Completely,\n      POST_Failure = POST_Failure,\n      POST_Done = POST_Done,\n      RAM_Failure = RAM_Failure,\n      ROM_failure = ROM_failure,\n      CPU_Failure = CPU_Failure,\n      Thread_Monitor_Failure = Thread_Monitor_Failure,\n      HW_Detected_Failure = HW_Detected_Failure\n    )\n  }\n  val wrap_pca_imp_Instance_pump_safety_fault_log : pca_pump__JVM.PCA_Safety.fault_logger_imp_pump_safety_fault_log_Bridge = {\n    val Log_Fault = Port[PCA_Types.Fault_Record_imp] (id = 19, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_Log_Fault\", mode = EventIn)\n    val The_Log = Port[PCA_Types.Fault_Log] (id = 20, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_The_Log\", mode = EventOut)\n    val Get_Log = Port[art.Empty] (id = 21, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_Get_Log\", mode = EventIn)\n    val POST_Failure = Port[art.Empty] (id = 22, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_POST_Failure\", mode = EventIn)\n    val RAM_Failure = Port[art.Empty] (id = 23, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_RAM_Failure\", mode = EventIn)\n    val ROM_Failure = Port[art.Empty] (id = 24, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_ROM_Failure\", mode = EventIn)\n    val CPU_Failure = Port[art.Empty] (id = 25, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_CPU_Failure\", mode = EventIn)\n    val Thread_Monitor_Failure = Port[art.Empty] (id = 26, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_Thread_Monitor_Failure\", mode = EventIn)\n    val Voltage_OOR = Port[art.Empty] (id = 27, name = \"wrap_pca_imp_Instance_pump_safety_fault_log_Voltage_OOR\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Safety.fault_logger_imp_pump_safety_fault_log_Bridge(\n      id = 2,\n      name = \"wrap_pca_imp_Instance_pump_safety_fault_log\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Log_Fault = Log_Fault,\n      The_Log = The_Log,\n      Get_Log = Get_Log,\n      POST_Failure = POST_Failure,\n      RAM_Failure = RAM_Failure,\n      ROM_Failure = ROM_Failure,\n      CPU_Failure = CPU_Failure,\n      Thread_Monitor_Failure = Thread_Monitor_Failure,\n      Voltage_OOR = Voltage_OOR\n    )\n  }\n  val wrap_pca_imp_Instance_pump_safety_led : pca_pump__JVM.PCA_Safety.failure_led_imp_pump_safety_led_Bridge = {\n    val Light = Port[Base_Types.Boolean] (id = 28, name = \"wrap_pca_imp_Instance_pump_safety_led_Light\", mode = DataOut)\n    val Illuminate = Port[art.Empty] (id = 29, name = \"wrap_pca_imp_Instance_pump_safety_led_Illuminate\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Safety.failure_led_imp_pump_safety_led_Bridge(\n      id = 3,\n      name = \"wrap_pca_imp_Instance_pump_safety_led\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Light = Light,\n      Illuminate = Illuminate\n    )\n  }\n  val wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr : pca_pump__JVM.PCA_Alarm.alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge = {\n    val Alarm = Port[PCA_Types.Alarm_Type.Type] (id = 30, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Alarm\", mode = EventOut)\n    val Warning = Port[PCA_Types.Warning_Type.Type] (id = 31, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Warning\", mode = EventOut)\n    val ICE_Alarm_Signal = Port[ICE_Types.Alarm_Signal.Type] (id = 32, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Alarm_Signal\", mode = EventIn)\n    val Log_Fault = Port[PCA_Types.Fault_Record_imp] (id = 33, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Log_Fault\", mode = EventOut)\n    val ICE_Immediate = Port[art.Empty] (id = 34, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Immediate\", mode = EventOut)\n    val ICE_Prompt = Port[art.Empty] (id = 35, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Prompt\", mode = EventOut)\n    val ICE_Delayed = Port[art.Empty] (id = 36, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Delayed\", mode = EventOut)\n    val ICE_Malfunction = Port[art.Empty] (id = 37, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Malfunction\", mode = EventOut)\n    val ICE_Reset_Alarm = Port[art.Empty] (id = 38, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_ICE_Reset_Alarm\", mode = EventIn)\n    val Stop_Pump_Completely = Port[art.Empty] (id = 39, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Stop_Pump_Completely\", mode = EventOut)\n    val Pump_At_KVO_Rate = Port[art.Empty] (id = 40, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Pump_At_KVO_Rate\", mode = EventOut)\n    val Max_Dose_Warning = Port[art.Empty] (id = 41, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Max_Dose_Warning\", mode = EventIn)\n    val Hard_Limit_Violation = Port[art.Empty] (id = 42, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Hard_Limit_Violation\", mode = EventIn)\n    val Empty_Res = Port[art.Empty] (id = 43, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Empty_Res\", mode = EventIn)\n    val Low_Res = Port[art.Empty] (id = 44, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Low_Res\", mode = EventIn)\n    val Pump_Hot = Port[art.Empty] (id = 45, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Pump_Hot\", mode = EventIn)\n    val Upstream_Occlusion = Port[art.Empty] (id = 46, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Upstream_Occlusion\", mode = EventIn)\n    val Downstream_Occlusion = Port[art.Empty] (id = 47, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Downstream_Occlusion\", mode = EventIn)\n    val Bubble = Port[art.Empty] (id = 48, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Bubble\", mode = EventIn)\n    val Prime_Failure = Port[art.Empty] (id = 49, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Prime_Failure\", mode = EventIn)\n    val CP_Reset_Alarm = Port[art.Empty] (id = 50, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_CP_Reset_Alarm\", mode = EventIn)\n    val Drug_Not_In_Library = Port[art.Empty] (id = 51, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Drug_Not_In_Library\", mode = EventIn)\n    val Defective_Btty = Port[art.Empty] (id = 52, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Defective_Btty\", mode = EventIn)\n    val Low_Battery_Warning = Port[art.Empty] (id = 53, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Low_Battery_Warning\", mode = EventIn)\n    val Voltage_OOR = Port[art.Empty] (id = 54, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Voltage_OOR\", mode = EventIn)\n    val Basal_Overinfusion = Port[art.Empty] (id = 55, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Basal_Overinfusion\", mode = EventIn)\n    val Bolus_Overinfusion = Port[art.Empty] (id = 56, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Bolus_Overinfusion\", mode = EventIn)\n    val Square_Bolus_Overinfusion = Port[art.Empty] (id = 57, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Square_Bolus_Overinfusion\", mode = EventIn)\n    val Basal_Underinfusion = Port[art.Empty] (id = 58, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Basal_Underinfusion\", mode = EventIn)\n    val Bolus_Underinfusion = Port[art.Empty] (id = 59, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Bolus_Underinfusion\", mode = EventIn)\n    val Square_Bolus_Underinfusion = Port[art.Empty] (id = 60, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Square_Bolus_Underinfusion\", mode = EventIn)\n    val Security_Fault = Port[art.Empty] (id = 61, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_Security_Fault\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Alarm.alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge(\n      id = 4,\n      name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Alarm = Alarm,\n      Warning = Warning,\n      ICE_Alarm_Signal = ICE_Alarm_Signal,\n      Log_Fault = Log_Fault,\n      ICE_Immediate = ICE_Immediate,\n      ICE_Prompt = ICE_Prompt,\n      ICE_Delayed = ICE_Delayed,\n      ICE_Malfunction = ICE_Malfunction,\n      ICE_Reset_Alarm = ICE_Reset_Alarm,\n      Stop_Pump_Completely = Stop_Pump_Completely,\n      Pump_At_KVO_Rate = Pump_At_KVO_Rate,\n      Max_Dose_Warning = Max_Dose_Warning,\n      Hard_Limit_Violation = Hard_Limit_Violation,\n      Empty_Res = Empty_Res,\n      Low_Res = Low_Res,\n      Pump_Hot = Pump_Hot,\n      Upstream_Occlusion = Upstream_Occlusion,\n      Downstream_Occlusion = Downstream_Occlusion,\n      Bubble = Bubble,\n      Prime_Failure = Prime_Failure,\n      CP_Reset_Alarm = CP_Reset_Alarm,\n      Drug_Not_In_Library = Drug_Not_In_Library,\n      Defective_Btty = Defective_Btty,\n      Low_Battery_Warning = Low_Battery_Warning,\n      Voltage_OOR = Voltage_OOR,\n      Basal_Overinfusion = Basal_Overinfusion,\n      Bolus_Overinfusion = Bolus_Overinfusion,\n      Square_Bolus_Overinfusion = Square_Bolus_Overinfusion,\n      Basal_Underinfusion = Basal_Underinfusion,\n      Bolus_Underinfusion = Bolus_Underinfusion,\n      Square_Bolus_Underinfusion = Square_Bolus_Underinfusion,\n      Security_Fault = Security_Fault\n    )\n  }\n  val wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate : pca_pump__JVM.PCA_Alarm.Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge = {\n    val System_Status = Port[PCA_Types.Status_Type.Type] (id = 62, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_System_Status\", mode = DataIn)\n    val Infusion_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 63, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Infusion_Flow_Rate\", mode = DataIn)\n    val Upstream_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 64, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Upstream_Flow_Rate\", mode = DataIn)\n    val Downstream_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 65, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Downstream_Flow_Rate\", mode = DataIn)\n    val Basal_Overinfusion = Port[art.Empty] (id = 66, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Basal_Overinfusion\", mode = EventOut)\n    val Bolus_Overinfusion = Port[art.Empty] (id = 67, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Bolus_Overinfusion\", mode = EventOut)\n    val Square_Bolus_Overinfusion = Port[art.Empty] (id = 68, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Square_Bolus_Overinfusion\", mode = EventOut)\n    val Basal_Underinfusion = Port[art.Empty] (id = 69, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Basal_Underinfusion\", mode = EventOut)\n    val Bolus_Underinfusion = Port[art.Empty] (id = 70, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Bolus_Underinfusion\", mode = EventOut)\n    val Square_Bolus_Underinfusion = Port[art.Empty] (id = 71, name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_Square_Bolus_Underinfusion\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Alarm.Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge(\n      id = 5,\n      name = \"wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      System_Status = System_Status,\n      Infusion_Flow_Rate = Infusion_Flow_Rate,\n      Upstream_Flow_Rate = Upstream_Flow_Rate,\n      Downstream_Flow_Rate = Downstream_Flow_Rate,\n      Basal_Overinfusion = Basal_Overinfusion,\n      Bolus_Overinfusion = Bolus_Overinfusion,\n      Square_Bolus_Overinfusion = Square_Bolus_Overinfusion,\n      Basal_Underinfusion = Basal_Underinfusion,\n      Bolus_Underinfusion = Bolus_Underinfusion,\n      Square_Bolus_Underinfusion = Square_Bolus_Underinfusion\n    )\n  }\n  val wrap_pca_imp_Instance_pump_power_pwr : pca_pump__JVM.PCA_Power.power_control_imp_pump_power_pwr_Bridge = {\n    val Battery_Voltage = Port[Physical_Types.Voltage_imp] (id = 72, name = \"wrap_pca_imp_Instance_pump_power_pwr_Battery_Voltage\", mode = DataIn)\n    val Battery_Current = Port[Physical_Types.Current_imp] (id = 73, name = \"wrap_pca_imp_Instance_pump_power_pwr_Battery_Current\", mode = DataIn)\n    val Power_Voltage = Port[Physical_Types.Voltage_imp] (id = 74, name = \"wrap_pca_imp_Instance_pump_power_pwr_Power_Voltage\", mode = DataIn)\n    val Using_Battery_Power = Port[Base_Types.Boolean] (id = 75, name = \"wrap_pca_imp_Instance_pump_power_pwr_Using_Battery_Power\", mode = DataOut)\n    val Remaining_Battery_Time = Port[BLESS_Types.Time] (id = 76, name = \"wrap_pca_imp_Instance_pump_power_pwr_Remaining_Battery_Time\", mode = DataOut)\n    val Low_Battery_Warning = Port[art.Empty] (id = 77, name = \"wrap_pca_imp_Instance_pump_power_pwr_Low_Battery_Warning\", mode = EventOut)\n    val Defective_Battery = Port[art.Empty] (id = 78, name = \"wrap_pca_imp_Instance_pump_power_pwr_Defective_Battery\", mode = EventOut)\n    val Voltage_OOR = Port[art.Empty] (id = 79, name = \"wrap_pca_imp_Instance_pump_power_pwr_Voltage_OOR\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Power.power_control_imp_pump_power_pwr_Bridge(\n      id = 6,\n      name = \"wrap_pca_imp_Instance_pump_power_pwr\",\n      dispatchProtocol = Periodic(period = 60000),\n      dispatchTriggers = None(),\n\n      Battery_Voltage = Battery_Voltage,\n      Battery_Current = Battery_Current,\n      Power_Voltage = Power_Voltage,\n      Using_Battery_Power = Using_Battery_Power,\n      Remaining_Battery_Time = Remaining_Battery_Time,\n      Low_Battery_Warning = Low_Battery_Warning,\n      Defective_Battery = Defective_Battery,\n      Voltage_OOR = Voltage_OOR\n    )\n  }\n  val wrap_pca_imp_Instance_pump_power_btty : pca_pump__JVM.PCA_Power.battery_imp_pump_power_btty_Bridge = {\n    val Battery_Voltage = Port[Physical_Types.Voltage_imp] (id = 80, name = \"wrap_pca_imp_Instance_pump_power_btty_Battery_Voltage\", mode = DataOut)\n    val Battery_Current = Port[Physical_Types.Current_imp] (id = 81, name = \"wrap_pca_imp_Instance_pump_power_btty_Battery_Current\", mode = DataOut)\n\n    pca_pump__JVM.PCA_Power.battery_imp_pump_power_btty_Bridge(\n      id = 7,\n      name = \"wrap_pca_imp_Instance_pump_power_btty\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      Battery_Voltage = Battery_Voltage,\n      Battery_Current = Battery_Current\n    )\n  }\n  val wrap_pca_imp_Instance_pump_power_vcc : pca_pump__JVM.PCA_Power.power_supply_imp_pump_power_vcc_Bridge = {\n    val Power_Voltage = Port[Physical_Types.Voltage_imp] (id = 82, name = \"wrap_pca_imp_Instance_pump_power_vcc_Power_Voltage\", mode = DataOut)\n\n    pca_pump__JVM.PCA_Power.power_supply_imp_pump_power_vcc_Bridge(\n      id = 8,\n      name = \"wrap_pca_imp_Instance_pump_power_vcc\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      Power_Voltage = Power_Voltage\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_patient_button : pca_pump__JVM.PCA_Mechanical.patient_button_imp_pump_operation_patient_button_Bridge = {\n    val Button_Press = Port[art.Empty] (id = 83, name = \"wrap_pca_imp_Instance_pump_operation_patient_button_Button_Press\", mode = EventIn)\n    val Request_Bolus = Port[art.Empty] (id = 84, name = \"wrap_pca_imp_Instance_pump_operation_patient_button_Request_Bolus\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.patient_button_imp_pump_operation_patient_button_Bridge(\n      id = 9,\n      name = \"wrap_pca_imp_Instance_pump_operation_patient_button\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Button_Press = Button_Press,\n      Request_Bolus = Request_Bolus\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_scanner : pca_pump__JVM.PCA_Mechanical.scanner_imp_pump_operation_scanner_Bridge = {\n    val Scan_Data = Port[PCA_Types.Scan_Data_Type] (id = 85, name = \"wrap_pca_imp_Instance_pump_operation_scanner_Scan_Data\", mode = EventOut)\n    val Do_Scan = Port[art.Empty] (id = 86, name = \"wrap_pca_imp_Instance_pump_operation_scanner_Do_Scan\", mode = EventIn)\n    val Scan_Done = Port[art.Empty] (id = 87, name = \"wrap_pca_imp_Instance_pump_operation_scanner_Scan_Done\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.scanner_imp_pump_operation_scanner_Bridge(\n      id = 10,\n      name = \"wrap_pca_imp_Instance_pump_operation_scanner\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Scan_Data = Scan_Data,\n      Do_Scan = Do_Scan,\n      Scan_Done = Scan_Done\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_drug_library : pca_pump__JVM.PCA_Drug_Library.drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge = {\n    val Load_Drug_Library = Port[PCA_Types.Drug_Library] (id = 88, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_drug_library_Load_Drug_Library\", mode = EventIn)\n    val Get_Drug_Record = Port[PCA_Types.Drug_Code_imp] (id = 89, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_drug_library_Get_Drug_Record\", mode = EventIn)\n    val The_Drug_Record = Port[PCA_Types.Drug_Record_imp] (id = 90, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_drug_library_The_Drug_Record\", mode = EventOut)\n    val No_Drug_Found = Port[art.Empty] (id = 91, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_drug_library_No_Drug_Found\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Drug_Library.drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge(\n      id = 11,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_drug_library\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Load_Drug_Library = Load_Drug_Library,\n      Get_Drug_Record = Get_Drug_Record,\n      The_Drug_Record = The_Drug_Record,\n      No_Drug_Found = No_Drug_Found\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_event_logger : pca_pump__JVM.PCA_Operation.event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge = {\n    val Log_Event = Port[PCA_Types.Event_Record] (id = 92, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_event_logger_Log_Event\", mode = EventIn)\n    val The_Event_Log = Port[PCA_Types.Event_Log] (id = 93, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_event_logger_The_Event_Log\", mode = EventOut)\n    val Get_Event_Log = Port[art.Empty] (id = 94, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_event_logger_Get_Event_Log\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Operation.event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge(\n      id = 12,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_event_logger\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Log_Event = Log_Event,\n      The_Event_Log = The_Event_Log,\n      Get_Event_Log = Get_Event_Log\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss : pca_pump__JVM.PCA_Boss.Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge = {\n    val Display_Message = Port[PCA_Types.Message.Type] (id = 95, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Display_Message\", mode = EventOut)\n    val Sound_Type = Port[PCA_Types.Sound.Type] (id = 96, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Sound_Type\", mode = EventOut)\n    val Log_Event = Port[PCA_Types.Event_Record] (id = 97, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Log_Event\", mode = EventOut)\n    val POST_done = Port[art.Empty] (id = 98, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_POST_done\", mode = EventIn)\n    val POST_fail = Port[art.Empty] (id = 99, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_POST_fail\", mode = EventIn)\n    val Stop_Button_Pressed = Port[art.Empty] (id = 100, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Stop_Button_Pressed\", mode = EventIn)\n    val Start_Button_Pressed = Port[art.Empty] (id = 101, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Start_Button_Pressed\", mode = EventIn)\n    val Do_Scan = Port[art.Empty] (id = 102, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Do_Scan\", mode = EventOut)\n    val Scan_Done = Port[art.Empty] (id = 103, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Scan_Done\", mode = EventIn)\n    val Authenticate_Clinician = Port[art.Empty] (id = 104, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Authenticate_Clinician\", mode = EventOut)\n    val Authenticate_Patient = Port[art.Empty] (id = 105, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Authenticate_Patient\", mode = EventOut)\n    val Authenticate_Prescription = Port[art.Empty] (id = 106, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Authenticate_Prescription\", mode = EventOut)\n    val Authentication_fail = Port[art.Empty] (id = 107, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Authentication_fail\", mode = EventIn)\n    val Authentication_pass = Port[art.Empty] (id = 108, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Authentication_pass\", mode = EventIn)\n    val Check_Rx = Port[art.Empty] (id = 109, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Check_Rx\", mode = EventOut)\n    val Drug_Not_In_Library = Port[art.Empty] (id = 110, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Drug_Not_In_Library\", mode = EventIn)\n    val Hard_Limit_Violated = Port[art.Empty] (id = 111, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Hard_Limit_Violated\", mode = EventIn)\n    val Reject_Soft_Limit_Exception = Port[art.Empty] (id = 112, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Reject_Soft_Limit_Exception\", mode = EventIn)\n    val Confirm_Soft_Limit_Exception = Port[art.Empty] (id = 113, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Confirm_Soft_Limit_Exception\", mode = EventIn)\n    val Rx_Okay = Port[art.Empty] (id = 114, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Rx_Okay\", mode = EventIn)\n    val Door_Closed = Port[art.Empty] (id = 115, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Door_Closed\", mode = EventIn)\n    val Begin_Priming = Port[art.Empty] (id = 116, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Begin_Priming\", mode = EventOut)\n    val End_Priming = Port[art.Empty] (id = 117, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_End_Priming\", mode = EventOut)\n    val Prime_Failure = Port[art.Empty] (id = 118, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Prime_Failure\", mode = EventOut)\n    val Begin_Infusion = Port[art.Empty] (id = 119, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Begin_Infusion\", mode = EventOut)\n    val Halt_Infusion = Port[art.Empty] (id = 120, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Halt_Infusion\", mode = EventOut)\n    val Turn_Off = Port[art.Empty] (id = 121, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_Turn_Off\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Boss.Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge(\n      id = 13,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Display_Message = Display_Message,\n      Sound_Type = Sound_Type,\n      Log_Event = Log_Event,\n      POST_done = POST_done,\n      POST_fail = POST_fail,\n      Stop_Button_Pressed = Stop_Button_Pressed,\n      Start_Button_Pressed = Start_Button_Pressed,\n      Do_Scan = Do_Scan,\n      Scan_Done = Scan_Done,\n      Authenticate_Clinician = Authenticate_Clinician,\n      Authenticate_Patient = Authenticate_Patient,\n      Authenticate_Prescription = Authenticate_Prescription,\n      Authentication_fail = Authentication_fail,\n      Authentication_pass = Authentication_pass,\n      Check_Rx = Check_Rx,\n      Drug_Not_In_Library = Drug_Not_In_Library,\n      Hard_Limit_Violated = Hard_Limit_Violated,\n      Reject_Soft_Limit_Exception = Reject_Soft_Limit_Exception,\n      Confirm_Soft_Limit_Exception = Confirm_Soft_Limit_Exception,\n      Rx_Okay = Rx_Okay,\n      Door_Closed = Door_Closed,\n      Begin_Priming = Begin_Priming,\n      End_Priming = End_Priming,\n      Prime_Failure = Prime_Failure,\n      Begin_Infusion = Begin_Infusion,\n      Halt_Infusion = Halt_Infusion,\n      Turn_Off = Turn_Off\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller : pca_pump__JVM.PCA_Operation_Threads.Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge = {\n    val Infusion_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 122, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Infusion_Flow_Rate\", mode = DataOut)\n    val Square_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 123, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Square_Bolus_Rate\", mode = DataIn)\n    val Patient_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 124, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Patient_Bolus_Rate\", mode = DataIn)\n    val Basal_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 125, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Basal_Rate\", mode = DataIn)\n    val VTBI = Port[PCA_Types.Drug_Volume_imp] (id = 126, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_VTBI\", mode = DataIn)\n    val Door_Open = Port[Base_Types.Boolean] (id = 127, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Door_Open\", mode = DataIn)\n    val System_Status = Port[PCA_Types.Status_Type.Type] (id = 128, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_System_Status\", mode = EventOut)\n    val Alarm = Port[PCA_Types.Alarm_Type.Type] (id = 129, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Alarm\", mode = EventIn)\n    val Warning = Port[PCA_Types.Warning_Type.Type] (id = 130, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Warning\", mode = EventIn)\n    val CP_Bolus_Duration = Port[ICE_Types.Minute_imp] (id = 131, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_CP_Bolus_Duration\", mode = EventIn)\n    val Begin_Infusion = Port[art.Empty] (id = 132, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Begin_Infusion\", mode = EventIn)\n    val Begin_Priming = Port[art.Empty] (id = 133, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Begin_Priming\", mode = EventIn)\n    val End_Priming = Port[art.Empty] (id = 134, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_End_Priming\", mode = EventIn)\n    val Halt_Infusion = Port[art.Empty] (id = 135, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Halt_Infusion\", mode = EventIn)\n    val HW_Detected_Failure = Port[art.Empty] (id = 136, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_HW_Detected_Failure\", mode = EventIn)\n    val Stop_Pump_Completely = Port[art.Empty] (id = 137, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Stop_Pump_Completely\", mode = EventIn)\n    val Pump_At_KVO_Rate = Port[art.Empty] (id = 138, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Pump_At_KVO_Rate\", mode = EventIn)\n    val Patient_Request_Not_Too_Soon = Port[art.Empty] (id = 139, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Patient_Request_Not_Too_Soon\", mode = EventIn)\n    val Pause_Infusion = Port[art.Empty] (id = 140, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Pause_Infusion\", mode = EventIn)\n    val Resume_Infusion = Port[art.Empty] (id = 141, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Resume_Infusion\", mode = EventIn)\n    val CP_Clinician_Request_Bolus = Port[art.Empty] (id = 142, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_CP_Clinician_Request_Bolus\", mode = EventIn)\n    val Near_Max_Drug_Per_Hour = Port[art.Empty] (id = 143, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Near_Max_Drug_Per_Hour\", mode = EventIn)\n    val Over_Max_Drug_Per_Hour = Port[art.Empty] (id = 144, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_Over_Max_Drug_Per_Hour\", mode = EventIn)\n    val ICE_Stop_Pump = Port[art.Empty] (id = 145, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_ICE_Stop_Pump\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Operation_Threads.Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge(\n      id = 14,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Infusion_Flow_Rate = Infusion_Flow_Rate,\n      Square_Bolus_Rate = Square_Bolus_Rate,\n      Patient_Bolus_Rate = Patient_Bolus_Rate,\n      Basal_Rate = Basal_Rate,\n      VTBI = VTBI,\n      Door_Open = Door_Open,\n      System_Status = System_Status,\n      Alarm = Alarm,\n      Warning = Warning,\n      CP_Bolus_Duration = CP_Bolus_Duration,\n      Begin_Infusion = Begin_Infusion,\n      Begin_Priming = Begin_Priming,\n      End_Priming = End_Priming,\n      Halt_Infusion = Halt_Infusion,\n      HW_Detected_Failure = HW_Detected_Failure,\n      Stop_Pump_Completely = Stop_Pump_Completely,\n      Pump_At_KVO_Rate = Pump_At_KVO_Rate,\n      Patient_Request_Not_Too_Soon = Patient_Request_Not_Too_Soon,\n      Pause_Infusion = Pause_Infusion,\n      Resume_Infusion = Resume_Infusion,\n      CP_Clinician_Request_Bolus = CP_Clinician_Request_Bolus,\n      Near_Max_Drug_Per_Hour = Near_Max_Drug_Per_Hour,\n      Over_Max_Drug_Per_Hour = Over_Max_Drug_Per_Hour,\n      ICE_Stop_Pump = ICE_Stop_Pump\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker : pca_pump__JVM.PCA_Operation_Threads.Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge = {\n    val Prescription = Port[PCA_Types.Prescription_imp] (id = 146, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Prescription\", mode = DataIn)\n    val VTBI = Port[PCA_Types.Drug_Volume_imp] (id = 147, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_VTBI\", mode = DataOut)\n    val Square_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 148, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Square_Bolus_Rate\", mode = DataOut)\n    val Patient_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 149, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Patient_Bolus_Rate\", mode = DataOut)\n    val Basal_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 150, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Basal_Rate\", mode = DataOut)\n    val Minimum_Time_Between_Bolus = Port[ICE_Types.Minute_imp] (id = 151, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Minimum_Time_Between_Bolus\", mode = DataOut)\n    val Max_Drug_Per_Hour = Port[PCA_Types.Drug_Volume_imp] (id = 152, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Max_Drug_Per_Hour\", mode = DataOut)\n    val Get_Drug_Record = Port[PCA_Types.Drug_Code_imp] (id = 153, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Get_Drug_Record\", mode = EventOut)\n    val The_Drug_Record = Port[PCA_Types.Drug_Record_imp] (id = 154, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_The_Drug_Record\", mode = EventIn)\n    val Check_Rx = Port[art.Empty] (id = 155, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Check_Rx\", mode = EventIn)\n    val Rx_Okay = Port[art.Empty] (id = 156, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Rx_Okay\", mode = EventOut)\n    val Drug_Not_In_Library = Port[art.Empty] (id = 157, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Drug_Not_In_Library\", mode = EventIn)\n    val Confirm_Soft_Limit_Exception = Port[art.Empty] (id = 158, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Confirm_Soft_Limit_Exception\", mode = EventIn)\n    val Reject_Soft_Limit_Exception = Port[art.Empty] (id = 159, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Reject_Soft_Limit_Exception\", mode = EventIn)\n    val Soft_Limit_Warning = Port[art.Empty] (id = 160, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Soft_Limit_Warning\", mode = EventOut)\n    val Hard_Limit_Violated = Port[art.Empty] (id = 161, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_Hard_Limit_Violated\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Operation_Threads.Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge(\n      id = 15,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Prescription = Prescription,\n      VTBI = VTBI,\n      Square_Bolus_Rate = Square_Bolus_Rate,\n      Patient_Bolus_Rate = Patient_Bolus_Rate,\n      Basal_Rate = Basal_Rate,\n      Minimum_Time_Between_Bolus = Minimum_Time_Between_Bolus,\n      Max_Drug_Per_Hour = Max_Drug_Per_Hour,\n      Get_Drug_Record = Get_Drug_Record,\n      The_Drug_Record = The_Drug_Record,\n      Check_Rx = Check_Rx,\n      Rx_Okay = Rx_Okay,\n      Drug_Not_In_Library = Drug_Not_In_Library,\n      Confirm_Soft_Limit_Exception = Confirm_Soft_Limit_Exception,\n      Reject_Soft_Limit_Exception = Reject_Soft_Limit_Exception,\n      Soft_Limit_Warning = Soft_Limit_Warning,\n      Hard_Limit_Violated = Hard_Limit_Violated\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread : pca_pump__JVM.PCA_Operation_Threads.ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge = {\n    val command_Start = Port[art.Empty] (id = 162, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_Start\", mode = EventIn)\n    val command_Suspend = Port[art.Empty] (id = 163, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_Suspend\", mode = EventIn)\n    val command_load_drug_library = Port[PCA_Types.Drug_Library] (id = 164, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_load_drug_library\", mode = EventIn)\n    val command_set_clinican_requested_bolus_duration = Port[ICE_Types.Minute_imp] (id = 165, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_set_clinican_requested_bolus_duration\", mode = EventIn)\n    val command_request_bolus = Port[art.Empty] (id = 166, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_request_bolus\", mode = EventIn)\n    val command_pause_infusion = Port[art.Empty] (id = 167, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_pause_infusion\", mode = EventIn)\n    val command_resume_infusion = Port[art.Empty] (id = 168, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_command_resume_infusion\", mode = EventIn)\n    val parameters_current_flow_rate = Port[ICE_Types.Milliliter_Per_Hour] (id = 169, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_current_flow_rate\", mode = DataOut)\n    val parameters_basal_flow_rate = Port[ICE_Types.Milliliter_Per_Hour] (id = 170, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_basal_flow_rate\", mode = DataOut)\n    val parameters_bolus_flow_rate = Port[ICE_Types.Milliliter_Per_Hour] (id = 171, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_bolus_flow_rate\", mode = DataOut)\n    val parameters_KVO_Flow_Rate = Port[ICE_Types.Milliliter_Per_Hour] (id = 172, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_KVO_Flow_Rate\", mode = DataOut)\n    val parameters_volume_to_be_infused = Port[ICE_Types.Milliliter] (id = 173, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_volume_to_be_infused\", mode = DataOut)\n    val parameters_clinican_requested_bolus_duration = Port[ICE_Types.Minute_imp] (id = 174, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_clinican_requested_bolus_duration\", mode = DataOut)\n    val parameters_square_flow_rate = Port[ICE_Types.Milliliter_Per_Hour] (id = 175, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_parameters_square_flow_rate\", mode = DataOut)\n    val status_On = Port[Base_Types.Boolean] (id = 176, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_status_On\", mode = DataOut)\n    val status_Okay = Port[Base_Types.Boolean] (id = 177, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_status_Okay\", mode = DataOut)\n    val status_AppConnected = Port[Base_Types.Boolean] (id = 178, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_status_AppConnected\", mode = DataIn)\n    val status_status = Port[PCA_Types.Status_Type.Type] (id = 179, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_status_status\", mode = DataOut)\n    val Infusion_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 180, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Infusion_Flow_Rate\", mode = DataIn)\n    val Patient_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 181, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Patient_Bolus_Rate\", mode = DataIn)\n    val Square_Bolus_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 182, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Square_Bolus_Rate\", mode = DataIn)\n    val Basal_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 183, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Basal_Rate\", mode = DataIn)\n    val VTBI = Port[PCA_Types.Drug_Volume_imp] (id = 184, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_VTBI\", mode = DataIn)\n    val Door_Open = Port[Base_Types.Boolean] (id = 185, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Door_Open\", mode = DataIn)\n    val Alarm_Inactivation = Port[ICE_Types.Alarm_Signal.Type] (id = 186, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Alarm_Inactivation\", mode = DataIn)\n    val Alarm = Port[PCA_Types.Alarm_Type.Type] (id = 187, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Alarm\", mode = EventIn)\n    val Warning = Port[PCA_Types.Warning_Type.Type] (id = 188, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Warning\", mode = EventIn)\n    val CP_Bolus_Duration = Port[ICE_Types.Minute_imp] (id = 189, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_CP_Bolus_Duration\", mode = EventIn)\n    val ICE_Stop_Pump = Port[art.Empty] (id = 190, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_ICE_Stop_Pump\", mode = EventOut)\n    val Rx_Okay = Port[art.Empty] (id = 191, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Rx_Okay\", mode = EventIn)\n    val Patient_Request_Not_Too_Soon = Port[art.Empty] (id = 192, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Patient_Request_Not_Too_Soon\", mode = EventIn)\n    val Patient_Request_Too_Soon = Port[art.Empty] (id = 193, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Patient_Request_Too_Soon\", mode = EventIn)\n    val HW_Detected_Failure = Port[art.Empty] (id = 194, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_HW_Detected_Failure\", mode = EventIn)\n    val Stop_Pump_Completely = Port[art.Empty] (id = 195, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Stop_Pump_Completely\", mode = EventIn)\n    val Pump_At_KVO_Rate = Port[art.Empty] (id = 196, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Pump_At_KVO_Rate\", mode = EventIn)\n    val CP_Clinician_Request_Bolus = Port[art.Empty] (id = 197, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_CP_Clinician_Request_Bolus\", mode = EventIn)\n    val Halt_Infusion = Port[art.Empty] (id = 198, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Halt_Infusion\", mode = EventIn)\n    val Begin_Infusion = Port[art.Empty] (id = 199, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Begin_Infusion\", mode = EventIn)\n    val Near_Max_Drug_Per_Hour = Port[art.Empty] (id = 200, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Near_Max_Drug_Per_Hour\", mode = EventIn)\n    val Over_Max_Drug_Per_Hour = Port[art.Empty] (id = 201, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_Over_Max_Drug_Per_Hour\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Operation_Threads.ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge(\n      id = 16,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      command_Start = command_Start,\n      command_Suspend = command_Suspend,\n      command_load_drug_library = command_load_drug_library,\n      command_set_clinican_requested_bolus_duration = command_set_clinican_requested_bolus_duration,\n      command_request_bolus = command_request_bolus,\n      command_pause_infusion = command_pause_infusion,\n      command_resume_infusion = command_resume_infusion,\n      parameters_current_flow_rate = parameters_current_flow_rate,\n      parameters_basal_flow_rate = parameters_basal_flow_rate,\n      parameters_bolus_flow_rate = parameters_bolus_flow_rate,\n      parameters_KVO_Flow_Rate = parameters_KVO_Flow_Rate,\n      parameters_volume_to_be_infused = parameters_volume_to_be_infused,\n      parameters_clinican_requested_bolus_duration = parameters_clinican_requested_bolus_duration,\n      parameters_square_flow_rate = parameters_square_flow_rate,\n      status_On = status_On,\n      status_Okay = status_Okay,\n      status_AppConnected = status_AppConnected,\n      status_status = status_status,\n      Infusion_Flow_Rate = Infusion_Flow_Rate,\n      Patient_Bolus_Rate = Patient_Bolus_Rate,\n      Square_Bolus_Rate = Square_Bolus_Rate,\n      Basal_Rate = Basal_Rate,\n      VTBI = VTBI,\n      Door_Open = Door_Open,\n      Alarm_Inactivation = Alarm_Inactivation,\n      Alarm = Alarm,\n      Warning = Warning,\n      CP_Bolus_Duration = CP_Bolus_Duration,\n      ICE_Stop_Pump = ICE_Stop_Pump,\n      Rx_Okay = Rx_Okay,\n      Patient_Request_Not_Too_Soon = Patient_Request_Not_Too_Soon,\n      Patient_Request_Too_Soon = Patient_Request_Too_Soon,\n      HW_Detected_Failure = HW_Detected_Failure,\n      Stop_Pump_Completely = Stop_Pump_Completely,\n      Pump_At_KVO_Rate = Pump_At_KVO_Rate,\n      CP_Clinician_Request_Bolus = CP_Clinician_Request_Bolus,\n      Halt_Infusion = Halt_Infusion,\n      Begin_Infusion = Begin_Infusion,\n      Near_Max_Drug_Per_Hour = Near_Max_Drug_Per_Hour,\n      Over_Max_Drug_Per_Hour = Over_Max_Drug_Per_Hour\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher : pca_pump__JVM.PCA_Operation_Threads.Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge = {\n    val Infusion_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 202, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher_Infusion_Flow_Rate\", mode = DataIn)\n    val Max_Drug_Per_Hour = Port[PCA_Types.Drug_Volume_imp] (id = 203, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher_Max_Drug_Per_Hour\", mode = DataIn)\n    val Near_Max_Drug_Per_Hour = Port[art.Empty] (id = 204, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher_Near_Max_Drug_Per_Hour\", mode = EventOut)\n    val Over_Max_Drug_Per_Hour = Port[art.Empty] (id = 205, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher_Over_Max_Drug_Per_Hour\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Operation_Threads.Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge(\n      id = 17,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      Infusion_Flow_Rate = Infusion_Flow_Rate,\n      Max_Drug_Per_Hour = Max_Drug_Per_Hour,\n      Near_Max_Drug_Per_Hour = Near_Max_Drug_Per_Hour,\n      Over_Max_Drug_Per_Hour = Over_Max_Drug_Per_Hour\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker : pca_pump__JVM.PCA_Operation_Threads.Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge = {\n    val Minimum_Time_Between_Bolus = Port[ICE_Types.Minute_imp] (id = 206, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker_Minimum_Time_Between_Bolus\", mode = DataIn)\n    val Patient_Button_Request = Port[art.Empty] (id = 207, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker_Patient_Button_Request\", mode = EventIn)\n    val Patient_Request_Not_Too_Soon = Port[art.Empty] (id = 208, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker_Patient_Request_Not_Too_Soon\", mode = EventOut)\n    val Patient_Request_Too_Soon = Port[art.Empty] (id = 209, name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker_Patient_Request_Too_Soon\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Operation_Threads.Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge(\n      id = 18,\n      name = \"wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Minimum_Time_Between_Bolus = Minimum_Time_Between_Bolus,\n      Patient_Button_Request = Patient_Button_Request,\n      Patient_Request_Not_Too_Soon = Patient_Request_Not_Too_Soon,\n      Patient_Request_Too_Soon = Patient_Request_Too_Soon\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread : pca_pump__JVM.PCA_Security.Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge = {\n    val Clinician_Name = Port[Base_Types.String] (id = 210, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Clinician_Name\", mode = DataOut)\n    val Patient_Name = Port[Base_Types.String] (id = 211, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Patient_Name\", mode = DataOut)\n    val Prescription = Port[PCA_Types.Prescription_imp] (id = 212, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Prescription\", mode = DataOut)\n    val Scan_Data = Port[PCA_Types.Scan_Data_Type] (id = 213, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Scan_Data\", mode = EventIn)\n    val Authenticate_Clinician = Port[art.Empty] (id = 214, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Authenticate_Clinician\", mode = EventIn)\n    val Authenticate_Patient = Port[art.Empty] (id = 215, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Authenticate_Patient\", mode = EventIn)\n    val Authenticate_Prescription = Port[art.Empty] (id = 216, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Authenticate_Prescription\", mode = EventIn)\n    val Authentication_fail = Port[art.Empty] (id = 217, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Authentication_fail\", mode = EventOut)\n    val Authentication_pass = Port[art.Empty] (id = 218, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Authentication_pass\", mode = EventOut)\n    val Security_Fault = Port[art.Empty] (id = 219, name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_Security_Fault\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Security.Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge(\n      id = 19,\n      name = \"wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      Clinician_Name = Clinician_Name,\n      Patient_Name = Patient_Name,\n      Prescription = Prescription,\n      Scan_Data = Scan_Data,\n      Authenticate_Clinician = Authenticate_Clinician,\n      Authenticate_Patient = Authenticate_Patient,\n      Authenticate_Prescription = Authenticate_Prescription,\n      Authentication_fail = Authentication_fail,\n      Authentication_pass = Authentication_pass,\n      Security_Fault = Security_Fault\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_control_panel_display : pca_pump__JVM.PCA_Control_Panel.pca_screen_imp_pump_operation_control_panel_display_Bridge = {\n    val Image = Port[PCA_Types.Image] (id = 220, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_display_Image\", mode = DataIn)\n    val LightToEye = Port[Base_Types.Boolean] (id = 221, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_display_LightToEye\", mode = DataOut)\n    val Touch = Port[PCA_Types.Touch] (id = 222, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_display_Touch\", mode = EventOut)\n    val Finger_Press = Port[Base_Types.Boolean] (id = 223, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_display_Finger_Press\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Control_Panel.pca_screen_imp_pump_operation_control_panel_display_Bridge(\n      id = 20,\n      name = \"wrap_pca_imp_Instance_pump_operation_control_panel_display\",\n      dispatchProtocol = Periodic(period = 1),\n      dispatchTriggers = None(),\n\n      Image = Image,\n      LightToEye = LightToEye,\n      Touch = Touch,\n      Finger_Press = Finger_Press\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_control_panel_audible : pca_pump__JVM.PCA_Control_Panel.pca_speaker_imp_pump_operation_control_panel_audible_Bridge = {\n    val AudioSignal = Port[PCA_Types.Sound.Type] (id = 224, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_audible_AudioSignal\", mode = DataIn)\n    val Sound = Port[PCA_Types.Sound.Type] (id = 225, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_audible_Sound\", mode = DataOut)\n\n    pca_pump__JVM.PCA_Control_Panel.pca_speaker_imp_pump_operation_control_panel_audible_Bridge(\n      id = 21,\n      name = \"wrap_pca_imp_Instance_pump_operation_control_panel_audible\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      AudioSignal = AudioSignal,\n      Sound = Sound\n    )\n  }\n  val wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread : pca_pump__JVM.PCA_Control_Panel.ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge = {\n    val Image = Port[PCA_Types.Image] (id = 226, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Image\", mode = DataOut)\n    val AudioSignal = Port[PCA_Types.Sound.Type] (id = 227, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_AudioSignal\", mode = DataOut)\n    val Alarm_Inactivation = Port[ICE_Types.Alarm_Signal.Type] (id = 228, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Alarm_Inactivation\", mode = DataOut)\n    val Remaining_Battery_Time = Port[BLESS_Types.Time] (id = 229, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Remaining_Battery_Time\", mode = DataIn)\n    val Using_Battery_Power = Port[Base_Types.Boolean] (id = 230, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Using_Battery_Power\", mode = DataIn)\n    val Prescription = Port[PCA_Types.Prescription_imp] (id = 231, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Prescription\", mode = DataIn)\n    val Infusion_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 232, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Infusion_Flow_Rate\", mode = DataIn)\n    val Clinician_Name = Port[Base_Types.String] (id = 233, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Clinician_Name\", mode = DataIn)\n    val Patient_Name = Port[Base_Types.String] (id = 234, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Patient_Name\", mode = DataIn)\n    val Touch = Port[PCA_Types.Touch] (id = 235, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Touch\", mode = EventIn)\n    val Alarm = Port[PCA_Types.Alarm_Type.Type] (id = 236, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Alarm\", mode = EventIn)\n    val Warning = Port[PCA_Types.Warning_Type.Type] (id = 237, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Warning\", mode = EventIn)\n    val System_Status = Port[PCA_Types.Status_Type.Type] (id = 238, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_System_Status\", mode = EventIn)\n    val Display_Message = Port[PCA_Types.Message.Type] (id = 239, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Display_Message\", mode = EventIn)\n    val Sound_Type = Port[PCA_Types.Sound.Type] (id = 240, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Sound_Type\", mode = EventIn)\n    val Bolus_Duration = Port[ICE_Types.Minute_imp] (id = 241, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Bolus_Duration\", mode = EventOut)\n    val CP_Reset_Alarm = Port[art.Empty] (id = 242, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_CP_Reset_Alarm\", mode = EventOut)\n    val Low_Battery_Warning = Port[art.Empty] (id = 243, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Low_Battery_Warning\", mode = EventIn)\n    val Hard_Limit_Violated = Port[art.Empty] (id = 244, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Hard_Limit_Violated\", mode = EventIn)\n    val Soft_Limit_Warning = Port[art.Empty] (id = 245, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Soft_Limit_Warning\", mode = EventIn)\n    val Confirm_Soft_Limit_Exception = Port[art.Empty] (id = 246, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Confirm_Soft_Limit_Exception\", mode = EventOut)\n    val Reject_Soft_Limit_Exception = Port[art.Empty] (id = 247, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Reject_Soft_Limit_Exception\", mode = EventOut)\n    val Stop_Button_Pressed = Port[art.Empty] (id = 248, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Stop_Button_Pressed\", mode = EventOut)\n    val Start_Button_Pressed = Port[art.Empty] (id = 249, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Start_Button_Pressed\", mode = EventOut)\n    val Clinician_Request_Bolus = Port[art.Empty] (id = 250, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Clinician_Request_Bolus\", mode = EventOut)\n    val Pause_Infusion = Port[art.Empty] (id = 251, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Pause_Infusion\", mode = EventOut)\n    val Resume_Infusion = Port[art.Empty] (id = 252, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Resume_Infusion\", mode = EventOut)\n    val Turn_Off = Port[art.Empty] (id = 253, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Turn_Off\", mode = EventOut)\n    val Patient_Request_Not_Too_Soon = Port[art.Empty] (id = 254, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Patient_Request_Not_Too_Soon\", mode = EventIn)\n    val Patient_Request_Too_Soon = Port[art.Empty] (id = 255, name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_Patient_Request_Too_Soon\", mode = EventIn)\n\n    pca_pump__JVM.PCA_Control_Panel.ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge(\n      id = 22,\n      name = \"wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Image = Image,\n      AudioSignal = AudioSignal,\n      Alarm_Inactivation = Alarm_Inactivation,\n      Remaining_Battery_Time = Remaining_Battery_Time,\n      Using_Battery_Power = Using_Battery_Power,\n      Prescription = Prescription,\n      Infusion_Flow_Rate = Infusion_Flow_Rate,\n      Clinician_Name = Clinician_Name,\n      Patient_Name = Patient_Name,\n      Touch = Touch,\n      Alarm = Alarm,\n      Warning = Warning,\n      System_Status = System_Status,\n      Display_Message = Display_Message,\n      Sound_Type = Sound_Type,\n      Bolus_Duration = Bolus_Duration,\n      CP_Reset_Alarm = CP_Reset_Alarm,\n      Low_Battery_Warning = Low_Battery_Warning,\n      Hard_Limit_Violated = Hard_Limit_Violated,\n      Soft_Limit_Warning = Soft_Limit_Warning,\n      Confirm_Soft_Limit_Exception = Confirm_Soft_Limit_Exception,\n      Reject_Soft_Limit_Exception = Reject_Soft_Limit_Exception,\n      Stop_Button_Pressed = Stop_Button_Pressed,\n      Start_Button_Pressed = Start_Button_Pressed,\n      Clinician_Request_Bolus = Clinician_Request_Bolus,\n      Pause_Infusion = Pause_Infusion,\n      Resume_Infusion = Resume_Infusion,\n      Turn_Off = Turn_Off,\n      Patient_Request_Not_Too_Soon = Patient_Request_Not_Too_Soon,\n      Patient_Request_Too_Soon = Patient_Request_Too_Soon\n    )\n  }\n  val wrap_pca_imp_Instance_pump_fluid_mech_pump : pca_pump__JVM.PCA_Mechanical.pump_imp_pump_fluid_mech_pump_Bridge = {\n    val Drug_Intake = Port[Physical_Types.Fluid_Flow_imp] (id = 256, name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump_Drug_Intake\", mode = DataIn)\n    val Rate = Port[PCA_Types.Flow_Rate_imp] (id = 257, name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump_Rate\", mode = DataIn)\n    val Drug_Outlet = Port[Physical_Types.Fluid_Flow_imp] (id = 258, name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump_Drug_Outlet\", mode = DataOut)\n    val Halt = Port[art.Empty] (id = 259, name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump_Halt\", mode = EventIn)\n    val Pump_Too_Hot = Port[art.Empty] (id = 260, name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump_Pump_Too_Hot\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.pump_imp_pump_fluid_mech_pump_Bridge(\n      id = 23,\n      name = \"wrap_pca_imp_Instance_pump_fluid_mech_pump\",\n      dispatchProtocol = Sporadic(min = 5),\n      dispatchTriggers = None(),\n\n      Drug_Intake = Drug_Intake,\n      Rate = Rate,\n      Drug_Outlet = Drug_Outlet,\n      Halt = Halt,\n      Pump_Too_Hot = Pump_Too_Hot\n    )\n  }\n  val wrap_pca_imp_Instance_pump_fluid_upstream_mon : pca_pump__JVM.PCA_Mechanical.upstream_monitor_imp_pump_fluid_upstream_mon_Bridge = {\n    val Drug_Intake = Port[Physical_Types.Fluid_Flow_imp] (id = 261, name = \"wrap_pca_imp_Instance_pump_fluid_upstream_mon_Drug_Intake\", mode = DataIn)\n    val Drug_Outlet = Port[Physical_Types.Fluid_Flow_imp] (id = 262, name = \"wrap_pca_imp_Instance_pump_fluid_upstream_mon_Drug_Outlet\", mode = DataOut)\n    val Upstream_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 263, name = \"wrap_pca_imp_Instance_pump_fluid_upstream_mon_Upstream_Flow_Rate\", mode = DataOut)\n    val Occlusion = Port[art.Empty] (id = 264, name = \"wrap_pca_imp_Instance_pump_fluid_upstream_mon_Occlusion\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.upstream_monitor_imp_pump_fluid_upstream_mon_Bridge(\n      id = 24,\n      name = \"wrap_pca_imp_Instance_pump_fluid_upstream_mon\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      Drug_Intake = Drug_Intake,\n      Drug_Outlet = Drug_Outlet,\n      Upstream_Flow_Rate = Upstream_Flow_Rate,\n      Occlusion = Occlusion\n    )\n  }\n  val wrap_pca_imp_Instance_pump_fluid_downstream_mon : pca_pump__JVM.PCA_Mechanical.downstream_monitor_imp_pump_fluid_downstream_mon_Bridge = {\n    val Drug_Intake = Port[Physical_Types.Fluid_Flow_imp] (id = 265, name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon_Drug_Intake\", mode = DataIn)\n    val Drug_Outlet = Port[Physical_Types.Fluid_Flow_imp] (id = 266, name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon_Drug_Outlet\", mode = DataOut)\n    val Downstream_Flow_Rate = Port[PCA_Types.Flow_Rate_imp] (id = 267, name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon_Downstream_Flow_Rate\", mode = DataOut)\n    val Occlusion = Port[art.Empty] (id = 268, name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon_Occlusion\", mode = EventOut)\n    val Bubble = Port[art.Empty] (id = 269, name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon_Bubble\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.downstream_monitor_imp_pump_fluid_downstream_mon_Bridge(\n      id = 25,\n      name = \"wrap_pca_imp_Instance_pump_fluid_downstream_mon\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      Drug_Intake = Drug_Intake,\n      Drug_Outlet = Drug_Outlet,\n      Downstream_Flow_Rate = Downstream_Flow_Rate,\n      Occlusion = Occlusion,\n      Bubble = Bubble\n    )\n  }\n  val wrap_pca_imp_Instance_pump_fluid_reservoir : pca_pump__JVM.PCA_Mechanical.drug_reservoir_imp_pump_fluid_reservoir_Bridge = {\n    val Fill_Reservoir = Port[Physical_Types.Fluid_Volume_imp] (id = 270, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Fill_Reservoir\", mode = DataIn)\n    val Drug_Outlet = Port[Physical_Types.Fluid_Flow_imp] (id = 271, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Drug_Outlet\", mode = DataOut)\n    val Door_Open = Port[Base_Types.Boolean] (id = 272, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Door_Open\", mode = DataOut)\n    val Door_Closed = Port[art.Empty] (id = 273, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Door_Closed\", mode = EventOut)\n    val Low_Reservoir = Port[art.Empty] (id = 274, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Low_Reservoir\", mode = EventOut)\n    val Empty_Reservoir = Port[art.Empty] (id = 275, name = \"wrap_pca_imp_Instance_pump_fluid_reservoir_Empty_Reservoir\", mode = EventOut)\n\n    pca_pump__JVM.PCA_Mechanical.drug_reservoir_imp_pump_fluid_reservoir_Bridge(\n      id = 26,\n      name = \"wrap_pca_imp_Instance_pump_fluid_reservoir\",\n      dispatchProtocol = Periodic(period = 5),\n      dispatchTriggers = None(),\n\n      Fill_Reservoir = Fill_Reservoir,\n      Drug_Outlet = Drug_Outlet,\n      Door_Open = Door_Open,\n      Door_Closed = Door_Closed,\n      Low_Reservoir = Low_Reservoir,\n      Empty_Reservoir = Empty_Reservoir\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = ISZ (wrap_pca_imp_Instance_maint, wrap_pca_imp_Instance_pump_safety_error_detect, wrap_pca_imp_Instance_pump_safety_fault_log, wrap_pca_imp_Instance_pump_safety_led, wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr, wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate, wrap_pca_imp_Instance_pump_power_pwr, wrap_pca_imp_Instance_pump_power_btty, wrap_pca_imp_Instance_pump_power_vcc, wrap_pca_imp_Instance_pump_operation_patient_button, wrap_pca_imp_Instance_pump_operation_scanner, wrap_pca_imp_Instance_pump_operation_operation_process_drug_library, wrap_pca_imp_Instance_pump_operation_operation_process_event_logger, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher, wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker, wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread, wrap_pca_imp_Instance_pump_operation_control_panel_display, wrap_pca_imp_Instance_pump_operation_control_panel_audible, wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread, wrap_pca_imp_Instance_pump_fluid_mech_pump, wrap_pca_imp_Instance_pump_fluid_upstream_mon, wrap_pca_imp_Instance_pump_fluid_downstream_mon, wrap_pca_imp_Instance_pump_fluid_reservoir),\n\n      connections = ISZ (Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Basal_Overinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Basal_Overinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Bolus_Overinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Bolus_Overinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Square_Bolus_Overinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Square_Bolus_Overinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Basal_Underinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Basal_Underinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Bolus_Underinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Bolus_Underinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Square_Bolus_Underinfusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Square_Bolus_Underinfusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.POST_Failure, to = wrap_pca_imp_Instance_pump_safety_fault_log.POST_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.RAM_Failure, to = wrap_pca_imp_Instance_pump_safety_fault_log.RAM_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.ROM_failure, to = wrap_pca_imp_Instance_pump_safety_fault_log.ROM_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.CPU_Failure, to = wrap_pca_imp_Instance_pump_safety_fault_log.CPU_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.Thread_Monitor_Failure, to = wrap_pca_imp_Instance_pump_safety_fault_log.Thread_Monitor_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.HW_Detected_Failure, to = wrap_pca_imp_Instance_pump_safety_led.Illuminate),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Log_Fault, to = wrap_pca_imp_Instance_pump_safety_fault_log.Log_Fault),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Stop_Pump_Completely, to = wrap_pca_imp_Instance_pump_safety_error_detect.Software_Stop_Pump),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_btty.Battery_Voltage, to = wrap_pca_imp_Instance_pump_power_pwr.Battery_Voltage),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_btty.Battery_Current, to = wrap_pca_imp_Instance_pump_power_pwr.Battery_Current),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_vcc.Power_Voltage, to = wrap_pca_imp_Instance_pump_power_pwr.Power_Voltage),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Check_Rx, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Check_Rx),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Begin_Priming, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Begin_Priming),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.End_Priming, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.End_Priming),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Begin_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Begin_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Begin_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Begin_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Halt_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Halt_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Halt_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Halt_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Infusion_Flow_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Infusion_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Infusion_Flow_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Infusion_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.VTBI, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.VTBI),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.VTBI, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.VTBI),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Square_Bolus_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Square_Bolus_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Square_Bolus_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Square_Bolus_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Patient_Bolus_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Patient_Bolus_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Patient_Bolus_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Patient_Bolus_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Basal_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Basal_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Basal_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Basal_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Minimum_Time_Between_Bolus, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Minimum_Time_Between_Bolus),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Max_Drug_Per_Hour),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Rx_Okay, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Rx_Okay),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Rx_Okay, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Rx_Okay),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Hard_Limit_Violated, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Hard_Limit_Violated),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.ICE_Stop_Pump, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.ICE_Stop_Pump),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Near_Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Near_Max_Drug_Per_Hour),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Near_Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Near_Max_Drug_Per_Hour),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Over_Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Over_Max_Drug_Per_Hour),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Over_Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Over_Max_Drug_Per_Hour),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Request_Not_Too_Soon, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Patient_Request_Not_Too_Soon),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Request_Not_Too_Soon, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Patient_Request_Not_Too_Soon),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Request_Too_Soon, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Patient_Request_Too_Soon),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.The_Drug_Record, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.The_Drug_Record),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.No_Drug_Found, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Drug_Not_In_Library),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.No_Drug_Found, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Drug_Not_In_Library),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Log_Event, to = wrap_pca_imp_Instance_pump_operation_operation_process_event_logger.Log_Event),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Get_Drug_Record, to = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.Get_Drug_Record),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_display.Touch, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Touch),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Image, to = wrap_pca_imp_Instance_pump_operation_control_panel_display.Image),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.AudioSignal, to = wrap_pca_imp_Instance_pump_operation_control_panel_audible.AudioSignal),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_patient_button.Request_Bolus, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Button_Request),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_scanner.Scan_Data, to = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Scan_Data),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_scanner.Scan_Done, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Scan_Done),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Display_Message, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Display_Message),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Sound_Type, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Sound_Type),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Do_Scan, to = wrap_pca_imp_Instance_pump_operation_scanner.Do_Scan),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Authenticate_Clinician, to = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Authenticate_Clinician),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Authenticate_Patient, to = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Authenticate_Patient),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Authenticate_Prescription, to = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Authenticate_Prescription),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Infusion_Flow_Rate, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Infusion_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.System_Status, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.System_Status),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Soft_Limit_Warning, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Soft_Limit_Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Hard_Limit_Violated, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Hard_Limit_Violated),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Request_Not_Too_Soon, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Patient_Request_Not_Too_Soon),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.Patient_Request_Too_Soon, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Patient_Request_Too_Soon),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Clinician_Name, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Clinician_Name),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Patient_Name, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Patient_Name),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Prescription, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Prescription),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Prescription, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Prescription),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Authentication_fail, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Authentication_fail),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Authentication_pass, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Authentication_pass),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Alarm_Inactivation, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Alarm_Inactivation),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Bolus_Duration, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.CP_Bolus_Duration),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Bolus_Duration, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.CP_Bolus_Duration),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Confirm_Soft_Limit_Exception, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Confirm_Soft_Limit_Exception),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Confirm_Soft_Limit_Exception, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Confirm_Soft_Limit_Exception),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Reject_Soft_Limit_Exception, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Reject_Soft_Limit_Exception),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Reject_Soft_Limit_Exception, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Reject_Soft_Limit_Exception),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Stop_Button_Pressed, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Stop_Button_Pressed),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Start_Button_Pressed, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Start_Button_Pressed),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Clinician_Request_Bolus, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.CP_Clinician_Request_Bolus),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Clinician_Request_Bolus, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.CP_Clinician_Request_Bolus),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Pause_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Pause_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Resume_Infusion, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Resume_Infusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Turn_Off, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Turn_Off),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_mech_pump.Drug_Outlet, to = wrap_pca_imp_Instance_pump_fluid_downstream_mon.Drug_Intake),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_upstream_mon.Drug_Outlet, to = wrap_pca_imp_Instance_pump_fluid_mech_pump.Drug_Intake),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Drug_Outlet, to = wrap_pca_imp_Instance_pump_fluid_upstream_mon.Drug_Intake),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.Stop_Pump_Completely, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Stop_Pump_Completely),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.Stop_Pump_Completely, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Stop_Pump_Completely),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.Stop_Pump_Completely, to = wrap_pca_imp_Instance_pump_fluid_mech_pump.Halt),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.POST_Failure, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.POST_fail),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.POST_Done, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.POST_done),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.HW_Detected_Failure, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.HW_Detected_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_error_detect.HW_Detected_Failure, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.HW_Detected_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Alarm, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Alarm),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Alarm, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Alarm),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Alarm, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Alarm),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Warning, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Warning, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Warning, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Pump_At_KVO_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Pump_At_KVO_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Pump_At_KVO_Rate, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Pump_At_KVO_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Using_Battery_Power, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Using_Battery_Power),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Remaining_Battery_Time, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Remaining_Battery_Time),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Low_Battery_Warning, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Low_Battery_Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Low_Battery_Warning, to = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.Low_Battery_Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Defective_Battery, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Defective_Btty),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Voltage_OOR, to = wrap_pca_imp_Instance_pump_safety_fault_log.Voltage_OOR),\n                         Connection(from = wrap_pca_imp_Instance_pump_power_pwr.Voltage_OOR, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Voltage_OOR),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.No_Drug_Found, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Drug_Not_In_Library),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Prime_Failure, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Prime_Failure),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Infusion_Flow_Rate, to = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Infusion_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Infusion_Flow_Rate, to = wrap_pca_imp_Instance_pump_fluid_mech_pump.Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.System_Status, to = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.System_Status),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.Hard_Limit_Violated, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Hard_Limit_Violation),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.Over_Max_Drug_Per_Hour, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Max_Dose_Warning),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.Security_Fault, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Security_Fault),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.CP_Reset_Alarm, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.CP_Reset_Alarm),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_mech_pump.Pump_Too_Hot, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Pump_Hot),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_upstream_mon.Upstream_Flow_Rate, to = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Upstream_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_upstream_mon.Occlusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Upstream_Occlusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_downstream_mon.Downstream_Flow_Rate, to = wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.Downstream_Flow_Rate),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_downstream_mon.Occlusion, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Downstream_Occlusion),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_downstream_mon.Bubble, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Bubble),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Door_Open, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.Door_Open),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Door_Open, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.Door_Open),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Door_Closed, to = wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.Door_Closed),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Low_Reservoir, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Low_Res),\n                         Connection(from = wrap_pca_imp_Instance_pump_fluid_reservoir.Empty_Reservoir, to = wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.Empty_Res),\n                         Connection(from = wrap_pca_imp_Instance_maint.Load_Drug_Library, to = wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.Load_Drug_Library),\n                         Connection(from = wrap_pca_imp_Instance_maint.Get_Fault_Log, to = wrap_pca_imp_Instance_pump_safety_fault_log.Get_Log),\n                         Connection(from = wrap_pca_imp_Instance_maint.Get_Event_Log, to = wrap_pca_imp_Instance_pump_operation_operation_process_event_logger.Get_Event_Log),\n                         Connection(from = wrap_pca_imp_Instance_pump_safety_fault_log.The_Log, to = wrap_pca_imp_Instance_maint.The_Fault_Log),\n                         Connection(from = wrap_pca_imp_Instance_pump_operation_operation_process_event_logger.The_Event_Log, to = wrap_pca_imp_Instance_maint.The_Event_Log))\n    )\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/architecture\/pca_pump__JVM\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticScheduler(None())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n        art.Art.run(Arch.ad, scheduler)\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/architecture\/pca_pump__JVM\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage pca_pump__JVM\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec, Slot}\nimport art.scheduling.static.StaticScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val wrap_pca_imp_Instance_pump_safety_safety_core_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = None(),\n    framePeriod = None(),\n    maxDomain = None(),\n    slotTime = None())\n\n  val wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_drug_library_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_event_logger_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_maint_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_safety_error_detect_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_safety_fault_log_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_safety_led_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_power_pwr_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_power_btty_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_power_vcc_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_patient_button_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_scanner_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_control_panel_display_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_operation_control_panel_audible_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_fluid_mech_pump_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_fluid_upstream_mon_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_fluid_downstream_mon_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val wrap_pca_imp_Instance_pump_fluid_reservoir_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[art.Bridge] = Arch.ad.components\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ staticSchedule represents the component dispatch order\n  val staticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Slot(Arch.wrap_pca_imp_Instance_maint.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_safety_error_detect.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_safety_fault_log.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_safety_led.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_power_pwr.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_power_btty.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_power_vcc.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_patient_button.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_scanner.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_drug_library.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_event_logger.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_control_panel_display.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_control_panel_audible.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_fluid_mech_pump.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_fluid_upstream_mon.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_fluid_downstream_mon.id, maxExecutionTime),\n    Slot(Arch.wrap_pca_imp_Instance_pump_fluid_reservoir.id, maxExecutionTime)\n  )))\n\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[art.Bridge]]): RoundRobin = {\n    if(roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  def getStaticScheduler(schedule: Option[DScheduleSpec]): StaticScheduler = {\n    if(staticSchedule.schedule.slots.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return StaticScheduler(Arch.ad.components, s)\n      case _ => return StaticScheduler(Arch.ad.components, ScheduleProviderI.getStaticSchedule())\n    }\n  }\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[art.Bridge] = $\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/architecture\/pca_pump__JVM\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM\n\nimport org.sireum._\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[art.Bridge] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.staticSchedule\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/inspector\/pca_pump__JVM\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/data\/pca_pump__JVM\/sergen.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_System\/maintenance_imp_maint_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_System\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class maintenance_imp_maint_TestApi extends BridgeTestSuite[maintenance_imp_maint_Bridge](Arch.wrap_pca_imp_Instance_maint) {\n\n  \/** helper function to set the values of all input ports.\n   * @param to_maintenance_processor_The_Fault_Log payloads for event data port to_maintenance_processor_The_Fault_Log.\n   *   ART currently supports single element event data queues so\n   *   only the last element of to_maintenance_processor_The_Fault_Log will be used\n   * @param to_maintenance_processor_The_Event_Log payloads for event data port to_maintenance_processor_The_Event_Log.\n   *   ART currently supports single element event data queues so\n   *   only the last element of to_maintenance_processor_The_Event_Log will be used\n   * @param The_Fault_Log payloads for event data port The_Fault_Log.\n   *   ART currently supports single element event data queues so\n   *   only the last element of The_Fault_Log will be used\n   * @param The_Event_Log payloads for event data port The_Event_Log.\n   *   ART currently supports single element event data queues so\n   *   only the last element of The_Event_Log will be used\n   *\/\n  def put_concrete_inputs(to_maintenance_processor_The_Fault_Log : ISZ[PCA_Types.Fault_Log],\n                          to_maintenance_processor_The_Event_Log : ISZ[PCA_Types.Event_Log],\n                          The_Fault_Log : ISZ[PCA_Types.Fault_Log],\n                          The_Event_Log : ISZ[PCA_Types.Event_Log]): Unit = {\n    for(v <- to_maintenance_processor_The_Fault_Log){\n      put_to_maintenance_processor_The_Fault_Log(v)\n    }\n    for(v <- to_maintenance_processor_The_Event_Log){\n      put_to_maintenance_processor_The_Event_Log(v)\n    }\n    for(v <- The_Fault_Log){\n      put_The_Fault_Log(v)\n    }\n    for(v <- The_Event_Log){\n      put_The_Event_Log(v)\n    }\n  }\n\n\n  \/** helper function to check maintenance_imp_maint's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param to_maintenance_processor_Load_Drug_Library method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'to_maintenance_processor_Load_Drug_Library'.\n   * @param to_maintenance_processor_Get_Fault_Log method that will be called with the number of events to be sent\n   *        on the outgoing event port 'to_maintenance_processor_Get_Fault_Log'.\n   * @param to_maintenance_processor_Get_Event_Log method that will be called with the number of events to be sent\n   *        on the outgoing event port 'to_maintenance_processor_Get_Event_Log'.\n   * @param Load_Drug_Library method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Load_Drug_Library'.\n   * @param Get_Fault_Log method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Get_Fault_Log'.\n   * @param Get_Event_Log method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Get_Event_Log'.\n   *\/\n  def check_concrete_output(to_maintenance_processor_Load_Drug_Library: ISZ[PCA_Types.Drug_Library] => B = to_maintenance_processor_Load_Drug_LibraryParam => {T},\n                            to_maintenance_processor_Get_Fault_Log: Z => B = to_maintenance_processor_Get_Fault_LogParam => {T},\n                            to_maintenance_processor_Get_Event_Log: Z => B = to_maintenance_processor_Get_Event_LogParam => {T},\n                            Load_Drug_Library: ISZ[PCA_Types.Drug_Library] => B = Load_Drug_LibraryParam => {T},\n                            Get_Fault_Log: Z => B = Get_Fault_LogParam => {T},\n                            Get_Event_Log: Z => B = Get_Event_LogParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var to_maintenance_processor_Load_Drug_LibraryValue: ISZ[PCA_Types.Drug_Library] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_to_maintenance_processor_Load_Drug_Library().nonEmpty) to_maintenance_processor_Load_Drug_LibraryValue = to_maintenance_processor_Load_Drug_LibraryValue :+ get_to_maintenance_processor_Load_Drug_Library().get\n    if(!to_maintenance_processor_Load_Drug_Library(to_maintenance_processor_Load_Drug_LibraryValue)) {\n      testFailures = testFailures :+ st\"'to_maintenance_processor_Load_Drug_Library' did not match expected: received ${to_maintenance_processor_Load_Drug_LibraryValue.size} events with the following payloads ${to_maintenance_processor_Load_Drug_LibraryValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val to_maintenance_processor_Get_Fault_LogValue: Z = if(get_to_maintenance_processor_Get_Fault_Log().nonEmpty) z\"1\" else z\"0\"\n    if(!to_maintenance_processor_Get_Fault_Log(to_maintenance_processor_Get_Fault_LogValue)) {\n      testFailures = testFailures :+ st\"'to_maintenance_processor_Get_Fault_Log' did not match expected: ${to_maintenance_processor_Get_Fault_LogValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val to_maintenance_processor_Get_Event_LogValue: Z = if(get_to_maintenance_processor_Get_Event_Log().nonEmpty) z\"1\" else z\"0\"\n    if(!to_maintenance_processor_Get_Event_Log(to_maintenance_processor_Get_Event_LogValue)) {\n      testFailures = testFailures :+ st\"'to_maintenance_processor_Get_Event_Log' did not match expected: ${to_maintenance_processor_Get_Event_LogValue} events were in the outgoing event queue\"\n    }\n    var Load_Drug_LibraryValue: ISZ[PCA_Types.Drug_Library] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Load_Drug_Library().nonEmpty) Load_Drug_LibraryValue = Load_Drug_LibraryValue :+ get_Load_Drug_Library().get\n    if(!Load_Drug_Library(Load_Drug_LibraryValue)) {\n      testFailures = testFailures :+ st\"'Load_Drug_Library' did not match expected: received ${Load_Drug_LibraryValue.size} events with the following payloads ${Load_Drug_LibraryValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Get_Fault_LogValue: Z = if(get_Get_Fault_Log().nonEmpty) z\"1\" else z\"0\"\n    if(!Get_Fault_Log(Get_Fault_LogValue)) {\n      testFailures = testFailures :+ st\"'Get_Fault_Log' did not match expected: ${Get_Fault_LogValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Get_Event_LogValue: Z = if(get_Get_Event_Log().nonEmpty) z\"1\" else z\"0\"\n    if(!Get_Event_Log(Get_Event_LogValue)) {\n      testFailures = testFailures :+ st\"'Get_Event_Log' did not match expected: ${Get_Event_LogValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_to_maintenance_processor_The_Fault_Log(value : PCA_Types.Fault_Log): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.to_maintenance_processor_The_Fault_Log_Id, PCA_Types.Fault_Log_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_to_maintenance_processor_The_Event_Log(value : PCA_Types.Event_Log): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.to_maintenance_processor_The_Event_Log_Id, PCA_Types.Event_Log_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_The_Fault_Log(value : PCA_Types.Fault_Log): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.The_Fault_Log_Id, PCA_Types.Fault_Log_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_The_Event_Log(value : PCA_Types.Event_Log): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.The_Event_Log_Id, PCA_Types.Event_Log_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_to_maintenance_processor_Load_Drug_Library(): Option[PCA_Types.Drug_Library] = {\n    val value: Option[PCA_Types.Drug_Library] = get_to_maintenance_processor_Load_Drug_Library_payload() match {\n      case Some(PCA_Types.Drug_Library_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port to_maintenance_processor_Load_Drug_Library.  Expecting 'PCA_Types.Drug_Library_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Library]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_to_maintenance_processor_Load_Drug_Library_payload(): Option[PCA_Types.Drug_Library_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.to_maintenance_processor_Load_Drug_Library_Id).asInstanceOf[Option[PCA_Types.Drug_Library_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_to_maintenance_processor_Get_Fault_Log(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_to_maintenance_processor_Get_Fault_Log_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port to_maintenance_processor_Get_Fault_Log.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_to_maintenance_processor_Get_Fault_Log_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.to_maintenance_processor_Get_Fault_Log_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_to_maintenance_processor_Get_Event_Log(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_to_maintenance_processor_Get_Event_Log_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port to_maintenance_processor_Get_Event_Log.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_to_maintenance_processor_Get_Event_Log_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.to_maintenance_processor_Get_Event_Log_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Load_Drug_Library(): Option[PCA_Types.Drug_Library] = {\n    val value: Option[PCA_Types.Drug_Library] = get_Load_Drug_Library_payload() match {\n      case Some(PCA_Types.Drug_Library_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Load_Drug_Library.  Expecting 'PCA_Types.Drug_Library_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Library]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Load_Drug_Library_payload(): Option[PCA_Types.Drug_Library_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Load_Drug_Library_Id).asInstanceOf[Option[PCA_Types.Drug_Library_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Get_Fault_Log(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Get_Fault_Log_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Get_Fault_Log.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Get_Fault_Log_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Get_Fault_Log_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Get_Event_Log(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Get_Event_Log_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Get_Event_Log.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Get_Event_Log_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Get_Event_Log_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_System\/maintenance_imp_maint_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_System\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_System._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass maintenance_imp_maint_Test extends maintenance_imp_maint_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_System\/maintenance_imp_maint_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_System\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_System.{maintenance_imp_maint => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class maintenance_imp_maint_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  to_maintenance_processor_The_Fault_Log: Port[PCA_Types.Fault_Log],\n  to_maintenance_processor_The_Event_Log: Port[PCA_Types.Event_Log],\n  to_maintenance_processor_Load_Drug_Library: Port[PCA_Types.Drug_Library],\n  to_maintenance_processor_Get_Fault_Log: Port[art.Empty],\n  to_maintenance_processor_Get_Event_Log: Port[art.Empty],\n  The_Fault_Log: Port[PCA_Types.Fault_Log],\n  The_Event_Log: Port[PCA_Types.Event_Log],\n  Load_Drug_Library: Port[PCA_Types.Drug_Library],\n  Get_Fault_Log: Port[art.Empty],\n  Get_Event_Log: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(to_maintenance_processor_The_Fault_Log,\n              to_maintenance_processor_The_Event_Log,\n              to_maintenance_processor_Load_Drug_Library,\n              to_maintenance_processor_Get_Fault_Log,\n              to_maintenance_processor_Get_Event_Log,\n              The_Fault_Log,\n              The_Event_Log,\n              Load_Drug_Library,\n              Get_Fault_Log,\n              Get_Event_Log),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(to_maintenance_processor_The_Fault_Log,\n                   to_maintenance_processor_The_Event_Log,\n                   The_Fault_Log,\n                   The_Event_Log),\n\n    eventOuts = ISZ(to_maintenance_processor_Load_Drug_Library,\n                    to_maintenance_processor_Get_Fault_Log,\n                    to_maintenance_processor_Get_Event_Log,\n                    Load_Drug_Library,\n                    Get_Fault_Log,\n                    Get_Event_Log)\n  )\n\n  val initialization_api : maintenance_imp_Initialization_Api = {\n    val api = maintenance_imp_Initialization_Api(\n      id,\n      to_maintenance_processor_The_Fault_Log.id,\n      to_maintenance_processor_The_Event_Log.id,\n      to_maintenance_processor_Load_Drug_Library.id,\n      to_maintenance_processor_Get_Fault_Log.id,\n      to_maintenance_processor_Get_Event_Log.id,\n      The_Fault_Log.id,\n      The_Event_Log.id,\n      Load_Drug_Library.id,\n      Get_Fault_Log.id,\n      Get_Event_Log.id\n    )\n    maintenance_imp_maint_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : maintenance_imp_Operational_Api = {\n    val api = maintenance_imp_Operational_Api(\n      id,\n      to_maintenance_processor_The_Fault_Log.id,\n      to_maintenance_processor_The_Event_Log.id,\n      to_maintenance_processor_Load_Drug_Library.id,\n      to_maintenance_processor_Get_Fault_Log.id,\n      to_maintenance_processor_Get_Event_Log.id,\n      The_Fault_Log.id,\n      The_Event_Log.id,\n      Load_Drug_Library.id,\n      Get_Fault_Log.id,\n      Get_Event_Log.id\n    )\n    maintenance_imp_maint_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    maintenance_imp_maint_Bridge.EntryPoints(\n      id,\n\n      to_maintenance_processor_The_Fault_Log.id,\n      to_maintenance_processor_The_Event_Log.id,\n      to_maintenance_processor_Load_Drug_Library.id,\n      to_maintenance_processor_Get_Fault_Log.id,\n      to_maintenance_processor_Get_Event_Log.id,\n      The_Fault_Log.id,\n      The_Event_Log.id,\n      Load_Drug_Library.id,\n      Get_Fault_Log.id,\n      Get_Event_Log.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject maintenance_imp_maint_Bridge {\n\n  var c_initialization_api: Option[maintenance_imp_Initialization_Api] = None()\n  var c_operational_api: Option[maintenance_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    maintenance_imp_maint_BridgeId : Art.BridgeId,\n\n    to_maintenance_processor_The_Fault_Log_Id : Art.PortId,\n    to_maintenance_processor_The_Event_Log_Id : Art.PortId,\n    to_maintenance_processor_Load_Drug_Library_Id : Art.PortId,\n    to_maintenance_processor_Get_Fault_Log_Id : Art.PortId,\n    to_maintenance_processor_Get_Event_Log_Id : Art.PortId,\n    The_Fault_Log_Id : Art.PortId,\n    The_Event_Log_Id : Art.PortId,\n    Load_Drug_Library_Id : Art.PortId,\n    Get_Fault_Log_Id : Art.PortId,\n    Get_Event_Log_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: maintenance_imp_Initialization_Api,\n    operational_api: maintenance_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(to_maintenance_processor_The_Fault_Log_Id,\n                                              to_maintenance_processor_The_Event_Log_Id,\n                                              The_Fault_Log_Id,\n                                              The_Event_Log_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(to_maintenance_processor_Load_Drug_Library_Id,\n                                               to_maintenance_processor_Get_Fault_Log_Id,\n                                               to_maintenance_processor_Get_Event_Log_Id,\n                                               Load_Drug_Library_Id,\n                                               Get_Fault_Log_Id,\n                                               Get_Event_Log_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: maintenance_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: maintenance_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: maintenance_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: maintenance_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: maintenance_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: maintenance_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: maintenance_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_System\/maintenance_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_System\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait maintenance_imp_Api {\n  def id: Art.BridgeId\n  def to_maintenance_processor_The_Fault_Log_Id : Art.PortId\n  def to_maintenance_processor_The_Event_Log_Id : Art.PortId\n  def to_maintenance_processor_Load_Drug_Library_Id : Art.PortId\n  def to_maintenance_processor_Get_Fault_Log_Id : Art.PortId\n  def to_maintenance_processor_Get_Event_Log_Id : Art.PortId\n  def The_Fault_Log_Id : Art.PortId\n  def The_Event_Log_Id : Art.PortId\n  def Load_Drug_Library_Id : Art.PortId\n  def Get_Fault_Log_Id : Art.PortId\n  def Get_Event_Log_Id : Art.PortId\n\n  def put_to_maintenance_processor_Load_Drug_Library(value : PCA_Types.Drug_Library) : Unit = {\n    Art.putValue(to_maintenance_processor_Load_Drug_Library_Id, PCA_Types.Drug_Library_Payload(value))\n  }\n\n  def put_to_maintenance_processor_Get_Fault_Log() : Unit = {\n    Art.putValue(to_maintenance_processor_Get_Fault_Log_Id, art.Empty())\n  }\n\n  def put_to_maintenance_processor_Get_Event_Log() : Unit = {\n    Art.putValue(to_maintenance_processor_Get_Event_Log_Id, art.Empty())\n  }\n\n  def put_Load_Drug_Library(value : PCA_Types.Drug_Library) : Unit = {\n    Art.putValue(Load_Drug_Library_Id, PCA_Types.Drug_Library_Payload(value))\n  }\n\n  def put_Get_Fault_Log() : Unit = {\n    Art.putValue(Get_Fault_Log_Id, art.Empty())\n  }\n\n  def put_Get_Event_Log() : Unit = {\n    Art.putValue(Get_Event_Log_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class maintenance_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val to_maintenance_processor_The_Fault_Log_Id : Art.PortId,\n  val to_maintenance_processor_The_Event_Log_Id : Art.PortId,\n  val to_maintenance_processor_Load_Drug_Library_Id : Art.PortId,\n  val to_maintenance_processor_Get_Fault_Log_Id : Art.PortId,\n  val to_maintenance_processor_Get_Event_Log_Id : Art.PortId,\n  val The_Fault_Log_Id : Art.PortId,\n  val The_Event_Log_Id : Art.PortId,\n  val Load_Drug_Library_Id : Art.PortId,\n  val Get_Fault_Log_Id : Art.PortId,\n  val Get_Event_Log_Id : Art.PortId) extends maintenance_imp_Api\n\n@datatype class maintenance_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val to_maintenance_processor_The_Fault_Log_Id : Art.PortId,\n  val to_maintenance_processor_The_Event_Log_Id : Art.PortId,\n  val to_maintenance_processor_Load_Drug_Library_Id : Art.PortId,\n  val to_maintenance_processor_Get_Fault_Log_Id : Art.PortId,\n  val to_maintenance_processor_Get_Event_Log_Id : Art.PortId,\n  val The_Fault_Log_Id : Art.PortId,\n  val The_Event_Log_Id : Art.PortId,\n  val Load_Drug_Library_Id : Art.PortId,\n  val Get_Fault_Log_Id : Art.PortId,\n  val Get_Event_Log_Id : Art.PortId) extends maintenance_imp_Api {\n\n  def get_to_maintenance_processor_The_Fault_Log() : Option[PCA_Types.Fault_Log] = {\n    val value : Option[PCA_Types.Fault_Log] = Art.getValue(to_maintenance_processor_The_Fault_Log_Id) match {\n      case Some(PCA_Types.Fault_Log_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port to_maintenance_processor_The_Fault_Log.  Expecting 'PCA_Types.Fault_Log_Payload' but received ${v}\")\n        None[PCA_Types.Fault_Log]()\n      case _ => None[PCA_Types.Fault_Log]()\n    }\n    return value\n  }\n\n  def get_to_maintenance_processor_The_Event_Log() : Option[PCA_Types.Event_Log] = {\n    val value : Option[PCA_Types.Event_Log] = Art.getValue(to_maintenance_processor_The_Event_Log_Id) match {\n      case Some(PCA_Types.Event_Log_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port to_maintenance_processor_The_Event_Log.  Expecting 'PCA_Types.Event_Log_Payload' but received ${v}\")\n        None[PCA_Types.Event_Log]()\n      case _ => None[PCA_Types.Event_Log]()\n    }\n    return value\n  }\n\n  def get_The_Fault_Log() : Option[PCA_Types.Fault_Log] = {\n    val value : Option[PCA_Types.Fault_Log] = Art.getValue(The_Fault_Log_Id) match {\n      case Some(PCA_Types.Fault_Log_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port The_Fault_Log.  Expecting 'PCA_Types.Fault_Log_Payload' but received ${v}\")\n        None[PCA_Types.Fault_Log]()\n      case _ => None[PCA_Types.Fault_Log]()\n    }\n    return value\n  }\n\n  def get_The_Event_Log() : Option[PCA_Types.Event_Log] = {\n    val value : Option[PCA_Types.Event_Log] = Art.getValue(The_Event_Log_Id) match {\n      case Some(PCA_Types.Event_Log_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port The_Event_Log.  Expecting 'PCA_Types.Event_Log_Payload' but received ${v}\")\n        None[PCA_Types.Event_Log]()\n      case _ => None[PCA_Types.Event_Log]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_System\/maintenance_imp_maint.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_System\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject maintenance_imp_maint {\n\n  def initialise(api: maintenance_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_to_maintenance_processor_Load_Drug_Library(PCA_Types.Drug_Library.example())\n    api.put_to_maintenance_processor_Get_Fault_Log()\n    api.put_to_maintenance_processor_Get_Event_Log()\n    api.put_Load_Drug_Library(PCA_Types.Drug_Library.example())\n    api.put_Get_Fault_Log()\n    api.put_Get_Event_Log()\n  }\n\n  def timeTriggered(api: maintenance_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_to_maintenance_processor_The_Fault_Log: Option[PCA_Types.Fault_Log] = api.get_to_maintenance_processor_The_Fault_Log()\n    api.logInfo(s\"Received on to_maintenance_processor_The_Fault_Log: ${apiUsage_to_maintenance_processor_The_Fault_Log}\")\n    val apiUsage_to_maintenance_processor_The_Event_Log: Option[PCA_Types.Event_Log] = api.get_to_maintenance_processor_The_Event_Log()\n    api.logInfo(s\"Received on to_maintenance_processor_The_Event_Log: ${apiUsage_to_maintenance_processor_The_Event_Log}\")\n    val apiUsage_The_Fault_Log: Option[PCA_Types.Fault_Log] = api.get_The_Fault_Log()\n    api.logInfo(s\"Received on The_Fault_Log: ${apiUsage_The_Fault_Log}\")\n    val apiUsage_The_Event_Log: Option[PCA_Types.Event_Log] = api.get_The_Event_Log()\n    api.logInfo(s\"Received on The_Event_Log: ${apiUsage_The_Event_Log}\")\n  }\n\n  def activate(api: maintenance_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: maintenance_imp_Operational_Api): Unit = { }\n\n  def finalise(api: maintenance_imp_Operational_Api): Unit = { }\n\n  def recover(api: maintenance_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/BridgeTestSuite.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[pca_pump__JVM.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Safety\/error_detector_imp_pump_safety_error_detect_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class error_detector_imp_pump_safety_error_detect_TestApi extends BridgeTestSuite[error_detector_imp_pump_safety_error_detect_Bridge](Arch.wrap_pca_imp_Instance_pump_safety_error_detect) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Software_Stop_Pump the number of events to place in the Software_Stop_Pump event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Software_Stop_Pump : Z): Unit = {\n    for(i <- 0 until Software_Stop_Pump) {\n      put_Software_Stop_Pump()\n    }\n  }\n\n\n  \/** helper function to check error_detector_imp_pump_safety_error_detect's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Stop_Pump_Completely method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Stop_Pump_Completely'.\n   * @param POST_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'POST_Failure'.\n   * @param POST_Done method that will be called with the number of events to be sent\n   *        on the outgoing event port 'POST_Done'.\n   * @param RAM_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'RAM_Failure'.\n   * @param ROM_failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ROM_failure'.\n   * @param CPU_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'CPU_Failure'.\n   * @param Thread_Monitor_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Thread_Monitor_Failure'.\n   * @param HW_Detected_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'HW_Detected_Failure'.\n   *\/\n  def check_concrete_output(Stop_Pump_Completely: Z => B = Stop_Pump_CompletelyParam => {T},\n                            POST_Failure: Z => B = POST_FailureParam => {T},\n                            POST_Done: Z => B = POST_DoneParam => {T},\n                            RAM_Failure: Z => B = RAM_FailureParam => {T},\n                            ROM_failure: Z => B = ROM_failureParam => {T},\n                            CPU_Failure: Z => B = CPU_FailureParam => {T},\n                            Thread_Monitor_Failure: Z => B = Thread_Monitor_FailureParam => {T},\n                            HW_Detected_Failure: Z => B = HW_Detected_FailureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Stop_Pump_CompletelyValue: Z = if(get_Stop_Pump_Completely().nonEmpty) z\"1\" else z\"0\"\n    if(!Stop_Pump_Completely(Stop_Pump_CompletelyValue)) {\n      testFailures = testFailures :+ st\"'Stop_Pump_Completely' did not match expected: ${Stop_Pump_CompletelyValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val POST_FailureValue: Z = if(get_POST_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!POST_Failure(POST_FailureValue)) {\n      testFailures = testFailures :+ st\"'POST_Failure' did not match expected: ${POST_FailureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val POST_DoneValue: Z = if(get_POST_Done().nonEmpty) z\"1\" else z\"0\"\n    if(!POST_Done(POST_DoneValue)) {\n      testFailures = testFailures :+ st\"'POST_Done' did not match expected: ${POST_DoneValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val RAM_FailureValue: Z = if(get_RAM_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!RAM_Failure(RAM_FailureValue)) {\n      testFailures = testFailures :+ st\"'RAM_Failure' did not match expected: ${RAM_FailureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ROM_failureValue: Z = if(get_ROM_failure().nonEmpty) z\"1\" else z\"0\"\n    if(!ROM_failure(ROM_failureValue)) {\n      testFailures = testFailures :+ st\"'ROM_failure' did not match expected: ${ROM_failureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val CPU_FailureValue: Z = if(get_CPU_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!CPU_Failure(CPU_FailureValue)) {\n      testFailures = testFailures :+ st\"'CPU_Failure' did not match expected: ${CPU_FailureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Thread_Monitor_FailureValue: Z = if(get_Thread_Monitor_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!Thread_Monitor_Failure(Thread_Monitor_FailureValue)) {\n      testFailures = testFailures :+ st\"'Thread_Monitor_Failure' did not match expected: ${Thread_Monitor_FailureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val HW_Detected_FailureValue: Z = if(get_HW_Detected_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!HW_Detected_Failure(HW_Detected_FailureValue)) {\n      testFailures = testFailures :+ st\"'HW_Detected_Failure' did not match expected: ${HW_Detected_FailureValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_Software_Stop_Pump(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Software_Stop_Pump_Id, Empty())\n  }\n\n  \/\/ getter for out EventPort\n  def get_Stop_Pump_Completely(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Stop_Pump_Completely_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Stop_Pump_Completely.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Stop_Pump_Completely_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Stop_Pump_Completely_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_POST_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_POST_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port POST_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_POST_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.POST_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_POST_Done(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_POST_Done_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port POST_Done.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_POST_Done_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.POST_Done_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_RAM_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_RAM_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port RAM_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_RAM_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.RAM_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ROM_failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ROM_failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ROM_failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ROM_failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ROM_failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_CPU_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_CPU_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port CPU_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_CPU_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.CPU_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Thread_Monitor_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Thread_Monitor_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Thread_Monitor_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Thread_Monitor_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Thread_Monitor_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_HW_Detected_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_HW_Detected_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port HW_Detected_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_HW_Detected_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.HW_Detected_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Safety\/error_detector_imp_pump_safety_error_detect_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Safety._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass error_detector_imp_pump_safety_error_detect_Test extends error_detector_imp_pump_safety_error_detect_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/error_detector_imp_pump_safety_error_detect_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Safety.{error_detector_imp_pump_safety_error_detect => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class error_detector_imp_pump_safety_error_detect_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Software_Stop_Pump: Port[art.Empty],\n  Stop_Pump_Completely: Port[art.Empty],\n  POST_Failure: Port[art.Empty],\n  POST_Done: Port[art.Empty],\n  RAM_Failure: Port[art.Empty],\n  ROM_failure: Port[art.Empty],\n  CPU_Failure: Port[art.Empty],\n  Thread_Monitor_Failure: Port[art.Empty],\n  HW_Detected_Failure: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Software_Stop_Pump,\n              Stop_Pump_Completely,\n              POST_Failure,\n              POST_Done,\n              RAM_Failure,\n              ROM_failure,\n              CPU_Failure,\n              Thread_Monitor_Failure,\n              HW_Detected_Failure),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Software_Stop_Pump),\n\n    eventOuts = ISZ(Stop_Pump_Completely,\n                    POST_Failure,\n                    POST_Done,\n                    RAM_Failure,\n                    ROM_failure,\n                    CPU_Failure,\n                    Thread_Monitor_Failure,\n                    HW_Detected_Failure)\n  )\n\n  val initialization_api : error_detector_imp_Initialization_Api = {\n    val api = error_detector_imp_Initialization_Api(\n      id,\n      Software_Stop_Pump.id,\n      Stop_Pump_Completely.id,\n      POST_Failure.id,\n      POST_Done.id,\n      RAM_Failure.id,\n      ROM_failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      HW_Detected_Failure.id\n    )\n    error_detector_imp_pump_safety_error_detect_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : error_detector_imp_Operational_Api = {\n    val api = error_detector_imp_Operational_Api(\n      id,\n      Software_Stop_Pump.id,\n      Stop_Pump_Completely.id,\n      POST_Failure.id,\n      POST_Done.id,\n      RAM_Failure.id,\n      ROM_failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      HW_Detected_Failure.id\n    )\n    error_detector_imp_pump_safety_error_detect_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    error_detector_imp_pump_safety_error_detect_Bridge.EntryPoints(\n      id,\n\n      Software_Stop_Pump.id,\n      Stop_Pump_Completely.id,\n      POST_Failure.id,\n      POST_Done.id,\n      RAM_Failure.id,\n      ROM_failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      HW_Detected_Failure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject error_detector_imp_pump_safety_error_detect_Bridge {\n\n  var c_initialization_api: Option[error_detector_imp_Initialization_Api] = None()\n  var c_operational_api: Option[error_detector_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    error_detector_imp_pump_safety_error_detect_BridgeId : Art.BridgeId,\n\n    Software_Stop_Pump_Id : Art.PortId,\n    Stop_Pump_Completely_Id : Art.PortId,\n    POST_Failure_Id : Art.PortId,\n    POST_Done_Id : Art.PortId,\n    RAM_Failure_Id : Art.PortId,\n    ROM_failure_Id : Art.PortId,\n    CPU_Failure_Id : Art.PortId,\n    Thread_Monitor_Failure_Id : Art.PortId,\n    HW_Detected_Failure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: error_detector_imp_Initialization_Api,\n    operational_api: error_detector_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Software_Stop_Pump_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Stop_Pump_Completely_Id,\n                                               POST_Failure_Id,\n                                               POST_Done_Id,\n                                               RAM_Failure_Id,\n                                               ROM_failure_Id,\n                                               CPU_Failure_Id,\n                                               Thread_Monitor_Failure_Id,\n                                               HW_Detected_Failure_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(error_detector_imp_pump_safety_error_detect_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Software_Stop_Pump_Id) {\n          \/\/ implement the following in 'component':  def handle_Software_Stop_Pump(api: error_detector_imp_Operational_Api): Unit = {}\n          component.handle_Software_Stop_Pump(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(error_detector_imp_pump_safety_error_detect_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Software_Stop_Pump_Id) {\n          \/\/ implement the following in 'component':  def handle_Software_Stop_Pump(api: error_detector_imp_Operational_Api): Unit = {}\n          component.handle_Software_Stop_Pump(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: error_detector_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: error_detector_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: error_detector_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: error_detector_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: error_detector_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/error_detector_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait error_detector_imp_Api {\n  def id: Art.BridgeId\n  def Software_Stop_Pump_Id : Art.PortId\n  def Stop_Pump_Completely_Id : Art.PortId\n  def POST_Failure_Id : Art.PortId\n  def POST_Done_Id : Art.PortId\n  def RAM_Failure_Id : Art.PortId\n  def ROM_failure_Id : Art.PortId\n  def CPU_Failure_Id : Art.PortId\n  def Thread_Monitor_Failure_Id : Art.PortId\n  def HW_Detected_Failure_Id : Art.PortId\n\n  def put_Stop_Pump_Completely() : Unit = {\n    Art.putValue(Stop_Pump_Completely_Id, art.Empty())\n  }\n\n  def put_POST_Failure() : Unit = {\n    Art.putValue(POST_Failure_Id, art.Empty())\n  }\n\n  def put_POST_Done() : Unit = {\n    Art.putValue(POST_Done_Id, art.Empty())\n  }\n\n  def put_RAM_Failure() : Unit = {\n    Art.putValue(RAM_Failure_Id, art.Empty())\n  }\n\n  def put_ROM_failure() : Unit = {\n    Art.putValue(ROM_failure_Id, art.Empty())\n  }\n\n  def put_CPU_Failure() : Unit = {\n    Art.putValue(CPU_Failure_Id, art.Empty())\n  }\n\n  def put_Thread_Monitor_Failure() : Unit = {\n    Art.putValue(Thread_Monitor_Failure_Id, art.Empty())\n  }\n\n  def put_HW_Detected_Failure() : Unit = {\n    Art.putValue(HW_Detected_Failure_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class error_detector_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Software_Stop_Pump_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val POST_Failure_Id : Art.PortId,\n  val POST_Done_Id : Art.PortId,\n  val RAM_Failure_Id : Art.PortId,\n  val ROM_failure_Id : Art.PortId,\n  val CPU_Failure_Id : Art.PortId,\n  val Thread_Monitor_Failure_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId) extends error_detector_imp_Api\n\n@datatype class error_detector_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Software_Stop_Pump_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val POST_Failure_Id : Art.PortId,\n  val POST_Done_Id : Art.PortId,\n  val RAM_Failure_Id : Art.PortId,\n  val ROM_failure_Id : Art.PortId,\n  val CPU_Failure_Id : Art.PortId,\n  val Thread_Monitor_Failure_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId) extends error_detector_imp_Api {\n\n  def get_Software_Stop_Pump() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Software_Stop_Pump_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Software_Stop_Pump.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Safety\/error_detector_imp_pump_safety_error_detect.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject error_detector_imp_pump_safety_error_detect {\n\n  def initialise(api: error_detector_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Stop_Pump_Completely()\n    api.put_POST_Failure()\n    api.put_POST_Done()\n    api.put_RAM_Failure()\n    api.put_ROM_failure()\n    api.put_CPU_Failure()\n    api.put_Thread_Monitor_Failure()\n    api.put_HW_Detected_Failure()\n  }\n\n  def handle_Software_Stop_Pump(api: error_detector_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Software_Stop_Pump implementation\")\n    api.logInfo(\"received Software_Stop_Pump event\")\n    \/\/ example api usage\n\n    val apiUsage_Software_Stop_Pump: Option[art.Empty] = api.get_Software_Stop_Pump()\n    api.logInfo(s\"Received on Software_Stop_Pump: ${apiUsage_Software_Stop_Pump}\")\n  }\n\n  def activate(api: error_detector_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: error_detector_imp_Operational_Api): Unit = { }\n\n  def finalise(api: error_detector_imp_Operational_Api): Unit = { }\n\n  def recover(api: error_detector_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Safety\/fault_logger_imp_pump_safety_fault_log_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class fault_logger_imp_pump_safety_fault_log_TestApi extends BridgeTestSuite[fault_logger_imp_pump_safety_fault_log_Bridge](Arch.wrap_pca_imp_Instance_pump_safety_fault_log) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Log_Fault payloads for event data port Log_Fault.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Log_Fault will be used\n   * @param Get_Log the number of events to place in the Get_Log event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param POST_Failure the number of events to place in the POST_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param RAM_Failure the number of events to place in the RAM_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param ROM_Failure the number of events to place in the ROM_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param CPU_Failure the number of events to place in the CPU_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Thread_Monitor_Failure the number of events to place in the Thread_Monitor_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Voltage_OOR the number of events to place in the Voltage_OOR event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Log_Fault : ISZ[PCA_Types.Fault_Record_imp],\n                          Get_Log : Z,\n                          POST_Failure : Z,\n                          RAM_Failure : Z,\n                          ROM_Failure : Z,\n                          CPU_Failure : Z,\n                          Thread_Monitor_Failure : Z,\n                          Voltage_OOR : Z): Unit = {\n    for(v <- Log_Fault){\n      put_Log_Fault(v)\n    }\n    for(i <- 0 until Get_Log) {\n      put_Get_Log()\n    }\n    for(i <- 0 until POST_Failure) {\n      put_POST_Failure()\n    }\n    for(i <- 0 until RAM_Failure) {\n      put_RAM_Failure()\n    }\n    for(i <- 0 until ROM_Failure) {\n      put_ROM_Failure()\n    }\n    for(i <- 0 until CPU_Failure) {\n      put_CPU_Failure()\n    }\n    for(i <- 0 until Thread_Monitor_Failure) {\n      put_Thread_Monitor_Failure()\n    }\n    for(i <- 0 until Voltage_OOR) {\n      put_Voltage_OOR()\n    }\n  }\n\n\n  \/** helper function to check fault_logger_imp_pump_safety_fault_log's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param The_Log method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'The_Log'.\n   *\/\n  def check_concrete_output(The_Log: ISZ[PCA_Types.Fault_Log] => B = The_LogParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var The_LogValue: ISZ[PCA_Types.Fault_Log] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_The_Log().nonEmpty) The_LogValue = The_LogValue :+ get_The_Log().get\n    if(!The_Log(The_LogValue)) {\n      testFailures = testFailures :+ st\"'The_Log' did not match expected: received ${The_LogValue.size} events with the following payloads ${The_LogValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Log_Fault(value : PCA_Types.Fault_Record_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Log_Fault_Id, PCA_Types.Fault_Record_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Get_Log(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Get_Log_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_POST_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.POST_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_RAM_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.RAM_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_ROM_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ROM_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_CPU_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CPU_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Thread_Monitor_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Thread_Monitor_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Voltage_OOR(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Voltage_OOR_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_The_Log(): Option[PCA_Types.Fault_Log] = {\n    val value: Option[PCA_Types.Fault_Log] = get_The_Log_payload() match {\n      case Some(PCA_Types.Fault_Log_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port The_Log.  Expecting 'PCA_Types.Fault_Log_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Fault_Log]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_The_Log_payload(): Option[PCA_Types.Fault_Log_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.The_Log_Id).asInstanceOf[Option[PCA_Types.Fault_Log_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Safety\/fault_logger_imp_pump_safety_fault_log_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Safety._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass fault_logger_imp_pump_safety_fault_log_Test extends fault_logger_imp_pump_safety_fault_log_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/fault_logger_imp_pump_safety_fault_log_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Safety.{fault_logger_imp_pump_safety_fault_log => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class fault_logger_imp_pump_safety_fault_log_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Log_Fault: Port[PCA_Types.Fault_Record_imp],\n  The_Log: Port[PCA_Types.Fault_Log],\n  Get_Log: Port[art.Empty],\n  POST_Failure: Port[art.Empty],\n  RAM_Failure: Port[art.Empty],\n  ROM_Failure: Port[art.Empty],\n  CPU_Failure: Port[art.Empty],\n  Thread_Monitor_Failure: Port[art.Empty],\n  Voltage_OOR: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Log_Fault,\n              The_Log,\n              Get_Log,\n              POST_Failure,\n              RAM_Failure,\n              ROM_Failure,\n              CPU_Failure,\n              Thread_Monitor_Failure,\n              Voltage_OOR),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Log_Fault,\n                   Get_Log,\n                   POST_Failure,\n                   RAM_Failure,\n                   ROM_Failure,\n                   CPU_Failure,\n                   Thread_Monitor_Failure,\n                   Voltage_OOR),\n\n    eventOuts = ISZ(The_Log)\n  )\n\n  val initialization_api : fault_logger_imp_Initialization_Api = {\n    val api = fault_logger_imp_Initialization_Api(\n      id,\n      Log_Fault.id,\n      The_Log.id,\n      Get_Log.id,\n      POST_Failure.id,\n      RAM_Failure.id,\n      ROM_Failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      Voltage_OOR.id\n    )\n    fault_logger_imp_pump_safety_fault_log_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : fault_logger_imp_Operational_Api = {\n    val api = fault_logger_imp_Operational_Api(\n      id,\n      Log_Fault.id,\n      The_Log.id,\n      Get_Log.id,\n      POST_Failure.id,\n      RAM_Failure.id,\n      ROM_Failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      Voltage_OOR.id\n    )\n    fault_logger_imp_pump_safety_fault_log_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    fault_logger_imp_pump_safety_fault_log_Bridge.EntryPoints(\n      id,\n\n      Log_Fault.id,\n      The_Log.id,\n      Get_Log.id,\n      POST_Failure.id,\n      RAM_Failure.id,\n      ROM_Failure.id,\n      CPU_Failure.id,\n      Thread_Monitor_Failure.id,\n      Voltage_OOR.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject fault_logger_imp_pump_safety_fault_log_Bridge {\n\n  var c_initialization_api: Option[fault_logger_imp_Initialization_Api] = None()\n  var c_operational_api: Option[fault_logger_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    fault_logger_imp_pump_safety_fault_log_BridgeId : Art.BridgeId,\n\n    Log_Fault_Id : Art.PortId,\n    The_Log_Id : Art.PortId,\n    Get_Log_Id : Art.PortId,\n    POST_Failure_Id : Art.PortId,\n    RAM_Failure_Id : Art.PortId,\n    ROM_Failure_Id : Art.PortId,\n    CPU_Failure_Id : Art.PortId,\n    Thread_Monitor_Failure_Id : Art.PortId,\n    Voltage_OOR_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: fault_logger_imp_Initialization_Api,\n    operational_api: fault_logger_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Log_Fault_Id,\n                                              Get_Log_Id,\n                                              POST_Failure_Id,\n                                              RAM_Failure_Id,\n                                              ROM_Failure_Id,\n                                              CPU_Failure_Id,\n                                              Thread_Monitor_Failure_Id,\n                                              Voltage_OOR_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(The_Log_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(fault_logger_imp_pump_safety_fault_log_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Log_Fault_Id){\n          val Some(PCA_Types.Fault_Record_imp_Payload(value)) = Art.getValue(Log_Fault_Id)\n\n          \/\/ implement the following in 'component':  def handle_Log_Fault(api: fault_logger_imp_Operational_Api, value: PCA_Types.Fault_Record_imp): Unit = {}\n          component.handle_Log_Fault(operational_api, value)\n        }\n        else if(portId == Get_Log_Id) {\n          \/\/ implement the following in 'component':  def handle_Get_Log(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Get_Log(operational_api)\n        }\n        else if(portId == POST_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_POST_Failure(operational_api)\n        }\n        else if(portId == RAM_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_RAM_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_RAM_Failure(operational_api)\n        }\n        else if(portId == ROM_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_ROM_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_ROM_Failure(operational_api)\n        }\n        else if(portId == CPU_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_CPU_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_CPU_Failure(operational_api)\n        }\n        else if(portId == Thread_Monitor_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_Thread_Monitor_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Thread_Monitor_Failure(operational_api)\n        }\n        else if(portId == Voltage_OOR_Id) {\n          \/\/ implement the following in 'component':  def handle_Voltage_OOR(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Voltage_OOR(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(fault_logger_imp_pump_safety_fault_log_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Log_Fault_Id){\n          val Some(PCA_Types.Fault_Record_imp_Payload(value)) = Art.getValue(Log_Fault_Id)\n\n          \/\/ implement the following in 'component':  def handle_Log_Fault(api: fault_logger_imp_Operational_Api, value: PCA_Types.Fault_Record_imp): Unit = {}\n          component.handle_Log_Fault(operational_api, value)\n        }\n        else if(portId == Get_Log_Id) {\n          \/\/ implement the following in 'component':  def handle_Get_Log(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Get_Log(operational_api)\n        }\n        else if(portId == POST_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_POST_Failure(operational_api)\n        }\n        else if(portId == RAM_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_RAM_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_RAM_Failure(operational_api)\n        }\n        else if(portId == ROM_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_ROM_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_ROM_Failure(operational_api)\n        }\n        else if(portId == CPU_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_CPU_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_CPU_Failure(operational_api)\n        }\n        else if(portId == Thread_Monitor_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_Thread_Monitor_Failure(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Thread_Monitor_Failure(operational_api)\n        }\n        else if(portId == Voltage_OOR_Id) {\n          \/\/ implement the following in 'component':  def handle_Voltage_OOR(api: fault_logger_imp_Operational_Api): Unit = {}\n          component.handle_Voltage_OOR(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: fault_logger_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: fault_logger_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: fault_logger_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: fault_logger_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: fault_logger_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/fault_logger_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait fault_logger_imp_Api {\n  def id: Art.BridgeId\n  def Log_Fault_Id : Art.PortId\n  def The_Log_Id : Art.PortId\n  def Get_Log_Id : Art.PortId\n  def POST_Failure_Id : Art.PortId\n  def RAM_Failure_Id : Art.PortId\n  def ROM_Failure_Id : Art.PortId\n  def CPU_Failure_Id : Art.PortId\n  def Thread_Monitor_Failure_Id : Art.PortId\n  def Voltage_OOR_Id : Art.PortId\n\n  def put_The_Log(value : PCA_Types.Fault_Log) : Unit = {\n    Art.putValue(The_Log_Id, PCA_Types.Fault_Log_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class fault_logger_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Log_Fault_Id : Art.PortId,\n  val The_Log_Id : Art.PortId,\n  val Get_Log_Id : Art.PortId,\n  val POST_Failure_Id : Art.PortId,\n  val RAM_Failure_Id : Art.PortId,\n  val ROM_Failure_Id : Art.PortId,\n  val CPU_Failure_Id : Art.PortId,\n  val Thread_Monitor_Failure_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId) extends fault_logger_imp_Api\n\n@datatype class fault_logger_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Log_Fault_Id : Art.PortId,\n  val The_Log_Id : Art.PortId,\n  val Get_Log_Id : Art.PortId,\n  val POST_Failure_Id : Art.PortId,\n  val RAM_Failure_Id : Art.PortId,\n  val ROM_Failure_Id : Art.PortId,\n  val CPU_Failure_Id : Art.PortId,\n  val Thread_Monitor_Failure_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId) extends fault_logger_imp_Api {\n\n  def get_Log_Fault() : Option[PCA_Types.Fault_Record_imp] = {\n    val value : Option[PCA_Types.Fault_Record_imp] = Art.getValue(Log_Fault_Id) match {\n      case Some(PCA_Types.Fault_Record_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Log_Fault.  Expecting 'PCA_Types.Fault_Record_imp_Payload' but received ${v}\")\n        None[PCA_Types.Fault_Record_imp]()\n      case _ => None[PCA_Types.Fault_Record_imp]()\n    }\n    return value\n  }\n\n  def get_Get_Log() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Get_Log_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Get_Log.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_POST_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(POST_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port POST_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_RAM_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(RAM_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port RAM_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_ROM_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(ROM_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ROM_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_CPU_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(CPU_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CPU_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Thread_Monitor_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Thread_Monitor_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Thread_Monitor_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Voltage_OOR() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Voltage_OOR_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Voltage_OOR.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Safety\/fault_logger_imp_pump_safety_fault_log.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject fault_logger_imp_pump_safety_fault_log {\n\n  def initialise(api: fault_logger_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_The_Log(PCA_Types.Fault_Log.example())\n  }\n\n  def handle_Log_Fault(api: fault_logger_imp_Operational_Api, value : PCA_Types.Fault_Record_imp): Unit = {\n    api.logInfo(\"example handle_Log_Fault implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Log_Fault: Option[PCA_Types.Fault_Record_imp] = api.get_Log_Fault()\n    api.logInfo(s\"Received on Log_Fault: ${apiUsage_Log_Fault}\")\n    val apiUsage_Get_Log: Option[art.Empty] = api.get_Get_Log()\n    api.logInfo(s\"Received on Get_Log: ${apiUsage_Get_Log}\")\n    val apiUsage_POST_Failure: Option[art.Empty] = api.get_POST_Failure()\n    api.logInfo(s\"Received on POST_Failure: ${apiUsage_POST_Failure}\")\n    val apiUsage_RAM_Failure: Option[art.Empty] = api.get_RAM_Failure()\n    api.logInfo(s\"Received on RAM_Failure: ${apiUsage_RAM_Failure}\")\n    val apiUsage_ROM_Failure: Option[art.Empty] = api.get_ROM_Failure()\n    api.logInfo(s\"Received on ROM_Failure: ${apiUsage_ROM_Failure}\")\n    val apiUsage_CPU_Failure: Option[art.Empty] = api.get_CPU_Failure()\n    api.logInfo(s\"Received on CPU_Failure: ${apiUsage_CPU_Failure}\")\n    val apiUsage_Thread_Monitor_Failure: Option[art.Empty] = api.get_Thread_Monitor_Failure()\n    api.logInfo(s\"Received on Thread_Monitor_Failure: ${apiUsage_Thread_Monitor_Failure}\")\n    val apiUsage_Voltage_OOR: Option[art.Empty] = api.get_Voltage_OOR()\n    api.logInfo(s\"Received on Voltage_OOR: ${apiUsage_Voltage_OOR}\")\n  }\n\n  def handle_Get_Log(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Get_Log implementation\")\n    api.logInfo(\"received Get_Log event\")\n  }\n\n  def handle_POST_Failure(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_POST_Failure implementation\")\n    api.logInfo(\"received POST_Failure event\")\n  }\n\n  def handle_RAM_Failure(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_RAM_Failure implementation\")\n    api.logInfo(\"received RAM_Failure event\")\n  }\n\n  def handle_ROM_Failure(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_ROM_Failure implementation\")\n    api.logInfo(\"received ROM_Failure event\")\n  }\n\n  def handle_CPU_Failure(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_CPU_Failure implementation\")\n    api.logInfo(\"received CPU_Failure event\")\n  }\n\n  def handle_Thread_Monitor_Failure(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Thread_Monitor_Failure implementation\")\n    api.logInfo(\"received Thread_Monitor_Failure event\")\n  }\n\n  def handle_Voltage_OOR(api: fault_logger_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Voltage_OOR implementation\")\n    api.logInfo(\"received Voltage_OOR event\")\n  }\n\n  def activate(api: fault_logger_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: fault_logger_imp_Operational_Api): Unit = { }\n\n  def finalise(api: fault_logger_imp_Operational_Api): Unit = { }\n\n  def recover(api: fault_logger_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Safety\/failure_led_imp_pump_safety_led_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class failure_led_imp_pump_safety_led_TestApi extends BridgeTestSuite[failure_led_imp_pump_safety_led_Bridge](Arch.wrap_pca_imp_Instance_pump_safety_led) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Illuminate the number of events to place in the Illuminate event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Illuminate : Z): Unit = {\n    for(i <- 0 until Illuminate) {\n      put_Illuminate()\n    }\n  }\n\n\n  \/** helper function to check failure_led_imp_pump_safety_led's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Light method that will be called with the value of the outgoing data\n   *        port 'Light'.\n   *\/\n  def check_concrete_output(Light: Base_Types.Boolean => B = LightParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val LightValue: Base_Types.Boolean = get_Light().get\n    if(!Light(LightValue)) {\n      testFailures = testFailures :+ st\"'Light' did not match expected: value of the outgoing data port is ${LightValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_Illuminate(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Illuminate_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_Light(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_Light_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Light.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Light_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Light_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Safety\/failure_led_imp_pump_safety_led_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Safety._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass failure_led_imp_pump_safety_led_Test extends failure_led_imp_pump_safety_led_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/failure_led_imp_pump_safety_led_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Safety.{failure_led_imp_pump_safety_led => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class failure_led_imp_pump_safety_led_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Light: Port[Base_Types.Boolean],\n  Illuminate: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Light,\n              Illuminate),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(Light),\n\n    eventIns = ISZ(Illuminate),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : failure_led_imp_Initialization_Api = {\n    val api = failure_led_imp_Initialization_Api(\n      id,\n      Light.id,\n      Illuminate.id\n    )\n    failure_led_imp_pump_safety_led_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : failure_led_imp_Operational_Api = {\n    val api = failure_led_imp_Operational_Api(\n      id,\n      Light.id,\n      Illuminate.id\n    )\n    failure_led_imp_pump_safety_led_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    failure_led_imp_pump_safety_led_Bridge.EntryPoints(\n      id,\n\n      Light.id,\n      Illuminate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject failure_led_imp_pump_safety_led_Bridge {\n\n  var c_initialization_api: Option[failure_led_imp_Initialization_Api] = None()\n  var c_operational_api: Option[failure_led_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    failure_led_imp_pump_safety_led_BridgeId : Art.BridgeId,\n\n    Light_Id : Art.PortId,\n    Illuminate_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: failure_led_imp_Initialization_Api,\n    operational_api: failure_led_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Illuminate_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Light_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(failure_led_imp_pump_safety_led_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Illuminate_Id) {\n          \/\/ implement the following in 'component':  def handle_Illuminate(api: failure_led_imp_Operational_Api): Unit = {}\n          component.handle_Illuminate(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(failure_led_imp_pump_safety_led_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Illuminate_Id) {\n          \/\/ implement the following in 'component':  def handle_Illuminate(api: failure_led_imp_Operational_Api): Unit = {}\n          component.handle_Illuminate(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: failure_led_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: failure_led_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: failure_led_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: failure_led_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: failure_led_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Safety\/failure_led_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait failure_led_imp_Api {\n  def id: Art.BridgeId\n  def Light_Id : Art.PortId\n  def Illuminate_Id : Art.PortId\n\n  def put_Light(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(Light_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class failure_led_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Light_Id : Art.PortId,\n  val Illuminate_Id : Art.PortId) extends failure_led_imp_Api\n\n@datatype class failure_led_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Light_Id : Art.PortId,\n  val Illuminate_Id : Art.PortId) extends failure_led_imp_Api {\n\n  def get_Illuminate() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Illuminate_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Illuminate.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Safety\/failure_led_imp_pump_safety_led.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Safety\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject failure_led_imp_pump_safety_led {\n\n  def initialise(api: failure_led_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Light(Base_Types.Boolean_example())\n  }\n\n  def handle_Illuminate(api: failure_led_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Illuminate implementation\")\n    api.logInfo(\"received Illuminate event\")\n    \/\/ example api usage\n\n    val apiUsage_Illuminate: Option[art.Empty] = api.get_Illuminate()\n    api.logInfo(s\"Received on Illuminate: ${apiUsage_Illuminate}\")\n  }\n\n  def activate(api: failure_led_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: failure_led_imp_Operational_Api): Unit = { }\n\n  def finalise(api: failure_led_imp_Operational_Api): Unit = { }\n\n  def recover(api: failure_led_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Alarm\/alarm_thread_imp_pump_safety_alarm_process_alarm_thr_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class alarm_thread_imp_pump_safety_alarm_process_alarm_thr_TestApi extends BridgeTestSuite[alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge](Arch.wrap_pca_imp_Instance_pump_safety_alarm_process_alarm_thr) {\n\n  \/** helper function to set the values of all input ports.\n   * @param ICE_Alarm_Signal payloads for event data port ICE_Alarm_Signal.\n   *   ART currently supports single element event data queues so\n   *   only the last element of ICE_Alarm_Signal will be used\n   * @param ICE_Reset_Alarm the number of events to place in the ICE_Reset_Alarm event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Max_Dose_Warning the number of events to place in the Max_Dose_Warning event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Hard_Limit_Violation the number of events to place in the Hard_Limit_Violation event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Empty_Res the number of events to place in the Empty_Res event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Low_Res the number of events to place in the Low_Res event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Pump_Hot the number of events to place in the Pump_Hot event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Upstream_Occlusion the number of events to place in the Upstream_Occlusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Downstream_Occlusion the number of events to place in the Downstream_Occlusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Bubble the number of events to place in the Bubble event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Prime_Failure the number of events to place in the Prime_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param CP_Reset_Alarm the number of events to place in the CP_Reset_Alarm event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Drug_Not_In_Library the number of events to place in the Drug_Not_In_Library event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Defective_Btty the number of events to place in the Defective_Btty event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Low_Battery_Warning the number of events to place in the Low_Battery_Warning event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Voltage_OOR the number of events to place in the Voltage_OOR event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Basal_Overinfusion the number of events to place in the Basal_Overinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Bolus_Overinfusion the number of events to place in the Bolus_Overinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Square_Bolus_Overinfusion the number of events to place in the Square_Bolus_Overinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Basal_Underinfusion the number of events to place in the Basal_Underinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Bolus_Underinfusion the number of events to place in the Bolus_Underinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Square_Bolus_Underinfusion the number of events to place in the Square_Bolus_Underinfusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Security_Fault the number of events to place in the Security_Fault event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(ICE_Alarm_Signal : ISZ[ICE_Types.Alarm_Signal.Type],\n                          ICE_Reset_Alarm : Z,\n                          Max_Dose_Warning : Z,\n                          Hard_Limit_Violation : Z,\n                          Empty_Res : Z,\n                          Low_Res : Z,\n                          Pump_Hot : Z,\n                          Upstream_Occlusion : Z,\n                          Downstream_Occlusion : Z,\n                          Bubble : Z,\n                          Prime_Failure : Z,\n                          CP_Reset_Alarm : Z,\n                          Drug_Not_In_Library : Z,\n                          Defective_Btty : Z,\n                          Low_Battery_Warning : Z,\n                          Voltage_OOR : Z,\n                          Basal_Overinfusion : Z,\n                          Bolus_Overinfusion : Z,\n                          Square_Bolus_Overinfusion : Z,\n                          Basal_Underinfusion : Z,\n                          Bolus_Underinfusion : Z,\n                          Square_Bolus_Underinfusion : Z,\n                          Security_Fault : Z): Unit = {\n    for(v <- ICE_Alarm_Signal){\n      put_ICE_Alarm_Signal(v)\n    }\n    for(i <- 0 until ICE_Reset_Alarm) {\n      put_ICE_Reset_Alarm()\n    }\n    for(i <- 0 until Max_Dose_Warning) {\n      put_Max_Dose_Warning()\n    }\n    for(i <- 0 until Hard_Limit_Violation) {\n      put_Hard_Limit_Violation()\n    }\n    for(i <- 0 until Empty_Res) {\n      put_Empty_Res()\n    }\n    for(i <- 0 until Low_Res) {\n      put_Low_Res()\n    }\n    for(i <- 0 until Pump_Hot) {\n      put_Pump_Hot()\n    }\n    for(i <- 0 until Upstream_Occlusion) {\n      put_Upstream_Occlusion()\n    }\n    for(i <- 0 until Downstream_Occlusion) {\n      put_Downstream_Occlusion()\n    }\n    for(i <- 0 until Bubble) {\n      put_Bubble()\n    }\n    for(i <- 0 until Prime_Failure) {\n      put_Prime_Failure()\n    }\n    for(i <- 0 until CP_Reset_Alarm) {\n      put_CP_Reset_Alarm()\n    }\n    for(i <- 0 until Drug_Not_In_Library) {\n      put_Drug_Not_In_Library()\n    }\n    for(i <- 0 until Defective_Btty) {\n      put_Defective_Btty()\n    }\n    for(i <- 0 until Low_Battery_Warning) {\n      put_Low_Battery_Warning()\n    }\n    for(i <- 0 until Voltage_OOR) {\n      put_Voltage_OOR()\n    }\n    for(i <- 0 until Basal_Overinfusion) {\n      put_Basal_Overinfusion()\n    }\n    for(i <- 0 until Bolus_Overinfusion) {\n      put_Bolus_Overinfusion()\n    }\n    for(i <- 0 until Square_Bolus_Overinfusion) {\n      put_Square_Bolus_Overinfusion()\n    }\n    for(i <- 0 until Basal_Underinfusion) {\n      put_Basal_Underinfusion()\n    }\n    for(i <- 0 until Bolus_Underinfusion) {\n      put_Bolus_Underinfusion()\n    }\n    for(i <- 0 until Square_Bolus_Underinfusion) {\n      put_Square_Bolus_Underinfusion()\n    }\n    for(i <- 0 until Security_Fault) {\n      put_Security_Fault()\n    }\n  }\n\n\n  \/** helper function to check alarm_thread_imp_pump_safety_alarm_process_alarm_thr's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Alarm method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Alarm'.\n   * @param Warning method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Warning'.\n   * @param Log_Fault method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Log_Fault'.\n   * @param ICE_Immediate method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ICE_Immediate'.\n   * @param ICE_Prompt method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ICE_Prompt'.\n   * @param ICE_Delayed method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ICE_Delayed'.\n   * @param ICE_Malfunction method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ICE_Malfunction'.\n   * @param Stop_Pump_Completely method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Stop_Pump_Completely'.\n   * @param Pump_At_KVO_Rate method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Pump_At_KVO_Rate'.\n   *\/\n  def check_concrete_output(Alarm: ISZ[PCA_Types.Alarm_Type.Type] => B = AlarmParam => {T},\n                            Warning: ISZ[PCA_Types.Warning_Type.Type] => B = WarningParam => {T},\n                            Log_Fault: ISZ[PCA_Types.Fault_Record_imp] => B = Log_FaultParam => {T},\n                            ICE_Immediate: Z => B = ICE_ImmediateParam => {T},\n                            ICE_Prompt: Z => B = ICE_PromptParam => {T},\n                            ICE_Delayed: Z => B = ICE_DelayedParam => {T},\n                            ICE_Malfunction: Z => B = ICE_MalfunctionParam => {T},\n                            Stop_Pump_Completely: Z => B = Stop_Pump_CompletelyParam => {T},\n                            Pump_At_KVO_Rate: Z => B = Pump_At_KVO_RateParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AlarmValue: ISZ[PCA_Types.Alarm_Type.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Alarm().nonEmpty) AlarmValue = AlarmValue :+ get_Alarm().get\n    if(!Alarm(AlarmValue)) {\n      testFailures = testFailures :+ st\"'Alarm' did not match expected: received ${AlarmValue.size} events with the following payloads ${AlarmValue}\"\n    }\n    var WarningValue: ISZ[PCA_Types.Warning_Type.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Warning().nonEmpty) WarningValue = WarningValue :+ get_Warning().get\n    if(!Warning(WarningValue)) {\n      testFailures = testFailures :+ st\"'Warning' did not match expected: received ${WarningValue.size} events with the following payloads ${WarningValue}\"\n    }\n    var Log_FaultValue: ISZ[PCA_Types.Fault_Record_imp] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Log_Fault().nonEmpty) Log_FaultValue = Log_FaultValue :+ get_Log_Fault().get\n    if(!Log_Fault(Log_FaultValue)) {\n      testFailures = testFailures :+ st\"'Log_Fault' did not match expected: received ${Log_FaultValue.size} events with the following payloads ${Log_FaultValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ICE_ImmediateValue: Z = if(get_ICE_Immediate().nonEmpty) z\"1\" else z\"0\"\n    if(!ICE_Immediate(ICE_ImmediateValue)) {\n      testFailures = testFailures :+ st\"'ICE_Immediate' did not match expected: ${ICE_ImmediateValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ICE_PromptValue: Z = if(get_ICE_Prompt().nonEmpty) z\"1\" else z\"0\"\n    if(!ICE_Prompt(ICE_PromptValue)) {\n      testFailures = testFailures :+ st\"'ICE_Prompt' did not match expected: ${ICE_PromptValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ICE_DelayedValue: Z = if(get_ICE_Delayed().nonEmpty) z\"1\" else z\"0\"\n    if(!ICE_Delayed(ICE_DelayedValue)) {\n      testFailures = testFailures :+ st\"'ICE_Delayed' did not match expected: ${ICE_DelayedValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ICE_MalfunctionValue: Z = if(get_ICE_Malfunction().nonEmpty) z\"1\" else z\"0\"\n    if(!ICE_Malfunction(ICE_MalfunctionValue)) {\n      testFailures = testFailures :+ st\"'ICE_Malfunction' did not match expected: ${ICE_MalfunctionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Stop_Pump_CompletelyValue: Z = if(get_Stop_Pump_Completely().nonEmpty) z\"1\" else z\"0\"\n    if(!Stop_Pump_Completely(Stop_Pump_CompletelyValue)) {\n      testFailures = testFailures :+ st\"'Stop_Pump_Completely' did not match expected: ${Stop_Pump_CompletelyValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Pump_At_KVO_RateValue: Z = if(get_Pump_At_KVO_Rate().nonEmpty) z\"1\" else z\"0\"\n    if(!Pump_At_KVO_Rate(Pump_At_KVO_RateValue)) {\n      testFailures = testFailures :+ st\"'Pump_At_KVO_Rate' did not match expected: ${Pump_At_KVO_RateValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_ICE_Alarm_Signal(value : ICE_Types.Alarm_Signal.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ICE_Alarm_Signal_Id, ICE_Types.Alarm_Signal_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_ICE_Reset_Alarm(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ICE_Reset_Alarm_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Max_Dose_Warning(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Max_Dose_Warning_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Hard_Limit_Violation(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Hard_Limit_Violation_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Empty_Res(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Empty_Res_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Low_Res(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Low_Res_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Pump_Hot(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Pump_Hot_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Upstream_Occlusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Upstream_Occlusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Downstream_Occlusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Downstream_Occlusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Bubble(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Bubble_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Prime_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Prime_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_CP_Reset_Alarm(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CP_Reset_Alarm_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Drug_Not_In_Library(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Not_In_Library_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Defective_Btty(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Defective_Btty_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Low_Battery_Warning(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Low_Battery_Warning_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Voltage_OOR(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Voltage_OOR_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Basal_Overinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Basal_Overinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Bolus_Overinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Bolus_Overinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Square_Bolus_Overinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Square_Bolus_Overinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Basal_Underinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Basal_Underinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Bolus_Underinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Bolus_Underinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Square_Bolus_Underinfusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Square_Bolus_Underinfusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Security_Fault(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Security_Fault_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Alarm(): Option[PCA_Types.Alarm_Type.Type] = {\n    val value: Option[PCA_Types.Alarm_Type.Type] = get_Alarm_payload() match {\n      case Some(PCA_Types.Alarm_Type_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Alarm.  Expecting 'PCA_Types.Alarm_Type_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Alarm_Type.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Alarm_payload(): Option[PCA_Types.Alarm_Type_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Alarm_Id).asInstanceOf[Option[PCA_Types.Alarm_Type_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Warning(): Option[PCA_Types.Warning_Type.Type] = {\n    val value: Option[PCA_Types.Warning_Type.Type] = get_Warning_payload() match {\n      case Some(PCA_Types.Warning_Type_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Warning.  Expecting 'PCA_Types.Warning_Type_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Warning_Type.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Warning_payload(): Option[PCA_Types.Warning_Type_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Warning_Id).asInstanceOf[Option[PCA_Types.Warning_Type_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Log_Fault(): Option[PCA_Types.Fault_Record_imp] = {\n    val value: Option[PCA_Types.Fault_Record_imp] = get_Log_Fault_payload() match {\n      case Some(PCA_Types.Fault_Record_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Log_Fault.  Expecting 'PCA_Types.Fault_Record_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Fault_Record_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Log_Fault_payload(): Option[PCA_Types.Fault_Record_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Log_Fault_Id).asInstanceOf[Option[PCA_Types.Fault_Record_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ICE_Immediate(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ICE_Immediate_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ICE_Immediate.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ICE_Immediate_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ICE_Immediate_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ICE_Prompt(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ICE_Prompt_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ICE_Prompt.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ICE_Prompt_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ICE_Prompt_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ICE_Delayed(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ICE_Delayed_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ICE_Delayed.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ICE_Delayed_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ICE_Delayed_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ICE_Malfunction(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ICE_Malfunction_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ICE_Malfunction.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ICE_Malfunction_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ICE_Malfunction_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Stop_Pump_Completely(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Stop_Pump_Completely_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Stop_Pump_Completely.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Stop_Pump_Completely_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Stop_Pump_Completely_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Pump_At_KVO_Rate(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Pump_At_KVO_Rate_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Pump_At_KVO_Rate.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Pump_At_KVO_Rate_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Pump_At_KVO_Rate_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Alarm\/alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Alarm._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Test extends alarm_thread_imp_pump_safety_alarm_process_alarm_thr_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Alarm\/alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Alarm.{alarm_thread_imp_pump_safety_alarm_process_alarm_thr => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Alarm: Port[PCA_Types.Alarm_Type.Type],\n  Warning: Port[PCA_Types.Warning_Type.Type],\n  ICE_Alarm_Signal: Port[ICE_Types.Alarm_Signal.Type],\n  Log_Fault: Port[PCA_Types.Fault_Record_imp],\n  ICE_Immediate: Port[art.Empty],\n  ICE_Prompt: Port[art.Empty],\n  ICE_Delayed: Port[art.Empty],\n  ICE_Malfunction: Port[art.Empty],\n  ICE_Reset_Alarm: Port[art.Empty],\n  Stop_Pump_Completely: Port[art.Empty],\n  Pump_At_KVO_Rate: Port[art.Empty],\n  Max_Dose_Warning: Port[art.Empty],\n  Hard_Limit_Violation: Port[art.Empty],\n  Empty_Res: Port[art.Empty],\n  Low_Res: Port[art.Empty],\n  Pump_Hot: Port[art.Empty],\n  Upstream_Occlusion: Port[art.Empty],\n  Downstream_Occlusion: Port[art.Empty],\n  Bubble: Port[art.Empty],\n  Prime_Failure: Port[art.Empty],\n  CP_Reset_Alarm: Port[art.Empty],\n  Drug_Not_In_Library: Port[art.Empty],\n  Defective_Btty: Port[art.Empty],\n  Low_Battery_Warning: Port[art.Empty],\n  Voltage_OOR: Port[art.Empty],\n  Basal_Overinfusion: Port[art.Empty],\n  Bolus_Overinfusion: Port[art.Empty],\n  Square_Bolus_Overinfusion: Port[art.Empty],\n  Basal_Underinfusion: Port[art.Empty],\n  Bolus_Underinfusion: Port[art.Empty],\n  Square_Bolus_Underinfusion: Port[art.Empty],\n  Security_Fault: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Alarm,\n              Warning,\n              ICE_Alarm_Signal,\n              Log_Fault,\n              ICE_Immediate,\n              ICE_Prompt,\n              ICE_Delayed,\n              ICE_Malfunction,\n              ICE_Reset_Alarm,\n              Stop_Pump_Completely,\n              Pump_At_KVO_Rate,\n              Max_Dose_Warning,\n              Hard_Limit_Violation,\n              Empty_Res,\n              Low_Res,\n              Pump_Hot,\n              Upstream_Occlusion,\n              Downstream_Occlusion,\n              Bubble,\n              Prime_Failure,\n              CP_Reset_Alarm,\n              Drug_Not_In_Library,\n              Defective_Btty,\n              Low_Battery_Warning,\n              Voltage_OOR,\n              Basal_Overinfusion,\n              Bolus_Overinfusion,\n              Square_Bolus_Overinfusion,\n              Basal_Underinfusion,\n              Bolus_Underinfusion,\n              Square_Bolus_Underinfusion,\n              Security_Fault),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(ICE_Alarm_Signal,\n                   ICE_Reset_Alarm,\n                   Max_Dose_Warning,\n                   Hard_Limit_Violation,\n                   Empty_Res,\n                   Low_Res,\n                   Pump_Hot,\n                   Upstream_Occlusion,\n                   Downstream_Occlusion,\n                   Bubble,\n                   Prime_Failure,\n                   CP_Reset_Alarm,\n                   Drug_Not_In_Library,\n                   Defective_Btty,\n                   Low_Battery_Warning,\n                   Voltage_OOR,\n                   Basal_Overinfusion,\n                   Bolus_Overinfusion,\n                   Square_Bolus_Overinfusion,\n                   Basal_Underinfusion,\n                   Bolus_Underinfusion,\n                   Square_Bolus_Underinfusion,\n                   Security_Fault),\n\n    eventOuts = ISZ(Alarm,\n                    Warning,\n                    Log_Fault,\n                    ICE_Immediate,\n                    ICE_Prompt,\n                    ICE_Delayed,\n                    ICE_Malfunction,\n                    Stop_Pump_Completely,\n                    Pump_At_KVO_Rate)\n  )\n\n  val initialization_api : alarm_thread_imp_Initialization_Api = {\n    val api = alarm_thread_imp_Initialization_Api(\n      id,\n      Alarm.id,\n      Warning.id,\n      ICE_Alarm_Signal.id,\n      Log_Fault.id,\n      ICE_Immediate.id,\n      ICE_Prompt.id,\n      ICE_Delayed.id,\n      ICE_Malfunction.id,\n      ICE_Reset_Alarm.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Max_Dose_Warning.id,\n      Hard_Limit_Violation.id,\n      Empty_Res.id,\n      Low_Res.id,\n      Pump_Hot.id,\n      Upstream_Occlusion.id,\n      Downstream_Occlusion.id,\n      Bubble.id,\n      Prime_Failure.id,\n      CP_Reset_Alarm.id,\n      Drug_Not_In_Library.id,\n      Defective_Btty.id,\n      Low_Battery_Warning.id,\n      Voltage_OOR.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id,\n      Security_Fault.id\n    )\n    alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : alarm_thread_imp_Operational_Api = {\n    val api = alarm_thread_imp_Operational_Api(\n      id,\n      Alarm.id,\n      Warning.id,\n      ICE_Alarm_Signal.id,\n      Log_Fault.id,\n      ICE_Immediate.id,\n      ICE_Prompt.id,\n      ICE_Delayed.id,\n      ICE_Malfunction.id,\n      ICE_Reset_Alarm.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Max_Dose_Warning.id,\n      Hard_Limit_Violation.id,\n      Empty_Res.id,\n      Low_Res.id,\n      Pump_Hot.id,\n      Upstream_Occlusion.id,\n      Downstream_Occlusion.id,\n      Bubble.id,\n      Prime_Failure.id,\n      CP_Reset_Alarm.id,\n      Drug_Not_In_Library.id,\n      Defective_Btty.id,\n      Low_Battery_Warning.id,\n      Voltage_OOR.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id,\n      Security_Fault.id\n    )\n    alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge.EntryPoints(\n      id,\n\n      Alarm.id,\n      Warning.id,\n      ICE_Alarm_Signal.id,\n      Log_Fault.id,\n      ICE_Immediate.id,\n      ICE_Prompt.id,\n      ICE_Delayed.id,\n      ICE_Malfunction.id,\n      ICE_Reset_Alarm.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Max_Dose_Warning.id,\n      Hard_Limit_Violation.id,\n      Empty_Res.id,\n      Low_Res.id,\n      Pump_Hot.id,\n      Upstream_Occlusion.id,\n      Downstream_Occlusion.id,\n      Bubble.id,\n      Prime_Failure.id,\n      CP_Reset_Alarm.id,\n      Drug_Not_In_Library.id,\n      Defective_Btty.id,\n      Low_Battery_Warning.id,\n      Voltage_OOR.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id,\n      Security_Fault.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject alarm_thread_imp_pump_safety_alarm_process_alarm_thr_Bridge {\n\n  var c_initialization_api: Option[alarm_thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[alarm_thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    alarm_thread_imp_pump_safety_alarm_process_alarm_thr_BridgeId : Art.BridgeId,\n\n    Alarm_Id : Art.PortId,\n    Warning_Id : Art.PortId,\n    ICE_Alarm_Signal_Id : Art.PortId,\n    Log_Fault_Id : Art.PortId,\n    ICE_Immediate_Id : Art.PortId,\n    ICE_Prompt_Id : Art.PortId,\n    ICE_Delayed_Id : Art.PortId,\n    ICE_Malfunction_Id : Art.PortId,\n    ICE_Reset_Alarm_Id : Art.PortId,\n    Stop_Pump_Completely_Id : Art.PortId,\n    Pump_At_KVO_Rate_Id : Art.PortId,\n    Max_Dose_Warning_Id : Art.PortId,\n    Hard_Limit_Violation_Id : Art.PortId,\n    Empty_Res_Id : Art.PortId,\n    Low_Res_Id : Art.PortId,\n    Pump_Hot_Id : Art.PortId,\n    Upstream_Occlusion_Id : Art.PortId,\n    Downstream_Occlusion_Id : Art.PortId,\n    Bubble_Id : Art.PortId,\n    Prime_Failure_Id : Art.PortId,\n    CP_Reset_Alarm_Id : Art.PortId,\n    Drug_Not_In_Library_Id : Art.PortId,\n    Defective_Btty_Id : Art.PortId,\n    Low_Battery_Warning_Id : Art.PortId,\n    Voltage_OOR_Id : Art.PortId,\n    Basal_Overinfusion_Id : Art.PortId,\n    Bolus_Overinfusion_Id : Art.PortId,\n    Square_Bolus_Overinfusion_Id : Art.PortId,\n    Basal_Underinfusion_Id : Art.PortId,\n    Bolus_Underinfusion_Id : Art.PortId,\n    Square_Bolus_Underinfusion_Id : Art.PortId,\n    Security_Fault_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: alarm_thread_imp_Initialization_Api,\n    operational_api: alarm_thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(ICE_Alarm_Signal_Id,\n                                              ICE_Reset_Alarm_Id,\n                                              Max_Dose_Warning_Id,\n                                              Hard_Limit_Violation_Id,\n                                              Empty_Res_Id,\n                                              Low_Res_Id,\n                                              Pump_Hot_Id,\n                                              Upstream_Occlusion_Id,\n                                              Downstream_Occlusion_Id,\n                                              Bubble_Id,\n                                              Prime_Failure_Id,\n                                              CP_Reset_Alarm_Id,\n                                              Drug_Not_In_Library_Id,\n                                              Defective_Btty_Id,\n                                              Low_Battery_Warning_Id,\n                                              Voltage_OOR_Id,\n                                              Basal_Overinfusion_Id,\n                                              Bolus_Overinfusion_Id,\n                                              Square_Bolus_Overinfusion_Id,\n                                              Basal_Underinfusion_Id,\n                                              Bolus_Underinfusion_Id,\n                                              Square_Bolus_Underinfusion_Id,\n                                              Security_Fault_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Alarm_Id,\n                                               Warning_Id,\n                                               Log_Fault_Id,\n                                               ICE_Immediate_Id,\n                                               ICE_Prompt_Id,\n                                               ICE_Delayed_Id,\n                                               ICE_Malfunction_Id,\n                                               Stop_Pump_Completely_Id,\n                                               Pump_At_KVO_Rate_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(alarm_thread_imp_pump_safety_alarm_process_alarm_thr_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == ICE_Alarm_Signal_Id){\n          val Some(ICE_Types.Alarm_Signal_Payload(value)) = Art.getValue(ICE_Alarm_Signal_Id)\n\n          \/\/ implement the following in 'component':  def handle_ICE_Alarm_Signal(api: alarm_thread_imp_Operational_Api, value: ICE_Types.Alarm_Signal.Type): Unit = {}\n          component.handle_ICE_Alarm_Signal(operational_api, value)\n        }\n        else if(portId == ICE_Reset_Alarm_Id) {\n          \/\/ implement the following in 'component':  def handle_ICE_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_ICE_Reset_Alarm(operational_api)\n        }\n        else if(portId == Max_Dose_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Max_Dose_Warning(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Max_Dose_Warning(operational_api)\n        }\n        else if(portId == Hard_Limit_Violation_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violation(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violation(operational_api)\n        }\n        else if(portId == Empty_Res_Id) {\n          \/\/ implement the following in 'component':  def handle_Empty_Res(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Empty_Res(operational_api)\n        }\n        else if(portId == Low_Res_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Res(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Res(operational_api)\n        }\n        else if(portId == Pump_Hot_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_Hot(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Pump_Hot(operational_api)\n        }\n        else if(portId == Upstream_Occlusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Upstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Upstream_Occlusion(operational_api)\n        }\n        else if(portId == Downstream_Occlusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Downstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Downstream_Occlusion(operational_api)\n        }\n        else if(portId == Bubble_Id) {\n          \/\/ implement the following in 'component':  def handle_Bubble(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bubble(operational_api)\n        }\n        else if(portId == Prime_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_Prime_Failure(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Prime_Failure(operational_api)\n        }\n        else if(portId == CP_Reset_Alarm_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_CP_Reset_Alarm(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Defective_Btty_Id) {\n          \/\/ implement the following in 'component':  def handle_Defective_Btty(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Defective_Btty(operational_api)\n        }\n        else if(portId == Low_Battery_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Battery_Warning(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Battery_Warning(operational_api)\n        }\n        else if(portId == Voltage_OOR_Id) {\n          \/\/ implement the following in 'component':  def handle_Voltage_OOR(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Voltage_OOR(operational_api)\n        }\n        else if(portId == Basal_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Basal_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Basal_Overinfusion(operational_api)\n        }\n        else if(portId == Bolus_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bolus_Overinfusion(operational_api)\n        }\n        else if(portId == Square_Bolus_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Square_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Square_Bolus_Overinfusion(operational_api)\n        }\n        else if(portId == Basal_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Basal_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Basal_Underinfusion(operational_api)\n        }\n        else if(portId == Bolus_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bolus_Underinfusion(operational_api)\n        }\n        else if(portId == Square_Bolus_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Square_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Square_Bolus_Underinfusion(operational_api)\n        }\n        else if(portId == Security_Fault_Id) {\n          \/\/ implement the following in 'component':  def handle_Security_Fault(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Security_Fault(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(alarm_thread_imp_pump_safety_alarm_process_alarm_thr_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == ICE_Alarm_Signal_Id){\n          val Some(ICE_Types.Alarm_Signal_Payload(value)) = Art.getValue(ICE_Alarm_Signal_Id)\n\n          \/\/ implement the following in 'component':  def handle_ICE_Alarm_Signal(api: alarm_thread_imp_Operational_Api, value: ICE_Types.Alarm_Signal.Type): Unit = {}\n          component.handle_ICE_Alarm_Signal(operational_api, value)\n        }\n        else if(portId == ICE_Reset_Alarm_Id) {\n          \/\/ implement the following in 'component':  def handle_ICE_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_ICE_Reset_Alarm(operational_api)\n        }\n        else if(portId == Max_Dose_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Max_Dose_Warning(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Max_Dose_Warning(operational_api)\n        }\n        else if(portId == Hard_Limit_Violation_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violation(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violation(operational_api)\n        }\n        else if(portId == Empty_Res_Id) {\n          \/\/ implement the following in 'component':  def handle_Empty_Res(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Empty_Res(operational_api)\n        }\n        else if(portId == Low_Res_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Res(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Res(operational_api)\n        }\n        else if(portId == Pump_Hot_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_Hot(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Pump_Hot(operational_api)\n        }\n        else if(portId == Upstream_Occlusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Upstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Upstream_Occlusion(operational_api)\n        }\n        else if(portId == Downstream_Occlusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Downstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Downstream_Occlusion(operational_api)\n        }\n        else if(portId == Bubble_Id) {\n          \/\/ implement the following in 'component':  def handle_Bubble(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bubble(operational_api)\n        }\n        else if(portId == Prime_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_Prime_Failure(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Prime_Failure(operational_api)\n        }\n        else if(portId == CP_Reset_Alarm_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_CP_Reset_Alarm(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Defective_Btty_Id) {\n          \/\/ implement the following in 'component':  def handle_Defective_Btty(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Defective_Btty(operational_api)\n        }\n        else if(portId == Low_Battery_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Battery_Warning(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Battery_Warning(operational_api)\n        }\n        else if(portId == Voltage_OOR_Id) {\n          \/\/ implement the following in 'component':  def handle_Voltage_OOR(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Voltage_OOR(operational_api)\n        }\n        else if(portId == Basal_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Basal_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Basal_Overinfusion(operational_api)\n        }\n        else if(portId == Bolus_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bolus_Overinfusion(operational_api)\n        }\n        else if(portId == Square_Bolus_Overinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Square_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Square_Bolus_Overinfusion(operational_api)\n        }\n        else if(portId == Basal_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Basal_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Basal_Underinfusion(operational_api)\n        }\n        else if(portId == Bolus_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Bolus_Underinfusion(operational_api)\n        }\n        else if(portId == Square_Bolus_Underinfusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Square_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Square_Bolus_Underinfusion(operational_api)\n        }\n        else if(portId == Security_Fault_Id) {\n          \/\/ implement the following in 'component':  def handle_Security_Fault(api: alarm_thread_imp_Operational_Api): Unit = {}\n          component.handle_Security_Fault(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: alarm_thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: alarm_thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: alarm_thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: alarm_thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: alarm_thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Alarm\/alarm_thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait alarm_thread_imp_Api {\n  def id: Art.BridgeId\n  def Alarm_Id : Art.PortId\n  def Warning_Id : Art.PortId\n  def ICE_Alarm_Signal_Id : Art.PortId\n  def Log_Fault_Id : Art.PortId\n  def ICE_Immediate_Id : Art.PortId\n  def ICE_Prompt_Id : Art.PortId\n  def ICE_Delayed_Id : Art.PortId\n  def ICE_Malfunction_Id : Art.PortId\n  def ICE_Reset_Alarm_Id : Art.PortId\n  def Stop_Pump_Completely_Id : Art.PortId\n  def Pump_At_KVO_Rate_Id : Art.PortId\n  def Max_Dose_Warning_Id : Art.PortId\n  def Hard_Limit_Violation_Id : Art.PortId\n  def Empty_Res_Id : Art.PortId\n  def Low_Res_Id : Art.PortId\n  def Pump_Hot_Id : Art.PortId\n  def Upstream_Occlusion_Id : Art.PortId\n  def Downstream_Occlusion_Id : Art.PortId\n  def Bubble_Id : Art.PortId\n  def Prime_Failure_Id : Art.PortId\n  def CP_Reset_Alarm_Id : Art.PortId\n  def Drug_Not_In_Library_Id : Art.PortId\n  def Defective_Btty_Id : Art.PortId\n  def Low_Battery_Warning_Id : Art.PortId\n  def Voltage_OOR_Id : Art.PortId\n  def Basal_Overinfusion_Id : Art.PortId\n  def Bolus_Overinfusion_Id : Art.PortId\n  def Square_Bolus_Overinfusion_Id : Art.PortId\n  def Basal_Underinfusion_Id : Art.PortId\n  def Bolus_Underinfusion_Id : Art.PortId\n  def Square_Bolus_Underinfusion_Id : Art.PortId\n  def Security_Fault_Id : Art.PortId\n\n  def put_Alarm(value : PCA_Types.Alarm_Type.Type) : Unit = {\n    Art.putValue(Alarm_Id, PCA_Types.Alarm_Type_Payload(value))\n  }\n\n  def put_Warning(value : PCA_Types.Warning_Type.Type) : Unit = {\n    Art.putValue(Warning_Id, PCA_Types.Warning_Type_Payload(value))\n  }\n\n  def put_Log_Fault(value : PCA_Types.Fault_Record_imp) : Unit = {\n    Art.putValue(Log_Fault_Id, PCA_Types.Fault_Record_imp_Payload(value))\n  }\n\n  def put_ICE_Immediate() : Unit = {\n    Art.putValue(ICE_Immediate_Id, art.Empty())\n  }\n\n  def put_ICE_Prompt() : Unit = {\n    Art.putValue(ICE_Prompt_Id, art.Empty())\n  }\n\n  def put_ICE_Delayed() : Unit = {\n    Art.putValue(ICE_Delayed_Id, art.Empty())\n  }\n\n  def put_ICE_Malfunction() : Unit = {\n    Art.putValue(ICE_Malfunction_Id, art.Empty())\n  }\n\n  def put_Stop_Pump_Completely() : Unit = {\n    Art.putValue(Stop_Pump_Completely_Id, art.Empty())\n  }\n\n  def put_Pump_At_KVO_Rate() : Unit = {\n    Art.putValue(Pump_At_KVO_Rate_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class alarm_thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val ICE_Alarm_Signal_Id : Art.PortId,\n  val Log_Fault_Id : Art.PortId,\n  val ICE_Immediate_Id : Art.PortId,\n  val ICE_Prompt_Id : Art.PortId,\n  val ICE_Delayed_Id : Art.PortId,\n  val ICE_Malfunction_Id : Art.PortId,\n  val ICE_Reset_Alarm_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val Max_Dose_Warning_Id : Art.PortId,\n  val Hard_Limit_Violation_Id : Art.PortId,\n  val Empty_Res_Id : Art.PortId,\n  val Low_Res_Id : Art.PortId,\n  val Pump_Hot_Id : Art.PortId,\n  val Upstream_Occlusion_Id : Art.PortId,\n  val Downstream_Occlusion_Id : Art.PortId,\n  val Bubble_Id : Art.PortId,\n  val Prime_Failure_Id : Art.PortId,\n  val CP_Reset_Alarm_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Defective_Btty_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId,\n  val Basal_Overinfusion_Id : Art.PortId,\n  val Bolus_Overinfusion_Id : Art.PortId,\n  val Square_Bolus_Overinfusion_Id : Art.PortId,\n  val Basal_Underinfusion_Id : Art.PortId,\n  val Bolus_Underinfusion_Id : Art.PortId,\n  val Square_Bolus_Underinfusion_Id : Art.PortId,\n  val Security_Fault_Id : Art.PortId) extends alarm_thread_imp_Api\n\n@datatype class alarm_thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val ICE_Alarm_Signal_Id : Art.PortId,\n  val Log_Fault_Id : Art.PortId,\n  val ICE_Immediate_Id : Art.PortId,\n  val ICE_Prompt_Id : Art.PortId,\n  val ICE_Delayed_Id : Art.PortId,\n  val ICE_Malfunction_Id : Art.PortId,\n  val ICE_Reset_Alarm_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val Max_Dose_Warning_Id : Art.PortId,\n  val Hard_Limit_Violation_Id : Art.PortId,\n  val Empty_Res_Id : Art.PortId,\n  val Low_Res_Id : Art.PortId,\n  val Pump_Hot_Id : Art.PortId,\n  val Upstream_Occlusion_Id : Art.PortId,\n  val Downstream_Occlusion_Id : Art.PortId,\n  val Bubble_Id : Art.PortId,\n  val Prime_Failure_Id : Art.PortId,\n  val CP_Reset_Alarm_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Defective_Btty_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId,\n  val Basal_Overinfusion_Id : Art.PortId,\n  val Bolus_Overinfusion_Id : Art.PortId,\n  val Square_Bolus_Overinfusion_Id : Art.PortId,\n  val Basal_Underinfusion_Id : Art.PortId,\n  val Bolus_Underinfusion_Id : Art.PortId,\n  val Square_Bolus_Underinfusion_Id : Art.PortId,\n  val Security_Fault_Id : Art.PortId) extends alarm_thread_imp_Api {\n\n  def get_ICE_Alarm_Signal() : Option[ICE_Types.Alarm_Signal.Type] = {\n    val value : Option[ICE_Types.Alarm_Signal.Type] = Art.getValue(ICE_Alarm_Signal_Id) match {\n      case Some(ICE_Types.Alarm_Signal_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ICE_Alarm_Signal.  Expecting 'ICE_Types.Alarm_Signal_Payload' but received ${v}\")\n        None[ICE_Types.Alarm_Signal.Type]()\n      case _ => None[ICE_Types.Alarm_Signal.Type]()\n    }\n    return value\n  }\n\n  def get_ICE_Reset_Alarm() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(ICE_Reset_Alarm_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ICE_Reset_Alarm.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Max_Dose_Warning() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Max_Dose_Warning_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Max_Dose_Warning.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Hard_Limit_Violation() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Hard_Limit_Violation_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Hard_Limit_Violation.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Empty_Res() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Empty_Res_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Empty_Res.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Low_Res() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Low_Res_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Low_Res.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Pump_Hot() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Pump_Hot_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Pump_Hot.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Upstream_Occlusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Upstream_Occlusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Upstream_Occlusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Downstream_Occlusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Downstream_Occlusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Downstream_Occlusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Bubble() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Bubble_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Bubble.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Prime_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Prime_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Prime_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_CP_Reset_Alarm() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(CP_Reset_Alarm_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CP_Reset_Alarm.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Drug_Not_In_Library() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Drug_Not_In_Library_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Not_In_Library.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Defective_Btty() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Defective_Btty_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Defective_Btty.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Low_Battery_Warning() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Low_Battery_Warning_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Low_Battery_Warning.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Voltage_OOR() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Voltage_OOR_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Voltage_OOR.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Basal_Overinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Basal_Overinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Basal_Overinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Bolus_Overinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Bolus_Overinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Bolus_Overinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Square_Bolus_Overinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Square_Bolus_Overinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Square_Bolus_Overinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Basal_Underinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Basal_Underinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Basal_Underinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Bolus_Underinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Bolus_Underinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Bolus_Underinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Square_Bolus_Underinfusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Square_Bolus_Underinfusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Square_Bolus_Underinfusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Security_Fault() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Security_Fault_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Security_Fault.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Alarm\/alarm_thread_imp_pump_safety_alarm_process_alarm_thr.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject alarm_thread_imp_pump_safety_alarm_process_alarm_thr {\n\n  def initialise(api: alarm_thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Alarm(PCA_Types.Alarm_Type.byOrdinal(0).get)\n    api.put_Warning(PCA_Types.Warning_Type.byOrdinal(0).get)\n    api.put_Log_Fault(PCA_Types.Fault_Record_imp.example())\n    api.put_ICE_Immediate()\n    api.put_ICE_Prompt()\n    api.put_ICE_Delayed()\n    api.put_ICE_Malfunction()\n    api.put_Stop_Pump_Completely()\n    api.put_Pump_At_KVO_Rate()\n  }\n\n  def handle_ICE_Alarm_Signal(api: alarm_thread_imp_Operational_Api, value : ICE_Types.Alarm_Signal.Type): Unit = {\n    api.logInfo(\"example handle_ICE_Alarm_Signal implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_ICE_Alarm_Signal: Option[ICE_Types.Alarm_Signal.Type] = api.get_ICE_Alarm_Signal()\n    api.logInfo(s\"Received on ICE_Alarm_Signal: ${apiUsage_ICE_Alarm_Signal}\")\n    val apiUsage_ICE_Reset_Alarm: Option[art.Empty] = api.get_ICE_Reset_Alarm()\n    api.logInfo(s\"Received on ICE_Reset_Alarm: ${apiUsage_ICE_Reset_Alarm}\")\n    val apiUsage_Max_Dose_Warning: Option[art.Empty] = api.get_Max_Dose_Warning()\n    api.logInfo(s\"Received on Max_Dose_Warning: ${apiUsage_Max_Dose_Warning}\")\n    val apiUsage_Hard_Limit_Violation: Option[art.Empty] = api.get_Hard_Limit_Violation()\n    api.logInfo(s\"Received on Hard_Limit_Violation: ${apiUsage_Hard_Limit_Violation}\")\n    val apiUsage_Empty_Res: Option[art.Empty] = api.get_Empty_Res()\n    api.logInfo(s\"Received on Empty_Res: ${apiUsage_Empty_Res}\")\n    val apiUsage_Low_Res: Option[art.Empty] = api.get_Low_Res()\n    api.logInfo(s\"Received on Low_Res: ${apiUsage_Low_Res}\")\n    val apiUsage_Pump_Hot: Option[art.Empty] = api.get_Pump_Hot()\n    api.logInfo(s\"Received on Pump_Hot: ${apiUsage_Pump_Hot}\")\n    val apiUsage_Upstream_Occlusion: Option[art.Empty] = api.get_Upstream_Occlusion()\n    api.logInfo(s\"Received on Upstream_Occlusion: ${apiUsage_Upstream_Occlusion}\")\n    val apiUsage_Downstream_Occlusion: Option[art.Empty] = api.get_Downstream_Occlusion()\n    api.logInfo(s\"Received on Downstream_Occlusion: ${apiUsage_Downstream_Occlusion}\")\n    val apiUsage_Bubble: Option[art.Empty] = api.get_Bubble()\n    api.logInfo(s\"Received on Bubble: ${apiUsage_Bubble}\")\n    val apiUsage_Prime_Failure: Option[art.Empty] = api.get_Prime_Failure()\n    api.logInfo(s\"Received on Prime_Failure: ${apiUsage_Prime_Failure}\")\n    val apiUsage_CP_Reset_Alarm: Option[art.Empty] = api.get_CP_Reset_Alarm()\n    api.logInfo(s\"Received on CP_Reset_Alarm: ${apiUsage_CP_Reset_Alarm}\")\n    val apiUsage_Drug_Not_In_Library: Option[art.Empty] = api.get_Drug_Not_In_Library()\n    api.logInfo(s\"Received on Drug_Not_In_Library: ${apiUsage_Drug_Not_In_Library}\")\n    val apiUsage_Defective_Btty: Option[art.Empty] = api.get_Defective_Btty()\n    api.logInfo(s\"Received on Defective_Btty: ${apiUsage_Defective_Btty}\")\n    val apiUsage_Low_Battery_Warning: Option[art.Empty] = api.get_Low_Battery_Warning()\n    api.logInfo(s\"Received on Low_Battery_Warning: ${apiUsage_Low_Battery_Warning}\")\n    val apiUsage_Voltage_OOR: Option[art.Empty] = api.get_Voltage_OOR()\n    api.logInfo(s\"Received on Voltage_OOR: ${apiUsage_Voltage_OOR}\")\n    val apiUsage_Basal_Overinfusion: Option[art.Empty] = api.get_Basal_Overinfusion()\n    api.logInfo(s\"Received on Basal_Overinfusion: ${apiUsage_Basal_Overinfusion}\")\n    val apiUsage_Bolus_Overinfusion: Option[art.Empty] = api.get_Bolus_Overinfusion()\n    api.logInfo(s\"Received on Bolus_Overinfusion: ${apiUsage_Bolus_Overinfusion}\")\n    val apiUsage_Square_Bolus_Overinfusion: Option[art.Empty] = api.get_Square_Bolus_Overinfusion()\n    api.logInfo(s\"Received on Square_Bolus_Overinfusion: ${apiUsage_Square_Bolus_Overinfusion}\")\n    val apiUsage_Basal_Underinfusion: Option[art.Empty] = api.get_Basal_Underinfusion()\n    api.logInfo(s\"Received on Basal_Underinfusion: ${apiUsage_Basal_Underinfusion}\")\n    val apiUsage_Bolus_Underinfusion: Option[art.Empty] = api.get_Bolus_Underinfusion()\n    api.logInfo(s\"Received on Bolus_Underinfusion: ${apiUsage_Bolus_Underinfusion}\")\n    val apiUsage_Square_Bolus_Underinfusion: Option[art.Empty] = api.get_Square_Bolus_Underinfusion()\n    api.logInfo(s\"Received on Square_Bolus_Underinfusion: ${apiUsage_Square_Bolus_Underinfusion}\")\n    val apiUsage_Security_Fault: Option[art.Empty] = api.get_Security_Fault()\n    api.logInfo(s\"Received on Security_Fault: ${apiUsage_Security_Fault}\")\n  }\n\n  def handle_ICE_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_ICE_Reset_Alarm implementation\")\n    api.logInfo(\"received ICE_Reset_Alarm event\")\n  }\n\n  def handle_Max_Dose_Warning(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Max_Dose_Warning implementation\")\n    api.logInfo(\"received Max_Dose_Warning event\")\n  }\n\n  def handle_Hard_Limit_Violation(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Hard_Limit_Violation implementation\")\n    api.logInfo(\"received Hard_Limit_Violation event\")\n  }\n\n  def handle_Empty_Res(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Empty_Res implementation\")\n    api.logInfo(\"received Empty_Res event\")\n  }\n\n  def handle_Low_Res(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Low_Res implementation\")\n    api.logInfo(\"received Low_Res event\")\n  }\n\n  def handle_Pump_Hot(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Pump_Hot implementation\")\n    api.logInfo(\"received Pump_Hot event\")\n  }\n\n  def handle_Upstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Upstream_Occlusion implementation\")\n    api.logInfo(\"received Upstream_Occlusion event\")\n  }\n\n  def handle_Downstream_Occlusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Downstream_Occlusion implementation\")\n    api.logInfo(\"received Downstream_Occlusion event\")\n  }\n\n  def handle_Bubble(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Bubble implementation\")\n    api.logInfo(\"received Bubble event\")\n  }\n\n  def handle_Prime_Failure(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Prime_Failure implementation\")\n    api.logInfo(\"received Prime_Failure event\")\n  }\n\n  def handle_CP_Reset_Alarm(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_CP_Reset_Alarm implementation\")\n    api.logInfo(\"received CP_Reset_Alarm event\")\n  }\n\n  def handle_Drug_Not_In_Library(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Drug_Not_In_Library implementation\")\n    api.logInfo(\"received Drug_Not_In_Library event\")\n  }\n\n  def handle_Defective_Btty(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Defective_Btty implementation\")\n    api.logInfo(\"received Defective_Btty event\")\n  }\n\n  def handle_Low_Battery_Warning(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Low_Battery_Warning implementation\")\n    api.logInfo(\"received Low_Battery_Warning event\")\n  }\n\n  def handle_Voltage_OOR(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Voltage_OOR implementation\")\n    api.logInfo(\"received Voltage_OOR event\")\n  }\n\n  def handle_Basal_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Basal_Overinfusion implementation\")\n    api.logInfo(\"received Basal_Overinfusion event\")\n  }\n\n  def handle_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Bolus_Overinfusion implementation\")\n    api.logInfo(\"received Bolus_Overinfusion event\")\n  }\n\n  def handle_Square_Bolus_Overinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Square_Bolus_Overinfusion implementation\")\n    api.logInfo(\"received Square_Bolus_Overinfusion event\")\n  }\n\n  def handle_Basal_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Basal_Underinfusion implementation\")\n    api.logInfo(\"received Basal_Underinfusion event\")\n  }\n\n  def handle_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Bolus_Underinfusion implementation\")\n    api.logInfo(\"received Bolus_Underinfusion event\")\n  }\n\n  def handle_Square_Bolus_Underinfusion(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Square_Bolus_Underinfusion implementation\")\n    api.logInfo(\"received Square_Bolus_Underinfusion event\")\n  }\n\n  def handle_Security_Fault(api: alarm_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Security_Fault implementation\")\n    api.logInfo(\"received Security_Fault event\")\n  }\n\n  def activate(api: alarm_thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: alarm_thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: alarm_thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: alarm_thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Alarm\/Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_TestApi extends BridgeTestSuite[Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge](Arch.wrap_pca_imp_Instance_pump_safety_alarm_process_flow_rate) {\n\n  \/** helper function to set the values of all input ports.\n   * @param System_Status payload for data port System_Status\n   * @param Infusion_Flow_Rate payload for data port Infusion_Flow_Rate\n   * @param Upstream_Flow_Rate payload for data port Upstream_Flow_Rate\n   * @param Downstream_Flow_Rate payload for data port Downstream_Flow_Rate\n   *\/\n  def put_concrete_inputs(System_Status : PCA_Types.Status_Type.Type,\n                          Infusion_Flow_Rate : PCA_Types.Flow_Rate_imp,\n                          Upstream_Flow_Rate : PCA_Types.Flow_Rate_imp,\n                          Downstream_Flow_Rate : PCA_Types.Flow_Rate_imp): Unit = {\n    put_System_Status(System_Status)\n    put_Infusion_Flow_Rate(Infusion_Flow_Rate)\n    put_Upstream_Flow_Rate(Upstream_Flow_Rate)\n    put_Downstream_Flow_Rate(Downstream_Flow_Rate)\n  }\n\n\n  \/** helper function to check Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Basal_Overinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Basal_Overinfusion'.\n   * @param Bolus_Overinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Bolus_Overinfusion'.\n   * @param Square_Bolus_Overinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Square_Bolus_Overinfusion'.\n   * @param Basal_Underinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Basal_Underinfusion'.\n   * @param Bolus_Underinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Bolus_Underinfusion'.\n   * @param Square_Bolus_Underinfusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Square_Bolus_Underinfusion'.\n   *\/\n  def check_concrete_output(Basal_Overinfusion: Z => B = Basal_OverinfusionParam => {T},\n                            Bolus_Overinfusion: Z => B = Bolus_OverinfusionParam => {T},\n                            Square_Bolus_Overinfusion: Z => B = Square_Bolus_OverinfusionParam => {T},\n                            Basal_Underinfusion: Z => B = Basal_UnderinfusionParam => {T},\n                            Bolus_Underinfusion: Z => B = Bolus_UnderinfusionParam => {T},\n                            Square_Bolus_Underinfusion: Z => B = Square_Bolus_UnderinfusionParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Basal_OverinfusionValue: Z = if(get_Basal_Overinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Basal_Overinfusion(Basal_OverinfusionValue)) {\n      testFailures = testFailures :+ st\"'Basal_Overinfusion' did not match expected: ${Basal_OverinfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Bolus_OverinfusionValue: Z = if(get_Bolus_Overinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Bolus_Overinfusion(Bolus_OverinfusionValue)) {\n      testFailures = testFailures :+ st\"'Bolus_Overinfusion' did not match expected: ${Bolus_OverinfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Square_Bolus_OverinfusionValue: Z = if(get_Square_Bolus_Overinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Square_Bolus_Overinfusion(Square_Bolus_OverinfusionValue)) {\n      testFailures = testFailures :+ st\"'Square_Bolus_Overinfusion' did not match expected: ${Square_Bolus_OverinfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Basal_UnderinfusionValue: Z = if(get_Basal_Underinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Basal_Underinfusion(Basal_UnderinfusionValue)) {\n      testFailures = testFailures :+ st\"'Basal_Underinfusion' did not match expected: ${Basal_UnderinfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Bolus_UnderinfusionValue: Z = if(get_Bolus_Underinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Bolus_Underinfusion(Bolus_UnderinfusionValue)) {\n      testFailures = testFailures :+ st\"'Bolus_Underinfusion' did not match expected: ${Bolus_UnderinfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Square_Bolus_UnderinfusionValue: Z = if(get_Square_Bolus_Underinfusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Square_Bolus_Underinfusion(Square_Bolus_UnderinfusionValue)) {\n      testFailures = testFailures :+ st\"'Square_Bolus_Underinfusion' did not match expected: ${Square_Bolus_UnderinfusionValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_System_Status(value : PCA_Types.Status_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.System_Status_Id, PCA_Types.Status_Type_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Infusion_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Infusion_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Upstream_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Upstream_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Downstream_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Downstream_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ getter for out EventPort\n  def get_Basal_Overinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Basal_Overinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Basal_Overinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Basal_Overinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Basal_Overinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Bolus_Overinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Bolus_Overinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Bolus_Overinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Bolus_Overinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Bolus_Overinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Square_Bolus_Overinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Square_Bolus_Overinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Square_Bolus_Overinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Square_Bolus_Overinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Square_Bolus_Overinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Basal_Underinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Basal_Underinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Basal_Underinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Basal_Underinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Basal_Underinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Bolus_Underinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Bolus_Underinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Bolus_Underinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Bolus_Underinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Bolus_Underinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Square_Bolus_Underinfusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Square_Bolus_Underinfusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Square_Bolus_Underinfusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Square_Bolus_Underinfusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Square_Bolus_Underinfusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Alarm\/Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Alarm._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Test extends Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Alarm\/Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Alarm.{Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  System_Status: Port[PCA_Types.Status_Type.Type],\n  Infusion_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Upstream_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Downstream_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Basal_Overinfusion: Port[art.Empty],\n  Bolus_Overinfusion: Port[art.Empty],\n  Square_Bolus_Overinfusion: Port[art.Empty],\n  Basal_Underinfusion: Port[art.Empty],\n  Bolus_Underinfusion: Port[art.Empty],\n  Square_Bolus_Underinfusion: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(System_Status,\n              Infusion_Flow_Rate,\n              Upstream_Flow_Rate,\n              Downstream_Flow_Rate,\n              Basal_Overinfusion,\n              Bolus_Overinfusion,\n              Square_Bolus_Overinfusion,\n              Basal_Underinfusion,\n              Bolus_Underinfusion,\n              Square_Bolus_Underinfusion),\n\n    dataIns = ISZ(System_Status,\n                  Infusion_Flow_Rate,\n                  Upstream_Flow_Rate,\n                  Downstream_Flow_Rate),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Basal_Overinfusion,\n                    Bolus_Overinfusion,\n                    Square_Bolus_Overinfusion,\n                    Basal_Underinfusion,\n                    Bolus_Underinfusion,\n                    Square_Bolus_Underinfusion)\n  )\n\n  val initialization_api : Flow_Rate_Checker_imp_Initialization_Api = {\n    val api = Flow_Rate_Checker_imp_Initialization_Api(\n      id,\n      System_Status.id,\n      Infusion_Flow_Rate.id,\n      Upstream_Flow_Rate.id,\n      Downstream_Flow_Rate.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id\n    )\n    Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Flow_Rate_Checker_imp_Operational_Api = {\n    val api = Flow_Rate_Checker_imp_Operational_Api(\n      id,\n      System_Status.id,\n      Infusion_Flow_Rate.id,\n      Upstream_Flow_Rate.id,\n      Downstream_Flow_Rate.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id\n    )\n    Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge.EntryPoints(\n      id,\n\n      System_Status.id,\n      Infusion_Flow_Rate.id,\n      Upstream_Flow_Rate.id,\n      Downstream_Flow_Rate.id,\n      Basal_Overinfusion.id,\n      Bolus_Overinfusion.id,\n      Square_Bolus_Overinfusion.id,\n      Basal_Underinfusion.id,\n      Bolus_Underinfusion.id,\n      Square_Bolus_Underinfusion.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_Bridge {\n\n  var c_initialization_api: Option[Flow_Rate_Checker_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Flow_Rate_Checker_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate_BridgeId : Art.BridgeId,\n\n    System_Status_Id : Art.PortId,\n    Infusion_Flow_Rate_Id : Art.PortId,\n    Upstream_Flow_Rate_Id : Art.PortId,\n    Downstream_Flow_Rate_Id : Art.PortId,\n    Basal_Overinfusion_Id : Art.PortId,\n    Bolus_Overinfusion_Id : Art.PortId,\n    Square_Bolus_Overinfusion_Id : Art.PortId,\n    Basal_Underinfusion_Id : Art.PortId,\n    Bolus_Underinfusion_Id : Art.PortId,\n    Square_Bolus_Underinfusion_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Flow_Rate_Checker_imp_Initialization_Api,\n    operational_api: Flow_Rate_Checker_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(System_Status_Id,\n                                             Infusion_Flow_Rate_Id,\n                                             Upstream_Flow_Rate_Id,\n                                             Downstream_Flow_Rate_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Basal_Overinfusion_Id,\n                                               Bolus_Overinfusion_Id,\n                                               Square_Bolus_Overinfusion_Id,\n                                               Basal_Underinfusion_Id,\n                                               Bolus_Underinfusion_Id,\n                                               Square_Bolus_Underinfusion_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Flow_Rate_Checker_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Alarm\/Flow_Rate_Checker_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Flow_Rate_Checker_imp_Api {\n  def id: Art.BridgeId\n  def System_Status_Id : Art.PortId\n  def Infusion_Flow_Rate_Id : Art.PortId\n  def Upstream_Flow_Rate_Id : Art.PortId\n  def Downstream_Flow_Rate_Id : Art.PortId\n  def Basal_Overinfusion_Id : Art.PortId\n  def Bolus_Overinfusion_Id : Art.PortId\n  def Square_Bolus_Overinfusion_Id : Art.PortId\n  def Basal_Underinfusion_Id : Art.PortId\n  def Bolus_Underinfusion_Id : Art.PortId\n  def Square_Bolus_Underinfusion_Id : Art.PortId\n\n  def put_Basal_Overinfusion() : Unit = {\n    Art.putValue(Basal_Overinfusion_Id, art.Empty())\n  }\n\n  def put_Bolus_Overinfusion() : Unit = {\n    Art.putValue(Bolus_Overinfusion_Id, art.Empty())\n  }\n\n  def put_Square_Bolus_Overinfusion() : Unit = {\n    Art.putValue(Square_Bolus_Overinfusion_Id, art.Empty())\n  }\n\n  def put_Basal_Underinfusion() : Unit = {\n    Art.putValue(Basal_Underinfusion_Id, art.Empty())\n  }\n\n  def put_Bolus_Underinfusion() : Unit = {\n    Art.putValue(Bolus_Underinfusion_Id, art.Empty())\n  }\n\n  def put_Square_Bolus_Underinfusion() : Unit = {\n    Art.putValue(Square_Bolus_Underinfusion_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Flow_Rate_Checker_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val System_Status_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Upstream_Flow_Rate_Id : Art.PortId,\n  val Downstream_Flow_Rate_Id : Art.PortId,\n  val Basal_Overinfusion_Id : Art.PortId,\n  val Bolus_Overinfusion_Id : Art.PortId,\n  val Square_Bolus_Overinfusion_Id : Art.PortId,\n  val Basal_Underinfusion_Id : Art.PortId,\n  val Bolus_Underinfusion_Id : Art.PortId,\n  val Square_Bolus_Underinfusion_Id : Art.PortId) extends Flow_Rate_Checker_imp_Api\n\n@datatype class Flow_Rate_Checker_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val System_Status_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Upstream_Flow_Rate_Id : Art.PortId,\n  val Downstream_Flow_Rate_Id : Art.PortId,\n  val Basal_Overinfusion_Id : Art.PortId,\n  val Bolus_Overinfusion_Id : Art.PortId,\n  val Square_Bolus_Overinfusion_Id : Art.PortId,\n  val Basal_Underinfusion_Id : Art.PortId,\n  val Bolus_Underinfusion_Id : Art.PortId,\n  val Square_Bolus_Underinfusion_Id : Art.PortId) extends Flow_Rate_Checker_imp_Api {\n\n  def get_System_Status() : Option[PCA_Types.Status_Type.Type] = {\n    val value : Option[PCA_Types.Status_Type.Type] = Art.getValue(System_Status_Id) match {\n      case Some(PCA_Types.Status_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port System_Status.  Expecting 'PCA_Types.Status_Type_Payload' but received ${v}\")\n        None[PCA_Types.Status_Type.Type]()\n      case _ => None[PCA_Types.Status_Type.Type]()\n    }\n    return value\n  }\n\n  def get_Infusion_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Infusion_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Infusion_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Upstream_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Upstream_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Upstream_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Downstream_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Downstream_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Downstream_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Alarm\/Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Alarm\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Flow_Rate_Checker_imp_pump_safety_alarm_process_flow_rate {\n\n  def initialise(api: Flow_Rate_Checker_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Basal_Overinfusion()\n    api.put_Bolus_Overinfusion()\n    api.put_Square_Bolus_Overinfusion()\n    api.put_Basal_Underinfusion()\n    api.put_Bolus_Underinfusion()\n    api.put_Square_Bolus_Underinfusion()\n  }\n\n  def timeTriggered(api: Flow_Rate_Checker_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_System_Status: Option[PCA_Types.Status_Type.Type] = api.get_System_Status()\n    api.logInfo(s\"Received on System_Status: ${apiUsage_System_Status}\")\n    val apiUsage_Infusion_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Infusion_Flow_Rate()\n    api.logInfo(s\"Received on Infusion_Flow_Rate: ${apiUsage_Infusion_Flow_Rate}\")\n    val apiUsage_Upstream_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Upstream_Flow_Rate()\n    api.logInfo(s\"Received on Upstream_Flow_Rate: ${apiUsage_Upstream_Flow_Rate}\")\n    val apiUsage_Downstream_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Downstream_Flow_Rate()\n    api.logInfo(s\"Received on Downstream_Flow_Rate: ${apiUsage_Downstream_Flow_Rate}\")\n  }\n\n  def activate(api: Flow_Rate_Checker_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Flow_Rate_Checker_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Flow_Rate_Checker_imp_Operational_Api): Unit = { }\n\n  def recover(api: Flow_Rate_Checker_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Power\/power_control_imp_pump_power_pwr_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class power_control_imp_pump_power_pwr_TestApi extends BridgeTestSuite[power_control_imp_pump_power_pwr_Bridge](Arch.wrap_pca_imp_Instance_pump_power_pwr) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Battery_Voltage payload for data port Battery_Voltage\n   * @param Battery_Current payload for data port Battery_Current\n   * @param Power_Voltage payload for data port Power_Voltage\n   *\/\n  def put_concrete_inputs(Battery_Voltage : Physical_Types.Voltage_imp,\n                          Battery_Current : Physical_Types.Current_imp,\n                          Power_Voltage : Physical_Types.Voltage_imp): Unit = {\n    put_Battery_Voltage(Battery_Voltage)\n    put_Battery_Current(Battery_Current)\n    put_Power_Voltage(Power_Voltage)\n  }\n\n\n  \/** helper function to check power_control_imp_pump_power_pwr's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Using_Battery_Power method that will be called with the value of the outgoing data\n   *        port 'Using_Battery_Power'.\n   * @param Remaining_Battery_Time method that will be called with the value of the outgoing data\n   *        port 'Remaining_Battery_Time'.\n   * @param Low_Battery_Warning method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Low_Battery_Warning'.\n   * @param Defective_Battery method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Defective_Battery'.\n   * @param Voltage_OOR method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Voltage_OOR'.\n   *\/\n  def check_concrete_output(Using_Battery_Power: Base_Types.Boolean => B = Using_Battery_PowerParam => {T},\n                            Remaining_Battery_Time: BLESS_Types.Time => B = Remaining_Battery_TimeParam => {T},\n                            Low_Battery_Warning: Z => B = Low_Battery_WarningParam => {T},\n                            Defective_Battery: Z => B = Defective_BatteryParam => {T},\n                            Voltage_OOR: Z => B = Voltage_OORParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Using_Battery_PowerValue: Base_Types.Boolean = get_Using_Battery_Power().get\n    if(!Using_Battery_Power(Using_Battery_PowerValue)) {\n      testFailures = testFailures :+ st\"'Using_Battery_Power' did not match expected: value of the outgoing data port is ${Using_Battery_PowerValue}\"\n    }\n    val Remaining_Battery_TimeValue: BLESS_Types.Time = get_Remaining_Battery_Time().get\n    if(!Remaining_Battery_Time(Remaining_Battery_TimeValue)) {\n      testFailures = testFailures :+ st\"'Remaining_Battery_Time' did not match expected: value of the outgoing data port is ${Remaining_Battery_TimeValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Low_Battery_WarningValue: Z = if(get_Low_Battery_Warning().nonEmpty) z\"1\" else z\"0\"\n    if(!Low_Battery_Warning(Low_Battery_WarningValue)) {\n      testFailures = testFailures :+ st\"'Low_Battery_Warning' did not match expected: ${Low_Battery_WarningValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Defective_BatteryValue: Z = if(get_Defective_Battery().nonEmpty) z\"1\" else z\"0\"\n    if(!Defective_Battery(Defective_BatteryValue)) {\n      testFailures = testFailures :+ st\"'Defective_Battery' did not match expected: ${Defective_BatteryValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Voltage_OORValue: Z = if(get_Voltage_OOR().nonEmpty) z\"1\" else z\"0\"\n    if(!Voltage_OOR(Voltage_OORValue)) {\n      testFailures = testFailures :+ st\"'Voltage_OOR' did not match expected: ${Voltage_OORValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Battery_Voltage(value : Physical_Types.Voltage_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Battery_Voltage_Id, Physical_Types.Voltage_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Battery_Current(value : Physical_Types.Current_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Battery_Current_Id, Physical_Types.Current_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Power_Voltage(value : Physical_Types.Voltage_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Power_Voltage_Id, Physical_Types.Voltage_imp_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_Using_Battery_Power(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_Using_Battery_Power_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Using_Battery_Power.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Using_Battery_Power_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Using_Battery_Power_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Remaining_Battery_Time(): Option[BLESS_Types.Time] = {\n    val value: Option[BLESS_Types.Time] = get_Remaining_Battery_Time_payload() match {\n      case Some(BLESS_Types.Time_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Remaining_Battery_Time.  Expecting 'BLESS_Types.Time_Payload' but received ${v}\")\n      case _ => None[BLESS_Types.Time]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Remaining_Battery_Time_payload(): Option[BLESS_Types.Time_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Remaining_Battery_Time_Id).asInstanceOf[Option[BLESS_Types.Time_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Low_Battery_Warning(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Low_Battery_Warning_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Low_Battery_Warning.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Low_Battery_Warning_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Low_Battery_Warning_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Defective_Battery(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Defective_Battery_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Defective_Battery.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Defective_Battery_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Defective_Battery_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Voltage_OOR(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Voltage_OOR_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Voltage_OOR.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Voltage_OOR_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Voltage_OOR_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Power\/power_control_imp_pump_power_pwr_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Power._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass power_control_imp_pump_power_pwr_Test extends power_control_imp_pump_power_pwr_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/power_control_imp_pump_power_pwr_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Power.{power_control_imp_pump_power_pwr => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class power_control_imp_pump_power_pwr_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Battery_Voltage: Port[Physical_Types.Voltage_imp],\n  Battery_Current: Port[Physical_Types.Current_imp],\n  Power_Voltage: Port[Physical_Types.Voltage_imp],\n  Using_Battery_Power: Port[Base_Types.Boolean],\n  Remaining_Battery_Time: Port[BLESS_Types.Time],\n  Low_Battery_Warning: Port[art.Empty],\n  Defective_Battery: Port[art.Empty],\n  Voltage_OOR: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Battery_Voltage,\n              Battery_Current,\n              Power_Voltage,\n              Using_Battery_Power,\n              Remaining_Battery_Time,\n              Low_Battery_Warning,\n              Defective_Battery,\n              Voltage_OOR),\n\n    dataIns = ISZ(Battery_Voltage,\n                  Battery_Current,\n                  Power_Voltage),\n\n    dataOuts = ISZ(Using_Battery_Power,\n                   Remaining_Battery_Time),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Low_Battery_Warning,\n                    Defective_Battery,\n                    Voltage_OOR)\n  )\n\n  val initialization_api : power_control_imp_Initialization_Api = {\n    val api = power_control_imp_Initialization_Api(\n      id,\n      Battery_Voltage.id,\n      Battery_Current.id,\n      Power_Voltage.id,\n      Using_Battery_Power.id,\n      Remaining_Battery_Time.id,\n      Low_Battery_Warning.id,\n      Defective_Battery.id,\n      Voltage_OOR.id\n    )\n    power_control_imp_pump_power_pwr_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : power_control_imp_Operational_Api = {\n    val api = power_control_imp_Operational_Api(\n      id,\n      Battery_Voltage.id,\n      Battery_Current.id,\n      Power_Voltage.id,\n      Using_Battery_Power.id,\n      Remaining_Battery_Time.id,\n      Low_Battery_Warning.id,\n      Defective_Battery.id,\n      Voltage_OOR.id\n    )\n    power_control_imp_pump_power_pwr_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    power_control_imp_pump_power_pwr_Bridge.EntryPoints(\n      id,\n\n      Battery_Voltage.id,\n      Battery_Current.id,\n      Power_Voltage.id,\n      Using_Battery_Power.id,\n      Remaining_Battery_Time.id,\n      Low_Battery_Warning.id,\n      Defective_Battery.id,\n      Voltage_OOR.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject power_control_imp_pump_power_pwr_Bridge {\n\n  var c_initialization_api: Option[power_control_imp_Initialization_Api] = None()\n  var c_operational_api: Option[power_control_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    power_control_imp_pump_power_pwr_BridgeId : Art.BridgeId,\n\n    Battery_Voltage_Id : Art.PortId,\n    Battery_Current_Id : Art.PortId,\n    Power_Voltage_Id : Art.PortId,\n    Using_Battery_Power_Id : Art.PortId,\n    Remaining_Battery_Time_Id : Art.PortId,\n    Low_Battery_Warning_Id : Art.PortId,\n    Defective_Battery_Id : Art.PortId,\n    Voltage_OOR_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: power_control_imp_Initialization_Api,\n    operational_api: power_control_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Battery_Voltage_Id,\n                                             Battery_Current_Id,\n                                             Power_Voltage_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Using_Battery_Power_Id,\n                                              Remaining_Battery_Time_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Low_Battery_Warning_Id,\n                                               Defective_Battery_Id,\n                                               Voltage_OOR_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: power_control_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: power_control_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: power_control_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: power_control_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: power_control_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: power_control_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: power_control_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/power_control_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait power_control_imp_Api {\n  def id: Art.BridgeId\n  def Battery_Voltage_Id : Art.PortId\n  def Battery_Current_Id : Art.PortId\n  def Power_Voltage_Id : Art.PortId\n  def Using_Battery_Power_Id : Art.PortId\n  def Remaining_Battery_Time_Id : Art.PortId\n  def Low_Battery_Warning_Id : Art.PortId\n  def Defective_Battery_Id : Art.PortId\n  def Voltage_OOR_Id : Art.PortId\n\n  def put_Using_Battery_Power(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(Using_Battery_Power_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def put_Remaining_Battery_Time(value : BLESS_Types.Time) : Unit = {\n    Art.putValue(Remaining_Battery_Time_Id, BLESS_Types.Time_Payload(value))\n  }\n\n  def put_Low_Battery_Warning() : Unit = {\n    Art.putValue(Low_Battery_Warning_Id, art.Empty())\n  }\n\n  def put_Defective_Battery() : Unit = {\n    Art.putValue(Defective_Battery_Id, art.Empty())\n  }\n\n  def put_Voltage_OOR() : Unit = {\n    Art.putValue(Voltage_OOR_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class power_control_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Battery_Voltage_Id : Art.PortId,\n  val Battery_Current_Id : Art.PortId,\n  val Power_Voltage_Id : Art.PortId,\n  val Using_Battery_Power_Id : Art.PortId,\n  val Remaining_Battery_Time_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Defective_Battery_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId) extends power_control_imp_Api\n\n@datatype class power_control_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Battery_Voltage_Id : Art.PortId,\n  val Battery_Current_Id : Art.PortId,\n  val Power_Voltage_Id : Art.PortId,\n  val Using_Battery_Power_Id : Art.PortId,\n  val Remaining_Battery_Time_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Defective_Battery_Id : Art.PortId,\n  val Voltage_OOR_Id : Art.PortId) extends power_control_imp_Api {\n\n  def get_Battery_Voltage() : Option[Physical_Types.Voltage_imp] = {\n    val value : Option[Physical_Types.Voltage_imp] = Art.getValue(Battery_Voltage_Id) match {\n      case Some(Physical_Types.Voltage_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Battery_Voltage.  Expecting 'Physical_Types.Voltage_imp_Payload' but received ${v}\")\n        None[Physical_Types.Voltage_imp]()\n      case _ => None[Physical_Types.Voltage_imp]()\n    }\n    return value\n  }\n\n  def get_Battery_Current() : Option[Physical_Types.Current_imp] = {\n    val value : Option[Physical_Types.Current_imp] = Art.getValue(Battery_Current_Id) match {\n      case Some(Physical_Types.Current_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Battery_Current.  Expecting 'Physical_Types.Current_imp_Payload' but received ${v}\")\n        None[Physical_Types.Current_imp]()\n      case _ => None[Physical_Types.Current_imp]()\n    }\n    return value\n  }\n\n  def get_Power_Voltage() : Option[Physical_Types.Voltage_imp] = {\n    val value : Option[Physical_Types.Voltage_imp] = Art.getValue(Power_Voltage_Id) match {\n      case Some(Physical_Types.Voltage_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Power_Voltage.  Expecting 'Physical_Types.Voltage_imp_Payload' but received ${v}\")\n        None[Physical_Types.Voltage_imp]()\n      case _ => None[Physical_Types.Voltage_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Power\/power_control_imp_pump_power_pwr.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject power_control_imp_pump_power_pwr {\n\n  def initialise(api: power_control_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Using_Battery_Power(Base_Types.Boolean_example())\n    api.put_Remaining_Battery_Time(BLESS_Types.Time.example())\n    api.put_Low_Battery_Warning()\n    api.put_Defective_Battery()\n    api.put_Voltage_OOR()\n  }\n\n  def timeTriggered(api: power_control_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Battery_Voltage: Option[Physical_Types.Voltage_imp] = api.get_Battery_Voltage()\n    api.logInfo(s\"Received on Battery_Voltage: ${apiUsage_Battery_Voltage}\")\n    val apiUsage_Battery_Current: Option[Physical_Types.Current_imp] = api.get_Battery_Current()\n    api.logInfo(s\"Received on Battery_Current: ${apiUsage_Battery_Current}\")\n    val apiUsage_Power_Voltage: Option[Physical_Types.Voltage_imp] = api.get_Power_Voltage()\n    api.logInfo(s\"Received on Power_Voltage: ${apiUsage_Power_Voltage}\")\n  }\n\n  def activate(api: power_control_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: power_control_imp_Operational_Api): Unit = { }\n\n  def finalise(api: power_control_imp_Operational_Api): Unit = { }\n\n  def recover(api: power_control_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Power\/battery_imp_pump_power_btty_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class battery_imp_pump_power_btty_TestApi extends BridgeTestSuite[battery_imp_pump_power_btty_Bridge](Arch.wrap_pca_imp_Instance_pump_power_btty) {\n\n  \/** helper function to check battery_imp_pump_power_btty's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Battery_Voltage method that will be called with the value of the outgoing data\n   *        port 'Battery_Voltage'.\n   * @param Battery_Current method that will be called with the value of the outgoing data\n   *        port 'Battery_Current'.\n   *\/\n  def check_concrete_output(Battery_Voltage: Physical_Types.Voltage_imp => B = Battery_VoltageParam => {T},\n                            Battery_Current: Physical_Types.Current_imp => B = Battery_CurrentParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Battery_VoltageValue: Physical_Types.Voltage_imp = get_Battery_Voltage().get\n    if(!Battery_Voltage(Battery_VoltageValue)) {\n      testFailures = testFailures :+ st\"'Battery_Voltage' did not match expected: value of the outgoing data port is ${Battery_VoltageValue}\"\n    }\n    val Battery_CurrentValue: Physical_Types.Current_imp = get_Battery_Current().get\n    if(!Battery_Current(Battery_CurrentValue)) {\n      testFailures = testFailures :+ st\"'Battery_Current' did not match expected: value of the outgoing data port is ${Battery_CurrentValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_Battery_Voltage(): Option[Physical_Types.Voltage_imp] = {\n    val value: Option[Physical_Types.Voltage_imp] = get_Battery_Voltage_payload() match {\n      case Some(Physical_Types.Voltage_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Battery_Voltage.  Expecting 'Physical_Types.Voltage_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Voltage_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Battery_Voltage_payload(): Option[Physical_Types.Voltage_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Battery_Voltage_Id).asInstanceOf[Option[Physical_Types.Voltage_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Battery_Current(): Option[Physical_Types.Current_imp] = {\n    val value: Option[Physical_Types.Current_imp] = get_Battery_Current_payload() match {\n      case Some(Physical_Types.Current_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Battery_Current.  Expecting 'Physical_Types.Current_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Current_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Battery_Current_payload(): Option[Physical_Types.Current_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Battery_Current_Id).asInstanceOf[Option[Physical_Types.Current_imp_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Power\/battery_imp_pump_power_btty_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Power._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass battery_imp_pump_power_btty_Test extends battery_imp_pump_power_btty_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/battery_imp_pump_power_btty_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Power.{battery_imp_pump_power_btty => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class battery_imp_pump_power_btty_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Battery_Voltage: Port[Physical_Types.Voltage_imp],\n  Battery_Current: Port[Physical_Types.Current_imp]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Battery_Voltage,\n              Battery_Current),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(Battery_Voltage,\n                   Battery_Current),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : battery_imp_Initialization_Api = {\n    val api = battery_imp_Initialization_Api(\n      id,\n      Battery_Voltage.id,\n      Battery_Current.id\n    )\n    battery_imp_pump_power_btty_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : battery_imp_Operational_Api = {\n    val api = battery_imp_Operational_Api(\n      id,\n      Battery_Voltage.id,\n      Battery_Current.id\n    )\n    battery_imp_pump_power_btty_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    battery_imp_pump_power_btty_Bridge.EntryPoints(\n      id,\n\n      Battery_Voltage.id,\n      Battery_Current.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject battery_imp_pump_power_btty_Bridge {\n\n  var c_initialization_api: Option[battery_imp_Initialization_Api] = None()\n  var c_operational_api: Option[battery_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    battery_imp_pump_power_btty_BridgeId : Art.BridgeId,\n\n    Battery_Voltage_Id : Art.PortId,\n    Battery_Current_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: battery_imp_Initialization_Api,\n    operational_api: battery_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Battery_Voltage_Id,\n                                              Battery_Current_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: battery_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: battery_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: battery_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: battery_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: battery_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: battery_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: battery_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/battery_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait battery_imp_Api {\n  def id: Art.BridgeId\n  def Battery_Voltage_Id : Art.PortId\n  def Battery_Current_Id : Art.PortId\n\n  def put_Battery_Voltage(value : Physical_Types.Voltage_imp) : Unit = {\n    Art.putValue(Battery_Voltage_Id, Physical_Types.Voltage_imp_Payload(value))\n  }\n\n  def put_Battery_Current(value : Physical_Types.Current_imp) : Unit = {\n    Art.putValue(Battery_Current_Id, Physical_Types.Current_imp_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class battery_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Battery_Voltage_Id : Art.PortId,\n  val Battery_Current_Id : Art.PortId) extends battery_imp_Api\n\n@datatype class battery_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Battery_Voltage_Id : Art.PortId,\n  val Battery_Current_Id : Art.PortId) extends battery_imp_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Power\/battery_imp_pump_power_btty.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject battery_imp_pump_power_btty {\n\n  def initialise(api: battery_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Battery_Voltage(Physical_Types.Voltage_imp.example())\n    api.put_Battery_Current(Physical_Types.Current_imp.example())\n  }\n\n  def timeTriggered(api: battery_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n\n  }\n\n  def activate(api: battery_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: battery_imp_Operational_Api): Unit = { }\n\n  def finalise(api: battery_imp_Operational_Api): Unit = { }\n\n  def recover(api: battery_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Power\/power_supply_imp_pump_power_vcc_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class power_supply_imp_pump_power_vcc_TestApi extends BridgeTestSuite[power_supply_imp_pump_power_vcc_Bridge](Arch.wrap_pca_imp_Instance_pump_power_vcc) {\n\n  \/** helper function to check power_supply_imp_pump_power_vcc's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Power_Voltage method that will be called with the value of the outgoing data\n   *        port 'Power_Voltage'.\n   *\/\n  def check_concrete_output(Power_Voltage: Physical_Types.Voltage_imp => B = Power_VoltageParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Power_VoltageValue: Physical_Types.Voltage_imp = get_Power_Voltage().get\n    if(!Power_Voltage(Power_VoltageValue)) {\n      testFailures = testFailures :+ st\"'Power_Voltage' did not match expected: value of the outgoing data port is ${Power_VoltageValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_Power_Voltage(): Option[Physical_Types.Voltage_imp] = {\n    val value: Option[Physical_Types.Voltage_imp] = get_Power_Voltage_payload() match {\n      case Some(Physical_Types.Voltage_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Power_Voltage.  Expecting 'Physical_Types.Voltage_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Voltage_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Power_Voltage_payload(): Option[Physical_Types.Voltage_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Power_Voltage_Id).asInstanceOf[Option[Physical_Types.Voltage_imp_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Power\/power_supply_imp_pump_power_vcc_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Power._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass power_supply_imp_pump_power_vcc_Test extends power_supply_imp_pump_power_vcc_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/power_supply_imp_pump_power_vcc_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Power.{power_supply_imp_pump_power_vcc => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class power_supply_imp_pump_power_vcc_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Power_Voltage: Port[Physical_Types.Voltage_imp]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Power_Voltage),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(Power_Voltage),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : power_supply_imp_Initialization_Api = {\n    val api = power_supply_imp_Initialization_Api(\n      id,\n      Power_Voltage.id\n    )\n    power_supply_imp_pump_power_vcc_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : power_supply_imp_Operational_Api = {\n    val api = power_supply_imp_Operational_Api(\n      id,\n      Power_Voltage.id\n    )\n    power_supply_imp_pump_power_vcc_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    power_supply_imp_pump_power_vcc_Bridge.EntryPoints(\n      id,\n\n      Power_Voltage.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject power_supply_imp_pump_power_vcc_Bridge {\n\n  var c_initialization_api: Option[power_supply_imp_Initialization_Api] = None()\n  var c_operational_api: Option[power_supply_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    power_supply_imp_pump_power_vcc_BridgeId : Art.BridgeId,\n\n    Power_Voltage_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: power_supply_imp_Initialization_Api,\n    operational_api: power_supply_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Power_Voltage_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: power_supply_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: power_supply_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: power_supply_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: power_supply_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: power_supply_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: power_supply_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: power_supply_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Power\/power_supply_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait power_supply_imp_Api {\n  def id: Art.BridgeId\n  def Power_Voltage_Id : Art.PortId\n\n  def put_Power_Voltage(value : Physical_Types.Voltage_imp) : Unit = {\n    Art.putValue(Power_Voltage_Id, Physical_Types.Voltage_imp_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class power_supply_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Power_Voltage_Id : Art.PortId) extends power_supply_imp_Api\n\n@datatype class power_supply_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Power_Voltage_Id : Art.PortId) extends power_supply_imp_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Power\/power_supply_imp_pump_power_vcc.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Power\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject power_supply_imp_pump_power_vcc {\n\n  def initialise(api: power_supply_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Power_Voltage(Physical_Types.Voltage_imp.example())\n  }\n\n  def timeTriggered(api: power_supply_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n\n  }\n\n  def activate(api: power_supply_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: power_supply_imp_Operational_Api): Unit = { }\n\n  def finalise(api: power_supply_imp_Operational_Api): Unit = { }\n\n  def recover(api: power_supply_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/patient_button_imp_pump_operation_patient_button_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class patient_button_imp_pump_operation_patient_button_TestApi extends BridgeTestSuite[patient_button_imp_pump_operation_patient_button_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_patient_button) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Button_Press the number of events to place in the Button_Press event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Button_Press : Z): Unit = {\n    for(i <- 0 until Button_Press) {\n      put_Button_Press()\n    }\n  }\n\n\n  \/** helper function to check patient_button_imp_pump_operation_patient_button's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Request_Bolus method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Request_Bolus'.\n   *\/\n  def check_concrete_output(Request_Bolus: Z => B = Request_BolusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Request_BolusValue: Z = if(get_Request_Bolus().nonEmpty) z\"1\" else z\"0\"\n    if(!Request_Bolus(Request_BolusValue)) {\n      testFailures = testFailures :+ st\"'Request_Bolus' did not match expected: ${Request_BolusValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_Button_Press(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Button_Press_Id, Empty())\n  }\n\n  \/\/ getter for out EventPort\n  def get_Request_Bolus(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Request_Bolus_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Request_Bolus.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Request_Bolus_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Request_Bolus_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/patient_button_imp_pump_operation_patient_button_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass patient_button_imp_pump_operation_patient_button_Test extends patient_button_imp_pump_operation_patient_button_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/patient_button_imp_pump_operation_patient_button_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{patient_button_imp_pump_operation_patient_button => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class patient_button_imp_pump_operation_patient_button_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Button_Press: Port[art.Empty],\n  Request_Bolus: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Button_Press,\n              Request_Bolus),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Button_Press),\n\n    eventOuts = ISZ(Request_Bolus)\n  )\n\n  val initialization_api : patient_button_imp_Initialization_Api = {\n    val api = patient_button_imp_Initialization_Api(\n      id,\n      Button_Press.id,\n      Request_Bolus.id\n    )\n    patient_button_imp_pump_operation_patient_button_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : patient_button_imp_Operational_Api = {\n    val api = patient_button_imp_Operational_Api(\n      id,\n      Button_Press.id,\n      Request_Bolus.id\n    )\n    patient_button_imp_pump_operation_patient_button_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    patient_button_imp_pump_operation_patient_button_Bridge.EntryPoints(\n      id,\n\n      Button_Press.id,\n      Request_Bolus.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject patient_button_imp_pump_operation_patient_button_Bridge {\n\n  var c_initialization_api: Option[patient_button_imp_Initialization_Api] = None()\n  var c_operational_api: Option[patient_button_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    patient_button_imp_pump_operation_patient_button_BridgeId : Art.BridgeId,\n\n    Button_Press_Id : Art.PortId,\n    Request_Bolus_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: patient_button_imp_Initialization_Api,\n    operational_api: patient_button_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Button_Press_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Request_Bolus_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(patient_button_imp_pump_operation_patient_button_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Button_Press_Id) {\n          \/\/ implement the following in 'component':  def handle_Button_Press(api: patient_button_imp_Operational_Api): Unit = {}\n          component.handle_Button_Press(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(patient_button_imp_pump_operation_patient_button_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Button_Press_Id) {\n          \/\/ implement the following in 'component':  def handle_Button_Press(api: patient_button_imp_Operational_Api): Unit = {}\n          component.handle_Button_Press(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: patient_button_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: patient_button_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: patient_button_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: patient_button_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: patient_button_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/patient_button_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait patient_button_imp_Api {\n  def id: Art.BridgeId\n  def Button_Press_Id : Art.PortId\n  def Request_Bolus_Id : Art.PortId\n\n  def put_Request_Bolus() : Unit = {\n    Art.putValue(Request_Bolus_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class patient_button_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Button_Press_Id : Art.PortId,\n  val Request_Bolus_Id : Art.PortId) extends patient_button_imp_Api\n\n@datatype class patient_button_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Button_Press_Id : Art.PortId,\n  val Request_Bolus_Id : Art.PortId) extends patient_button_imp_Api {\n\n  def get_Button_Press() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Button_Press_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Button_Press.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/patient_button_imp_pump_operation_patient_button.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject patient_button_imp_pump_operation_patient_button {\n\n  def initialise(api: patient_button_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Request_Bolus()\n  }\n\n  def handle_Button_Press(api: patient_button_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Button_Press implementation\")\n    api.logInfo(\"received Button_Press event\")\n    \/\/ example api usage\n\n    val apiUsage_Button_Press: Option[art.Empty] = api.get_Button_Press()\n    api.logInfo(s\"Received on Button_Press: ${apiUsage_Button_Press}\")\n  }\n\n  def activate(api: patient_button_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: patient_button_imp_Operational_Api): Unit = { }\n\n  def finalise(api: patient_button_imp_Operational_Api): Unit = { }\n\n  def recover(api: patient_button_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/scanner_imp_pump_operation_scanner_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class scanner_imp_pump_operation_scanner_TestApi extends BridgeTestSuite[scanner_imp_pump_operation_scanner_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_scanner) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Do_Scan the number of events to place in the Do_Scan event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Do_Scan : Z): Unit = {\n    for(i <- 0 until Do_Scan) {\n      put_Do_Scan()\n    }\n  }\n\n\n  \/** helper function to check scanner_imp_pump_operation_scanner's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Scan_Data method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Scan_Data'.\n   * @param Scan_Done method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Scan_Done'.\n   *\/\n  def check_concrete_output(Scan_Data: ISZ[PCA_Types.Scan_Data_Type] => B = Scan_DataParam => {T},\n                            Scan_Done: Z => B = Scan_DoneParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Scan_DataValue: ISZ[PCA_Types.Scan_Data_Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Scan_Data().nonEmpty) Scan_DataValue = Scan_DataValue :+ get_Scan_Data().get\n    if(!Scan_Data(Scan_DataValue)) {\n      testFailures = testFailures :+ st\"'Scan_Data' did not match expected: received ${Scan_DataValue.size} events with the following payloads ${Scan_DataValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Scan_DoneValue: Z = if(get_Scan_Done().nonEmpty) z\"1\" else z\"0\"\n    if(!Scan_Done(Scan_DoneValue)) {\n      testFailures = testFailures :+ st\"'Scan_Done' did not match expected: ${Scan_DoneValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_Do_Scan(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Do_Scan_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Scan_Data(): Option[PCA_Types.Scan_Data_Type] = {\n    val value: Option[PCA_Types.Scan_Data_Type] = get_Scan_Data_payload() match {\n      case Some(PCA_Types.Scan_Data_Type_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Scan_Data.  Expecting 'PCA_Types.Scan_Data_Type_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Scan_Data_Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Scan_Data_payload(): Option[PCA_Types.Scan_Data_Type_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Scan_Data_Id).asInstanceOf[Option[PCA_Types.Scan_Data_Type_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Scan_Done(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Scan_Done_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Scan_Done.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Scan_Done_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Scan_Done_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/scanner_imp_pump_operation_scanner_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass scanner_imp_pump_operation_scanner_Test extends scanner_imp_pump_operation_scanner_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/scanner_imp_pump_operation_scanner_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{scanner_imp_pump_operation_scanner => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class scanner_imp_pump_operation_scanner_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Scan_Data: Port[PCA_Types.Scan_Data_Type],\n  Do_Scan: Port[art.Empty],\n  Scan_Done: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Scan_Data,\n              Do_Scan,\n              Scan_Done),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Do_Scan),\n\n    eventOuts = ISZ(Scan_Data,\n                    Scan_Done)\n  )\n\n  val initialization_api : scanner_imp_Initialization_Api = {\n    val api = scanner_imp_Initialization_Api(\n      id,\n      Scan_Data.id,\n      Do_Scan.id,\n      Scan_Done.id\n    )\n    scanner_imp_pump_operation_scanner_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : scanner_imp_Operational_Api = {\n    val api = scanner_imp_Operational_Api(\n      id,\n      Scan_Data.id,\n      Do_Scan.id,\n      Scan_Done.id\n    )\n    scanner_imp_pump_operation_scanner_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    scanner_imp_pump_operation_scanner_Bridge.EntryPoints(\n      id,\n\n      Scan_Data.id,\n      Do_Scan.id,\n      Scan_Done.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject scanner_imp_pump_operation_scanner_Bridge {\n\n  var c_initialization_api: Option[scanner_imp_Initialization_Api] = None()\n  var c_operational_api: Option[scanner_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    scanner_imp_pump_operation_scanner_BridgeId : Art.BridgeId,\n\n    Scan_Data_Id : Art.PortId,\n    Do_Scan_Id : Art.PortId,\n    Scan_Done_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: scanner_imp_Initialization_Api,\n    operational_api: scanner_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Do_Scan_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Scan_Data_Id,\n                                               Scan_Done_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(scanner_imp_pump_operation_scanner_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Do_Scan_Id) {\n          \/\/ implement the following in 'component':  def handle_Do_Scan(api: scanner_imp_Operational_Api): Unit = {}\n          component.handle_Do_Scan(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(scanner_imp_pump_operation_scanner_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Do_Scan_Id) {\n          \/\/ implement the following in 'component':  def handle_Do_Scan(api: scanner_imp_Operational_Api): Unit = {}\n          component.handle_Do_Scan(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: scanner_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: scanner_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: scanner_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: scanner_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: scanner_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/scanner_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait scanner_imp_Api {\n  def id: Art.BridgeId\n  def Scan_Data_Id : Art.PortId\n  def Do_Scan_Id : Art.PortId\n  def Scan_Done_Id : Art.PortId\n\n  def put_Scan_Data(value : PCA_Types.Scan_Data_Type) : Unit = {\n    Art.putValue(Scan_Data_Id, PCA_Types.Scan_Data_Type_Payload(value))\n  }\n\n  def put_Scan_Done() : Unit = {\n    Art.putValue(Scan_Done_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class scanner_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Scan_Data_Id : Art.PortId,\n  val Do_Scan_Id : Art.PortId,\n  val Scan_Done_Id : Art.PortId) extends scanner_imp_Api\n\n@datatype class scanner_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Scan_Data_Id : Art.PortId,\n  val Do_Scan_Id : Art.PortId,\n  val Scan_Done_Id : Art.PortId) extends scanner_imp_Api {\n\n  def get_Do_Scan() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Do_Scan_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Do_Scan.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/scanner_imp_pump_operation_scanner.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject scanner_imp_pump_operation_scanner {\n\n  def initialise(api: scanner_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Scan_Data(PCA_Types.Scan_Data_Type.example())\n    api.put_Scan_Done()\n  }\n\n  def handle_Do_Scan(api: scanner_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Do_Scan implementation\")\n    api.logInfo(\"received Do_Scan event\")\n    \/\/ example api usage\n\n    val apiUsage_Do_Scan: Option[art.Empty] = api.get_Do_Scan()\n    api.logInfo(s\"Received on Do_Scan: ${apiUsage_Do_Scan}\")\n  }\n\n  def activate(api: scanner_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: scanner_imp_Operational_Api): Unit = { }\n\n  def finalise(api: scanner_imp_Operational_Api): Unit = { }\n\n  def recover(api: scanner_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Drug_Library\/drug_library_thread_imp_pump_operation_operation_process_drug_library_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Drug_Library\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class drug_library_thread_imp_pump_operation_operation_process_drug_library_TestApi extends BridgeTestSuite[drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_drug_library) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Load_Drug_Library payloads for event data port Load_Drug_Library.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Load_Drug_Library will be used\n   * @param Get_Drug_Record payloads for event data port Get_Drug_Record.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Get_Drug_Record will be used\n   *\/\n  def put_concrete_inputs(Load_Drug_Library : ISZ[PCA_Types.Drug_Library],\n                          Get_Drug_Record : ISZ[PCA_Types.Drug_Code_imp]): Unit = {\n    for(v <- Load_Drug_Library){\n      put_Load_Drug_Library(v)\n    }\n    for(v <- Get_Drug_Record){\n      put_Get_Drug_Record(v)\n    }\n  }\n\n\n  \/** helper function to check drug_library_thread_imp_pump_operation_operation_process_drug_library's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param The_Drug_Record method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'The_Drug_Record'.\n   * @param No_Drug_Found method that will be called with the number of events to be sent\n   *        on the outgoing event port 'No_Drug_Found'.\n   *\/\n  def check_concrete_output(The_Drug_Record: ISZ[PCA_Types.Drug_Record_imp] => B = The_Drug_RecordParam => {T},\n                            No_Drug_Found: Z => B = No_Drug_FoundParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var The_Drug_RecordValue: ISZ[PCA_Types.Drug_Record_imp] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_The_Drug_Record().nonEmpty) The_Drug_RecordValue = The_Drug_RecordValue :+ get_The_Drug_Record().get\n    if(!The_Drug_Record(The_Drug_RecordValue)) {\n      testFailures = testFailures :+ st\"'The_Drug_Record' did not match expected: received ${The_Drug_RecordValue.size} events with the following payloads ${The_Drug_RecordValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val No_Drug_FoundValue: Z = if(get_No_Drug_Found().nonEmpty) z\"1\" else z\"0\"\n    if(!No_Drug_Found(No_Drug_FoundValue)) {\n      testFailures = testFailures :+ st\"'No_Drug_Found' did not match expected: ${No_Drug_FoundValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Load_Drug_Library(value : PCA_Types.Drug_Library): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Load_Drug_Library_Id, PCA_Types.Drug_Library_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Get_Drug_Record(value : PCA_Types.Drug_Code_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Get_Drug_Record_Id, PCA_Types.Drug_Code_imp_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_The_Drug_Record(): Option[PCA_Types.Drug_Record_imp] = {\n    val value: Option[PCA_Types.Drug_Record_imp] = get_The_Drug_Record_payload() match {\n      case Some(PCA_Types.Drug_Record_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port The_Drug_Record.  Expecting 'PCA_Types.Drug_Record_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Record_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_The_Drug_Record_payload(): Option[PCA_Types.Drug_Record_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.The_Drug_Record_Id).asInstanceOf[Option[PCA_Types.Drug_Record_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_No_Drug_Found(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_No_Drug_Found_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port No_Drug_Found.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_No_Drug_Found_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.No_Drug_Found_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Drug_Library\/drug_library_thread_imp_pump_operation_operation_process_drug_library_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Drug_Library\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Drug_Library._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass drug_library_thread_imp_pump_operation_operation_process_drug_library_Test extends drug_library_thread_imp_pump_operation_operation_process_drug_library_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Drug_Library\/drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Drug_Library\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Drug_Library.{drug_library_thread_imp_pump_operation_operation_process_drug_library => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Load_Drug_Library: Port[PCA_Types.Drug_Library],\n  Get_Drug_Record: Port[PCA_Types.Drug_Code_imp],\n  The_Drug_Record: Port[PCA_Types.Drug_Record_imp],\n  No_Drug_Found: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Load_Drug_Library,\n              Get_Drug_Record,\n              The_Drug_Record,\n              No_Drug_Found),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Load_Drug_Library,\n                   Get_Drug_Record),\n\n    eventOuts = ISZ(The_Drug_Record,\n                    No_Drug_Found)\n  )\n\n  val initialization_api : drug_library_thread_imp_Initialization_Api = {\n    val api = drug_library_thread_imp_Initialization_Api(\n      id,\n      Load_Drug_Library.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      No_Drug_Found.id\n    )\n    drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : drug_library_thread_imp_Operational_Api = {\n    val api = drug_library_thread_imp_Operational_Api(\n      id,\n      Load_Drug_Library.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      No_Drug_Found.id\n    )\n    drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge.EntryPoints(\n      id,\n\n      Load_Drug_Library.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      No_Drug_Found.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject drug_library_thread_imp_pump_operation_operation_process_drug_library_Bridge {\n\n  var c_initialization_api: Option[drug_library_thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[drug_library_thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    drug_library_thread_imp_pump_operation_operation_process_drug_library_BridgeId : Art.BridgeId,\n\n    Load_Drug_Library_Id : Art.PortId,\n    Get_Drug_Record_Id : Art.PortId,\n    The_Drug_Record_Id : Art.PortId,\n    No_Drug_Found_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: drug_library_thread_imp_Initialization_Api,\n    operational_api: drug_library_thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Load_Drug_Library_Id,\n                                              Get_Drug_Record_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(The_Drug_Record_Id,\n                                               No_Drug_Found_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(drug_library_thread_imp_pump_operation_operation_process_drug_library_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Load_Drug_Library_Id){\n          val Some(PCA_Types.Drug_Library_Payload(value)) = Art.getValue(Load_Drug_Library_Id)\n\n          \/\/ implement the following in 'component':  def handle_Load_Drug_Library(api: drug_library_thread_imp_Operational_Api, value: PCA_Types.Drug_Library): Unit = {}\n          component.handle_Load_Drug_Library(operational_api, value)\n        }\n        else if(portId == Get_Drug_Record_Id){\n          val Some(PCA_Types.Drug_Code_imp_Payload(value)) = Art.getValue(Get_Drug_Record_Id)\n\n          \/\/ implement the following in 'component':  def handle_Get_Drug_Record(api: drug_library_thread_imp_Operational_Api, value: PCA_Types.Drug_Code_imp): Unit = {}\n          component.handle_Get_Drug_Record(operational_api, value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(drug_library_thread_imp_pump_operation_operation_process_drug_library_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Load_Drug_Library_Id){\n          val Some(PCA_Types.Drug_Library_Payload(value)) = Art.getValue(Load_Drug_Library_Id)\n\n          \/\/ implement the following in 'component':  def handle_Load_Drug_Library(api: drug_library_thread_imp_Operational_Api, value: PCA_Types.Drug_Library): Unit = {}\n          component.handle_Load_Drug_Library(operational_api, value)\n        }\n        else if(portId == Get_Drug_Record_Id){\n          val Some(PCA_Types.Drug_Code_imp_Payload(value)) = Art.getValue(Get_Drug_Record_Id)\n\n          \/\/ implement the following in 'component':  def handle_Get_Drug_Record(api: drug_library_thread_imp_Operational_Api, value: PCA_Types.Drug_Code_imp): Unit = {}\n          component.handle_Get_Drug_Record(operational_api, value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: drug_library_thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: drug_library_thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: drug_library_thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: drug_library_thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: drug_library_thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Drug_Library\/drug_library_thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Drug_Library\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait drug_library_thread_imp_Api {\n  def id: Art.BridgeId\n  def Load_Drug_Library_Id : Art.PortId\n  def Get_Drug_Record_Id : Art.PortId\n  def The_Drug_Record_Id : Art.PortId\n  def No_Drug_Found_Id : Art.PortId\n\n  def put_The_Drug_Record(value : PCA_Types.Drug_Record_imp) : Unit = {\n    Art.putValue(The_Drug_Record_Id, PCA_Types.Drug_Record_imp_Payload(value))\n  }\n\n  def put_No_Drug_Found() : Unit = {\n    Art.putValue(No_Drug_Found_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class drug_library_thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Load_Drug_Library_Id : Art.PortId,\n  val Get_Drug_Record_Id : Art.PortId,\n  val The_Drug_Record_Id : Art.PortId,\n  val No_Drug_Found_Id : Art.PortId) extends drug_library_thread_imp_Api\n\n@datatype class drug_library_thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Load_Drug_Library_Id : Art.PortId,\n  val Get_Drug_Record_Id : Art.PortId,\n  val The_Drug_Record_Id : Art.PortId,\n  val No_Drug_Found_Id : Art.PortId) extends drug_library_thread_imp_Api {\n\n  def get_Load_Drug_Library() : Option[PCA_Types.Drug_Library] = {\n    val value : Option[PCA_Types.Drug_Library] = Art.getValue(Load_Drug_Library_Id) match {\n      case Some(PCA_Types.Drug_Library_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Load_Drug_Library.  Expecting 'PCA_Types.Drug_Library_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Library]()\n      case _ => None[PCA_Types.Drug_Library]()\n    }\n    return value\n  }\n\n  def get_Get_Drug_Record() : Option[PCA_Types.Drug_Code_imp] = {\n    val value : Option[PCA_Types.Drug_Code_imp] = Art.getValue(Get_Drug_Record_Id) match {\n      case Some(PCA_Types.Drug_Code_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Get_Drug_Record.  Expecting 'PCA_Types.Drug_Code_imp_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Code_imp]()\n      case _ => None[PCA_Types.Drug_Code_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Drug_Library\/drug_library_thread_imp_pump_operation_operation_process_drug_library.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Drug_Library\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject drug_library_thread_imp_pump_operation_operation_process_drug_library {\n\n  def initialise(api: drug_library_thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_The_Drug_Record(PCA_Types.Drug_Record_imp.example())\n    api.put_No_Drug_Found()\n  }\n\n  def handle_Load_Drug_Library(api: drug_library_thread_imp_Operational_Api, value : PCA_Types.Drug_Library): Unit = {\n    api.logInfo(\"example handle_Load_Drug_Library implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Load_Drug_Library: Option[PCA_Types.Drug_Library] = api.get_Load_Drug_Library()\n    api.logInfo(s\"Received on Load_Drug_Library: ${apiUsage_Load_Drug_Library}\")\n    val apiUsage_Get_Drug_Record: Option[PCA_Types.Drug_Code_imp] = api.get_Get_Drug_Record()\n    api.logInfo(s\"Received on Get_Drug_Record: ${apiUsage_Get_Drug_Record}\")\n  }\n\n  def handle_Get_Drug_Record(api: drug_library_thread_imp_Operational_Api, value : PCA_Types.Drug_Code_imp): Unit = {\n    api.logInfo(\"example handle_Get_Drug_Record implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def activate(api: drug_library_thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: drug_library_thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: drug_library_thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: drug_library_thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation\/event_logger_thread_imp_pump_operation_operation_process_event_logger_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class event_logger_thread_imp_pump_operation_operation_process_event_logger_TestApi extends BridgeTestSuite[event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_event_logger) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Log_Event payloads for event data port Log_Event.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Log_Event will be used\n   * @param Get_Event_Log the number of events to place in the Get_Event_Log event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Log_Event : ISZ[PCA_Types.Event_Record],\n                          Get_Event_Log : Z): Unit = {\n    for(v <- Log_Event){\n      put_Log_Event(v)\n    }\n    for(i <- 0 until Get_Event_Log) {\n      put_Get_Event_Log()\n    }\n  }\n\n\n  \/** helper function to check event_logger_thread_imp_pump_operation_operation_process_event_logger's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param The_Event_Log method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'The_Event_Log'.\n   *\/\n  def check_concrete_output(The_Event_Log: ISZ[PCA_Types.Event_Log] => B = The_Event_LogParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var The_Event_LogValue: ISZ[PCA_Types.Event_Log] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_The_Event_Log().nonEmpty) The_Event_LogValue = The_Event_LogValue :+ get_The_Event_Log().get\n    if(!The_Event_Log(The_Event_LogValue)) {\n      testFailures = testFailures :+ st\"'The_Event_Log' did not match expected: received ${The_Event_LogValue.size} events with the following payloads ${The_Event_LogValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Log_Event(value : PCA_Types.Event_Record): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Log_Event_Id, PCA_Types.Event_Record_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Get_Event_Log(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Get_Event_Log_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_The_Event_Log(): Option[PCA_Types.Event_Log] = {\n    val value: Option[PCA_Types.Event_Log] = get_The_Event_Log_payload() match {\n      case Some(PCA_Types.Event_Log_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port The_Event_Log.  Expecting 'PCA_Types.Event_Log_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Event_Log]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_The_Event_Log_payload(): Option[PCA_Types.Event_Log_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.The_Event_Log_Id).asInstanceOf[Option[PCA_Types.Event_Log_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation\/event_logger_thread_imp_pump_operation_operation_process_event_logger_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass event_logger_thread_imp_pump_operation_operation_process_event_logger_Test extends event_logger_thread_imp_pump_operation_operation_process_event_logger_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation\/event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation.{event_logger_thread_imp_pump_operation_operation_process_event_logger => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Log_Event: Port[PCA_Types.Event_Record],\n  The_Event_Log: Port[PCA_Types.Event_Log],\n  Get_Event_Log: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Log_Event,\n              The_Event_Log,\n              Get_Event_Log),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Log_Event,\n                   Get_Event_Log),\n\n    eventOuts = ISZ(The_Event_Log)\n  )\n\n  val initialization_api : event_logger_thread_imp_Initialization_Api = {\n    val api = event_logger_thread_imp_Initialization_Api(\n      id,\n      Log_Event.id,\n      The_Event_Log.id,\n      Get_Event_Log.id\n    )\n    event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : event_logger_thread_imp_Operational_Api = {\n    val api = event_logger_thread_imp_Operational_Api(\n      id,\n      Log_Event.id,\n      The_Event_Log.id,\n      Get_Event_Log.id\n    )\n    event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge.EntryPoints(\n      id,\n\n      Log_Event.id,\n      The_Event_Log.id,\n      Get_Event_Log.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject event_logger_thread_imp_pump_operation_operation_process_event_logger_Bridge {\n\n  var c_initialization_api: Option[event_logger_thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[event_logger_thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    event_logger_thread_imp_pump_operation_operation_process_event_logger_BridgeId : Art.BridgeId,\n\n    Log_Event_Id : Art.PortId,\n    The_Event_Log_Id : Art.PortId,\n    Get_Event_Log_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: event_logger_thread_imp_Initialization_Api,\n    operational_api: event_logger_thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Log_Event_Id,\n                                              Get_Event_Log_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(The_Event_Log_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(event_logger_thread_imp_pump_operation_operation_process_event_logger_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Log_Event_Id){\n          val Some(PCA_Types.Event_Record_Payload(value)) = Art.getValue(Log_Event_Id)\n\n          \/\/ implement the following in 'component':  def handle_Log_Event(api: event_logger_thread_imp_Operational_Api, value: PCA_Types.Event_Record): Unit = {}\n          component.handle_Log_Event(operational_api, value)\n        }\n        else if(portId == Get_Event_Log_Id) {\n          \/\/ implement the following in 'component':  def handle_Get_Event_Log(api: event_logger_thread_imp_Operational_Api): Unit = {}\n          component.handle_Get_Event_Log(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(event_logger_thread_imp_pump_operation_operation_process_event_logger_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Log_Event_Id){\n          val Some(PCA_Types.Event_Record_Payload(value)) = Art.getValue(Log_Event_Id)\n\n          \/\/ implement the following in 'component':  def handle_Log_Event(api: event_logger_thread_imp_Operational_Api, value: PCA_Types.Event_Record): Unit = {}\n          component.handle_Log_Event(operational_api, value)\n        }\n        else if(portId == Get_Event_Log_Id) {\n          \/\/ implement the following in 'component':  def handle_Get_Event_Log(api: event_logger_thread_imp_Operational_Api): Unit = {}\n          component.handle_Get_Event_Log(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: event_logger_thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: event_logger_thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: event_logger_thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: event_logger_thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: event_logger_thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation\/event_logger_thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait event_logger_thread_imp_Api {\n  def id: Art.BridgeId\n  def Log_Event_Id : Art.PortId\n  def The_Event_Log_Id : Art.PortId\n  def Get_Event_Log_Id : Art.PortId\n\n  def put_The_Event_Log(value : PCA_Types.Event_Log) : Unit = {\n    Art.putValue(The_Event_Log_Id, PCA_Types.Event_Log_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class event_logger_thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Log_Event_Id : Art.PortId,\n  val The_Event_Log_Id : Art.PortId,\n  val Get_Event_Log_Id : Art.PortId) extends event_logger_thread_imp_Api\n\n@datatype class event_logger_thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Log_Event_Id : Art.PortId,\n  val The_Event_Log_Id : Art.PortId,\n  val Get_Event_Log_Id : Art.PortId) extends event_logger_thread_imp_Api {\n\n  def get_Log_Event() : Option[PCA_Types.Event_Record] = {\n    val value : Option[PCA_Types.Event_Record] = Art.getValue(Log_Event_Id) match {\n      case Some(PCA_Types.Event_Record_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Log_Event.  Expecting 'PCA_Types.Event_Record_Payload' but received ${v}\")\n        None[PCA_Types.Event_Record]()\n      case _ => None[PCA_Types.Event_Record]()\n    }\n    return value\n  }\n\n  def get_Get_Event_Log() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Get_Event_Log_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Get_Event_Log.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation\/event_logger_thread_imp_pump_operation_operation_process_event_logger.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject event_logger_thread_imp_pump_operation_operation_process_event_logger {\n\n  def initialise(api: event_logger_thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_The_Event_Log(PCA_Types.Event_Log.example())\n  }\n\n  def handle_Log_Event(api: event_logger_thread_imp_Operational_Api, value : PCA_Types.Event_Record): Unit = {\n    api.logInfo(\"example handle_Log_Event implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Log_Event: Option[PCA_Types.Event_Record] = api.get_Log_Event()\n    api.logInfo(s\"Received on Log_Event: ${apiUsage_Log_Event}\")\n    val apiUsage_Get_Event_Log: Option[art.Empty] = api.get_Get_Event_Log()\n    api.logInfo(s\"Received on Get_Event_Log: ${apiUsage_Get_Event_Log}\")\n  }\n\n  def handle_Get_Event_Log(api: event_logger_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Get_Event_Log implementation\")\n    api.logInfo(\"received Get_Event_Log event\")\n  }\n\n  def activate(api: event_logger_thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: event_logger_thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: event_logger_thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: event_logger_thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Boss\/Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Boss\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_TestApi extends BridgeTestSuite[Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_boss) {\n\n  \/** helper function to set the values of all input ports.\n   * @param POST_done the number of events to place in the POST_done event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param POST_fail the number of events to place in the POST_fail event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Stop_Button_Pressed the number of events to place in the Stop_Button_Pressed event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Start_Button_Pressed the number of events to place in the Start_Button_Pressed event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Scan_Done the number of events to place in the Scan_Done event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Authentication_fail the number of events to place in the Authentication_fail event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Authentication_pass the number of events to place in the Authentication_pass event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Drug_Not_In_Library the number of events to place in the Drug_Not_In_Library event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Hard_Limit_Violated the number of events to place in the Hard_Limit_Violated event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Reject_Soft_Limit_Exception the number of events to place in the Reject_Soft_Limit_Exception event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Confirm_Soft_Limit_Exception the number of events to place in the Confirm_Soft_Limit_Exception event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Rx_Okay the number of events to place in the Rx_Okay event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Door_Closed the number of events to place in the Door_Closed event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Turn_Off the number of events to place in the Turn_Off event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(POST_done : Z,\n                          POST_fail : Z,\n                          Stop_Button_Pressed : Z,\n                          Start_Button_Pressed : Z,\n                          Scan_Done : Z,\n                          Authentication_fail : Z,\n                          Authentication_pass : Z,\n                          Drug_Not_In_Library : Z,\n                          Hard_Limit_Violated : Z,\n                          Reject_Soft_Limit_Exception : Z,\n                          Confirm_Soft_Limit_Exception : Z,\n                          Rx_Okay : Z,\n                          Door_Closed : Z,\n                          Turn_Off : Z): Unit = {\n    for(i <- 0 until POST_done) {\n      put_POST_done()\n    }\n    for(i <- 0 until POST_fail) {\n      put_POST_fail()\n    }\n    for(i <- 0 until Stop_Button_Pressed) {\n      put_Stop_Button_Pressed()\n    }\n    for(i <- 0 until Start_Button_Pressed) {\n      put_Start_Button_Pressed()\n    }\n    for(i <- 0 until Scan_Done) {\n      put_Scan_Done()\n    }\n    for(i <- 0 until Authentication_fail) {\n      put_Authentication_fail()\n    }\n    for(i <- 0 until Authentication_pass) {\n      put_Authentication_pass()\n    }\n    for(i <- 0 until Drug_Not_In_Library) {\n      put_Drug_Not_In_Library()\n    }\n    for(i <- 0 until Hard_Limit_Violated) {\n      put_Hard_Limit_Violated()\n    }\n    for(i <- 0 until Reject_Soft_Limit_Exception) {\n      put_Reject_Soft_Limit_Exception()\n    }\n    for(i <- 0 until Confirm_Soft_Limit_Exception) {\n      put_Confirm_Soft_Limit_Exception()\n    }\n    for(i <- 0 until Rx_Okay) {\n      put_Rx_Okay()\n    }\n    for(i <- 0 until Door_Closed) {\n      put_Door_Closed()\n    }\n    for(i <- 0 until Turn_Off) {\n      put_Turn_Off()\n    }\n  }\n\n\n  \/** helper function to check Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Display_Message method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Display_Message'.\n   * @param Sound_Type method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Sound_Type'.\n   * @param Log_Event method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Log_Event'.\n   * @param Do_Scan method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Do_Scan'.\n   * @param Authenticate_Clinician method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Authenticate_Clinician'.\n   * @param Authenticate_Patient method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Authenticate_Patient'.\n   * @param Authenticate_Prescription method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Authenticate_Prescription'.\n   * @param Check_Rx method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Check_Rx'.\n   * @param Begin_Priming method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Begin_Priming'.\n   * @param End_Priming method that will be called with the number of events to be sent\n   *        on the outgoing event port 'End_Priming'.\n   * @param Prime_Failure method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Prime_Failure'.\n   * @param Begin_Infusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Begin_Infusion'.\n   * @param Halt_Infusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Halt_Infusion'.\n   *\/\n  def check_concrete_output(Display_Message: ISZ[PCA_Types.Message.Type] => B = Display_MessageParam => {T},\n                            Sound_Type: ISZ[PCA_Types.Sound.Type] => B = Sound_TypeParam => {T},\n                            Log_Event: ISZ[PCA_Types.Event_Record] => B = Log_EventParam => {T},\n                            Do_Scan: Z => B = Do_ScanParam => {T},\n                            Authenticate_Clinician: Z => B = Authenticate_ClinicianParam => {T},\n                            Authenticate_Patient: Z => B = Authenticate_PatientParam => {T},\n                            Authenticate_Prescription: Z => B = Authenticate_PrescriptionParam => {T},\n                            Check_Rx: Z => B = Check_RxParam => {T},\n                            Begin_Priming: Z => B = Begin_PrimingParam => {T},\n                            End_Priming: Z => B = End_PrimingParam => {T},\n                            Prime_Failure: Z => B = Prime_FailureParam => {T},\n                            Begin_Infusion: Z => B = Begin_InfusionParam => {T},\n                            Halt_Infusion: Z => B = Halt_InfusionParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Display_MessageValue: ISZ[PCA_Types.Message.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Display_Message().nonEmpty) Display_MessageValue = Display_MessageValue :+ get_Display_Message().get\n    if(!Display_Message(Display_MessageValue)) {\n      testFailures = testFailures :+ st\"'Display_Message' did not match expected: received ${Display_MessageValue.size} events with the following payloads ${Display_MessageValue}\"\n    }\n    var Sound_TypeValue: ISZ[PCA_Types.Sound.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Sound_Type().nonEmpty) Sound_TypeValue = Sound_TypeValue :+ get_Sound_Type().get\n    if(!Sound_Type(Sound_TypeValue)) {\n      testFailures = testFailures :+ st\"'Sound_Type' did not match expected: received ${Sound_TypeValue.size} events with the following payloads ${Sound_TypeValue}\"\n    }\n    var Log_EventValue: ISZ[PCA_Types.Event_Record] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Log_Event().nonEmpty) Log_EventValue = Log_EventValue :+ get_Log_Event().get\n    if(!Log_Event(Log_EventValue)) {\n      testFailures = testFailures :+ st\"'Log_Event' did not match expected: received ${Log_EventValue.size} events with the following payloads ${Log_EventValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Do_ScanValue: Z = if(get_Do_Scan().nonEmpty) z\"1\" else z\"0\"\n    if(!Do_Scan(Do_ScanValue)) {\n      testFailures = testFailures :+ st\"'Do_Scan' did not match expected: ${Do_ScanValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Authenticate_ClinicianValue: Z = if(get_Authenticate_Clinician().nonEmpty) z\"1\" else z\"0\"\n    if(!Authenticate_Clinician(Authenticate_ClinicianValue)) {\n      testFailures = testFailures :+ st\"'Authenticate_Clinician' did not match expected: ${Authenticate_ClinicianValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Authenticate_PatientValue: Z = if(get_Authenticate_Patient().nonEmpty) z\"1\" else z\"0\"\n    if(!Authenticate_Patient(Authenticate_PatientValue)) {\n      testFailures = testFailures :+ st\"'Authenticate_Patient' did not match expected: ${Authenticate_PatientValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Authenticate_PrescriptionValue: Z = if(get_Authenticate_Prescription().nonEmpty) z\"1\" else z\"0\"\n    if(!Authenticate_Prescription(Authenticate_PrescriptionValue)) {\n      testFailures = testFailures :+ st\"'Authenticate_Prescription' did not match expected: ${Authenticate_PrescriptionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Check_RxValue: Z = if(get_Check_Rx().nonEmpty) z\"1\" else z\"0\"\n    if(!Check_Rx(Check_RxValue)) {\n      testFailures = testFailures :+ st\"'Check_Rx' did not match expected: ${Check_RxValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Begin_PrimingValue: Z = if(get_Begin_Priming().nonEmpty) z\"1\" else z\"0\"\n    if(!Begin_Priming(Begin_PrimingValue)) {\n      testFailures = testFailures :+ st\"'Begin_Priming' did not match expected: ${Begin_PrimingValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val End_PrimingValue: Z = if(get_End_Priming().nonEmpty) z\"1\" else z\"0\"\n    if(!End_Priming(End_PrimingValue)) {\n      testFailures = testFailures :+ st\"'End_Priming' did not match expected: ${End_PrimingValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Prime_FailureValue: Z = if(get_Prime_Failure().nonEmpty) z\"1\" else z\"0\"\n    if(!Prime_Failure(Prime_FailureValue)) {\n      testFailures = testFailures :+ st\"'Prime_Failure' did not match expected: ${Prime_FailureValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Begin_InfusionValue: Z = if(get_Begin_Infusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Begin_Infusion(Begin_InfusionValue)) {\n      testFailures = testFailures :+ st\"'Begin_Infusion' did not match expected: ${Begin_InfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Halt_InfusionValue: Z = if(get_Halt_Infusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Halt_Infusion(Halt_InfusionValue)) {\n      testFailures = testFailures :+ st\"'Halt_Infusion' did not match expected: ${Halt_InfusionValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_POST_done(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.POST_done_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_POST_fail(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.POST_fail_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Stop_Button_Pressed(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Stop_Button_Pressed_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Start_Button_Pressed(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Start_Button_Pressed_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Scan_Done(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Scan_Done_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Authentication_fail(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Authentication_fail_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Authentication_pass(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Authentication_pass_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Drug_Not_In_Library(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Not_In_Library_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Hard_Limit_Violated(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Hard_Limit_Violated_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Reject_Soft_Limit_Exception(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Reject_Soft_Limit_Exception_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Confirm_Soft_Limit_Exception(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Confirm_Soft_Limit_Exception_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Rx_Okay(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Rx_Okay_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Door_Closed(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Door_Closed_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Turn_Off(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Turn_Off_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Display_Message(): Option[PCA_Types.Message.Type] = {\n    val value: Option[PCA_Types.Message.Type] = get_Display_Message_payload() match {\n      case Some(PCA_Types.Message_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Display_Message.  Expecting 'PCA_Types.Message_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Message.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Display_Message_payload(): Option[PCA_Types.Message_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Display_Message_Id).asInstanceOf[Option[PCA_Types.Message_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Sound_Type(): Option[PCA_Types.Sound.Type] = {\n    val value: Option[PCA_Types.Sound.Type] = get_Sound_Type_payload() match {\n      case Some(PCA_Types.Sound_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Sound_Type.  Expecting 'PCA_Types.Sound_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Sound.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Sound_Type_payload(): Option[PCA_Types.Sound_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Sound_Type_Id).asInstanceOf[Option[PCA_Types.Sound_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Log_Event(): Option[PCA_Types.Event_Record] = {\n    val value: Option[PCA_Types.Event_Record] = get_Log_Event_payload() match {\n      case Some(PCA_Types.Event_Record_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Log_Event.  Expecting 'PCA_Types.Event_Record_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Event_Record]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Log_Event_payload(): Option[PCA_Types.Event_Record_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Log_Event_Id).asInstanceOf[Option[PCA_Types.Event_Record_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Do_Scan(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Do_Scan_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Do_Scan.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Do_Scan_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Do_Scan_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Authenticate_Clinician(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Authenticate_Clinician_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Authenticate_Clinician.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Authenticate_Clinician_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Authenticate_Clinician_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Authenticate_Patient(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Authenticate_Patient_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Authenticate_Patient.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Authenticate_Patient_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Authenticate_Patient_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Authenticate_Prescription(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Authenticate_Prescription_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Authenticate_Prescription.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Authenticate_Prescription_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Authenticate_Prescription_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Check_Rx(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Check_Rx_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Check_Rx.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Check_Rx_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Check_Rx_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Begin_Priming(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Begin_Priming_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Begin_Priming.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Begin_Priming_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Begin_Priming_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_End_Priming(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_End_Priming_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port End_Priming.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_End_Priming_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.End_Priming_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Prime_Failure(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Prime_Failure_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Prime_Failure.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Prime_Failure_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Prime_Failure_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Begin_Infusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Begin_Infusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Begin_Infusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Begin_Infusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Begin_Infusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Halt_Infusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Halt_Infusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Halt_Infusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Halt_Infusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Halt_Infusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Boss\/Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Boss\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Boss._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Test extends Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Boss\/Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Boss\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Boss.{Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Display_Message: Port[PCA_Types.Message.Type],\n  Sound_Type: Port[PCA_Types.Sound.Type],\n  Log_Event: Port[PCA_Types.Event_Record],\n  POST_done: Port[art.Empty],\n  POST_fail: Port[art.Empty],\n  Stop_Button_Pressed: Port[art.Empty],\n  Start_Button_Pressed: Port[art.Empty],\n  Do_Scan: Port[art.Empty],\n  Scan_Done: Port[art.Empty],\n  Authenticate_Clinician: Port[art.Empty],\n  Authenticate_Patient: Port[art.Empty],\n  Authenticate_Prescription: Port[art.Empty],\n  Authentication_fail: Port[art.Empty],\n  Authentication_pass: Port[art.Empty],\n  Check_Rx: Port[art.Empty],\n  Drug_Not_In_Library: Port[art.Empty],\n  Hard_Limit_Violated: Port[art.Empty],\n  Reject_Soft_Limit_Exception: Port[art.Empty],\n  Confirm_Soft_Limit_Exception: Port[art.Empty],\n  Rx_Okay: Port[art.Empty],\n  Door_Closed: Port[art.Empty],\n  Begin_Priming: Port[art.Empty],\n  End_Priming: Port[art.Empty],\n  Prime_Failure: Port[art.Empty],\n  Begin_Infusion: Port[art.Empty],\n  Halt_Infusion: Port[art.Empty],\n  Turn_Off: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Display_Message,\n              Sound_Type,\n              Log_Event,\n              POST_done,\n              POST_fail,\n              Stop_Button_Pressed,\n              Start_Button_Pressed,\n              Do_Scan,\n              Scan_Done,\n              Authenticate_Clinician,\n              Authenticate_Patient,\n              Authenticate_Prescription,\n              Authentication_fail,\n              Authentication_pass,\n              Check_Rx,\n              Drug_Not_In_Library,\n              Hard_Limit_Violated,\n              Reject_Soft_Limit_Exception,\n              Confirm_Soft_Limit_Exception,\n              Rx_Okay,\n              Door_Closed,\n              Begin_Priming,\n              End_Priming,\n              Prime_Failure,\n              Begin_Infusion,\n              Halt_Infusion,\n              Turn_Off),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(POST_done,\n                   POST_fail,\n                   Stop_Button_Pressed,\n                   Start_Button_Pressed,\n                   Scan_Done,\n                   Authentication_fail,\n                   Authentication_pass,\n                   Drug_Not_In_Library,\n                   Hard_Limit_Violated,\n                   Reject_Soft_Limit_Exception,\n                   Confirm_Soft_Limit_Exception,\n                   Rx_Okay,\n                   Door_Closed,\n                   Turn_Off),\n\n    eventOuts = ISZ(Display_Message,\n                    Sound_Type,\n                    Log_Event,\n                    Do_Scan,\n                    Authenticate_Clinician,\n                    Authenticate_Patient,\n                    Authenticate_Prescription,\n                    Check_Rx,\n                    Begin_Priming,\n                    End_Priming,\n                    Prime_Failure,\n                    Begin_Infusion,\n                    Halt_Infusion)\n  )\n\n  val initialization_api : Boss_Thread_imp_Initialization_Api = {\n    val api = Boss_Thread_imp_Initialization_Api(\n      id,\n      Display_Message.id,\n      Sound_Type.id,\n      Log_Event.id,\n      POST_done.id,\n      POST_fail.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Do_Scan.id,\n      Scan_Done.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Check_Rx.id,\n      Drug_Not_In_Library.id,\n      Hard_Limit_Violated.id,\n      Reject_Soft_Limit_Exception.id,\n      Confirm_Soft_Limit_Exception.id,\n      Rx_Okay.id,\n      Door_Closed.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Prime_Failure.id,\n      Begin_Infusion.id,\n      Halt_Infusion.id,\n      Turn_Off.id\n    )\n    Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Boss_Thread_imp_Operational_Api = {\n    val api = Boss_Thread_imp_Operational_Api(\n      id,\n      Display_Message.id,\n      Sound_Type.id,\n      Log_Event.id,\n      POST_done.id,\n      POST_fail.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Do_Scan.id,\n      Scan_Done.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Check_Rx.id,\n      Drug_Not_In_Library.id,\n      Hard_Limit_Violated.id,\n      Reject_Soft_Limit_Exception.id,\n      Confirm_Soft_Limit_Exception.id,\n      Rx_Okay.id,\n      Door_Closed.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Prime_Failure.id,\n      Begin_Infusion.id,\n      Halt_Infusion.id,\n      Turn_Off.id\n    )\n    Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge.EntryPoints(\n      id,\n\n      Display_Message.id,\n      Sound_Type.id,\n      Log_Event.id,\n      POST_done.id,\n      POST_fail.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Do_Scan.id,\n      Scan_Done.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Check_Rx.id,\n      Drug_Not_In_Library.id,\n      Hard_Limit_Violated.id,\n      Reject_Soft_Limit_Exception.id,\n      Confirm_Soft_Limit_Exception.id,\n      Rx_Okay.id,\n      Door_Closed.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Prime_Failure.id,\n      Begin_Infusion.id,\n      Halt_Infusion.id,\n      Turn_Off.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_Bridge {\n\n  var c_initialization_api: Option[Boss_Thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Boss_Thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_BridgeId : Art.BridgeId,\n\n    Display_Message_Id : Art.PortId,\n    Sound_Type_Id : Art.PortId,\n    Log_Event_Id : Art.PortId,\n    POST_done_Id : Art.PortId,\n    POST_fail_Id : Art.PortId,\n    Stop_Button_Pressed_Id : Art.PortId,\n    Start_Button_Pressed_Id : Art.PortId,\n    Do_Scan_Id : Art.PortId,\n    Scan_Done_Id : Art.PortId,\n    Authenticate_Clinician_Id : Art.PortId,\n    Authenticate_Patient_Id : Art.PortId,\n    Authenticate_Prescription_Id : Art.PortId,\n    Authentication_fail_Id : Art.PortId,\n    Authentication_pass_Id : Art.PortId,\n    Check_Rx_Id : Art.PortId,\n    Drug_Not_In_Library_Id : Art.PortId,\n    Hard_Limit_Violated_Id : Art.PortId,\n    Reject_Soft_Limit_Exception_Id : Art.PortId,\n    Confirm_Soft_Limit_Exception_Id : Art.PortId,\n    Rx_Okay_Id : Art.PortId,\n    Door_Closed_Id : Art.PortId,\n    Begin_Priming_Id : Art.PortId,\n    End_Priming_Id : Art.PortId,\n    Prime_Failure_Id : Art.PortId,\n    Begin_Infusion_Id : Art.PortId,\n    Halt_Infusion_Id : Art.PortId,\n    Turn_Off_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Boss_Thread_imp_Initialization_Api,\n    operational_api: Boss_Thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(POST_done_Id,\n                                              POST_fail_Id,\n                                              Stop_Button_Pressed_Id,\n                                              Start_Button_Pressed_Id,\n                                              Scan_Done_Id,\n                                              Authentication_fail_Id,\n                                              Authentication_pass_Id,\n                                              Drug_Not_In_Library_Id,\n                                              Hard_Limit_Violated_Id,\n                                              Reject_Soft_Limit_Exception_Id,\n                                              Confirm_Soft_Limit_Exception_Id,\n                                              Rx_Okay_Id,\n                                              Door_Closed_Id,\n                                              Turn_Off_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Display_Message_Id,\n                                               Sound_Type_Id,\n                                               Log_Event_Id,\n                                               Do_Scan_Id,\n                                               Authenticate_Clinician_Id,\n                                               Authenticate_Patient_Id,\n                                               Authenticate_Prescription_Id,\n                                               Check_Rx_Id,\n                                               Begin_Priming_Id,\n                                               End_Priming_Id,\n                                               Prime_Failure_Id,\n                                               Begin_Infusion_Id,\n                                               Halt_Infusion_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == POST_done_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_done(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_POST_done(operational_api)\n        }\n        else if(portId == POST_fail_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_fail(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_POST_fail(operational_api)\n        }\n        else if(portId == Stop_Button_Pressed_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Button_Pressed(operational_api)\n        }\n        else if(portId == Start_Button_Pressed_Id) {\n          \/\/ implement the following in 'component':  def handle_Start_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Start_Button_Pressed(operational_api)\n        }\n        else if(portId == Scan_Done_Id) {\n          \/\/ implement the following in 'component':  def handle_Scan_Done(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Scan_Done(operational_api)\n        }\n        else if(portId == Authentication_fail_Id) {\n          \/\/ implement the following in 'component':  def handle_Authentication_fail(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authentication_fail(operational_api)\n        }\n        else if(portId == Authentication_pass_Id) {\n          \/\/ implement the following in 'component':  def handle_Authentication_pass(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authentication_pass(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Hard_Limit_Violated_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violated(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violated(operational_api)\n        }\n        else if(portId == Reject_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Reject_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Reject_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Confirm_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Confirm_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Confirm_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Rx_Okay_Id) {\n          \/\/ implement the following in 'component':  def handle_Rx_Okay(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Rx_Okay(operational_api)\n        }\n        else if(portId == Door_Closed_Id) {\n          \/\/ implement the following in 'component':  def handle_Door_Closed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Door_Closed(operational_api)\n        }\n        else if(portId == Turn_Off_Id) {\n          \/\/ implement the following in 'component':  def handle_Turn_Off(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Turn_Off(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == POST_done_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_done(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_POST_done(operational_api)\n        }\n        else if(portId == POST_fail_Id) {\n          \/\/ implement the following in 'component':  def handle_POST_fail(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_POST_fail(operational_api)\n        }\n        else if(portId == Stop_Button_Pressed_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Button_Pressed(operational_api)\n        }\n        else if(portId == Start_Button_Pressed_Id) {\n          \/\/ implement the following in 'component':  def handle_Start_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Start_Button_Pressed(operational_api)\n        }\n        else if(portId == Scan_Done_Id) {\n          \/\/ implement the following in 'component':  def handle_Scan_Done(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Scan_Done(operational_api)\n        }\n        else if(portId == Authentication_fail_Id) {\n          \/\/ implement the following in 'component':  def handle_Authentication_fail(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authentication_fail(operational_api)\n        }\n        else if(portId == Authentication_pass_Id) {\n          \/\/ implement the following in 'component':  def handle_Authentication_pass(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authentication_pass(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Hard_Limit_Violated_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violated(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violated(operational_api)\n        }\n        else if(portId == Reject_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Reject_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Reject_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Confirm_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Confirm_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Confirm_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Rx_Okay_Id) {\n          \/\/ implement the following in 'component':  def handle_Rx_Okay(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Rx_Okay(operational_api)\n        }\n        else if(portId == Door_Closed_Id) {\n          \/\/ implement the following in 'component':  def handle_Door_Closed(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Door_Closed(operational_api)\n        }\n        else if(portId == Turn_Off_Id) {\n          \/\/ implement the following in 'component':  def handle_Turn_Off(api: Boss_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Turn_Off(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Boss_Thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Boss_Thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Boss_Thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Boss_Thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Boss_Thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Boss\/Boss_Thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Boss\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Boss_Thread_imp_Api {\n  def id: Art.BridgeId\n  def Display_Message_Id : Art.PortId\n  def Sound_Type_Id : Art.PortId\n  def Log_Event_Id : Art.PortId\n  def POST_done_Id : Art.PortId\n  def POST_fail_Id : Art.PortId\n  def Stop_Button_Pressed_Id : Art.PortId\n  def Start_Button_Pressed_Id : Art.PortId\n  def Do_Scan_Id : Art.PortId\n  def Scan_Done_Id : Art.PortId\n  def Authenticate_Clinician_Id : Art.PortId\n  def Authenticate_Patient_Id : Art.PortId\n  def Authenticate_Prescription_Id : Art.PortId\n  def Authentication_fail_Id : Art.PortId\n  def Authentication_pass_Id : Art.PortId\n  def Check_Rx_Id : Art.PortId\n  def Drug_Not_In_Library_Id : Art.PortId\n  def Hard_Limit_Violated_Id : Art.PortId\n  def Reject_Soft_Limit_Exception_Id : Art.PortId\n  def Confirm_Soft_Limit_Exception_Id : Art.PortId\n  def Rx_Okay_Id : Art.PortId\n  def Door_Closed_Id : Art.PortId\n  def Begin_Priming_Id : Art.PortId\n  def End_Priming_Id : Art.PortId\n  def Prime_Failure_Id : Art.PortId\n  def Begin_Infusion_Id : Art.PortId\n  def Halt_Infusion_Id : Art.PortId\n  def Turn_Off_Id : Art.PortId\n\n  def put_Display_Message(value : PCA_Types.Message.Type) : Unit = {\n    Art.putValue(Display_Message_Id, PCA_Types.Message_Payload(value))\n  }\n\n  def put_Sound_Type(value : PCA_Types.Sound.Type) : Unit = {\n    Art.putValue(Sound_Type_Id, PCA_Types.Sound_Payload(value))\n  }\n\n  def put_Log_Event(value : PCA_Types.Event_Record) : Unit = {\n    Art.putValue(Log_Event_Id, PCA_Types.Event_Record_Payload(value))\n  }\n\n  def put_Do_Scan() : Unit = {\n    Art.putValue(Do_Scan_Id, art.Empty())\n  }\n\n  def put_Authenticate_Clinician() : Unit = {\n    Art.putValue(Authenticate_Clinician_Id, art.Empty())\n  }\n\n  def put_Authenticate_Patient() : Unit = {\n    Art.putValue(Authenticate_Patient_Id, art.Empty())\n  }\n\n  def put_Authenticate_Prescription() : Unit = {\n    Art.putValue(Authenticate_Prescription_Id, art.Empty())\n  }\n\n  def put_Check_Rx() : Unit = {\n    Art.putValue(Check_Rx_Id, art.Empty())\n  }\n\n  def put_Begin_Priming() : Unit = {\n    Art.putValue(Begin_Priming_Id, art.Empty())\n  }\n\n  def put_End_Priming() : Unit = {\n    Art.putValue(End_Priming_Id, art.Empty())\n  }\n\n  def put_Prime_Failure() : Unit = {\n    Art.putValue(Prime_Failure_Id, art.Empty())\n  }\n\n  def put_Begin_Infusion() : Unit = {\n    Art.putValue(Begin_Infusion_Id, art.Empty())\n  }\n\n  def put_Halt_Infusion() : Unit = {\n    Art.putValue(Halt_Infusion_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Boss_Thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Display_Message_Id : Art.PortId,\n  val Sound_Type_Id : Art.PortId,\n  val Log_Event_Id : Art.PortId,\n  val POST_done_Id : Art.PortId,\n  val POST_fail_Id : Art.PortId,\n  val Stop_Button_Pressed_Id : Art.PortId,\n  val Start_Button_Pressed_Id : Art.PortId,\n  val Do_Scan_Id : Art.PortId,\n  val Scan_Done_Id : Art.PortId,\n  val Authenticate_Clinician_Id : Art.PortId,\n  val Authenticate_Patient_Id : Art.PortId,\n  val Authenticate_Prescription_Id : Art.PortId,\n  val Authentication_fail_Id : Art.PortId,\n  val Authentication_pass_Id : Art.PortId,\n  val Check_Rx_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Door_Closed_Id : Art.PortId,\n  val Begin_Priming_Id : Art.PortId,\n  val End_Priming_Id : Art.PortId,\n  val Prime_Failure_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val Turn_Off_Id : Art.PortId) extends Boss_Thread_imp_Api\n\n@datatype class Boss_Thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Display_Message_Id : Art.PortId,\n  val Sound_Type_Id : Art.PortId,\n  val Log_Event_Id : Art.PortId,\n  val POST_done_Id : Art.PortId,\n  val POST_fail_Id : Art.PortId,\n  val Stop_Button_Pressed_Id : Art.PortId,\n  val Start_Button_Pressed_Id : Art.PortId,\n  val Do_Scan_Id : Art.PortId,\n  val Scan_Done_Id : Art.PortId,\n  val Authenticate_Clinician_Id : Art.PortId,\n  val Authenticate_Patient_Id : Art.PortId,\n  val Authenticate_Prescription_Id : Art.PortId,\n  val Authentication_fail_Id : Art.PortId,\n  val Authentication_pass_Id : Art.PortId,\n  val Check_Rx_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Door_Closed_Id : Art.PortId,\n  val Begin_Priming_Id : Art.PortId,\n  val End_Priming_Id : Art.PortId,\n  val Prime_Failure_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val Turn_Off_Id : Art.PortId) extends Boss_Thread_imp_Api {\n\n  def get_POST_done() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(POST_done_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port POST_done.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_POST_fail() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(POST_fail_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port POST_fail.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Stop_Button_Pressed() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Stop_Button_Pressed_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Stop_Button_Pressed.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Start_Button_Pressed() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Start_Button_Pressed_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Start_Button_Pressed.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Scan_Done() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Scan_Done_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Scan_Done.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Authentication_fail() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Authentication_fail_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Authentication_fail.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Authentication_pass() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Authentication_pass_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Authentication_pass.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Drug_Not_In_Library() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Drug_Not_In_Library_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Not_In_Library.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Hard_Limit_Violated() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Hard_Limit_Violated_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Hard_Limit_Violated.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Reject_Soft_Limit_Exception() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Reject_Soft_Limit_Exception_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Reject_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Confirm_Soft_Limit_Exception() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Confirm_Soft_Limit_Exception_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Confirm_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Rx_Okay() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Rx_Okay_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Rx_Okay.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Door_Closed() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Door_Closed_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Door_Closed.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Turn_Off() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Turn_Off_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Turn_Off.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Boss\/Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Boss\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Boss_Thread_imp_pump_operation_operation_process_operation_threads_boss {\n\n  def initialise(api: Boss_Thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Display_Message(PCA_Types.Message.byOrdinal(0).get)\n    api.put_Sound_Type(PCA_Types.Sound.byOrdinal(0).get)\n    api.put_Log_Event(PCA_Types.Event_Record.example())\n    api.put_Do_Scan()\n    api.put_Authenticate_Clinician()\n    api.put_Authenticate_Patient()\n    api.put_Authenticate_Prescription()\n    api.put_Check_Rx()\n    api.put_Begin_Priming()\n    api.put_End_Priming()\n    api.put_Prime_Failure()\n    api.put_Begin_Infusion()\n    api.put_Halt_Infusion()\n  }\n\n  def handle_POST_done(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_POST_done implementation\")\n    api.logInfo(\"received POST_done event\")\n    \/\/ example api usage\n\n    val apiUsage_POST_done: Option[art.Empty] = api.get_POST_done()\n    api.logInfo(s\"Received on POST_done: ${apiUsage_POST_done}\")\n    val apiUsage_POST_fail: Option[art.Empty] = api.get_POST_fail()\n    api.logInfo(s\"Received on POST_fail: ${apiUsage_POST_fail}\")\n    val apiUsage_Stop_Button_Pressed: Option[art.Empty] = api.get_Stop_Button_Pressed()\n    api.logInfo(s\"Received on Stop_Button_Pressed: ${apiUsage_Stop_Button_Pressed}\")\n    val apiUsage_Start_Button_Pressed: Option[art.Empty] = api.get_Start_Button_Pressed()\n    api.logInfo(s\"Received on Start_Button_Pressed: ${apiUsage_Start_Button_Pressed}\")\n    val apiUsage_Scan_Done: Option[art.Empty] = api.get_Scan_Done()\n    api.logInfo(s\"Received on Scan_Done: ${apiUsage_Scan_Done}\")\n    val apiUsage_Authentication_fail: Option[art.Empty] = api.get_Authentication_fail()\n    api.logInfo(s\"Received on Authentication_fail: ${apiUsage_Authentication_fail}\")\n    val apiUsage_Authentication_pass: Option[art.Empty] = api.get_Authentication_pass()\n    api.logInfo(s\"Received on Authentication_pass: ${apiUsage_Authentication_pass}\")\n    val apiUsage_Drug_Not_In_Library: Option[art.Empty] = api.get_Drug_Not_In_Library()\n    api.logInfo(s\"Received on Drug_Not_In_Library: ${apiUsage_Drug_Not_In_Library}\")\n    val apiUsage_Hard_Limit_Violated: Option[art.Empty] = api.get_Hard_Limit_Violated()\n    api.logInfo(s\"Received on Hard_Limit_Violated: ${apiUsage_Hard_Limit_Violated}\")\n    val apiUsage_Reject_Soft_Limit_Exception: Option[art.Empty] = api.get_Reject_Soft_Limit_Exception()\n    api.logInfo(s\"Received on Reject_Soft_Limit_Exception: ${apiUsage_Reject_Soft_Limit_Exception}\")\n    val apiUsage_Confirm_Soft_Limit_Exception: Option[art.Empty] = api.get_Confirm_Soft_Limit_Exception()\n    api.logInfo(s\"Received on Confirm_Soft_Limit_Exception: ${apiUsage_Confirm_Soft_Limit_Exception}\")\n    val apiUsage_Rx_Okay: Option[art.Empty] = api.get_Rx_Okay()\n    api.logInfo(s\"Received on Rx_Okay: ${apiUsage_Rx_Okay}\")\n    val apiUsage_Door_Closed: Option[art.Empty] = api.get_Door_Closed()\n    api.logInfo(s\"Received on Door_Closed: ${apiUsage_Door_Closed}\")\n    val apiUsage_Turn_Off: Option[art.Empty] = api.get_Turn_Off()\n    api.logInfo(s\"Received on Turn_Off: ${apiUsage_Turn_Off}\")\n  }\n\n  def handle_POST_fail(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_POST_fail implementation\")\n    api.logInfo(\"received POST_fail event\")\n  }\n\n  def handle_Stop_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Stop_Button_Pressed implementation\")\n    api.logInfo(\"received Stop_Button_Pressed event\")\n  }\n\n  def handle_Start_Button_Pressed(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Start_Button_Pressed implementation\")\n    api.logInfo(\"received Start_Button_Pressed event\")\n  }\n\n  def handle_Scan_Done(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Scan_Done implementation\")\n    api.logInfo(\"received Scan_Done event\")\n  }\n\n  def handle_Authentication_fail(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Authentication_fail implementation\")\n    api.logInfo(\"received Authentication_fail event\")\n  }\n\n  def handle_Authentication_pass(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Authentication_pass implementation\")\n    api.logInfo(\"received Authentication_pass event\")\n  }\n\n  def handle_Drug_Not_In_Library(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Drug_Not_In_Library implementation\")\n    api.logInfo(\"received Drug_Not_In_Library event\")\n  }\n\n  def handle_Hard_Limit_Violated(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Hard_Limit_Violated implementation\")\n    api.logInfo(\"received Hard_Limit_Violated event\")\n  }\n\n  def handle_Reject_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Reject_Soft_Limit_Exception implementation\")\n    api.logInfo(\"received Reject_Soft_Limit_Exception event\")\n  }\n\n  def handle_Confirm_Soft_Limit_Exception(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Confirm_Soft_Limit_Exception implementation\")\n    api.logInfo(\"received Confirm_Soft_Limit_Exception event\")\n  }\n\n  def handle_Rx_Okay(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Rx_Okay implementation\")\n    api.logInfo(\"received Rx_Okay event\")\n  }\n\n  def handle_Door_Closed(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Door_Closed implementation\")\n    api.logInfo(\"received Door_Closed event\")\n  }\n\n  def handle_Turn_Off(api: Boss_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Turn_Off implementation\")\n    api.logInfo(\"received Turn_Off event\")\n  }\n\n  def activate(api: Boss_Thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Boss_Thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Boss_Thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: Boss_Thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation_Threads\/Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_TestApi extends BridgeTestSuite[Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_rate_controller) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Square_Bolus_Rate payload for data port Square_Bolus_Rate\n   * @param Patient_Bolus_Rate payload for data port Patient_Bolus_Rate\n   * @param Basal_Rate payload for data port Basal_Rate\n   * @param VTBI payload for data port VTBI\n   * @param Door_Open payload for data port Door_Open\n   * @param Alarm payloads for event data port Alarm.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Alarm will be used\n   * @param Warning payloads for event data port Warning.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Warning will be used\n   * @param CP_Bolus_Duration payloads for event data port CP_Bolus_Duration.\n   *   ART currently supports single element event data queues so\n   *   only the last element of CP_Bolus_Duration will be used\n   * @param Begin_Infusion the number of events to place in the Begin_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Begin_Priming the number of events to place in the Begin_Priming event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param End_Priming the number of events to place in the End_Priming event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Halt_Infusion the number of events to place in the Halt_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param HW_Detected_Failure the number of events to place in the HW_Detected_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Stop_Pump_Completely the number of events to place in the Stop_Pump_Completely event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Pump_At_KVO_Rate the number of events to place in the Pump_At_KVO_Rate event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Patient_Request_Not_Too_Soon the number of events to place in the Patient_Request_Not_Too_Soon event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Pause_Infusion the number of events to place in the Pause_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Resume_Infusion the number of events to place in the Resume_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param CP_Clinician_Request_Bolus the number of events to place in the CP_Clinician_Request_Bolus event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Near_Max_Drug_Per_Hour the number of events to place in the Near_Max_Drug_Per_Hour event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Over_Max_Drug_Per_Hour the number of events to place in the Over_Max_Drug_Per_Hour event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param ICE_Stop_Pump the number of events to place in the ICE_Stop_Pump event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Square_Bolus_Rate : PCA_Types.Flow_Rate_imp,\n                          Patient_Bolus_Rate : PCA_Types.Flow_Rate_imp,\n                          Basal_Rate : PCA_Types.Flow_Rate_imp,\n                          VTBI : PCA_Types.Drug_Volume_imp,\n                          Door_Open : Base_Types.Boolean,\n                          Alarm : ISZ[PCA_Types.Alarm_Type.Type],\n                          Warning : ISZ[PCA_Types.Warning_Type.Type],\n                          CP_Bolus_Duration : ISZ[ICE_Types.Minute_imp],\n                          Begin_Infusion : Z,\n                          Begin_Priming : Z,\n                          End_Priming : Z,\n                          Halt_Infusion : Z,\n                          HW_Detected_Failure : Z,\n                          Stop_Pump_Completely : Z,\n                          Pump_At_KVO_Rate : Z,\n                          Patient_Request_Not_Too_Soon : Z,\n                          Pause_Infusion : Z,\n                          Resume_Infusion : Z,\n                          CP_Clinician_Request_Bolus : Z,\n                          Near_Max_Drug_Per_Hour : Z,\n                          Over_Max_Drug_Per_Hour : Z,\n                          ICE_Stop_Pump : Z): Unit = {\n    put_Square_Bolus_Rate(Square_Bolus_Rate)\n    put_Patient_Bolus_Rate(Patient_Bolus_Rate)\n    put_Basal_Rate(Basal_Rate)\n    put_VTBI(VTBI)\n    put_Door_Open(Door_Open)\n    for(v <- Alarm){\n      put_Alarm(v)\n    }\n    for(v <- Warning){\n      put_Warning(v)\n    }\n    for(v <- CP_Bolus_Duration){\n      put_CP_Bolus_Duration(v)\n    }\n    for(i <- 0 until Begin_Infusion) {\n      put_Begin_Infusion()\n    }\n    for(i <- 0 until Begin_Priming) {\n      put_Begin_Priming()\n    }\n    for(i <- 0 until End_Priming) {\n      put_End_Priming()\n    }\n    for(i <- 0 until Halt_Infusion) {\n      put_Halt_Infusion()\n    }\n    for(i <- 0 until HW_Detected_Failure) {\n      put_HW_Detected_Failure()\n    }\n    for(i <- 0 until Stop_Pump_Completely) {\n      put_Stop_Pump_Completely()\n    }\n    for(i <- 0 until Pump_At_KVO_Rate) {\n      put_Pump_At_KVO_Rate()\n    }\n    for(i <- 0 until Patient_Request_Not_Too_Soon) {\n      put_Patient_Request_Not_Too_Soon()\n    }\n    for(i <- 0 until Pause_Infusion) {\n      put_Pause_Infusion()\n    }\n    for(i <- 0 until Resume_Infusion) {\n      put_Resume_Infusion()\n    }\n    for(i <- 0 until CP_Clinician_Request_Bolus) {\n      put_CP_Clinician_Request_Bolus()\n    }\n    for(i <- 0 until Near_Max_Drug_Per_Hour) {\n      put_Near_Max_Drug_Per_Hour()\n    }\n    for(i <- 0 until Over_Max_Drug_Per_Hour) {\n      put_Over_Max_Drug_Per_Hour()\n    }\n    for(i <- 0 until ICE_Stop_Pump) {\n      put_ICE_Stop_Pump()\n    }\n  }\n\n\n  \/** helper function to check Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Infusion_Flow_Rate method that will be called with the value of the outgoing data\n   *        port 'Infusion_Flow_Rate'.\n   * @param System_Status method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'System_Status'.\n   *\/\n  def check_concrete_output(Infusion_Flow_Rate: PCA_Types.Flow_Rate_imp => B = Infusion_Flow_RateParam => {T},\n                            System_Status: ISZ[PCA_Types.Status_Type.Type] => B = System_StatusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Infusion_Flow_RateValue: PCA_Types.Flow_Rate_imp = get_Infusion_Flow_Rate().get\n    if(!Infusion_Flow_Rate(Infusion_Flow_RateValue)) {\n      testFailures = testFailures :+ st\"'Infusion_Flow_Rate' did not match expected: value of the outgoing data port is ${Infusion_Flow_RateValue}\"\n    }\n    var System_StatusValue: ISZ[PCA_Types.Status_Type.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_System_Status().nonEmpty) System_StatusValue = System_StatusValue :+ get_System_Status().get\n    if(!System_Status(System_StatusValue)) {\n      testFailures = testFailures :+ st\"'System_Status' did not match expected: received ${System_StatusValue.size} events with the following payloads ${System_StatusValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Square_Bolus_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Square_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Patient_Bolus_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Basal_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Basal_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_VTBI(value : PCA_Types.Drug_Volume_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.VTBI_Id, PCA_Types.Drug_Volume_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Door_Open(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Door_Open_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Alarm(value : PCA_Types.Alarm_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Alarm_Id, PCA_Types.Alarm_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Warning(value : PCA_Types.Warning_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Warning_Id, PCA_Types.Warning_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_CP_Bolus_Duration(value : ICE_Types.Minute_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CP_Bolus_Duration_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Begin_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Begin_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Begin_Priming(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Begin_Priming_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_End_Priming(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.End_Priming_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Halt_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Halt_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_HW_Detected_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.HW_Detected_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Stop_Pump_Completely(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Stop_Pump_Completely_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Pump_At_KVO_Rate(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Pump_At_KVO_Rate_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Request_Not_Too_Soon(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Request_Not_Too_Soon_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Pause_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Pause_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Resume_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Resume_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_CP_Clinician_Request_Bolus(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CP_Clinician_Request_Bolus_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Near_Max_Drug_Per_Hour(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Near_Max_Drug_Per_Hour_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Over_Max_Drug_Per_Hour(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Over_Max_Drug_Per_Hour_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_ICE_Stop_Pump(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ICE_Stop_Pump_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_Infusion_Flow_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Infusion_Flow_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Infusion_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Infusion_Flow_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Infusion_Flow_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_System_Status(): Option[PCA_Types.Status_Type.Type] = {\n    val value: Option[PCA_Types.Status_Type.Type] = get_System_Status_payload() match {\n      case Some(PCA_Types.Status_Type_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port System_Status.  Expecting 'PCA_Types.Status_Type_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Status_Type.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_System_Status_payload(): Option[PCA_Types.Status_Type_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.System_Status_Id).asInstanceOf[Option[PCA_Types.Status_Type_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation_Threads._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Test extends Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation_Threads.{Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Infusion_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Square_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Patient_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Basal_Rate: Port[PCA_Types.Flow_Rate_imp],\n  VTBI: Port[PCA_Types.Drug_Volume_imp],\n  Door_Open: Port[Base_Types.Boolean],\n  System_Status: Port[PCA_Types.Status_Type.Type],\n  Alarm: Port[PCA_Types.Alarm_Type.Type],\n  Warning: Port[PCA_Types.Warning_Type.Type],\n  CP_Bolus_Duration: Port[ICE_Types.Minute_imp],\n  Begin_Infusion: Port[art.Empty],\n  Begin_Priming: Port[art.Empty],\n  End_Priming: Port[art.Empty],\n  Halt_Infusion: Port[art.Empty],\n  HW_Detected_Failure: Port[art.Empty],\n  Stop_Pump_Completely: Port[art.Empty],\n  Pump_At_KVO_Rate: Port[art.Empty],\n  Patient_Request_Not_Too_Soon: Port[art.Empty],\n  Pause_Infusion: Port[art.Empty],\n  Resume_Infusion: Port[art.Empty],\n  CP_Clinician_Request_Bolus: Port[art.Empty],\n  Near_Max_Drug_Per_Hour: Port[art.Empty],\n  Over_Max_Drug_Per_Hour: Port[art.Empty],\n  ICE_Stop_Pump: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Infusion_Flow_Rate,\n              Square_Bolus_Rate,\n              Patient_Bolus_Rate,\n              Basal_Rate,\n              VTBI,\n              Door_Open,\n              System_Status,\n              Alarm,\n              Warning,\n              CP_Bolus_Duration,\n              Begin_Infusion,\n              Begin_Priming,\n              End_Priming,\n              Halt_Infusion,\n              HW_Detected_Failure,\n              Stop_Pump_Completely,\n              Pump_At_KVO_Rate,\n              Patient_Request_Not_Too_Soon,\n              Pause_Infusion,\n              Resume_Infusion,\n              CP_Clinician_Request_Bolus,\n              Near_Max_Drug_Per_Hour,\n              Over_Max_Drug_Per_Hour,\n              ICE_Stop_Pump),\n\n    dataIns = ISZ(Square_Bolus_Rate,\n                  Patient_Bolus_Rate,\n                  Basal_Rate,\n                  VTBI,\n                  Door_Open),\n\n    dataOuts = ISZ(Infusion_Flow_Rate),\n\n    eventIns = ISZ(Alarm,\n                   Warning,\n                   CP_Bolus_Duration,\n                   Begin_Infusion,\n                   Begin_Priming,\n                   End_Priming,\n                   Halt_Infusion,\n                   HW_Detected_Failure,\n                   Stop_Pump_Completely,\n                   Pump_At_KVO_Rate,\n                   Patient_Request_Not_Too_Soon,\n                   Pause_Infusion,\n                   Resume_Infusion,\n                   CP_Clinician_Request_Bolus,\n                   Near_Max_Drug_Per_Hour,\n                   Over_Max_Drug_Per_Hour,\n                   ICE_Stop_Pump),\n\n    eventOuts = ISZ(System_Status)\n  )\n\n  val initialization_api : Rate_Controller_imp_Initialization_Api = {\n    val api = Rate_Controller_imp_Initialization_Api(\n      id,\n      Infusion_Flow_Rate.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      System_Status.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      Begin_Infusion.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Halt_Infusion.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Patient_Request_Not_Too_Soon.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      CP_Clinician_Request_Bolus.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id,\n      ICE_Stop_Pump.id\n    )\n    Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Rate_Controller_imp_Operational_Api = {\n    val api = Rate_Controller_imp_Operational_Api(\n      id,\n      Infusion_Flow_Rate.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      System_Status.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      Begin_Infusion.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Halt_Infusion.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Patient_Request_Not_Too_Soon.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      CP_Clinician_Request_Bolus.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id,\n      ICE_Stop_Pump.id\n    )\n    Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge.EntryPoints(\n      id,\n\n      Infusion_Flow_Rate.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      System_Status.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      Begin_Infusion.id,\n      Begin_Priming.id,\n      End_Priming.id,\n      Halt_Infusion.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      Patient_Request_Not_Too_Soon.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      CP_Clinician_Request_Bolus.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id,\n      ICE_Stop_Pump.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_Bridge {\n\n  var c_initialization_api: Option[Rate_Controller_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Rate_Controller_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_BridgeId : Art.BridgeId,\n\n    Infusion_Flow_Rate_Id : Art.PortId,\n    Square_Bolus_Rate_Id : Art.PortId,\n    Patient_Bolus_Rate_Id : Art.PortId,\n    Basal_Rate_Id : Art.PortId,\n    VTBI_Id : Art.PortId,\n    Door_Open_Id : Art.PortId,\n    System_Status_Id : Art.PortId,\n    Alarm_Id : Art.PortId,\n    Warning_Id : Art.PortId,\n    CP_Bolus_Duration_Id : Art.PortId,\n    Begin_Infusion_Id : Art.PortId,\n    Begin_Priming_Id : Art.PortId,\n    End_Priming_Id : Art.PortId,\n    Halt_Infusion_Id : Art.PortId,\n    HW_Detected_Failure_Id : Art.PortId,\n    Stop_Pump_Completely_Id : Art.PortId,\n    Pump_At_KVO_Rate_Id : Art.PortId,\n    Patient_Request_Not_Too_Soon_Id : Art.PortId,\n    Pause_Infusion_Id : Art.PortId,\n    Resume_Infusion_Id : Art.PortId,\n    CP_Clinician_Request_Bolus_Id : Art.PortId,\n    Near_Max_Drug_Per_Hour_Id : Art.PortId,\n    Over_Max_Drug_Per_Hour_Id : Art.PortId,\n    ICE_Stop_Pump_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Rate_Controller_imp_Initialization_Api,\n    operational_api: Rate_Controller_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Square_Bolus_Rate_Id,\n                                             Patient_Bolus_Rate_Id,\n                                             Basal_Rate_Id,\n                                             VTBI_Id,\n                                             Door_Open_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Alarm_Id,\n                                              Warning_Id,\n                                              CP_Bolus_Duration_Id,\n                                              Begin_Infusion_Id,\n                                              Begin_Priming_Id,\n                                              End_Priming_Id,\n                                              Halt_Infusion_Id,\n                                              HW_Detected_Failure_Id,\n                                              Stop_Pump_Completely_Id,\n                                              Pump_At_KVO_Rate_Id,\n                                              Patient_Request_Not_Too_Soon_Id,\n                                              Pause_Infusion_Id,\n                                              Resume_Infusion_Id,\n                                              CP_Clinician_Request_Bolus_Id,\n                                              Near_Max_Drug_Per_Hour_Id,\n                                              Over_Max_Drug_Per_Hour_Id,\n                                              ICE_Stop_Pump_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Infusion_Flow_Rate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(System_Status_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: Rate_Controller_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: Rate_Controller_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == CP_Bolus_Duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(CP_Bolus_Duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_CP_Bolus_Duration(api: Rate_Controller_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_CP_Bolus_Duration(operational_api, value)\n        }\n        else if(portId == Begin_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Infusion(operational_api)\n        }\n        else if(portId == Begin_Priming_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Priming(operational_api)\n        }\n        else if(portId == End_Priming_Id) {\n          \/\/ implement the following in 'component':  def handle_End_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_End_Priming(operational_api)\n        }\n        else if(portId == Halt_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Halt_Infusion(operational_api)\n        }\n        else if(portId == HW_Detected_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_HW_Detected_Failure(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_HW_Detected_Failure(operational_api)\n        }\n        else if(portId == Stop_Pump_Completely_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Pump_Completely(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Pump_Completely(operational_api)\n        }\n        else if(portId == Pump_At_KVO_Rate_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_At_KVO_Rate(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Pump_At_KVO_Rate(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Pause_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Pause_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Pause_Infusion(operational_api)\n        }\n        else if(portId == Resume_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Resume_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Resume_Infusion(operational_api)\n        }\n        else if(portId == CP_Clinician_Request_Bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Clinician_Request_Bolus(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_CP_Clinician_Request_Bolus(operational_api)\n        }\n        else if(portId == Near_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Near_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Near_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == Over_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Over_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Over_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == ICE_Stop_Pump_Id) {\n          \/\/ implement the following in 'component':  def handle_ICE_Stop_Pump(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_ICE_Stop_Pump(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: Rate_Controller_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: Rate_Controller_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == CP_Bolus_Duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(CP_Bolus_Duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_CP_Bolus_Duration(api: Rate_Controller_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_CP_Bolus_Duration(operational_api, value)\n        }\n        else if(portId == Begin_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Infusion(operational_api)\n        }\n        else if(portId == Begin_Priming_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Priming(operational_api)\n        }\n        else if(portId == End_Priming_Id) {\n          \/\/ implement the following in 'component':  def handle_End_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_End_Priming(operational_api)\n        }\n        else if(portId == Halt_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Halt_Infusion(operational_api)\n        }\n        else if(portId == HW_Detected_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_HW_Detected_Failure(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_HW_Detected_Failure(operational_api)\n        }\n        else if(portId == Stop_Pump_Completely_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Pump_Completely(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Pump_Completely(operational_api)\n        }\n        else if(portId == Pump_At_KVO_Rate_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_At_KVO_Rate(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Pump_At_KVO_Rate(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Pause_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Pause_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Pause_Infusion(operational_api)\n        }\n        else if(portId == Resume_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Resume_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Resume_Infusion(operational_api)\n        }\n        else if(portId == CP_Clinician_Request_Bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Clinician_Request_Bolus(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_CP_Clinician_Request_Bolus(operational_api)\n        }\n        else if(portId == Near_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Near_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Near_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == Over_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Over_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_Over_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == ICE_Stop_Pump_Id) {\n          \/\/ implement the following in 'component':  def handle_ICE_Stop_Pump(api: Rate_Controller_imp_Operational_Api): Unit = {}\n          component.handle_ICE_Stop_Pump(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Rate_Controller_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Rate_Controller_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Rate_Controller_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Rate_Controller_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Rate_Controller_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Rate_Controller_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Rate_Controller_imp_Api {\n  def id: Art.BridgeId\n  def Infusion_Flow_Rate_Id : Art.PortId\n  def Square_Bolus_Rate_Id : Art.PortId\n  def Patient_Bolus_Rate_Id : Art.PortId\n  def Basal_Rate_Id : Art.PortId\n  def VTBI_Id : Art.PortId\n  def Door_Open_Id : Art.PortId\n  def System_Status_Id : Art.PortId\n  def Alarm_Id : Art.PortId\n  def Warning_Id : Art.PortId\n  def CP_Bolus_Duration_Id : Art.PortId\n  def Begin_Infusion_Id : Art.PortId\n  def Begin_Priming_Id : Art.PortId\n  def End_Priming_Id : Art.PortId\n  def Halt_Infusion_Id : Art.PortId\n  def HW_Detected_Failure_Id : Art.PortId\n  def Stop_Pump_Completely_Id : Art.PortId\n  def Pump_At_KVO_Rate_Id : Art.PortId\n  def Patient_Request_Not_Too_Soon_Id : Art.PortId\n  def Pause_Infusion_Id : Art.PortId\n  def Resume_Infusion_Id : Art.PortId\n  def CP_Clinician_Request_Bolus_Id : Art.PortId\n  def Near_Max_Drug_Per_Hour_Id : Art.PortId\n  def Over_Max_Drug_Per_Hour_Id : Art.PortId\n  def ICE_Stop_Pump_Id : Art.PortId\n\n  def put_Infusion_Flow_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Infusion_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_System_Status(value : PCA_Types.Status_Type.Type) : Unit = {\n    Art.putValue(System_Status_Id, PCA_Types.Status_Type_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Rate_Controller_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val System_Status_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val CP_Bolus_Duration_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Begin_Priming_Id : Art.PortId,\n  val End_Priming_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Pause_Infusion_Id : Art.PortId,\n  val Resume_Infusion_Id : Art.PortId,\n  val CP_Clinician_Request_Bolus_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId,\n  val ICE_Stop_Pump_Id : Art.PortId) extends Rate_Controller_imp_Api\n\n@datatype class Rate_Controller_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val System_Status_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val CP_Bolus_Duration_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Begin_Priming_Id : Art.PortId,\n  val End_Priming_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Pause_Infusion_Id : Art.PortId,\n  val Resume_Infusion_Id : Art.PortId,\n  val CP_Clinician_Request_Bolus_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId,\n  val ICE_Stop_Pump_Id : Art.PortId) extends Rate_Controller_imp_Api {\n\n  def get_Square_Bolus_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Square_Bolus_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Square_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Patient_Bolus_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Patient_Bolus_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Basal_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Basal_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Basal_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_VTBI() : Option[PCA_Types.Drug_Volume_imp] = {\n    val value : Option[PCA_Types.Drug_Volume_imp] = Art.getValue(VTBI_Id) match {\n      case Some(PCA_Types.Drug_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port VTBI.  Expecting 'PCA_Types.Drug_Volume_imp_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Volume_imp]()\n      case _ => None[PCA_Types.Drug_Volume_imp]()\n    }\n    return value\n  }\n\n  def get_Door_Open() : Option[Base_Types.Boolean] = {\n    val value : Option[Base_Types.Boolean] = Art.getValue(Door_Open_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Door_Open.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  def get_Alarm() : Option[PCA_Types.Alarm_Type.Type] = {\n    val value : Option[PCA_Types.Alarm_Type.Type] = Art.getValue(Alarm_Id) match {\n      case Some(PCA_Types.Alarm_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Alarm.  Expecting 'PCA_Types.Alarm_Type_Payload' but received ${v}\")\n        None[PCA_Types.Alarm_Type.Type]()\n      case _ => None[PCA_Types.Alarm_Type.Type]()\n    }\n    return value\n  }\n\n  def get_Warning() : Option[PCA_Types.Warning_Type.Type] = {\n    val value : Option[PCA_Types.Warning_Type.Type] = Art.getValue(Warning_Id) match {\n      case Some(PCA_Types.Warning_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Warning.  Expecting 'PCA_Types.Warning_Type_Payload' but received ${v}\")\n        None[PCA_Types.Warning_Type.Type]()\n      case _ => None[PCA_Types.Warning_Type.Type]()\n    }\n    return value\n  }\n\n  def get_CP_Bolus_Duration() : Option[ICE_Types.Minute_imp] = {\n    val value : Option[ICE_Types.Minute_imp] = Art.getValue(CP_Bolus_Duration_Id) match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CP_Bolus_Duration.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n        None[ICE_Types.Minute_imp]()\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  def get_Begin_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Begin_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Begin_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Begin_Priming() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Begin_Priming_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Begin_Priming.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_End_Priming() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(End_Priming_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port End_Priming.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Halt_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Halt_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Halt_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_HW_Detected_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(HW_Detected_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port HW_Detected_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Stop_Pump_Completely() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Stop_Pump_Completely_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Stop_Pump_Completely.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Pump_At_KVO_Rate() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Pump_At_KVO_Rate_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Pump_At_KVO_Rate.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Patient_Request_Not_Too_Soon() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Request_Not_Too_Soon_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Request_Not_Too_Soon.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Pause_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Pause_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Pause_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Resume_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Resume_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Resume_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_CP_Clinician_Request_Bolus() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(CP_Clinician_Request_Bolus_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CP_Clinician_Request_Bolus.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Near_Max_Drug_Per_Hour() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Near_Max_Drug_Per_Hour_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Near_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Over_Max_Drug_Per_Hour() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Over_Max_Drug_Per_Hour_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Over_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_ICE_Stop_Pump() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(ICE_Stop_Pump_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ICE_Stop_Pump.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation_Threads\/Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Rate_Controller_imp_pump_operation_operation_process_operation_threads_rate_controller {\n\n  def initialise(api: Rate_Controller_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Infusion_Flow_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_System_Status(PCA_Types.Status_Type.byOrdinal(0).get)\n  }\n\n  def handle_Alarm(api: Rate_Controller_imp_Operational_Api, value : PCA_Types.Alarm_Type.Type): Unit = {\n    api.logInfo(\"example handle_Alarm implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Square_Bolus_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Square_Bolus_Rate()\n    api.logInfo(s\"Received on Square_Bolus_Rate: ${apiUsage_Square_Bolus_Rate}\")\n    val apiUsage_Patient_Bolus_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Patient_Bolus_Rate()\n    api.logInfo(s\"Received on Patient_Bolus_Rate: ${apiUsage_Patient_Bolus_Rate}\")\n    val apiUsage_Basal_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Basal_Rate()\n    api.logInfo(s\"Received on Basal_Rate: ${apiUsage_Basal_Rate}\")\n    val apiUsage_VTBI: Option[PCA_Types.Drug_Volume_imp] = api.get_VTBI()\n    api.logInfo(s\"Received on VTBI: ${apiUsage_VTBI}\")\n    val apiUsage_Door_Open: Option[Base_Types.Boolean] = api.get_Door_Open()\n    api.logInfo(s\"Received on Door_Open: ${apiUsage_Door_Open}\")\n    val apiUsage_Alarm: Option[PCA_Types.Alarm_Type.Type] = api.get_Alarm()\n    api.logInfo(s\"Received on Alarm: ${apiUsage_Alarm}\")\n    val apiUsage_Warning: Option[PCA_Types.Warning_Type.Type] = api.get_Warning()\n    api.logInfo(s\"Received on Warning: ${apiUsage_Warning}\")\n    val apiUsage_CP_Bolus_Duration: Option[ICE_Types.Minute_imp] = api.get_CP_Bolus_Duration()\n    api.logInfo(s\"Received on CP_Bolus_Duration: ${apiUsage_CP_Bolus_Duration}\")\n    val apiUsage_Begin_Infusion: Option[art.Empty] = api.get_Begin_Infusion()\n    api.logInfo(s\"Received on Begin_Infusion: ${apiUsage_Begin_Infusion}\")\n    val apiUsage_Begin_Priming: Option[art.Empty] = api.get_Begin_Priming()\n    api.logInfo(s\"Received on Begin_Priming: ${apiUsage_Begin_Priming}\")\n    val apiUsage_End_Priming: Option[art.Empty] = api.get_End_Priming()\n    api.logInfo(s\"Received on End_Priming: ${apiUsage_End_Priming}\")\n    val apiUsage_Halt_Infusion: Option[art.Empty] = api.get_Halt_Infusion()\n    api.logInfo(s\"Received on Halt_Infusion: ${apiUsage_Halt_Infusion}\")\n    val apiUsage_HW_Detected_Failure: Option[art.Empty] = api.get_HW_Detected_Failure()\n    api.logInfo(s\"Received on HW_Detected_Failure: ${apiUsage_HW_Detected_Failure}\")\n    val apiUsage_Stop_Pump_Completely: Option[art.Empty] = api.get_Stop_Pump_Completely()\n    api.logInfo(s\"Received on Stop_Pump_Completely: ${apiUsage_Stop_Pump_Completely}\")\n    val apiUsage_Pump_At_KVO_Rate: Option[art.Empty] = api.get_Pump_At_KVO_Rate()\n    api.logInfo(s\"Received on Pump_At_KVO_Rate: ${apiUsage_Pump_At_KVO_Rate}\")\n    val apiUsage_Patient_Request_Not_Too_Soon: Option[art.Empty] = api.get_Patient_Request_Not_Too_Soon()\n    api.logInfo(s\"Received on Patient_Request_Not_Too_Soon: ${apiUsage_Patient_Request_Not_Too_Soon}\")\n    val apiUsage_Pause_Infusion: Option[art.Empty] = api.get_Pause_Infusion()\n    api.logInfo(s\"Received on Pause_Infusion: ${apiUsage_Pause_Infusion}\")\n    val apiUsage_Resume_Infusion: Option[art.Empty] = api.get_Resume_Infusion()\n    api.logInfo(s\"Received on Resume_Infusion: ${apiUsage_Resume_Infusion}\")\n    val apiUsage_CP_Clinician_Request_Bolus: Option[art.Empty] = api.get_CP_Clinician_Request_Bolus()\n    api.logInfo(s\"Received on CP_Clinician_Request_Bolus: ${apiUsage_CP_Clinician_Request_Bolus}\")\n    val apiUsage_Near_Max_Drug_Per_Hour: Option[art.Empty] = api.get_Near_Max_Drug_Per_Hour()\n    api.logInfo(s\"Received on Near_Max_Drug_Per_Hour: ${apiUsage_Near_Max_Drug_Per_Hour}\")\n    val apiUsage_Over_Max_Drug_Per_Hour: Option[art.Empty] = api.get_Over_Max_Drug_Per_Hour()\n    api.logInfo(s\"Received on Over_Max_Drug_Per_Hour: ${apiUsage_Over_Max_Drug_Per_Hour}\")\n    val apiUsage_ICE_Stop_Pump: Option[art.Empty] = api.get_ICE_Stop_Pump()\n    api.logInfo(s\"Received on ICE_Stop_Pump: ${apiUsage_ICE_Stop_Pump}\")\n  }\n\n  def handle_Warning(api: Rate_Controller_imp_Operational_Api, value : PCA_Types.Warning_Type.Type): Unit = {\n    api.logInfo(\"example handle_Warning implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_CP_Bolus_Duration(api: Rate_Controller_imp_Operational_Api, value : ICE_Types.Minute_imp): Unit = {\n    api.logInfo(\"example handle_CP_Bolus_Duration implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Begin_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Begin_Infusion implementation\")\n    api.logInfo(\"received Begin_Infusion event\")\n  }\n\n  def handle_Begin_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Begin_Priming implementation\")\n    api.logInfo(\"received Begin_Priming event\")\n  }\n\n  def handle_End_Priming(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_End_Priming implementation\")\n    api.logInfo(\"received End_Priming event\")\n  }\n\n  def handle_Halt_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Halt_Infusion implementation\")\n    api.logInfo(\"received Halt_Infusion event\")\n  }\n\n  def handle_HW_Detected_Failure(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_HW_Detected_Failure implementation\")\n    api.logInfo(\"received HW_Detected_Failure event\")\n  }\n\n  def handle_Stop_Pump_Completely(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Stop_Pump_Completely implementation\")\n    api.logInfo(\"received Stop_Pump_Completely event\")\n  }\n\n  def handle_Pump_At_KVO_Rate(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Pump_At_KVO_Rate implementation\")\n    api.logInfo(\"received Pump_At_KVO_Rate event\")\n  }\n\n  def handle_Patient_Request_Not_Too_Soon(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Request_Not_Too_Soon implementation\")\n    api.logInfo(\"received Patient_Request_Not_Too_Soon event\")\n  }\n\n  def handle_Pause_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Pause_Infusion implementation\")\n    api.logInfo(\"received Pause_Infusion event\")\n  }\n\n  def handle_Resume_Infusion(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Resume_Infusion implementation\")\n    api.logInfo(\"received Resume_Infusion event\")\n  }\n\n  def handle_CP_Clinician_Request_Bolus(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_CP_Clinician_Request_Bolus implementation\")\n    api.logInfo(\"received CP_Clinician_Request_Bolus event\")\n  }\n\n  def handle_Near_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Near_Max_Drug_Per_Hour implementation\")\n    api.logInfo(\"received Near_Max_Drug_Per_Hour event\")\n  }\n\n  def handle_Over_Max_Drug_Per_Hour(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Over_Max_Drug_Per_Hour implementation\")\n    api.logInfo(\"received Over_Max_Drug_Per_Hour event\")\n  }\n\n  def handle_ICE_Stop_Pump(api: Rate_Controller_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_ICE_Stop_Pump implementation\")\n    api.logInfo(\"received ICE_Stop_Pump event\")\n  }\n\n  def activate(api: Rate_Controller_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Rate_Controller_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Rate_Controller_imp_Operational_Api): Unit = { }\n\n  def recover(api: Rate_Controller_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation_Threads\/Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_TestApi extends BridgeTestSuite[Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_prescription_checker) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Prescription payload for data port Prescription\n   * @param The_Drug_Record payloads for event data port The_Drug_Record.\n   *   ART currently supports single element event data queues so\n   *   only the last element of The_Drug_Record will be used\n   * @param Check_Rx the number of events to place in the Check_Rx event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Drug_Not_In_Library the number of events to place in the Drug_Not_In_Library event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Confirm_Soft_Limit_Exception the number of events to place in the Confirm_Soft_Limit_Exception event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Reject_Soft_Limit_Exception the number of events to place in the Reject_Soft_Limit_Exception event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Prescription : PCA_Types.Prescription_imp,\n                          The_Drug_Record : ISZ[PCA_Types.Drug_Record_imp],\n                          Check_Rx : Z,\n                          Drug_Not_In_Library : Z,\n                          Confirm_Soft_Limit_Exception : Z,\n                          Reject_Soft_Limit_Exception : Z): Unit = {\n    put_Prescription(Prescription)\n    for(v <- The_Drug_Record){\n      put_The_Drug_Record(v)\n    }\n    for(i <- 0 until Check_Rx) {\n      put_Check_Rx()\n    }\n    for(i <- 0 until Drug_Not_In_Library) {\n      put_Drug_Not_In_Library()\n    }\n    for(i <- 0 until Confirm_Soft_Limit_Exception) {\n      put_Confirm_Soft_Limit_Exception()\n    }\n    for(i <- 0 until Reject_Soft_Limit_Exception) {\n      put_Reject_Soft_Limit_Exception()\n    }\n  }\n\n\n  \/** helper function to check Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param VTBI method that will be called with the value of the outgoing data\n   *        port 'VTBI'.\n   * @param Square_Bolus_Rate method that will be called with the value of the outgoing data\n   *        port 'Square_Bolus_Rate'.\n   * @param Patient_Bolus_Rate method that will be called with the value of the outgoing data\n   *        port 'Patient_Bolus_Rate'.\n   * @param Basal_Rate method that will be called with the value of the outgoing data\n   *        port 'Basal_Rate'.\n   * @param Minimum_Time_Between_Bolus method that will be called with the value of the outgoing data\n   *        port 'Minimum_Time_Between_Bolus'.\n   * @param Max_Drug_Per_Hour method that will be called with the value of the outgoing data\n   *        port 'Max_Drug_Per_Hour'.\n   * @param Get_Drug_Record method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Get_Drug_Record'.\n   * @param Rx_Okay method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Rx_Okay'.\n   * @param Soft_Limit_Warning method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Soft_Limit_Warning'.\n   * @param Hard_Limit_Violated method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Hard_Limit_Violated'.\n   *\/\n  def check_concrete_output(VTBI: PCA_Types.Drug_Volume_imp => B = VTBIParam => {T},\n                            Square_Bolus_Rate: PCA_Types.Flow_Rate_imp => B = Square_Bolus_RateParam => {T},\n                            Patient_Bolus_Rate: PCA_Types.Flow_Rate_imp => B = Patient_Bolus_RateParam => {T},\n                            Basal_Rate: PCA_Types.Flow_Rate_imp => B = Basal_RateParam => {T},\n                            Minimum_Time_Between_Bolus: ICE_Types.Minute_imp => B = Minimum_Time_Between_BolusParam => {T},\n                            Max_Drug_Per_Hour: PCA_Types.Drug_Volume_imp => B = Max_Drug_Per_HourParam => {T},\n                            Get_Drug_Record: ISZ[PCA_Types.Drug_Code_imp] => B = Get_Drug_RecordParam => {T},\n                            Rx_Okay: Z => B = Rx_OkayParam => {T},\n                            Soft_Limit_Warning: Z => B = Soft_Limit_WarningParam => {T},\n                            Hard_Limit_Violated: Z => B = Hard_Limit_ViolatedParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val VTBIValue: PCA_Types.Drug_Volume_imp = get_VTBI().get\n    if(!VTBI(VTBIValue)) {\n      testFailures = testFailures :+ st\"'VTBI' did not match expected: value of the outgoing data port is ${VTBIValue}\"\n    }\n    val Square_Bolus_RateValue: PCA_Types.Flow_Rate_imp = get_Square_Bolus_Rate().get\n    if(!Square_Bolus_Rate(Square_Bolus_RateValue)) {\n      testFailures = testFailures :+ st\"'Square_Bolus_Rate' did not match expected: value of the outgoing data port is ${Square_Bolus_RateValue}\"\n    }\n    val Patient_Bolus_RateValue: PCA_Types.Flow_Rate_imp = get_Patient_Bolus_Rate().get\n    if(!Patient_Bolus_Rate(Patient_Bolus_RateValue)) {\n      testFailures = testFailures :+ st\"'Patient_Bolus_Rate' did not match expected: value of the outgoing data port is ${Patient_Bolus_RateValue}\"\n    }\n    val Basal_RateValue: PCA_Types.Flow_Rate_imp = get_Basal_Rate().get\n    if(!Basal_Rate(Basal_RateValue)) {\n      testFailures = testFailures :+ st\"'Basal_Rate' did not match expected: value of the outgoing data port is ${Basal_RateValue}\"\n    }\n    val Minimum_Time_Between_BolusValue: ICE_Types.Minute_imp = get_Minimum_Time_Between_Bolus().get\n    if(!Minimum_Time_Between_Bolus(Minimum_Time_Between_BolusValue)) {\n      testFailures = testFailures :+ st\"'Minimum_Time_Between_Bolus' did not match expected: value of the outgoing data port is ${Minimum_Time_Between_BolusValue}\"\n    }\n    val Max_Drug_Per_HourValue: PCA_Types.Drug_Volume_imp = get_Max_Drug_Per_Hour().get\n    if(!Max_Drug_Per_Hour(Max_Drug_Per_HourValue)) {\n      testFailures = testFailures :+ st\"'Max_Drug_Per_Hour' did not match expected: value of the outgoing data port is ${Max_Drug_Per_HourValue}\"\n    }\n    var Get_Drug_RecordValue: ISZ[PCA_Types.Drug_Code_imp] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Get_Drug_Record().nonEmpty) Get_Drug_RecordValue = Get_Drug_RecordValue :+ get_Get_Drug_Record().get\n    if(!Get_Drug_Record(Get_Drug_RecordValue)) {\n      testFailures = testFailures :+ st\"'Get_Drug_Record' did not match expected: received ${Get_Drug_RecordValue.size} events with the following payloads ${Get_Drug_RecordValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Rx_OkayValue: Z = if(get_Rx_Okay().nonEmpty) z\"1\" else z\"0\"\n    if(!Rx_Okay(Rx_OkayValue)) {\n      testFailures = testFailures :+ st\"'Rx_Okay' did not match expected: ${Rx_OkayValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Soft_Limit_WarningValue: Z = if(get_Soft_Limit_Warning().nonEmpty) z\"1\" else z\"0\"\n    if(!Soft_Limit_Warning(Soft_Limit_WarningValue)) {\n      testFailures = testFailures :+ st\"'Soft_Limit_Warning' did not match expected: ${Soft_Limit_WarningValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Hard_Limit_ViolatedValue: Z = if(get_Hard_Limit_Violated().nonEmpty) z\"1\" else z\"0\"\n    if(!Hard_Limit_Violated(Hard_Limit_ViolatedValue)) {\n      testFailures = testFailures :+ st\"'Hard_Limit_Violated' did not match expected: ${Hard_Limit_ViolatedValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Prescription(value : PCA_Types.Prescription_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Prescription_Id, PCA_Types.Prescription_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_The_Drug_Record(value : PCA_Types.Drug_Record_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.The_Drug_Record_Id, PCA_Types.Drug_Record_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Check_Rx(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Check_Rx_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Drug_Not_In_Library(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Not_In_Library_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Confirm_Soft_Limit_Exception(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Confirm_Soft_Limit_Exception_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Reject_Soft_Limit_Exception(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Reject_Soft_Limit_Exception_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_VTBI(): Option[PCA_Types.Drug_Volume_imp] = {\n    val value: Option[PCA_Types.Drug_Volume_imp] = get_VTBI_payload() match {\n      case Some(PCA_Types.Drug_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port VTBI.  Expecting 'PCA_Types.Drug_Volume_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Volume_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_VTBI_payload(): Option[PCA_Types.Drug_Volume_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.VTBI_Id).asInstanceOf[Option[PCA_Types.Drug_Volume_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Square_Bolus_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Square_Bolus_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Square_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Square_Bolus_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Square_Bolus_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Patient_Bolus_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Patient_Bolus_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Patient_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Patient_Bolus_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Patient_Bolus_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Basal_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Basal_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Basal_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Basal_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Basal_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Minimum_Time_Between_Bolus(): Option[ICE_Types.Minute_imp] = {\n    val value: Option[ICE_Types.Minute_imp] = get_Minimum_Time_Between_Bolus_payload() match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Minimum_Time_Between_Bolus.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Minimum_Time_Between_Bolus_payload(): Option[ICE_Types.Minute_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Minimum_Time_Between_Bolus_Id).asInstanceOf[Option[ICE_Types.Minute_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Max_Drug_Per_Hour(): Option[PCA_Types.Drug_Volume_imp] = {\n    val value: Option[PCA_Types.Drug_Volume_imp] = get_Max_Drug_Per_Hour_payload() match {\n      case Some(PCA_Types.Drug_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Max_Drug_Per_Hour.  Expecting 'PCA_Types.Drug_Volume_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Volume_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Max_Drug_Per_Hour_payload(): Option[PCA_Types.Drug_Volume_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Max_Drug_Per_Hour_Id).asInstanceOf[Option[PCA_Types.Drug_Volume_imp_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Get_Drug_Record(): Option[PCA_Types.Drug_Code_imp] = {\n    val value: Option[PCA_Types.Drug_Code_imp] = get_Get_Drug_Record_payload() match {\n      case Some(PCA_Types.Drug_Code_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Get_Drug_Record.  Expecting 'PCA_Types.Drug_Code_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Drug_Code_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Get_Drug_Record_payload(): Option[PCA_Types.Drug_Code_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Get_Drug_Record_Id).asInstanceOf[Option[PCA_Types.Drug_Code_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Rx_Okay(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Rx_Okay_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Rx_Okay.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Rx_Okay_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Rx_Okay_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Soft_Limit_Warning(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Soft_Limit_Warning_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Soft_Limit_Warning.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Soft_Limit_Warning_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Soft_Limit_Warning_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Hard_Limit_Violated(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Hard_Limit_Violated_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Hard_Limit_Violated.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Hard_Limit_Violated_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Hard_Limit_Violated_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation_Threads._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Test extends Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation_Threads.{Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Prescription: Port[PCA_Types.Prescription_imp],\n  VTBI: Port[PCA_Types.Drug_Volume_imp],\n  Square_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Patient_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Basal_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Minimum_Time_Between_Bolus: Port[ICE_Types.Minute_imp],\n  Max_Drug_Per_Hour: Port[PCA_Types.Drug_Volume_imp],\n  Get_Drug_Record: Port[PCA_Types.Drug_Code_imp],\n  The_Drug_Record: Port[PCA_Types.Drug_Record_imp],\n  Check_Rx: Port[art.Empty],\n  Rx_Okay: Port[art.Empty],\n  Drug_Not_In_Library: Port[art.Empty],\n  Confirm_Soft_Limit_Exception: Port[art.Empty],\n  Reject_Soft_Limit_Exception: Port[art.Empty],\n  Soft_Limit_Warning: Port[art.Empty],\n  Hard_Limit_Violated: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Prescription,\n              VTBI,\n              Square_Bolus_Rate,\n              Patient_Bolus_Rate,\n              Basal_Rate,\n              Minimum_Time_Between_Bolus,\n              Max_Drug_Per_Hour,\n              Get_Drug_Record,\n              The_Drug_Record,\n              Check_Rx,\n              Rx_Okay,\n              Drug_Not_In_Library,\n              Confirm_Soft_Limit_Exception,\n              Reject_Soft_Limit_Exception,\n              Soft_Limit_Warning,\n              Hard_Limit_Violated),\n\n    dataIns = ISZ(Prescription),\n\n    dataOuts = ISZ(VTBI,\n                   Square_Bolus_Rate,\n                   Patient_Bolus_Rate,\n                   Basal_Rate,\n                   Minimum_Time_Between_Bolus,\n                   Max_Drug_Per_Hour),\n\n    eventIns = ISZ(The_Drug_Record,\n                   Check_Rx,\n                   Drug_Not_In_Library,\n                   Confirm_Soft_Limit_Exception,\n                   Reject_Soft_Limit_Exception),\n\n    eventOuts = ISZ(Get_Drug_Record,\n                    Rx_Okay,\n                    Soft_Limit_Warning,\n                    Hard_Limit_Violated)\n  )\n\n  val initialization_api : Prescription_Checker_imp_Initialization_Api = {\n    val api = Prescription_Checker_imp_Initialization_Api(\n      id,\n      Prescription.id,\n      VTBI.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      Minimum_Time_Between_Bolus.id,\n      Max_Drug_Per_Hour.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      Check_Rx.id,\n      Rx_Okay.id,\n      Drug_Not_In_Library.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Soft_Limit_Warning.id,\n      Hard_Limit_Violated.id\n    )\n    Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Prescription_Checker_imp_Operational_Api = {\n    val api = Prescription_Checker_imp_Operational_Api(\n      id,\n      Prescription.id,\n      VTBI.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      Minimum_Time_Between_Bolus.id,\n      Max_Drug_Per_Hour.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      Check_Rx.id,\n      Rx_Okay.id,\n      Drug_Not_In_Library.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Soft_Limit_Warning.id,\n      Hard_Limit_Violated.id\n    )\n    Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge.EntryPoints(\n      id,\n\n      Prescription.id,\n      VTBI.id,\n      Square_Bolus_Rate.id,\n      Patient_Bolus_Rate.id,\n      Basal_Rate.id,\n      Minimum_Time_Between_Bolus.id,\n      Max_Drug_Per_Hour.id,\n      Get_Drug_Record.id,\n      The_Drug_Record.id,\n      Check_Rx.id,\n      Rx_Okay.id,\n      Drug_Not_In_Library.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Soft_Limit_Warning.id,\n      Hard_Limit_Violated.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_Bridge {\n\n  var c_initialization_api: Option[Prescription_Checker_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Prescription_Checker_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_BridgeId : Art.BridgeId,\n\n    Prescription_Id : Art.PortId,\n    VTBI_Id : Art.PortId,\n    Square_Bolus_Rate_Id : Art.PortId,\n    Patient_Bolus_Rate_Id : Art.PortId,\n    Basal_Rate_Id : Art.PortId,\n    Minimum_Time_Between_Bolus_Id : Art.PortId,\n    Max_Drug_Per_Hour_Id : Art.PortId,\n    Get_Drug_Record_Id : Art.PortId,\n    The_Drug_Record_Id : Art.PortId,\n    Check_Rx_Id : Art.PortId,\n    Rx_Okay_Id : Art.PortId,\n    Drug_Not_In_Library_Id : Art.PortId,\n    Confirm_Soft_Limit_Exception_Id : Art.PortId,\n    Reject_Soft_Limit_Exception_Id : Art.PortId,\n    Soft_Limit_Warning_Id : Art.PortId,\n    Hard_Limit_Violated_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Prescription_Checker_imp_Initialization_Api,\n    operational_api: Prescription_Checker_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Prescription_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(The_Drug_Record_Id,\n                                              Check_Rx_Id,\n                                              Drug_Not_In_Library_Id,\n                                              Confirm_Soft_Limit_Exception_Id,\n                                              Reject_Soft_Limit_Exception_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(VTBI_Id,\n                                              Square_Bolus_Rate_Id,\n                                              Patient_Bolus_Rate_Id,\n                                              Basal_Rate_Id,\n                                              Minimum_Time_Between_Bolus_Id,\n                                              Max_Drug_Per_Hour_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Get_Drug_Record_Id,\n                                               Rx_Okay_Id,\n                                               Soft_Limit_Warning_Id,\n                                               Hard_Limit_Violated_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == The_Drug_Record_Id){\n          val Some(PCA_Types.Drug_Record_imp_Payload(value)) = Art.getValue(The_Drug_Record_Id)\n\n          \/\/ implement the following in 'component':  def handle_The_Drug_Record(api: Prescription_Checker_imp_Operational_Api, value: PCA_Types.Drug_Record_imp): Unit = {}\n          component.handle_The_Drug_Record(operational_api, value)\n        }\n        else if(portId == Check_Rx_Id) {\n          \/\/ implement the following in 'component':  def handle_Check_Rx(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Check_Rx(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Confirm_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Confirm_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Confirm_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Reject_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Reject_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Reject_Soft_Limit_Exception(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == The_Drug_Record_Id){\n          val Some(PCA_Types.Drug_Record_imp_Payload(value)) = Art.getValue(The_Drug_Record_Id)\n\n          \/\/ implement the following in 'component':  def handle_The_Drug_Record(api: Prescription_Checker_imp_Operational_Api, value: PCA_Types.Drug_Record_imp): Unit = {}\n          component.handle_The_Drug_Record(operational_api, value)\n        }\n        else if(portId == Check_Rx_Id) {\n          \/\/ implement the following in 'component':  def handle_Check_Rx(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Check_Rx(operational_api)\n        }\n        else if(portId == Drug_Not_In_Library_Id) {\n          \/\/ implement the following in 'component':  def handle_Drug_Not_In_Library(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Drug_Not_In_Library(operational_api)\n        }\n        else if(portId == Confirm_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Confirm_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Confirm_Soft_Limit_Exception(operational_api)\n        }\n        else if(portId == Reject_Soft_Limit_Exception_Id) {\n          \/\/ implement the following in 'component':  def handle_Reject_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Reject_Soft_Limit_Exception(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Prescription_Checker_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Prescription_Checker_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Prescription_Checker_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Prescription_Checker_imp_Api {\n  def id: Art.BridgeId\n  def Prescription_Id : Art.PortId\n  def VTBI_Id : Art.PortId\n  def Square_Bolus_Rate_Id : Art.PortId\n  def Patient_Bolus_Rate_Id : Art.PortId\n  def Basal_Rate_Id : Art.PortId\n  def Minimum_Time_Between_Bolus_Id : Art.PortId\n  def Max_Drug_Per_Hour_Id : Art.PortId\n  def Get_Drug_Record_Id : Art.PortId\n  def The_Drug_Record_Id : Art.PortId\n  def Check_Rx_Id : Art.PortId\n  def Rx_Okay_Id : Art.PortId\n  def Drug_Not_In_Library_Id : Art.PortId\n  def Confirm_Soft_Limit_Exception_Id : Art.PortId\n  def Reject_Soft_Limit_Exception_Id : Art.PortId\n  def Soft_Limit_Warning_Id : Art.PortId\n  def Hard_Limit_Violated_Id : Art.PortId\n\n  def put_VTBI(value : PCA_Types.Drug_Volume_imp) : Unit = {\n    Art.putValue(VTBI_Id, PCA_Types.Drug_Volume_imp_Payload(value))\n  }\n\n  def put_Square_Bolus_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Square_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_Patient_Bolus_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Patient_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_Basal_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Basal_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_Minimum_Time_Between_Bolus(value : ICE_Types.Minute_imp) : Unit = {\n    Art.putValue(Minimum_Time_Between_Bolus_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  def put_Max_Drug_Per_Hour(value : PCA_Types.Drug_Volume_imp) : Unit = {\n    Art.putValue(Max_Drug_Per_Hour_Id, PCA_Types.Drug_Volume_imp_Payload(value))\n  }\n\n  def put_Get_Drug_Record(value : PCA_Types.Drug_Code_imp) : Unit = {\n    Art.putValue(Get_Drug_Record_Id, PCA_Types.Drug_Code_imp_Payload(value))\n  }\n\n  def put_Rx_Okay() : Unit = {\n    Art.putValue(Rx_Okay_Id, art.Empty())\n  }\n\n  def put_Soft_Limit_Warning() : Unit = {\n    Art.putValue(Soft_Limit_Warning_Id, art.Empty())\n  }\n\n  def put_Hard_Limit_Violated() : Unit = {\n    Art.putValue(Hard_Limit_Violated_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Prescription_Checker_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Prescription_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val Minimum_Time_Between_Bolus_Id : Art.PortId,\n  val Max_Drug_Per_Hour_Id : Art.PortId,\n  val Get_Drug_Record_Id : Art.PortId,\n  val The_Drug_Record_Id : Art.PortId,\n  val Check_Rx_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Soft_Limit_Warning_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId) extends Prescription_Checker_imp_Api\n\n@datatype class Prescription_Checker_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Prescription_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val Minimum_Time_Between_Bolus_Id : Art.PortId,\n  val Max_Drug_Per_Hour_Id : Art.PortId,\n  val Get_Drug_Record_Id : Art.PortId,\n  val The_Drug_Record_Id : Art.PortId,\n  val Check_Rx_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Drug_Not_In_Library_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Soft_Limit_Warning_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId) extends Prescription_Checker_imp_Api {\n\n  def get_Prescription() : Option[PCA_Types.Prescription_imp] = {\n    val value : Option[PCA_Types.Prescription_imp] = Art.getValue(Prescription_Id) match {\n      case Some(PCA_Types.Prescription_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Prescription.  Expecting 'PCA_Types.Prescription_imp_Payload' but received ${v}\")\n        None[PCA_Types.Prescription_imp]()\n      case _ => None[PCA_Types.Prescription_imp]()\n    }\n    return value\n  }\n\n  def get_The_Drug_Record() : Option[PCA_Types.Drug_Record_imp] = {\n    val value : Option[PCA_Types.Drug_Record_imp] = Art.getValue(The_Drug_Record_Id) match {\n      case Some(PCA_Types.Drug_Record_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port The_Drug_Record.  Expecting 'PCA_Types.Drug_Record_imp_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Record_imp]()\n      case _ => None[PCA_Types.Drug_Record_imp]()\n    }\n    return value\n  }\n\n  def get_Check_Rx() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Check_Rx_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Check_Rx.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Drug_Not_In_Library() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Drug_Not_In_Library_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Not_In_Library.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Confirm_Soft_Limit_Exception() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Confirm_Soft_Limit_Exception_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Confirm_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Reject_Soft_Limit_Exception() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Reject_Soft_Limit_Exception_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Reject_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation_Threads\/Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Prescription_Checker_imp_pump_operation_operation_process_operation_threads_prescription_checker {\n\n  def initialise(api: Prescription_Checker_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_VTBI(PCA_Types.Drug_Volume_imp.example())\n    api.put_Square_Bolus_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_Patient_Bolus_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_Basal_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_Minimum_Time_Between_Bolus(ICE_Types.Minute_imp.example())\n    api.put_Max_Drug_Per_Hour(PCA_Types.Drug_Volume_imp.example())\n    api.put_Get_Drug_Record(PCA_Types.Drug_Code_imp.example())\n    api.put_Rx_Okay()\n    api.put_Soft_Limit_Warning()\n    api.put_Hard_Limit_Violated()\n  }\n\n  def handle_The_Drug_Record(api: Prescription_Checker_imp_Operational_Api, value : PCA_Types.Drug_Record_imp): Unit = {\n    api.logInfo(\"example handle_The_Drug_Record implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Prescription: Option[PCA_Types.Prescription_imp] = api.get_Prescription()\n    api.logInfo(s\"Received on Prescription: ${apiUsage_Prescription}\")\n    val apiUsage_The_Drug_Record: Option[PCA_Types.Drug_Record_imp] = api.get_The_Drug_Record()\n    api.logInfo(s\"Received on The_Drug_Record: ${apiUsage_The_Drug_Record}\")\n    val apiUsage_Check_Rx: Option[art.Empty] = api.get_Check_Rx()\n    api.logInfo(s\"Received on Check_Rx: ${apiUsage_Check_Rx}\")\n    val apiUsage_Drug_Not_In_Library: Option[art.Empty] = api.get_Drug_Not_In_Library()\n    api.logInfo(s\"Received on Drug_Not_In_Library: ${apiUsage_Drug_Not_In_Library}\")\n    val apiUsage_Confirm_Soft_Limit_Exception: Option[art.Empty] = api.get_Confirm_Soft_Limit_Exception()\n    api.logInfo(s\"Received on Confirm_Soft_Limit_Exception: ${apiUsage_Confirm_Soft_Limit_Exception}\")\n    val apiUsage_Reject_Soft_Limit_Exception: Option[art.Empty] = api.get_Reject_Soft_Limit_Exception()\n    api.logInfo(s\"Received on Reject_Soft_Limit_Exception: ${apiUsage_Reject_Soft_Limit_Exception}\")\n  }\n\n  def handle_Check_Rx(api: Prescription_Checker_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Check_Rx implementation\")\n    api.logInfo(\"received Check_Rx event\")\n  }\n\n  def handle_Drug_Not_In_Library(api: Prescription_Checker_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Drug_Not_In_Library implementation\")\n    api.logInfo(\"received Drug_Not_In_Library event\")\n  }\n\n  def handle_Confirm_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Confirm_Soft_Limit_Exception implementation\")\n    api.logInfo(\"received Confirm_Soft_Limit_Exception event\")\n  }\n\n  def handle_Reject_Soft_Limit_Exception(api: Prescription_Checker_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Reject_Soft_Limit_Exception implementation\")\n    api.logInfo(\"received Reject_Soft_Limit_Exception event\")\n  }\n\n  def activate(api: Prescription_Checker_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Prescription_Checker_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Prescription_Checker_imp_Operational_Api): Unit = { }\n\n  def recover(api: Prescription_Checker_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation_Threads\/ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_TestApi extends BridgeTestSuite[ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_ice_thread) {\n\n  \/** helper function to set the values of all input ports.\n   * @param command_Start the number of events to place in the command_Start event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param command_Suspend the number of events to place in the command_Suspend event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param command_load_drug_library payloads for event data port command_load_drug_library.\n   *   ART currently supports single element event data queues so\n   *   only the last element of command_load_drug_library will be used\n   * @param command_set_clinican_requested_bolus_duration payloads for event data port command_set_clinican_requested_bolus_duration.\n   *   ART currently supports single element event data queues so\n   *   only the last element of command_set_clinican_requested_bolus_duration will be used\n   * @param command_request_bolus the number of events to place in the command_request_bolus event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param command_pause_infusion the number of events to place in the command_pause_infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param command_resume_infusion the number of events to place in the command_resume_infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param status_AppConnected payload for data port status_AppConnected\n   * @param Infusion_Flow_Rate payload for data port Infusion_Flow_Rate\n   * @param Patient_Bolus_Rate payload for data port Patient_Bolus_Rate\n   * @param Square_Bolus_Rate payload for data port Square_Bolus_Rate\n   * @param Basal_Rate payload for data port Basal_Rate\n   * @param VTBI payload for data port VTBI\n   * @param Door_Open payload for data port Door_Open\n   * @param Alarm_Inactivation payload for data port Alarm_Inactivation\n   * @param Alarm payloads for event data port Alarm.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Alarm will be used\n   * @param Warning payloads for event data port Warning.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Warning will be used\n   * @param CP_Bolus_Duration payloads for event data port CP_Bolus_Duration.\n   *   ART currently supports single element event data queues so\n   *   only the last element of CP_Bolus_Duration will be used\n   * @param Rx_Okay the number of events to place in the Rx_Okay event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Patient_Request_Not_Too_Soon the number of events to place in the Patient_Request_Not_Too_Soon event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Patient_Request_Too_Soon the number of events to place in the Patient_Request_Too_Soon event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param HW_Detected_Failure the number of events to place in the HW_Detected_Failure event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Stop_Pump_Completely the number of events to place in the Stop_Pump_Completely event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Pump_At_KVO_Rate the number of events to place in the Pump_At_KVO_Rate event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param CP_Clinician_Request_Bolus the number of events to place in the CP_Clinician_Request_Bolus event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Halt_Infusion the number of events to place in the Halt_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Begin_Infusion the number of events to place in the Begin_Infusion event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Near_Max_Drug_Per_Hour the number of events to place in the Near_Max_Drug_Per_Hour event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Over_Max_Drug_Per_Hour the number of events to place in the Over_Max_Drug_Per_Hour event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(command_Start : Z,\n                          command_Suspend : Z,\n                          command_load_drug_library : ISZ[PCA_Types.Drug_Library],\n                          command_set_clinican_requested_bolus_duration : ISZ[ICE_Types.Minute_imp],\n                          command_request_bolus : Z,\n                          command_pause_infusion : Z,\n                          command_resume_infusion : Z,\n                          status_AppConnected : Base_Types.Boolean,\n                          Infusion_Flow_Rate : PCA_Types.Flow_Rate_imp,\n                          Patient_Bolus_Rate : PCA_Types.Flow_Rate_imp,\n                          Square_Bolus_Rate : PCA_Types.Flow_Rate_imp,\n                          Basal_Rate : PCA_Types.Flow_Rate_imp,\n                          VTBI : PCA_Types.Drug_Volume_imp,\n                          Door_Open : Base_Types.Boolean,\n                          Alarm_Inactivation : ICE_Types.Alarm_Signal.Type,\n                          Alarm : ISZ[PCA_Types.Alarm_Type.Type],\n                          Warning : ISZ[PCA_Types.Warning_Type.Type],\n                          CP_Bolus_Duration : ISZ[ICE_Types.Minute_imp],\n                          Rx_Okay : Z,\n                          Patient_Request_Not_Too_Soon : Z,\n                          Patient_Request_Too_Soon : Z,\n                          HW_Detected_Failure : Z,\n                          Stop_Pump_Completely : Z,\n                          Pump_At_KVO_Rate : Z,\n                          CP_Clinician_Request_Bolus : Z,\n                          Halt_Infusion : Z,\n                          Begin_Infusion : Z,\n                          Near_Max_Drug_Per_Hour : Z,\n                          Over_Max_Drug_Per_Hour : Z): Unit = {\n    for(i <- 0 until command_Start) {\n      put_command_Start()\n    }\n    for(i <- 0 until command_Suspend) {\n      put_command_Suspend()\n    }\n    for(v <- command_load_drug_library){\n      put_command_load_drug_library(v)\n    }\n    for(v <- command_set_clinican_requested_bolus_duration){\n      put_command_set_clinican_requested_bolus_duration(v)\n    }\n    for(i <- 0 until command_request_bolus) {\n      put_command_request_bolus()\n    }\n    for(i <- 0 until command_pause_infusion) {\n      put_command_pause_infusion()\n    }\n    for(i <- 0 until command_resume_infusion) {\n      put_command_resume_infusion()\n    }\n    put_status_AppConnected(status_AppConnected)\n    put_Infusion_Flow_Rate(Infusion_Flow_Rate)\n    put_Patient_Bolus_Rate(Patient_Bolus_Rate)\n    put_Square_Bolus_Rate(Square_Bolus_Rate)\n    put_Basal_Rate(Basal_Rate)\n    put_VTBI(VTBI)\n    put_Door_Open(Door_Open)\n    put_Alarm_Inactivation(Alarm_Inactivation)\n    for(v <- Alarm){\n      put_Alarm(v)\n    }\n    for(v <- Warning){\n      put_Warning(v)\n    }\n    for(v <- CP_Bolus_Duration){\n      put_CP_Bolus_Duration(v)\n    }\n    for(i <- 0 until Rx_Okay) {\n      put_Rx_Okay()\n    }\n    for(i <- 0 until Patient_Request_Not_Too_Soon) {\n      put_Patient_Request_Not_Too_Soon()\n    }\n    for(i <- 0 until Patient_Request_Too_Soon) {\n      put_Patient_Request_Too_Soon()\n    }\n    for(i <- 0 until HW_Detected_Failure) {\n      put_HW_Detected_Failure()\n    }\n    for(i <- 0 until Stop_Pump_Completely) {\n      put_Stop_Pump_Completely()\n    }\n    for(i <- 0 until Pump_At_KVO_Rate) {\n      put_Pump_At_KVO_Rate()\n    }\n    for(i <- 0 until CP_Clinician_Request_Bolus) {\n      put_CP_Clinician_Request_Bolus()\n    }\n    for(i <- 0 until Halt_Infusion) {\n      put_Halt_Infusion()\n    }\n    for(i <- 0 until Begin_Infusion) {\n      put_Begin_Infusion()\n    }\n    for(i <- 0 until Near_Max_Drug_Per_Hour) {\n      put_Near_Max_Drug_Per_Hour()\n    }\n    for(i <- 0 until Over_Max_Drug_Per_Hour) {\n      put_Over_Max_Drug_Per_Hour()\n    }\n  }\n\n\n  \/** helper function to check ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param parameters_current_flow_rate method that will be called with the value of the outgoing data\n   *        port 'parameters_current_flow_rate'.\n   * @param parameters_basal_flow_rate method that will be called with the value of the outgoing data\n   *        port 'parameters_basal_flow_rate'.\n   * @param parameters_bolus_flow_rate method that will be called with the value of the outgoing data\n   *        port 'parameters_bolus_flow_rate'.\n   * @param parameters_KVO_Flow_Rate method that will be called with the value of the outgoing data\n   *        port 'parameters_KVO_Flow_Rate'.\n   * @param parameters_volume_to_be_infused method that will be called with the value of the outgoing data\n   *        port 'parameters_volume_to_be_infused'.\n   * @param parameters_clinican_requested_bolus_duration method that will be called with the value of the outgoing data\n   *        port 'parameters_clinican_requested_bolus_duration'.\n   * @param parameters_square_flow_rate method that will be called with the value of the outgoing data\n   *        port 'parameters_square_flow_rate'.\n   * @param status_On method that will be called with the value of the outgoing data\n   *        port 'status_On'.\n   * @param status_Okay method that will be called with the value of the outgoing data\n   *        port 'status_Okay'.\n   * @param status_status method that will be called with the value of the outgoing data\n   *        port 'status_status'.\n   * @param ICE_Stop_Pump method that will be called with the number of events to be sent\n   *        on the outgoing event port 'ICE_Stop_Pump'.\n   *\/\n  def check_concrete_output(parameters_current_flow_rate: ICE_Types.Milliliter_Per_Hour => B = parameters_current_flow_rateParam => {T},\n                            parameters_basal_flow_rate: ICE_Types.Milliliter_Per_Hour => B = parameters_basal_flow_rateParam => {T},\n                            parameters_bolus_flow_rate: ICE_Types.Milliliter_Per_Hour => B = parameters_bolus_flow_rateParam => {T},\n                            parameters_KVO_Flow_Rate: ICE_Types.Milliliter_Per_Hour => B = parameters_KVO_Flow_RateParam => {T},\n                            parameters_volume_to_be_infused: ICE_Types.Milliliter => B = parameters_volume_to_be_infusedParam => {T},\n                            parameters_clinican_requested_bolus_duration: ICE_Types.Minute_imp => B = parameters_clinican_requested_bolus_durationParam => {T},\n                            parameters_square_flow_rate: ICE_Types.Milliliter_Per_Hour => B = parameters_square_flow_rateParam => {T},\n                            status_On: Base_Types.Boolean => B = status_OnParam => {T},\n                            status_Okay: Base_Types.Boolean => B = status_OkayParam => {T},\n                            status_status: PCA_Types.Status_Type.Type => B = status_statusParam => {T},\n                            ICE_Stop_Pump: Z => B = ICE_Stop_PumpParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val parameters_current_flow_rateValue: ICE_Types.Milliliter_Per_Hour = get_parameters_current_flow_rate().get\n    if(!parameters_current_flow_rate(parameters_current_flow_rateValue)) {\n      testFailures = testFailures :+ st\"'parameters_current_flow_rate' did not match expected: value of the outgoing data port is ${parameters_current_flow_rateValue}\"\n    }\n    val parameters_basal_flow_rateValue: ICE_Types.Milliliter_Per_Hour = get_parameters_basal_flow_rate().get\n    if(!parameters_basal_flow_rate(parameters_basal_flow_rateValue)) {\n      testFailures = testFailures :+ st\"'parameters_basal_flow_rate' did not match expected: value of the outgoing data port is ${parameters_basal_flow_rateValue}\"\n    }\n    val parameters_bolus_flow_rateValue: ICE_Types.Milliliter_Per_Hour = get_parameters_bolus_flow_rate().get\n    if(!parameters_bolus_flow_rate(parameters_bolus_flow_rateValue)) {\n      testFailures = testFailures :+ st\"'parameters_bolus_flow_rate' did not match expected: value of the outgoing data port is ${parameters_bolus_flow_rateValue}\"\n    }\n    val parameters_KVO_Flow_RateValue: ICE_Types.Milliliter_Per_Hour = get_parameters_KVO_Flow_Rate().get\n    if(!parameters_KVO_Flow_Rate(parameters_KVO_Flow_RateValue)) {\n      testFailures = testFailures :+ st\"'parameters_KVO_Flow_Rate' did not match expected: value of the outgoing data port is ${parameters_KVO_Flow_RateValue}\"\n    }\n    val parameters_volume_to_be_infusedValue: ICE_Types.Milliliter = get_parameters_volume_to_be_infused().get\n    if(!parameters_volume_to_be_infused(parameters_volume_to_be_infusedValue)) {\n      testFailures = testFailures :+ st\"'parameters_volume_to_be_infused' did not match expected: value of the outgoing data port is ${parameters_volume_to_be_infusedValue}\"\n    }\n    val parameters_clinican_requested_bolus_durationValue: ICE_Types.Minute_imp = get_parameters_clinican_requested_bolus_duration().get\n    if(!parameters_clinican_requested_bolus_duration(parameters_clinican_requested_bolus_durationValue)) {\n      testFailures = testFailures :+ st\"'parameters_clinican_requested_bolus_duration' did not match expected: value of the outgoing data port is ${parameters_clinican_requested_bolus_durationValue}\"\n    }\n    val parameters_square_flow_rateValue: ICE_Types.Milliliter_Per_Hour = get_parameters_square_flow_rate().get\n    if(!parameters_square_flow_rate(parameters_square_flow_rateValue)) {\n      testFailures = testFailures :+ st\"'parameters_square_flow_rate' did not match expected: value of the outgoing data port is ${parameters_square_flow_rateValue}\"\n    }\n    val status_OnValue: Base_Types.Boolean = get_status_On().get\n    if(!status_On(status_OnValue)) {\n      testFailures = testFailures :+ st\"'status_On' did not match expected: value of the outgoing data port is ${status_OnValue}\"\n    }\n    val status_OkayValue: Base_Types.Boolean = get_status_Okay().get\n    if(!status_Okay(status_OkayValue)) {\n      testFailures = testFailures :+ st\"'status_Okay' did not match expected: value of the outgoing data port is ${status_OkayValue}\"\n    }\n    val status_statusValue: PCA_Types.Status_Type.Type = get_status_status().get\n    if(!status_status(status_statusValue)) {\n      testFailures = testFailures :+ st\"'status_status' did not match expected: value of the outgoing data port is ${status_statusValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val ICE_Stop_PumpValue: Z = if(get_ICE_Stop_Pump().nonEmpty) z\"1\" else z\"0\"\n    if(!ICE_Stop_Pump(ICE_Stop_PumpValue)) {\n      testFailures = testFailures :+ st\"'ICE_Stop_Pump' did not match expected: ${ICE_Stop_PumpValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_command_Start(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_Start_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_command_Suspend(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_Suspend_Id, Empty())\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_command_load_drug_library(value : PCA_Types.Drug_Library): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_load_drug_library_Id, PCA_Types.Drug_Library_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_command_set_clinican_requested_bolus_duration(value : ICE_Types.Minute_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_set_clinican_requested_bolus_duration_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_command_request_bolus(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_request_bolus_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_command_pause_infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_pause_infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_command_resume_infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.command_resume_infusion_Id, Empty())\n  }\n\n  \/\/ setter for in DataPort\n  def put_status_AppConnected(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.status_AppConnected_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Infusion_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Infusion_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Patient_Bolus_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Square_Bolus_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Square_Bolus_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Basal_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Basal_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_VTBI(value : PCA_Types.Drug_Volume_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.VTBI_Id, PCA_Types.Drug_Volume_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Door_Open(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Door_Open_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Alarm_Inactivation(value : ICE_Types.Alarm_Signal.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Alarm_Inactivation_Id, ICE_Types.Alarm_Signal_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Alarm(value : PCA_Types.Alarm_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Alarm_Id, PCA_Types.Alarm_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Warning(value : PCA_Types.Warning_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Warning_Id, PCA_Types.Warning_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_CP_Bolus_Duration(value : ICE_Types.Minute_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CP_Bolus_Duration_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Rx_Okay(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Rx_Okay_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Request_Not_Too_Soon(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Request_Not_Too_Soon_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Request_Too_Soon(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Request_Too_Soon_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_HW_Detected_Failure(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.HW_Detected_Failure_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Stop_Pump_Completely(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Stop_Pump_Completely_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Pump_At_KVO_Rate(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Pump_At_KVO_Rate_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_CP_Clinician_Request_Bolus(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.CP_Clinician_Request_Bolus_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Halt_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Halt_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Begin_Infusion(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Begin_Infusion_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Near_Max_Drug_Per_Hour(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Near_Max_Drug_Per_Hour_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Over_Max_Drug_Per_Hour(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Over_Max_Drug_Per_Hour_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_current_flow_rate(): Option[ICE_Types.Milliliter_Per_Hour] = {\n    val value: Option[ICE_Types.Milliliter_Per_Hour] = get_parameters_current_flow_rate_payload() match {\n      case Some(ICE_Types.Milliliter_Per_Hour_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_current_flow_rate.  Expecting 'ICE_Types.Milliliter_Per_Hour_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter_Per_Hour]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_current_flow_rate_payload(): Option[ICE_Types.Milliliter_Per_Hour_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_current_flow_rate_Id).asInstanceOf[Option[ICE_Types.Milliliter_Per_Hour_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_basal_flow_rate(): Option[ICE_Types.Milliliter_Per_Hour] = {\n    val value: Option[ICE_Types.Milliliter_Per_Hour] = get_parameters_basal_flow_rate_payload() match {\n      case Some(ICE_Types.Milliliter_Per_Hour_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_basal_flow_rate.  Expecting 'ICE_Types.Milliliter_Per_Hour_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter_Per_Hour]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_basal_flow_rate_payload(): Option[ICE_Types.Milliliter_Per_Hour_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_basal_flow_rate_Id).asInstanceOf[Option[ICE_Types.Milliliter_Per_Hour_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_bolus_flow_rate(): Option[ICE_Types.Milliliter_Per_Hour] = {\n    val value: Option[ICE_Types.Milliliter_Per_Hour] = get_parameters_bolus_flow_rate_payload() match {\n      case Some(ICE_Types.Milliliter_Per_Hour_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_bolus_flow_rate.  Expecting 'ICE_Types.Milliliter_Per_Hour_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter_Per_Hour]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_bolus_flow_rate_payload(): Option[ICE_Types.Milliliter_Per_Hour_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_bolus_flow_rate_Id).asInstanceOf[Option[ICE_Types.Milliliter_Per_Hour_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_KVO_Flow_Rate(): Option[ICE_Types.Milliliter_Per_Hour] = {\n    val value: Option[ICE_Types.Milliliter_Per_Hour] = get_parameters_KVO_Flow_Rate_payload() match {\n      case Some(ICE_Types.Milliliter_Per_Hour_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_KVO_Flow_Rate.  Expecting 'ICE_Types.Milliliter_Per_Hour_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter_Per_Hour]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_KVO_Flow_Rate_payload(): Option[ICE_Types.Milliliter_Per_Hour_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_KVO_Flow_Rate_Id).asInstanceOf[Option[ICE_Types.Milliliter_Per_Hour_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_volume_to_be_infused(): Option[ICE_Types.Milliliter] = {\n    val value: Option[ICE_Types.Milliliter] = get_parameters_volume_to_be_infused_payload() match {\n      case Some(ICE_Types.Milliliter_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_volume_to_be_infused.  Expecting 'ICE_Types.Milliliter_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_volume_to_be_infused_payload(): Option[ICE_Types.Milliliter_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_volume_to_be_infused_Id).asInstanceOf[Option[ICE_Types.Milliliter_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_clinican_requested_bolus_duration(): Option[ICE_Types.Minute_imp] = {\n    val value: Option[ICE_Types.Minute_imp] = get_parameters_clinican_requested_bolus_duration_payload() match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_clinican_requested_bolus_duration.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_clinican_requested_bolus_duration_payload(): Option[ICE_Types.Minute_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_clinican_requested_bolus_duration_Id).asInstanceOf[Option[ICE_Types.Minute_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_parameters_square_flow_rate(): Option[ICE_Types.Milliliter_Per_Hour] = {\n    val value: Option[ICE_Types.Milliliter_Per_Hour] = get_parameters_square_flow_rate_payload() match {\n      case Some(ICE_Types.Milliliter_Per_Hour_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port parameters_square_flow_rate.  Expecting 'ICE_Types.Milliliter_Per_Hour_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Milliliter_Per_Hour]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_parameters_square_flow_rate_payload(): Option[ICE_Types.Milliliter_Per_Hour_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.parameters_square_flow_rate_Id).asInstanceOf[Option[ICE_Types.Milliliter_Per_Hour_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_status_On(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_status_On_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port status_On.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_status_On_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.status_On_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_status_Okay(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_status_Okay_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port status_Okay.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_status_Okay_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.status_Okay_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_status_status(): Option[PCA_Types.Status_Type.Type] = {\n    val value: Option[PCA_Types.Status_Type.Type] = get_status_status_payload() match {\n      case Some(PCA_Types.Status_Type_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port status_status.  Expecting 'PCA_Types.Status_Type_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Status_Type.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_status_status_payload(): Option[PCA_Types.Status_Type_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.status_status_Id).asInstanceOf[Option[PCA_Types.Status_Type_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_ICE_Stop_Pump(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_ICE_Stop_Pump_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port ICE_Stop_Pump.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_ICE_Stop_Pump_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ICE_Stop_Pump_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation_Threads._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Test extends ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation_Threads.{ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  command_Start: Port[art.Empty],\n  command_Suspend: Port[art.Empty],\n  command_load_drug_library: Port[PCA_Types.Drug_Library],\n  command_set_clinican_requested_bolus_duration: Port[ICE_Types.Minute_imp],\n  command_request_bolus: Port[art.Empty],\n  command_pause_infusion: Port[art.Empty],\n  command_resume_infusion: Port[art.Empty],\n  parameters_current_flow_rate: Port[ICE_Types.Milliliter_Per_Hour],\n  parameters_basal_flow_rate: Port[ICE_Types.Milliliter_Per_Hour],\n  parameters_bolus_flow_rate: Port[ICE_Types.Milliliter_Per_Hour],\n  parameters_KVO_Flow_Rate: Port[ICE_Types.Milliliter_Per_Hour],\n  parameters_volume_to_be_infused: Port[ICE_Types.Milliliter],\n  parameters_clinican_requested_bolus_duration: Port[ICE_Types.Minute_imp],\n  parameters_square_flow_rate: Port[ICE_Types.Milliliter_Per_Hour],\n  status_On: Port[Base_Types.Boolean],\n  status_Okay: Port[Base_Types.Boolean],\n  status_AppConnected: Port[Base_Types.Boolean],\n  status_status: Port[PCA_Types.Status_Type.Type],\n  Infusion_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Patient_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Square_Bolus_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Basal_Rate: Port[PCA_Types.Flow_Rate_imp],\n  VTBI: Port[PCA_Types.Drug_Volume_imp],\n  Door_Open: Port[Base_Types.Boolean],\n  Alarm_Inactivation: Port[ICE_Types.Alarm_Signal.Type],\n  Alarm: Port[PCA_Types.Alarm_Type.Type],\n  Warning: Port[PCA_Types.Warning_Type.Type],\n  CP_Bolus_Duration: Port[ICE_Types.Minute_imp],\n  ICE_Stop_Pump: Port[art.Empty],\n  Rx_Okay: Port[art.Empty],\n  Patient_Request_Not_Too_Soon: Port[art.Empty],\n  Patient_Request_Too_Soon: Port[art.Empty],\n  HW_Detected_Failure: Port[art.Empty],\n  Stop_Pump_Completely: Port[art.Empty],\n  Pump_At_KVO_Rate: Port[art.Empty],\n  CP_Clinician_Request_Bolus: Port[art.Empty],\n  Halt_Infusion: Port[art.Empty],\n  Begin_Infusion: Port[art.Empty],\n  Near_Max_Drug_Per_Hour: Port[art.Empty],\n  Over_Max_Drug_Per_Hour: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(command_Start,\n              command_Suspend,\n              command_load_drug_library,\n              command_set_clinican_requested_bolus_duration,\n              command_request_bolus,\n              command_pause_infusion,\n              command_resume_infusion,\n              parameters_current_flow_rate,\n              parameters_basal_flow_rate,\n              parameters_bolus_flow_rate,\n              parameters_KVO_Flow_Rate,\n              parameters_volume_to_be_infused,\n              parameters_clinican_requested_bolus_duration,\n              parameters_square_flow_rate,\n              status_On,\n              status_Okay,\n              status_AppConnected,\n              status_status,\n              Infusion_Flow_Rate,\n              Patient_Bolus_Rate,\n              Square_Bolus_Rate,\n              Basal_Rate,\n              VTBI,\n              Door_Open,\n              Alarm_Inactivation,\n              Alarm,\n              Warning,\n              CP_Bolus_Duration,\n              ICE_Stop_Pump,\n              Rx_Okay,\n              Patient_Request_Not_Too_Soon,\n              Patient_Request_Too_Soon,\n              HW_Detected_Failure,\n              Stop_Pump_Completely,\n              Pump_At_KVO_Rate,\n              CP_Clinician_Request_Bolus,\n              Halt_Infusion,\n              Begin_Infusion,\n              Near_Max_Drug_Per_Hour,\n              Over_Max_Drug_Per_Hour),\n\n    dataIns = ISZ(status_AppConnected,\n                  Infusion_Flow_Rate,\n                  Patient_Bolus_Rate,\n                  Square_Bolus_Rate,\n                  Basal_Rate,\n                  VTBI,\n                  Door_Open,\n                  Alarm_Inactivation),\n\n    dataOuts = ISZ(parameters_current_flow_rate,\n                   parameters_basal_flow_rate,\n                   parameters_bolus_flow_rate,\n                   parameters_KVO_Flow_Rate,\n                   parameters_volume_to_be_infused,\n                   parameters_clinican_requested_bolus_duration,\n                   parameters_square_flow_rate,\n                   status_On,\n                   status_Okay,\n                   status_status),\n\n    eventIns = ISZ(command_Start,\n                   command_Suspend,\n                   command_load_drug_library,\n                   command_set_clinican_requested_bolus_duration,\n                   command_request_bolus,\n                   command_pause_infusion,\n                   command_resume_infusion,\n                   Alarm,\n                   Warning,\n                   CP_Bolus_Duration,\n                   Rx_Okay,\n                   Patient_Request_Not_Too_Soon,\n                   Patient_Request_Too_Soon,\n                   HW_Detected_Failure,\n                   Stop_Pump_Completely,\n                   Pump_At_KVO_Rate,\n                   CP_Clinician_Request_Bolus,\n                   Halt_Infusion,\n                   Begin_Infusion,\n                   Near_Max_Drug_Per_Hour,\n                   Over_Max_Drug_Per_Hour),\n\n    eventOuts = ISZ(ICE_Stop_Pump)\n  )\n\n  val initialization_api : ICE_Thread_imp_Initialization_Api = {\n    val api = ICE_Thread_imp_Initialization_Api(\n      id,\n      command_Start.id,\n      command_Suspend.id,\n      command_load_drug_library.id,\n      command_set_clinican_requested_bolus_duration.id,\n      command_request_bolus.id,\n      command_pause_infusion.id,\n      command_resume_infusion.id,\n      parameters_current_flow_rate.id,\n      parameters_basal_flow_rate.id,\n      parameters_bolus_flow_rate.id,\n      parameters_KVO_Flow_Rate.id,\n      parameters_volume_to_be_infused.id,\n      parameters_clinican_requested_bolus_duration.id,\n      parameters_square_flow_rate.id,\n      status_On.id,\n      status_Okay.id,\n      status_AppConnected.id,\n      status_status.id,\n      Infusion_Flow_Rate.id,\n      Patient_Bolus_Rate.id,\n      Square_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      Alarm_Inactivation.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      ICE_Stop_Pump.id,\n      Rx_Okay.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      CP_Clinician_Request_Bolus.id,\n      Halt_Infusion.id,\n      Begin_Infusion.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id\n    )\n    ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : ICE_Thread_imp_Operational_Api = {\n    val api = ICE_Thread_imp_Operational_Api(\n      id,\n      command_Start.id,\n      command_Suspend.id,\n      command_load_drug_library.id,\n      command_set_clinican_requested_bolus_duration.id,\n      command_request_bolus.id,\n      command_pause_infusion.id,\n      command_resume_infusion.id,\n      parameters_current_flow_rate.id,\n      parameters_basal_flow_rate.id,\n      parameters_bolus_flow_rate.id,\n      parameters_KVO_Flow_Rate.id,\n      parameters_volume_to_be_infused.id,\n      parameters_clinican_requested_bolus_duration.id,\n      parameters_square_flow_rate.id,\n      status_On.id,\n      status_Okay.id,\n      status_AppConnected.id,\n      status_status.id,\n      Infusion_Flow_Rate.id,\n      Patient_Bolus_Rate.id,\n      Square_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      Alarm_Inactivation.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      ICE_Stop_Pump.id,\n      Rx_Okay.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      CP_Clinician_Request_Bolus.id,\n      Halt_Infusion.id,\n      Begin_Infusion.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id\n    )\n    ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge.EntryPoints(\n      id,\n\n      command_Start.id,\n      command_Suspend.id,\n      command_load_drug_library.id,\n      command_set_clinican_requested_bolus_duration.id,\n      command_request_bolus.id,\n      command_pause_infusion.id,\n      command_resume_infusion.id,\n      parameters_current_flow_rate.id,\n      parameters_basal_flow_rate.id,\n      parameters_bolus_flow_rate.id,\n      parameters_KVO_Flow_Rate.id,\n      parameters_volume_to_be_infused.id,\n      parameters_clinican_requested_bolus_duration.id,\n      parameters_square_flow_rate.id,\n      status_On.id,\n      status_Okay.id,\n      status_AppConnected.id,\n      status_status.id,\n      Infusion_Flow_Rate.id,\n      Patient_Bolus_Rate.id,\n      Square_Bolus_Rate.id,\n      Basal_Rate.id,\n      VTBI.id,\n      Door_Open.id,\n      Alarm_Inactivation.id,\n      Alarm.id,\n      Warning.id,\n      CP_Bolus_Duration.id,\n      ICE_Stop_Pump.id,\n      Rx_Okay.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id,\n      HW_Detected_Failure.id,\n      Stop_Pump_Completely.id,\n      Pump_At_KVO_Rate.id,\n      CP_Clinician_Request_Bolus.id,\n      Halt_Infusion.id,\n      Begin_Infusion.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_Bridge {\n\n  var c_initialization_api: Option[ICE_Thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[ICE_Thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_BridgeId : Art.BridgeId,\n\n    command_Start_Id : Art.PortId,\n    command_Suspend_Id : Art.PortId,\n    command_load_drug_library_Id : Art.PortId,\n    command_set_clinican_requested_bolus_duration_Id : Art.PortId,\n    command_request_bolus_Id : Art.PortId,\n    command_pause_infusion_Id : Art.PortId,\n    command_resume_infusion_Id : Art.PortId,\n    parameters_current_flow_rate_Id : Art.PortId,\n    parameters_basal_flow_rate_Id : Art.PortId,\n    parameters_bolus_flow_rate_Id : Art.PortId,\n    parameters_KVO_Flow_Rate_Id : Art.PortId,\n    parameters_volume_to_be_infused_Id : Art.PortId,\n    parameters_clinican_requested_bolus_duration_Id : Art.PortId,\n    parameters_square_flow_rate_Id : Art.PortId,\n    status_On_Id : Art.PortId,\n    status_Okay_Id : Art.PortId,\n    status_AppConnected_Id : Art.PortId,\n    status_status_Id : Art.PortId,\n    Infusion_Flow_Rate_Id : Art.PortId,\n    Patient_Bolus_Rate_Id : Art.PortId,\n    Square_Bolus_Rate_Id : Art.PortId,\n    Basal_Rate_Id : Art.PortId,\n    VTBI_Id : Art.PortId,\n    Door_Open_Id : Art.PortId,\n    Alarm_Inactivation_Id : Art.PortId,\n    Alarm_Id : Art.PortId,\n    Warning_Id : Art.PortId,\n    CP_Bolus_Duration_Id : Art.PortId,\n    ICE_Stop_Pump_Id : Art.PortId,\n    Rx_Okay_Id : Art.PortId,\n    Patient_Request_Not_Too_Soon_Id : Art.PortId,\n    Patient_Request_Too_Soon_Id : Art.PortId,\n    HW_Detected_Failure_Id : Art.PortId,\n    Stop_Pump_Completely_Id : Art.PortId,\n    Pump_At_KVO_Rate_Id : Art.PortId,\n    CP_Clinician_Request_Bolus_Id : Art.PortId,\n    Halt_Infusion_Id : Art.PortId,\n    Begin_Infusion_Id : Art.PortId,\n    Near_Max_Drug_Per_Hour_Id : Art.PortId,\n    Over_Max_Drug_Per_Hour_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: ICE_Thread_imp_Initialization_Api,\n    operational_api: ICE_Thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(status_AppConnected_Id,\n                                             Infusion_Flow_Rate_Id,\n                                             Patient_Bolus_Rate_Id,\n                                             Square_Bolus_Rate_Id,\n                                             Basal_Rate_Id,\n                                             VTBI_Id,\n                                             Door_Open_Id,\n                                             Alarm_Inactivation_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(command_Start_Id,\n                                              command_Suspend_Id,\n                                              command_load_drug_library_Id,\n                                              command_set_clinican_requested_bolus_duration_Id,\n                                              command_request_bolus_Id,\n                                              command_pause_infusion_Id,\n                                              command_resume_infusion_Id,\n                                              Alarm_Id,\n                                              Warning_Id,\n                                              CP_Bolus_Duration_Id,\n                                              Rx_Okay_Id,\n                                              Patient_Request_Not_Too_Soon_Id,\n                                              Patient_Request_Too_Soon_Id,\n                                              HW_Detected_Failure_Id,\n                                              Stop_Pump_Completely_Id,\n                                              Pump_At_KVO_Rate_Id,\n                                              CP_Clinician_Request_Bolus_Id,\n                                              Halt_Infusion_Id,\n                                              Begin_Infusion_Id,\n                                              Near_Max_Drug_Per_Hour_Id,\n                                              Over_Max_Drug_Per_Hour_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(parameters_current_flow_rate_Id,\n                                              parameters_basal_flow_rate_Id,\n                                              parameters_bolus_flow_rate_Id,\n                                              parameters_KVO_Flow_Rate_Id,\n                                              parameters_volume_to_be_infused_Id,\n                                              parameters_clinican_requested_bolus_duration_Id,\n                                              parameters_square_flow_rate_Id,\n                                              status_On_Id,\n                                              status_Okay_Id,\n                                              status_status_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(ICE_Stop_Pump_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == command_Start_Id) {\n          \/\/ implement the following in 'component':  def handle_command_Start(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_Start(operational_api)\n        }\n        else if(portId == command_Suspend_Id) {\n          \/\/ implement the following in 'component':  def handle_command_Suspend(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_Suspend(operational_api)\n        }\n        else if(portId == command_load_drug_library_Id){\n          val Some(PCA_Types.Drug_Library_Payload(value)) = Art.getValue(command_load_drug_library_Id)\n\n          \/\/ implement the following in 'component':  def handle_command_load_drug_library(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Drug_Library): Unit = {}\n          component.handle_command_load_drug_library(operational_api, value)\n        }\n        else if(portId == command_set_clinican_requested_bolus_duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(command_set_clinican_requested_bolus_duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_command_set_clinican_requested_bolus_duration(api: ICE_Thread_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_command_set_clinican_requested_bolus_duration(operational_api, value)\n        }\n        else if(portId == command_request_bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_command_request_bolus(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_request_bolus(operational_api)\n        }\n        else if(portId == command_pause_infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_command_pause_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_pause_infusion(operational_api)\n        }\n        else if(portId == command_resume_infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_command_resume_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_resume_infusion(operational_api)\n        }\n        else if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == CP_Bolus_Duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(CP_Bolus_Duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_CP_Bolus_Duration(api: ICE_Thread_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_CP_Bolus_Duration(operational_api, value)\n        }\n        else if(portId == Rx_Okay_Id) {\n          \/\/ implement the following in 'component':  def handle_Rx_Okay(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Rx_Okay(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Patient_Request_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Too_Soon(operational_api)\n        }\n        else if(portId == HW_Detected_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_HW_Detected_Failure(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_HW_Detected_Failure(operational_api)\n        }\n        else if(portId == Stop_Pump_Completely_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Pump_Completely(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Pump_Completely(operational_api)\n        }\n        else if(portId == Pump_At_KVO_Rate_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_At_KVO_Rate(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Pump_At_KVO_Rate(operational_api)\n        }\n        else if(portId == CP_Clinician_Request_Bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Clinician_Request_Bolus(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_CP_Clinician_Request_Bolus(operational_api)\n        }\n        else if(portId == Halt_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Halt_Infusion(operational_api)\n        }\n        else if(portId == Begin_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Infusion(operational_api)\n        }\n        else if(portId == Near_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Near_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Near_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == Over_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Over_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Over_Max_Drug_Per_Hour(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == command_Start_Id) {\n          \/\/ implement the following in 'component':  def handle_command_Start(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_Start(operational_api)\n        }\n        else if(portId == command_Suspend_Id) {\n          \/\/ implement the following in 'component':  def handle_command_Suspend(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_Suspend(operational_api)\n        }\n        else if(portId == command_load_drug_library_Id){\n          val Some(PCA_Types.Drug_Library_Payload(value)) = Art.getValue(command_load_drug_library_Id)\n\n          \/\/ implement the following in 'component':  def handle_command_load_drug_library(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Drug_Library): Unit = {}\n          component.handle_command_load_drug_library(operational_api, value)\n        }\n        else if(portId == command_set_clinican_requested_bolus_duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(command_set_clinican_requested_bolus_duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_command_set_clinican_requested_bolus_duration(api: ICE_Thread_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_command_set_clinican_requested_bolus_duration(operational_api, value)\n        }\n        else if(portId == command_request_bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_command_request_bolus(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_request_bolus(operational_api)\n        }\n        else if(portId == command_pause_infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_command_pause_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_pause_infusion(operational_api)\n        }\n        else if(portId == command_resume_infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_command_resume_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_command_resume_infusion(operational_api)\n        }\n        else if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: ICE_Thread_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == CP_Bolus_Duration_Id){\n          val Some(ICE_Types.Minute_imp_Payload(value)) = Art.getValue(CP_Bolus_Duration_Id)\n\n          \/\/ implement the following in 'component':  def handle_CP_Bolus_Duration(api: ICE_Thread_imp_Operational_Api, value: ICE_Types.Minute_imp): Unit = {}\n          component.handle_CP_Bolus_Duration(operational_api, value)\n        }\n        else if(portId == Rx_Okay_Id) {\n          \/\/ implement the following in 'component':  def handle_Rx_Okay(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Rx_Okay(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Patient_Request_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Too_Soon(operational_api)\n        }\n        else if(portId == HW_Detected_Failure_Id) {\n          \/\/ implement the following in 'component':  def handle_HW_Detected_Failure(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_HW_Detected_Failure(operational_api)\n        }\n        else if(portId == Stop_Pump_Completely_Id) {\n          \/\/ implement the following in 'component':  def handle_Stop_Pump_Completely(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Stop_Pump_Completely(operational_api)\n        }\n        else if(portId == Pump_At_KVO_Rate_Id) {\n          \/\/ implement the following in 'component':  def handle_Pump_At_KVO_Rate(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Pump_At_KVO_Rate(operational_api)\n        }\n        else if(portId == CP_Clinician_Request_Bolus_Id) {\n          \/\/ implement the following in 'component':  def handle_CP_Clinician_Request_Bolus(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_CP_Clinician_Request_Bolus(operational_api)\n        }\n        else if(portId == Halt_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Halt_Infusion(operational_api)\n        }\n        else if(portId == Begin_Infusion_Id) {\n          \/\/ implement the following in 'component':  def handle_Begin_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Begin_Infusion(operational_api)\n        }\n        else if(portId == Near_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Near_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Near_Max_Drug_Per_Hour(operational_api)\n        }\n        else if(portId == Over_Max_Drug_Per_Hour_Id) {\n          \/\/ implement the following in 'component':  def handle_Over_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Over_Max_Drug_Per_Hour(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: ICE_Thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: ICE_Thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: ICE_Thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: ICE_Thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: ICE_Thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/ICE_Thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait ICE_Thread_imp_Api {\n  def id: Art.BridgeId\n  def command_Start_Id : Art.PortId\n  def command_Suspend_Id : Art.PortId\n  def command_load_drug_library_Id : Art.PortId\n  def command_set_clinican_requested_bolus_duration_Id : Art.PortId\n  def command_request_bolus_Id : Art.PortId\n  def command_pause_infusion_Id : Art.PortId\n  def command_resume_infusion_Id : Art.PortId\n  def parameters_current_flow_rate_Id : Art.PortId\n  def parameters_basal_flow_rate_Id : Art.PortId\n  def parameters_bolus_flow_rate_Id : Art.PortId\n  def parameters_KVO_Flow_Rate_Id : Art.PortId\n  def parameters_volume_to_be_infused_Id : Art.PortId\n  def parameters_clinican_requested_bolus_duration_Id : Art.PortId\n  def parameters_square_flow_rate_Id : Art.PortId\n  def status_On_Id : Art.PortId\n  def status_Okay_Id : Art.PortId\n  def status_AppConnected_Id : Art.PortId\n  def status_status_Id : Art.PortId\n  def Infusion_Flow_Rate_Id : Art.PortId\n  def Patient_Bolus_Rate_Id : Art.PortId\n  def Square_Bolus_Rate_Id : Art.PortId\n  def Basal_Rate_Id : Art.PortId\n  def VTBI_Id : Art.PortId\n  def Door_Open_Id : Art.PortId\n  def Alarm_Inactivation_Id : Art.PortId\n  def Alarm_Id : Art.PortId\n  def Warning_Id : Art.PortId\n  def CP_Bolus_Duration_Id : Art.PortId\n  def ICE_Stop_Pump_Id : Art.PortId\n  def Rx_Okay_Id : Art.PortId\n  def Patient_Request_Not_Too_Soon_Id : Art.PortId\n  def Patient_Request_Too_Soon_Id : Art.PortId\n  def HW_Detected_Failure_Id : Art.PortId\n  def Stop_Pump_Completely_Id : Art.PortId\n  def Pump_At_KVO_Rate_Id : Art.PortId\n  def CP_Clinician_Request_Bolus_Id : Art.PortId\n  def Halt_Infusion_Id : Art.PortId\n  def Begin_Infusion_Id : Art.PortId\n  def Near_Max_Drug_Per_Hour_Id : Art.PortId\n  def Over_Max_Drug_Per_Hour_Id : Art.PortId\n\n  def put_parameters_current_flow_rate(value : ICE_Types.Milliliter_Per_Hour) : Unit = {\n    Art.putValue(parameters_current_flow_rate_Id, ICE_Types.Milliliter_Per_Hour_Payload(value))\n  }\n\n  def put_parameters_basal_flow_rate(value : ICE_Types.Milliliter_Per_Hour) : Unit = {\n    Art.putValue(parameters_basal_flow_rate_Id, ICE_Types.Milliliter_Per_Hour_Payload(value))\n  }\n\n  def put_parameters_bolus_flow_rate(value : ICE_Types.Milliliter_Per_Hour) : Unit = {\n    Art.putValue(parameters_bolus_flow_rate_Id, ICE_Types.Milliliter_Per_Hour_Payload(value))\n  }\n\n  def put_parameters_KVO_Flow_Rate(value : ICE_Types.Milliliter_Per_Hour) : Unit = {\n    Art.putValue(parameters_KVO_Flow_Rate_Id, ICE_Types.Milliliter_Per_Hour_Payload(value))\n  }\n\n  def put_parameters_volume_to_be_infused(value : ICE_Types.Milliliter) : Unit = {\n    Art.putValue(parameters_volume_to_be_infused_Id, ICE_Types.Milliliter_Payload(value))\n  }\n\n  def put_parameters_clinican_requested_bolus_duration(value : ICE_Types.Minute_imp) : Unit = {\n    Art.putValue(parameters_clinican_requested_bolus_duration_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  def put_parameters_square_flow_rate(value : ICE_Types.Milliliter_Per_Hour) : Unit = {\n    Art.putValue(parameters_square_flow_rate_Id, ICE_Types.Milliliter_Per_Hour_Payload(value))\n  }\n\n  def put_status_On(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(status_On_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def put_status_Okay(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(status_Okay_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def put_status_status(value : PCA_Types.Status_Type.Type) : Unit = {\n    Art.putValue(status_status_Id, PCA_Types.Status_Type_Payload(value))\n  }\n\n  def put_ICE_Stop_Pump() : Unit = {\n    Art.putValue(ICE_Stop_Pump_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class ICE_Thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val command_Start_Id : Art.PortId,\n  val command_Suspend_Id : Art.PortId,\n  val command_load_drug_library_Id : Art.PortId,\n  val command_set_clinican_requested_bolus_duration_Id : Art.PortId,\n  val command_request_bolus_Id : Art.PortId,\n  val command_pause_infusion_Id : Art.PortId,\n  val command_resume_infusion_Id : Art.PortId,\n  val parameters_current_flow_rate_Id : Art.PortId,\n  val parameters_basal_flow_rate_Id : Art.PortId,\n  val parameters_bolus_flow_rate_Id : Art.PortId,\n  val parameters_KVO_Flow_Rate_Id : Art.PortId,\n  val parameters_volume_to_be_infused_Id : Art.PortId,\n  val parameters_clinican_requested_bolus_duration_Id : Art.PortId,\n  val parameters_square_flow_rate_Id : Art.PortId,\n  val status_On_Id : Art.PortId,\n  val status_Okay_Id : Art.PortId,\n  val status_AppConnected_Id : Art.PortId,\n  val status_status_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val Alarm_Inactivation_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val CP_Bolus_Duration_Id : Art.PortId,\n  val ICE_Stop_Pump_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val CP_Clinician_Request_Bolus_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId) extends ICE_Thread_imp_Api\n\n@datatype class ICE_Thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val command_Start_Id : Art.PortId,\n  val command_Suspend_Id : Art.PortId,\n  val command_load_drug_library_Id : Art.PortId,\n  val command_set_clinican_requested_bolus_duration_Id : Art.PortId,\n  val command_request_bolus_Id : Art.PortId,\n  val command_pause_infusion_Id : Art.PortId,\n  val command_resume_infusion_Id : Art.PortId,\n  val parameters_current_flow_rate_Id : Art.PortId,\n  val parameters_basal_flow_rate_Id : Art.PortId,\n  val parameters_bolus_flow_rate_Id : Art.PortId,\n  val parameters_KVO_Flow_Rate_Id : Art.PortId,\n  val parameters_volume_to_be_infused_Id : Art.PortId,\n  val parameters_clinican_requested_bolus_duration_Id : Art.PortId,\n  val parameters_square_flow_rate_Id : Art.PortId,\n  val status_On_Id : Art.PortId,\n  val status_Okay_Id : Art.PortId,\n  val status_AppConnected_Id : Art.PortId,\n  val status_status_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Patient_Bolus_Rate_Id : Art.PortId,\n  val Square_Bolus_Rate_Id : Art.PortId,\n  val Basal_Rate_Id : Art.PortId,\n  val VTBI_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val Alarm_Inactivation_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val CP_Bolus_Duration_Id : Art.PortId,\n  val ICE_Stop_Pump_Id : Art.PortId,\n  val Rx_Okay_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId,\n  val HW_Detected_Failure_Id : Art.PortId,\n  val Stop_Pump_Completely_Id : Art.PortId,\n  val Pump_At_KVO_Rate_Id : Art.PortId,\n  val CP_Clinician_Request_Bolus_Id : Art.PortId,\n  val Halt_Infusion_Id : Art.PortId,\n  val Begin_Infusion_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId) extends ICE_Thread_imp_Api {\n\n  def get_command_Start() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(command_Start_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_Start.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_command_Suspend() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(command_Suspend_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_Suspend.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_command_load_drug_library() : Option[PCA_Types.Drug_Library] = {\n    val value : Option[PCA_Types.Drug_Library] = Art.getValue(command_load_drug_library_Id) match {\n      case Some(PCA_Types.Drug_Library_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_load_drug_library.  Expecting 'PCA_Types.Drug_Library_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Library]()\n      case _ => None[PCA_Types.Drug_Library]()\n    }\n    return value\n  }\n\n  def get_command_set_clinican_requested_bolus_duration() : Option[ICE_Types.Minute_imp] = {\n    val value : Option[ICE_Types.Minute_imp] = Art.getValue(command_set_clinican_requested_bolus_duration_Id) match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_set_clinican_requested_bolus_duration.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n        None[ICE_Types.Minute_imp]()\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  def get_command_request_bolus() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(command_request_bolus_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_request_bolus.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_command_pause_infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(command_pause_infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_pause_infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_command_resume_infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(command_resume_infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port command_resume_infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_status_AppConnected() : Option[Base_Types.Boolean] = {\n    val value : Option[Base_Types.Boolean] = Art.getValue(status_AppConnected_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port status_AppConnected.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  def get_Infusion_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Infusion_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Infusion_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Patient_Bolus_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Patient_Bolus_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Square_Bolus_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Square_Bolus_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Square_Bolus_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Basal_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Basal_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Basal_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_VTBI() : Option[PCA_Types.Drug_Volume_imp] = {\n    val value : Option[PCA_Types.Drug_Volume_imp] = Art.getValue(VTBI_Id) match {\n      case Some(PCA_Types.Drug_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port VTBI.  Expecting 'PCA_Types.Drug_Volume_imp_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Volume_imp]()\n      case _ => None[PCA_Types.Drug_Volume_imp]()\n    }\n    return value\n  }\n\n  def get_Door_Open() : Option[Base_Types.Boolean] = {\n    val value : Option[Base_Types.Boolean] = Art.getValue(Door_Open_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Door_Open.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  def get_Alarm_Inactivation() : Option[ICE_Types.Alarm_Signal.Type] = {\n    val value : Option[ICE_Types.Alarm_Signal.Type] = Art.getValue(Alarm_Inactivation_Id) match {\n      case Some(ICE_Types.Alarm_Signal_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Alarm_Inactivation.  Expecting 'ICE_Types.Alarm_Signal_Payload' but received ${v}\")\n        None[ICE_Types.Alarm_Signal.Type]()\n      case _ => None[ICE_Types.Alarm_Signal.Type]()\n    }\n    return value\n  }\n\n  def get_Alarm() : Option[PCA_Types.Alarm_Type.Type] = {\n    val value : Option[PCA_Types.Alarm_Type.Type] = Art.getValue(Alarm_Id) match {\n      case Some(PCA_Types.Alarm_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Alarm.  Expecting 'PCA_Types.Alarm_Type_Payload' but received ${v}\")\n        None[PCA_Types.Alarm_Type.Type]()\n      case _ => None[PCA_Types.Alarm_Type.Type]()\n    }\n    return value\n  }\n\n  def get_Warning() : Option[PCA_Types.Warning_Type.Type] = {\n    val value : Option[PCA_Types.Warning_Type.Type] = Art.getValue(Warning_Id) match {\n      case Some(PCA_Types.Warning_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Warning.  Expecting 'PCA_Types.Warning_Type_Payload' but received ${v}\")\n        None[PCA_Types.Warning_Type.Type]()\n      case _ => None[PCA_Types.Warning_Type.Type]()\n    }\n    return value\n  }\n\n  def get_CP_Bolus_Duration() : Option[ICE_Types.Minute_imp] = {\n    val value : Option[ICE_Types.Minute_imp] = Art.getValue(CP_Bolus_Duration_Id) match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CP_Bolus_Duration.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n        None[ICE_Types.Minute_imp]()\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  def get_Rx_Okay() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Rx_Okay_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Rx_Okay.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Patient_Request_Not_Too_Soon() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Request_Not_Too_Soon_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Request_Not_Too_Soon.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Patient_Request_Too_Soon() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Request_Too_Soon_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Request_Too_Soon.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_HW_Detected_Failure() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(HW_Detected_Failure_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port HW_Detected_Failure.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Stop_Pump_Completely() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Stop_Pump_Completely_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Stop_Pump_Completely.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Pump_At_KVO_Rate() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Pump_At_KVO_Rate_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Pump_At_KVO_Rate.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_CP_Clinician_Request_Bolus() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(CP_Clinician_Request_Bolus_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port CP_Clinician_Request_Bolus.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Halt_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Halt_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Halt_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Begin_Infusion() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Begin_Infusion_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Begin_Infusion.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Near_Max_Drug_Per_Hour() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Near_Max_Drug_Per_Hour_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Near_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Over_Max_Drug_Per_Hour() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Over_Max_Drug_Per_Hour_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Over_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation_Threads\/ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject ICE_Thread_imp_pump_operation_operation_process_operation_threads_ice_thread {\n\n  def initialise(api: ICE_Thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_parameters_current_flow_rate(ICE_Types.Milliliter_Per_Hour.example())\n    api.put_parameters_basal_flow_rate(ICE_Types.Milliliter_Per_Hour.example())\n    api.put_parameters_bolus_flow_rate(ICE_Types.Milliliter_Per_Hour.example())\n    api.put_parameters_KVO_Flow_Rate(ICE_Types.Milliliter_Per_Hour.example())\n    api.put_parameters_volume_to_be_infused(ICE_Types.Milliliter.example())\n    api.put_parameters_clinican_requested_bolus_duration(ICE_Types.Minute_imp.example())\n    api.put_parameters_square_flow_rate(ICE_Types.Milliliter_Per_Hour.example())\n    api.put_status_On(Base_Types.Boolean_example())\n    api.put_status_Okay(Base_Types.Boolean_example())\n    api.put_status_status(PCA_Types.Status_Type.byOrdinal(0).get)\n    api.put_ICE_Stop_Pump()\n  }\n\n  def handle_command_Start(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_command_Start implementation\")\n    api.logInfo(\"received command_Start event\")\n    \/\/ example api usage\n\n    val apiUsage_command_Start: Option[art.Empty] = api.get_command_Start()\n    api.logInfo(s\"Received on command_Start: ${apiUsage_command_Start}\")\n    val apiUsage_command_Suspend: Option[art.Empty] = api.get_command_Suspend()\n    api.logInfo(s\"Received on command_Suspend: ${apiUsage_command_Suspend}\")\n    val apiUsage_command_load_drug_library: Option[PCA_Types.Drug_Library] = api.get_command_load_drug_library()\n    api.logInfo(s\"Received on command_load_drug_library: ${apiUsage_command_load_drug_library}\")\n    val apiUsage_command_set_clinican_requested_bolus_duration: Option[ICE_Types.Minute_imp] = api.get_command_set_clinican_requested_bolus_duration()\n    api.logInfo(s\"Received on command_set_clinican_requested_bolus_duration: ${apiUsage_command_set_clinican_requested_bolus_duration}\")\n    val apiUsage_command_request_bolus: Option[art.Empty] = api.get_command_request_bolus()\n    api.logInfo(s\"Received on command_request_bolus: ${apiUsage_command_request_bolus}\")\n    val apiUsage_command_pause_infusion: Option[art.Empty] = api.get_command_pause_infusion()\n    api.logInfo(s\"Received on command_pause_infusion: ${apiUsage_command_pause_infusion}\")\n    val apiUsage_command_resume_infusion: Option[art.Empty] = api.get_command_resume_infusion()\n    api.logInfo(s\"Received on command_resume_infusion: ${apiUsage_command_resume_infusion}\")\n    val apiUsage_status_AppConnected: Option[Base_Types.Boolean] = api.get_status_AppConnected()\n    api.logInfo(s\"Received on status_AppConnected: ${apiUsage_status_AppConnected}\")\n    val apiUsage_Infusion_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Infusion_Flow_Rate()\n    api.logInfo(s\"Received on Infusion_Flow_Rate: ${apiUsage_Infusion_Flow_Rate}\")\n    val apiUsage_Patient_Bolus_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Patient_Bolus_Rate()\n    api.logInfo(s\"Received on Patient_Bolus_Rate: ${apiUsage_Patient_Bolus_Rate}\")\n    val apiUsage_Square_Bolus_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Square_Bolus_Rate()\n    api.logInfo(s\"Received on Square_Bolus_Rate: ${apiUsage_Square_Bolus_Rate}\")\n    val apiUsage_Basal_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Basal_Rate()\n    api.logInfo(s\"Received on Basal_Rate: ${apiUsage_Basal_Rate}\")\n    val apiUsage_VTBI: Option[PCA_Types.Drug_Volume_imp] = api.get_VTBI()\n    api.logInfo(s\"Received on VTBI: ${apiUsage_VTBI}\")\n    val apiUsage_Door_Open: Option[Base_Types.Boolean] = api.get_Door_Open()\n    api.logInfo(s\"Received on Door_Open: ${apiUsage_Door_Open}\")\n    val apiUsage_Alarm_Inactivation: Option[ICE_Types.Alarm_Signal.Type] = api.get_Alarm_Inactivation()\n    api.logInfo(s\"Received on Alarm_Inactivation: ${apiUsage_Alarm_Inactivation}\")\n    val apiUsage_Alarm: Option[PCA_Types.Alarm_Type.Type] = api.get_Alarm()\n    api.logInfo(s\"Received on Alarm: ${apiUsage_Alarm}\")\n    val apiUsage_Warning: Option[PCA_Types.Warning_Type.Type] = api.get_Warning()\n    api.logInfo(s\"Received on Warning: ${apiUsage_Warning}\")\n    val apiUsage_CP_Bolus_Duration: Option[ICE_Types.Minute_imp] = api.get_CP_Bolus_Duration()\n    api.logInfo(s\"Received on CP_Bolus_Duration: ${apiUsage_CP_Bolus_Duration}\")\n    val apiUsage_Rx_Okay: Option[art.Empty] = api.get_Rx_Okay()\n    api.logInfo(s\"Received on Rx_Okay: ${apiUsage_Rx_Okay}\")\n    val apiUsage_Patient_Request_Not_Too_Soon: Option[art.Empty] = api.get_Patient_Request_Not_Too_Soon()\n    api.logInfo(s\"Received on Patient_Request_Not_Too_Soon: ${apiUsage_Patient_Request_Not_Too_Soon}\")\n    val apiUsage_Patient_Request_Too_Soon: Option[art.Empty] = api.get_Patient_Request_Too_Soon()\n    api.logInfo(s\"Received on Patient_Request_Too_Soon: ${apiUsage_Patient_Request_Too_Soon}\")\n    val apiUsage_HW_Detected_Failure: Option[art.Empty] = api.get_HW_Detected_Failure()\n    api.logInfo(s\"Received on HW_Detected_Failure: ${apiUsage_HW_Detected_Failure}\")\n    val apiUsage_Stop_Pump_Completely: Option[art.Empty] = api.get_Stop_Pump_Completely()\n    api.logInfo(s\"Received on Stop_Pump_Completely: ${apiUsage_Stop_Pump_Completely}\")\n    val apiUsage_Pump_At_KVO_Rate: Option[art.Empty] = api.get_Pump_At_KVO_Rate()\n    api.logInfo(s\"Received on Pump_At_KVO_Rate: ${apiUsage_Pump_At_KVO_Rate}\")\n    val apiUsage_CP_Clinician_Request_Bolus: Option[art.Empty] = api.get_CP_Clinician_Request_Bolus()\n    api.logInfo(s\"Received on CP_Clinician_Request_Bolus: ${apiUsage_CP_Clinician_Request_Bolus}\")\n    val apiUsage_Halt_Infusion: Option[art.Empty] = api.get_Halt_Infusion()\n    api.logInfo(s\"Received on Halt_Infusion: ${apiUsage_Halt_Infusion}\")\n    val apiUsage_Begin_Infusion: Option[art.Empty] = api.get_Begin_Infusion()\n    api.logInfo(s\"Received on Begin_Infusion: ${apiUsage_Begin_Infusion}\")\n    val apiUsage_Near_Max_Drug_Per_Hour: Option[art.Empty] = api.get_Near_Max_Drug_Per_Hour()\n    api.logInfo(s\"Received on Near_Max_Drug_Per_Hour: ${apiUsage_Near_Max_Drug_Per_Hour}\")\n    val apiUsage_Over_Max_Drug_Per_Hour: Option[art.Empty] = api.get_Over_Max_Drug_Per_Hour()\n    api.logInfo(s\"Received on Over_Max_Drug_Per_Hour: ${apiUsage_Over_Max_Drug_Per_Hour}\")\n  }\n\n  def handle_command_Suspend(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_command_Suspend implementation\")\n    api.logInfo(\"received command_Suspend event\")\n  }\n\n  def handle_command_load_drug_library(api: ICE_Thread_imp_Operational_Api, value : PCA_Types.Drug_Library): Unit = {\n    api.logInfo(\"example handle_command_load_drug_library implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_command_set_clinican_requested_bolus_duration(api: ICE_Thread_imp_Operational_Api, value : ICE_Types.Minute_imp): Unit = {\n    api.logInfo(\"example handle_command_set_clinican_requested_bolus_duration implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_command_request_bolus(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_command_request_bolus implementation\")\n    api.logInfo(\"received command_request_bolus event\")\n  }\n\n  def handle_command_pause_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_command_pause_infusion implementation\")\n    api.logInfo(\"received command_pause_infusion event\")\n  }\n\n  def handle_command_resume_infusion(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_command_resume_infusion implementation\")\n    api.logInfo(\"received command_resume_infusion event\")\n  }\n\n  def handle_Alarm(api: ICE_Thread_imp_Operational_Api, value : PCA_Types.Alarm_Type.Type): Unit = {\n    api.logInfo(\"example handle_Alarm implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Warning(api: ICE_Thread_imp_Operational_Api, value : PCA_Types.Warning_Type.Type): Unit = {\n    api.logInfo(\"example handle_Warning implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_CP_Bolus_Duration(api: ICE_Thread_imp_Operational_Api, value : ICE_Types.Minute_imp): Unit = {\n    api.logInfo(\"example handle_CP_Bolus_Duration implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Rx_Okay(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Rx_Okay implementation\")\n    api.logInfo(\"received Rx_Okay event\")\n  }\n\n  def handle_Patient_Request_Not_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Request_Not_Too_Soon implementation\")\n    api.logInfo(\"received Patient_Request_Not_Too_Soon event\")\n  }\n\n  def handle_Patient_Request_Too_Soon(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Request_Too_Soon implementation\")\n    api.logInfo(\"received Patient_Request_Too_Soon event\")\n  }\n\n  def handle_HW_Detected_Failure(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_HW_Detected_Failure implementation\")\n    api.logInfo(\"received HW_Detected_Failure event\")\n  }\n\n  def handle_Stop_Pump_Completely(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Stop_Pump_Completely implementation\")\n    api.logInfo(\"received Stop_Pump_Completely event\")\n  }\n\n  def handle_Pump_At_KVO_Rate(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Pump_At_KVO_Rate implementation\")\n    api.logInfo(\"received Pump_At_KVO_Rate event\")\n  }\n\n  def handle_CP_Clinician_Request_Bolus(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_CP_Clinician_Request_Bolus implementation\")\n    api.logInfo(\"received CP_Clinician_Request_Bolus event\")\n  }\n\n  def handle_Halt_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Halt_Infusion implementation\")\n    api.logInfo(\"received Halt_Infusion event\")\n  }\n\n  def handle_Begin_Infusion(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Begin_Infusion implementation\")\n    api.logInfo(\"received Begin_Infusion event\")\n  }\n\n  def handle_Near_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Near_Max_Drug_Per_Hour implementation\")\n    api.logInfo(\"received Near_Max_Drug_Per_Hour event\")\n  }\n\n  def handle_Over_Max_Drug_Per_Hour(api: ICE_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Over_Max_Drug_Per_Hour implementation\")\n    api.logInfo(\"received Over_Max_Drug_Per_Hour event\")\n  }\n\n  def activate(api: ICE_Thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: ICE_Thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: ICE_Thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: ICE_Thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation_Threads\/Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_TestApi extends BridgeTestSuite[Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_max_drug_watcher) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Infusion_Flow_Rate payload for data port Infusion_Flow_Rate\n   * @param Max_Drug_Per_Hour payload for data port Max_Drug_Per_Hour\n   *\/\n  def put_concrete_inputs(Infusion_Flow_Rate : PCA_Types.Flow_Rate_imp,\n                          Max_Drug_Per_Hour : PCA_Types.Drug_Volume_imp): Unit = {\n    put_Infusion_Flow_Rate(Infusion_Flow_Rate)\n    put_Max_Drug_Per_Hour(Max_Drug_Per_Hour)\n  }\n\n\n  \/** helper function to check Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Near_Max_Drug_Per_Hour method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Near_Max_Drug_Per_Hour'.\n   * @param Over_Max_Drug_Per_Hour method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Over_Max_Drug_Per_Hour'.\n   *\/\n  def check_concrete_output(Near_Max_Drug_Per_Hour: Z => B = Near_Max_Drug_Per_HourParam => {T},\n                            Over_Max_Drug_Per_Hour: Z => B = Over_Max_Drug_Per_HourParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Near_Max_Drug_Per_HourValue: Z = if(get_Near_Max_Drug_Per_Hour().nonEmpty) z\"1\" else z\"0\"\n    if(!Near_Max_Drug_Per_Hour(Near_Max_Drug_Per_HourValue)) {\n      testFailures = testFailures :+ st\"'Near_Max_Drug_Per_Hour' did not match expected: ${Near_Max_Drug_Per_HourValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Over_Max_Drug_Per_HourValue: Z = if(get_Over_Max_Drug_Per_Hour().nonEmpty) z\"1\" else z\"0\"\n    if(!Over_Max_Drug_Per_Hour(Over_Max_Drug_Per_HourValue)) {\n      testFailures = testFailures :+ st\"'Over_Max_Drug_Per_Hour' did not match expected: ${Over_Max_Drug_Per_HourValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Infusion_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Infusion_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Max_Drug_Per_Hour(value : PCA_Types.Drug_Volume_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Max_Drug_Per_Hour_Id, PCA_Types.Drug_Volume_imp_Payload(value))\n  }\n\n  \/\/ getter for out EventPort\n  def get_Near_Max_Drug_Per_Hour(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Near_Max_Drug_Per_Hour_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Near_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Near_Max_Drug_Per_Hour_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Near_Max_Drug_Per_Hour_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Over_Max_Drug_Per_Hour(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Over_Max_Drug_Per_Hour_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Over_Max_Drug_Per_Hour.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Over_Max_Drug_Per_Hour_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Over_Max_Drug_Per_Hour_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation_Threads._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Test extends Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation_Threads.{Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Infusion_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Max_Drug_Per_Hour: Port[PCA_Types.Drug_Volume_imp],\n  Near_Max_Drug_Per_Hour: Port[art.Empty],\n  Over_Max_Drug_Per_Hour: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Infusion_Flow_Rate,\n              Max_Drug_Per_Hour,\n              Near_Max_Drug_Per_Hour,\n              Over_Max_Drug_Per_Hour),\n\n    dataIns = ISZ(Infusion_Flow_Rate,\n                  Max_Drug_Per_Hour),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Near_Max_Drug_Per_Hour,\n                    Over_Max_Drug_Per_Hour)\n  )\n\n  val initialization_api : Max_Drug_Per_Hour_Watcher_imp_Initialization_Api = {\n    val api = Max_Drug_Per_Hour_Watcher_imp_Initialization_Api(\n      id,\n      Infusion_Flow_Rate.id,\n      Max_Drug_Per_Hour.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id\n    )\n    Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Max_Drug_Per_Hour_Watcher_imp_Operational_Api = {\n    val api = Max_Drug_Per_Hour_Watcher_imp_Operational_Api(\n      id,\n      Infusion_Flow_Rate.id,\n      Max_Drug_Per_Hour.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id\n    )\n    Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge.EntryPoints(\n      id,\n\n      Infusion_Flow_Rate.id,\n      Max_Drug_Per_Hour.id,\n      Near_Max_Drug_Per_Hour.id,\n      Over_Max_Drug_Per_Hour.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_Bridge {\n\n  var c_initialization_api: Option[Max_Drug_Per_Hour_Watcher_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Max_Drug_Per_Hour_Watcher_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher_BridgeId : Art.BridgeId,\n\n    Infusion_Flow_Rate_Id : Art.PortId,\n    Max_Drug_Per_Hour_Id : Art.PortId,\n    Near_Max_Drug_Per_Hour_Id : Art.PortId,\n    Over_Max_Drug_Per_Hour_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Max_Drug_Per_Hour_Watcher_imp_Initialization_Api,\n    operational_api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Infusion_Flow_Rate_Id,\n                                             Max_Drug_Per_Hour_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Near_Max_Drug_Per_Hour_Id,\n                                               Over_Max_Drug_Per_Hour_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Max_Drug_Per_Hour_Watcher_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Max_Drug_Per_Hour_Watcher_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Max_Drug_Per_Hour_Watcher_imp_Api {\n  def id: Art.BridgeId\n  def Infusion_Flow_Rate_Id : Art.PortId\n  def Max_Drug_Per_Hour_Id : Art.PortId\n  def Near_Max_Drug_Per_Hour_Id : Art.PortId\n  def Over_Max_Drug_Per_Hour_Id : Art.PortId\n\n  def put_Near_Max_Drug_Per_Hour() : Unit = {\n    Art.putValue(Near_Max_Drug_Per_Hour_Id, art.Empty())\n  }\n\n  def put_Over_Max_Drug_Per_Hour() : Unit = {\n    Art.putValue(Over_Max_Drug_Per_Hour_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Max_Drug_Per_Hour_Watcher_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Max_Drug_Per_Hour_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId) extends Max_Drug_Per_Hour_Watcher_imp_Api\n\n@datatype class Max_Drug_Per_Hour_Watcher_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Max_Drug_Per_Hour_Id : Art.PortId,\n  val Near_Max_Drug_Per_Hour_Id : Art.PortId,\n  val Over_Max_Drug_Per_Hour_Id : Art.PortId) extends Max_Drug_Per_Hour_Watcher_imp_Api {\n\n  def get_Infusion_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Infusion_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Infusion_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Max_Drug_Per_Hour() : Option[PCA_Types.Drug_Volume_imp] = {\n    val value : Option[PCA_Types.Drug_Volume_imp] = Art.getValue(Max_Drug_Per_Hour_Id) match {\n      case Some(PCA_Types.Drug_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Max_Drug_Per_Hour.  Expecting 'PCA_Types.Drug_Volume_imp_Payload' but received ${v}\")\n        None[PCA_Types.Drug_Volume_imp]()\n      case _ => None[PCA_Types.Drug_Volume_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation_Threads\/Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Max_Drug_Per_Hour_Watcher_imp_pump_operation_operation_process_operation_threads_max_drug_watcher {\n\n  def initialise(api: Max_Drug_Per_Hour_Watcher_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Near_Max_Drug_Per_Hour()\n    api.put_Over_Max_Drug_Per_Hour()\n  }\n\n  def timeTriggered(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Infusion_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Infusion_Flow_Rate()\n    api.logInfo(s\"Received on Infusion_Flow_Rate: ${apiUsage_Infusion_Flow_Rate}\")\n    val apiUsage_Max_Drug_Per_Hour: Option[PCA_Types.Drug_Volume_imp] = api.get_Max_Drug_Per_Hour()\n    api.logInfo(s\"Received on Max_Drug_Per_Hour: ${apiUsage_Max_Drug_Per_Hour}\")\n  }\n\n  def activate(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = { }\n\n  def recover(api: Max_Drug_Per_Hour_Watcher_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Operation_Threads\/Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_TestApi extends BridgeTestSuite[Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_operation_process_operation_threads_patient_bolus_checker) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Minimum_Time_Between_Bolus payload for data port Minimum_Time_Between_Bolus\n   * @param Patient_Button_Request the number of events to place in the Patient_Button_Request event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Minimum_Time_Between_Bolus : ICE_Types.Minute_imp,\n                          Patient_Button_Request : Z): Unit = {\n    put_Minimum_Time_Between_Bolus(Minimum_Time_Between_Bolus)\n    for(i <- 0 until Patient_Button_Request) {\n      put_Patient_Button_Request()\n    }\n  }\n\n\n  \/** helper function to check Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Patient_Request_Not_Too_Soon method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Patient_Request_Not_Too_Soon'.\n   * @param Patient_Request_Too_Soon method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Patient_Request_Too_Soon'.\n   *\/\n  def check_concrete_output(Patient_Request_Not_Too_Soon: Z => B = Patient_Request_Not_Too_SoonParam => {T},\n                            Patient_Request_Too_Soon: Z => B = Patient_Request_Too_SoonParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Patient_Request_Not_Too_SoonValue: Z = if(get_Patient_Request_Not_Too_Soon().nonEmpty) z\"1\" else z\"0\"\n    if(!Patient_Request_Not_Too_Soon(Patient_Request_Not_Too_SoonValue)) {\n      testFailures = testFailures :+ st\"'Patient_Request_Not_Too_Soon' did not match expected: ${Patient_Request_Not_Too_SoonValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Patient_Request_Too_SoonValue: Z = if(get_Patient_Request_Too_Soon().nonEmpty) z\"1\" else z\"0\"\n    if(!Patient_Request_Too_Soon(Patient_Request_Too_SoonValue)) {\n      testFailures = testFailures :+ st\"'Patient_Request_Too_Soon' did not match expected: ${Patient_Request_Too_SoonValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Minimum_Time_Between_Bolus(value : ICE_Types.Minute_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Minimum_Time_Between_Bolus_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Button_Request(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Button_Request_Id, Empty())\n  }\n\n  \/\/ getter for out EventPort\n  def get_Patient_Request_Not_Too_Soon(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Patient_Request_Not_Too_Soon_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Patient_Request_Not_Too_Soon.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Patient_Request_Not_Too_Soon_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Patient_Request_Not_Too_Soon_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Patient_Request_Too_Soon(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Patient_Request_Too_Soon_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Patient_Request_Too_Soon.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Patient_Request_Too_Soon_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Patient_Request_Too_Soon_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Operation_Threads._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Test extends Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Operation_Threads.{Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Minimum_Time_Between_Bolus: Port[ICE_Types.Minute_imp],\n  Patient_Button_Request: Port[art.Empty],\n  Patient_Request_Not_Too_Soon: Port[art.Empty],\n  Patient_Request_Too_Soon: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Minimum_Time_Between_Bolus,\n              Patient_Button_Request,\n              Patient_Request_Not_Too_Soon,\n              Patient_Request_Too_Soon),\n\n    dataIns = ISZ(Minimum_Time_Between_Bolus),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Patient_Button_Request),\n\n    eventOuts = ISZ(Patient_Request_Not_Too_Soon,\n                    Patient_Request_Too_Soon)\n  )\n\n  val initialization_api : Patient_Bolus_Checker_imp_Initialization_Api = {\n    val api = Patient_Bolus_Checker_imp_Initialization_Api(\n      id,\n      Minimum_Time_Between_Bolus.id,\n      Patient_Button_Request.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id\n    )\n    Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Patient_Bolus_Checker_imp_Operational_Api = {\n    val api = Patient_Bolus_Checker_imp_Operational_Api(\n      id,\n      Minimum_Time_Between_Bolus.id,\n      Patient_Button_Request.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id\n    )\n    Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge.EntryPoints(\n      id,\n\n      Minimum_Time_Between_Bolus.id,\n      Patient_Button_Request.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_Bridge {\n\n  var c_initialization_api: Option[Patient_Bolus_Checker_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Patient_Bolus_Checker_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_BridgeId : Art.BridgeId,\n\n    Minimum_Time_Between_Bolus_Id : Art.PortId,\n    Patient_Button_Request_Id : Art.PortId,\n    Patient_Request_Not_Too_Soon_Id : Art.PortId,\n    Patient_Request_Too_Soon_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Patient_Bolus_Checker_imp_Initialization_Api,\n    operational_api: Patient_Bolus_Checker_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Minimum_Time_Between_Bolus_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Patient_Button_Request_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Patient_Request_Not_Too_Soon_Id,\n                                               Patient_Request_Too_Soon_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Patient_Button_Request_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Button_Request(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Button_Request(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Patient_Button_Request_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Button_Request(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Button_Request(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Patient_Bolus_Checker_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Operation_Threads\/Patient_Bolus_Checker_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Patient_Bolus_Checker_imp_Api {\n  def id: Art.BridgeId\n  def Minimum_Time_Between_Bolus_Id : Art.PortId\n  def Patient_Button_Request_Id : Art.PortId\n  def Patient_Request_Not_Too_Soon_Id : Art.PortId\n  def Patient_Request_Too_Soon_Id : Art.PortId\n\n  def put_Patient_Request_Not_Too_Soon() : Unit = {\n    Art.putValue(Patient_Request_Not_Too_Soon_Id, art.Empty())\n  }\n\n  def put_Patient_Request_Too_Soon() : Unit = {\n    Art.putValue(Patient_Request_Too_Soon_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Patient_Bolus_Checker_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Minimum_Time_Between_Bolus_Id : Art.PortId,\n  val Patient_Button_Request_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId) extends Patient_Bolus_Checker_imp_Api\n\n@datatype class Patient_Bolus_Checker_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Minimum_Time_Between_Bolus_Id : Art.PortId,\n  val Patient_Button_Request_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId) extends Patient_Bolus_Checker_imp_Api {\n\n  def get_Minimum_Time_Between_Bolus() : Option[ICE_Types.Minute_imp] = {\n    val value : Option[ICE_Types.Minute_imp] = Art.getValue(Minimum_Time_Between_Bolus_Id) match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Minimum_Time_Between_Bolus.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n        None[ICE_Types.Minute_imp]()\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  def get_Patient_Button_Request() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Button_Request_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Button_Request.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Operation_Threads\/Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Operation_Threads\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Patient_Bolus_Checker_imp_pump_operation_operation_process_operation_threads_patient_bolus_checker {\n\n  def initialise(api: Patient_Bolus_Checker_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Patient_Request_Not_Too_Soon()\n    api.put_Patient_Request_Too_Soon()\n  }\n\n  def handle_Patient_Button_Request(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Button_Request implementation\")\n    api.logInfo(\"received Patient_Button_Request event\")\n    \/\/ example api usage\n\n    val apiUsage_Minimum_Time_Between_Bolus: Option[ICE_Types.Minute_imp] = api.get_Minimum_Time_Between_Bolus()\n    api.logInfo(s\"Received on Minimum_Time_Between_Bolus: ${apiUsage_Minimum_Time_Between_Bolus}\")\n    val apiUsage_Patient_Button_Request: Option[art.Empty] = api.get_Patient_Button_Request()\n    api.logInfo(s\"Received on Patient_Button_Request: ${apiUsage_Patient_Button_Request}\")\n  }\n\n  def activate(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = { }\n\n  def recover(api: Patient_Bolus_Checker_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Security\/Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Security\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_TestApi extends BridgeTestSuite[Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_security_subsystem_security_process_security_thread) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Scan_Data payloads for event data port Scan_Data.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Scan_Data will be used\n   * @param Authenticate_Clinician the number of events to place in the Authenticate_Clinician event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Authenticate_Patient the number of events to place in the Authenticate_Patient event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Authenticate_Prescription the number of events to place in the Authenticate_Prescription event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Scan_Data : ISZ[PCA_Types.Scan_Data_Type],\n                          Authenticate_Clinician : Z,\n                          Authenticate_Patient : Z,\n                          Authenticate_Prescription : Z): Unit = {\n    for(v <- Scan_Data){\n      put_Scan_Data(v)\n    }\n    for(i <- 0 until Authenticate_Clinician) {\n      put_Authenticate_Clinician()\n    }\n    for(i <- 0 until Authenticate_Patient) {\n      put_Authenticate_Patient()\n    }\n    for(i <- 0 until Authenticate_Prescription) {\n      put_Authenticate_Prescription()\n    }\n  }\n\n\n  \/** helper function to check Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Clinician_Name method that will be called with the value of the outgoing data\n   *        port 'Clinician_Name'.\n   * @param Patient_Name method that will be called with the value of the outgoing data\n   *        port 'Patient_Name'.\n   * @param Prescription method that will be called with the value of the outgoing data\n   *        port 'Prescription'.\n   * @param Authentication_fail method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Authentication_fail'.\n   * @param Authentication_pass method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Authentication_pass'.\n   * @param Security_Fault method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Security_Fault'.\n   *\/\n  def check_concrete_output(Clinician_Name: Base_Types.String => B = Clinician_NameParam => {T},\n                            Patient_Name: Base_Types.String => B = Patient_NameParam => {T},\n                            Prescription: PCA_Types.Prescription_imp => B = PrescriptionParam => {T},\n                            Authentication_fail: Z => B = Authentication_failParam => {T},\n                            Authentication_pass: Z => B = Authentication_passParam => {T},\n                            Security_Fault: Z => B = Security_FaultParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Clinician_NameValue: Base_Types.String = get_Clinician_Name().get\n    if(!Clinician_Name(Clinician_NameValue)) {\n      testFailures = testFailures :+ st\"'Clinician_Name' did not match expected: value of the outgoing data port is ${Clinician_NameValue}\"\n    }\n    val Patient_NameValue: Base_Types.String = get_Patient_Name().get\n    if(!Patient_Name(Patient_NameValue)) {\n      testFailures = testFailures :+ st\"'Patient_Name' did not match expected: value of the outgoing data port is ${Patient_NameValue}\"\n    }\n    val PrescriptionValue: PCA_Types.Prescription_imp = get_Prescription().get\n    if(!Prescription(PrescriptionValue)) {\n      testFailures = testFailures :+ st\"'Prescription' did not match expected: value of the outgoing data port is ${PrescriptionValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Authentication_failValue: Z = if(get_Authentication_fail().nonEmpty) z\"1\" else z\"0\"\n    if(!Authentication_fail(Authentication_failValue)) {\n      testFailures = testFailures :+ st\"'Authentication_fail' did not match expected: ${Authentication_failValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Authentication_passValue: Z = if(get_Authentication_pass().nonEmpty) z\"1\" else z\"0\"\n    if(!Authentication_pass(Authentication_passValue)) {\n      testFailures = testFailures :+ st\"'Authentication_pass' did not match expected: ${Authentication_passValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Security_FaultValue: Z = if(get_Security_Fault().nonEmpty) z\"1\" else z\"0\"\n    if(!Security_Fault(Security_FaultValue)) {\n      testFailures = testFailures :+ st\"'Security_Fault' did not match expected: ${Security_FaultValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Scan_Data(value : PCA_Types.Scan_Data_Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Scan_Data_Id, PCA_Types.Scan_Data_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Authenticate_Clinician(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Authenticate_Clinician_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Authenticate_Patient(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Authenticate_Patient_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Authenticate_Prescription(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Authenticate_Prescription_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_Clinician_Name(): Option[Base_Types.String] = {\n    val value: Option[Base_Types.String] = get_Clinician_Name_payload() match {\n      case Some(Base_Types.String_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Clinician_Name.  Expecting 'Base_Types.String_Payload' but received ${v}\")\n      case _ => None[Base_Types.String]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Clinician_Name_payload(): Option[Base_Types.String_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Clinician_Name_Id).asInstanceOf[Option[Base_Types.String_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Patient_Name(): Option[Base_Types.String] = {\n    val value: Option[Base_Types.String] = get_Patient_Name_payload() match {\n      case Some(Base_Types.String_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Patient_Name.  Expecting 'Base_Types.String_Payload' but received ${v}\")\n      case _ => None[Base_Types.String]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Patient_Name_payload(): Option[Base_Types.String_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Patient_Name_Id).asInstanceOf[Option[Base_Types.String_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Prescription(): Option[PCA_Types.Prescription_imp] = {\n    val value: Option[PCA_Types.Prescription_imp] = get_Prescription_payload() match {\n      case Some(PCA_Types.Prescription_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Prescription.  Expecting 'PCA_Types.Prescription_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Prescription_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Prescription_payload(): Option[PCA_Types.Prescription_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Prescription_Id).asInstanceOf[Option[PCA_Types.Prescription_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Authentication_fail(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Authentication_fail_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Authentication_fail.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Authentication_fail_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Authentication_fail_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Authentication_pass(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Authentication_pass_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Authentication_pass.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Authentication_pass_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Authentication_pass_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Security_Fault(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Security_Fault_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Security_Fault.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Security_Fault_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Security_Fault_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Security\/Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Security\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Security._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Test extends Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Security\/Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Security\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Security.{Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Clinician_Name: Port[Base_Types.String],\n  Patient_Name: Port[Base_Types.String],\n  Prescription: Port[PCA_Types.Prescription_imp],\n  Scan_Data: Port[PCA_Types.Scan_Data_Type],\n  Authenticate_Clinician: Port[art.Empty],\n  Authenticate_Patient: Port[art.Empty],\n  Authenticate_Prescription: Port[art.Empty],\n  Authentication_fail: Port[art.Empty],\n  Authentication_pass: Port[art.Empty],\n  Security_Fault: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Clinician_Name,\n              Patient_Name,\n              Prescription,\n              Scan_Data,\n              Authenticate_Clinician,\n              Authenticate_Patient,\n              Authenticate_Prescription,\n              Authentication_fail,\n              Authentication_pass,\n              Security_Fault),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(Clinician_Name,\n                   Patient_Name,\n                   Prescription),\n\n    eventIns = ISZ(Scan_Data,\n                   Authenticate_Clinician,\n                   Authenticate_Patient,\n                   Authenticate_Prescription),\n\n    eventOuts = ISZ(Authentication_fail,\n                    Authentication_pass,\n                    Security_Fault)\n  )\n\n  val initialization_api : Security_Thread_imp_Initialization_Api = {\n    val api = Security_Thread_imp_Initialization_Api(\n      id,\n      Clinician_Name.id,\n      Patient_Name.id,\n      Prescription.id,\n      Scan_Data.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Security_Fault.id\n    )\n    Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Security_Thread_imp_Operational_Api = {\n    val api = Security_Thread_imp_Operational_Api(\n      id,\n      Clinician_Name.id,\n      Patient_Name.id,\n      Prescription.id,\n      Scan_Data.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Security_Fault.id\n    )\n    Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge.EntryPoints(\n      id,\n\n      Clinician_Name.id,\n      Patient_Name.id,\n      Prescription.id,\n      Scan_Data.id,\n      Authenticate_Clinician.id,\n      Authenticate_Patient.id,\n      Authenticate_Prescription.id,\n      Authentication_fail.id,\n      Authentication_pass.id,\n      Security_Fault.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_Bridge {\n\n  var c_initialization_api: Option[Security_Thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[Security_Thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_BridgeId : Art.BridgeId,\n\n    Clinician_Name_Id : Art.PortId,\n    Patient_Name_Id : Art.PortId,\n    Prescription_Id : Art.PortId,\n    Scan_Data_Id : Art.PortId,\n    Authenticate_Clinician_Id : Art.PortId,\n    Authenticate_Patient_Id : Art.PortId,\n    Authenticate_Prescription_Id : Art.PortId,\n    Authentication_fail_Id : Art.PortId,\n    Authentication_pass_Id : Art.PortId,\n    Security_Fault_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Security_Thread_imp_Initialization_Api,\n    operational_api: Security_Thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Scan_Data_Id,\n                                              Authenticate_Clinician_Id,\n                                              Authenticate_Patient_Id,\n                                              Authenticate_Prescription_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Clinician_Name_Id,\n                                              Patient_Name_Id,\n                                              Prescription_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Authentication_fail_Id,\n                                               Authentication_pass_Id,\n                                               Security_Fault_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Scan_Data_Id){\n          val Some(PCA_Types.Scan_Data_Type_Payload(value)) = Art.getValue(Scan_Data_Id)\n\n          \/\/ implement the following in 'component':  def handle_Scan_Data(api: Security_Thread_imp_Operational_Api, value: PCA_Types.Scan_Data_Type): Unit = {}\n          component.handle_Scan_Data(operational_api, value)\n        }\n        else if(portId == Authenticate_Clinician_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Clinician(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Clinician(operational_api)\n        }\n        else if(portId == Authenticate_Patient_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Patient(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Patient(operational_api)\n        }\n        else if(portId == Authenticate_Prescription_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Prescription(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Prescription(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Scan_Data_Id){\n          val Some(PCA_Types.Scan_Data_Type_Payload(value)) = Art.getValue(Scan_Data_Id)\n\n          \/\/ implement the following in 'component':  def handle_Scan_Data(api: Security_Thread_imp_Operational_Api, value: PCA_Types.Scan_Data_Type): Unit = {}\n          component.handle_Scan_Data(operational_api, value)\n        }\n        else if(portId == Authenticate_Clinician_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Clinician(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Clinician(operational_api)\n        }\n        else if(portId == Authenticate_Patient_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Patient(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Patient(operational_api)\n        }\n        else if(portId == Authenticate_Prescription_Id) {\n          \/\/ implement the following in 'component':  def handle_Authenticate_Prescription(api: Security_Thread_imp_Operational_Api): Unit = {}\n          component.handle_Authenticate_Prescription(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Security_Thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Security_Thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Security_Thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Security_Thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Security_Thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Security\/Security_Thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Security\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait Security_Thread_imp_Api {\n  def id: Art.BridgeId\n  def Clinician_Name_Id : Art.PortId\n  def Patient_Name_Id : Art.PortId\n  def Prescription_Id : Art.PortId\n  def Scan_Data_Id : Art.PortId\n  def Authenticate_Clinician_Id : Art.PortId\n  def Authenticate_Patient_Id : Art.PortId\n  def Authenticate_Prescription_Id : Art.PortId\n  def Authentication_fail_Id : Art.PortId\n  def Authentication_pass_Id : Art.PortId\n  def Security_Fault_Id : Art.PortId\n\n  def put_Clinician_Name(value : Base_Types.String) : Unit = {\n    Art.putValue(Clinician_Name_Id, Base_Types.String_Payload(value))\n  }\n\n  def put_Patient_Name(value : Base_Types.String) : Unit = {\n    Art.putValue(Patient_Name_Id, Base_Types.String_Payload(value))\n  }\n\n  def put_Prescription(value : PCA_Types.Prescription_imp) : Unit = {\n    Art.putValue(Prescription_Id, PCA_Types.Prescription_imp_Payload(value))\n  }\n\n  def put_Authentication_fail() : Unit = {\n    Art.putValue(Authentication_fail_Id, art.Empty())\n  }\n\n  def put_Authentication_pass() : Unit = {\n    Art.putValue(Authentication_pass_Id, art.Empty())\n  }\n\n  def put_Security_Fault() : Unit = {\n    Art.putValue(Security_Fault_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Security_Thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Clinician_Name_Id : Art.PortId,\n  val Patient_Name_Id : Art.PortId,\n  val Prescription_Id : Art.PortId,\n  val Scan_Data_Id : Art.PortId,\n  val Authenticate_Clinician_Id : Art.PortId,\n  val Authenticate_Patient_Id : Art.PortId,\n  val Authenticate_Prescription_Id : Art.PortId,\n  val Authentication_fail_Id : Art.PortId,\n  val Authentication_pass_Id : Art.PortId,\n  val Security_Fault_Id : Art.PortId) extends Security_Thread_imp_Api\n\n@datatype class Security_Thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Clinician_Name_Id : Art.PortId,\n  val Patient_Name_Id : Art.PortId,\n  val Prescription_Id : Art.PortId,\n  val Scan_Data_Id : Art.PortId,\n  val Authenticate_Clinician_Id : Art.PortId,\n  val Authenticate_Patient_Id : Art.PortId,\n  val Authenticate_Prescription_Id : Art.PortId,\n  val Authentication_fail_Id : Art.PortId,\n  val Authentication_pass_Id : Art.PortId,\n  val Security_Fault_Id : Art.PortId) extends Security_Thread_imp_Api {\n\n  def get_Scan_Data() : Option[PCA_Types.Scan_Data_Type] = {\n    val value : Option[PCA_Types.Scan_Data_Type] = Art.getValue(Scan_Data_Id) match {\n      case Some(PCA_Types.Scan_Data_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Scan_Data.  Expecting 'PCA_Types.Scan_Data_Type_Payload' but received ${v}\")\n        None[PCA_Types.Scan_Data_Type]()\n      case _ => None[PCA_Types.Scan_Data_Type]()\n    }\n    return value\n  }\n\n  def get_Authenticate_Clinician() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Authenticate_Clinician_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Authenticate_Clinician.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Authenticate_Patient() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Authenticate_Patient_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Authenticate_Patient.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Authenticate_Prescription() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Authenticate_Prescription_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Authenticate_Prescription.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Security\/Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Security\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Security_Thread_imp_pump_operation_security_subsystem_security_process_security_thread {\n\n  def initialise(api: Security_Thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Clinician_Name(Base_Types.String_example())\n    api.put_Patient_Name(Base_Types.String_example())\n    api.put_Prescription(PCA_Types.Prescription_imp.example())\n    api.put_Authentication_fail()\n    api.put_Authentication_pass()\n    api.put_Security_Fault()\n  }\n\n  def handle_Scan_Data(api: Security_Thread_imp_Operational_Api, value : PCA_Types.Scan_Data_Type): Unit = {\n    api.logInfo(\"example handle_Scan_Data implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Scan_Data: Option[PCA_Types.Scan_Data_Type] = api.get_Scan_Data()\n    api.logInfo(s\"Received on Scan_Data: ${apiUsage_Scan_Data}\")\n    val apiUsage_Authenticate_Clinician: Option[art.Empty] = api.get_Authenticate_Clinician()\n    api.logInfo(s\"Received on Authenticate_Clinician: ${apiUsage_Authenticate_Clinician}\")\n    val apiUsage_Authenticate_Patient: Option[art.Empty] = api.get_Authenticate_Patient()\n    api.logInfo(s\"Received on Authenticate_Patient: ${apiUsage_Authenticate_Patient}\")\n    val apiUsage_Authenticate_Prescription: Option[art.Empty] = api.get_Authenticate_Prescription()\n    api.logInfo(s\"Received on Authenticate_Prescription: ${apiUsage_Authenticate_Prescription}\")\n  }\n\n  def handle_Authenticate_Clinician(api: Security_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Authenticate_Clinician implementation\")\n    api.logInfo(\"received Authenticate_Clinician event\")\n  }\n\n  def handle_Authenticate_Patient(api: Security_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Authenticate_Patient implementation\")\n    api.logInfo(\"received Authenticate_Patient event\")\n  }\n\n  def handle_Authenticate_Prescription(api: Security_Thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Authenticate_Prescription implementation\")\n    api.logInfo(\"received Authenticate_Prescription event\")\n  }\n\n  def activate(api: Security_Thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: Security_Thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: Security_Thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: Security_Thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Control_Panel\/pca_screen_imp_pump_operation_control_panel_display_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class pca_screen_imp_pump_operation_control_panel_display_TestApi extends BridgeTestSuite[pca_screen_imp_pump_operation_control_panel_display_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_control_panel_display) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Image payload for data port Image\n   * @param Finger_Press payloads for event data port Finger_Press.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Finger_Press will be used\n   *\/\n  def put_concrete_inputs(Image : PCA_Types.Image,\n                          Finger_Press : ISZ[Base_Types.Boolean]): Unit = {\n    put_Image(Image)\n    for(v <- Finger_Press){\n      put_Finger_Press(v)\n    }\n  }\n\n\n  \/** helper function to check pca_screen_imp_pump_operation_control_panel_display's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param LightToEye method that will be called with the value of the outgoing data\n   *        port 'LightToEye'.\n   * @param Touch method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Touch'.\n   *\/\n  def check_concrete_output(LightToEye: Base_Types.Boolean => B = LightToEyeParam => {T},\n                            Touch: ISZ[PCA_Types.Touch] => B = TouchParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val LightToEyeValue: Base_Types.Boolean = get_LightToEye().get\n    if(!LightToEye(LightToEyeValue)) {\n      testFailures = testFailures :+ st\"'LightToEye' did not match expected: value of the outgoing data port is ${LightToEyeValue}\"\n    }\n    var TouchValue: ISZ[PCA_Types.Touch] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Touch().nonEmpty) TouchValue = TouchValue :+ get_Touch().get\n    if(!Touch(TouchValue)) {\n      testFailures = testFailures :+ st\"'Touch' did not match expected: received ${TouchValue.size} events with the following payloads ${TouchValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Image(value : PCA_Types.Image): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Image_Id, PCA_Types.Image_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Finger_Press(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Finger_Press_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_LightToEye(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_LightToEye_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port LightToEye.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_LightToEye_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.LightToEye_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Touch(): Option[PCA_Types.Touch] = {\n    val value: Option[PCA_Types.Touch] = get_Touch_payload() match {\n      case Some(PCA_Types.Touch_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Touch.  Expecting 'PCA_Types.Touch_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Touch]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Touch_payload(): Option[PCA_Types.Touch_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Touch_Id).asInstanceOf[Option[PCA_Types.Touch_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_screen_imp_pump_operation_control_panel_display_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Control_Panel._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass pca_screen_imp_pump_operation_control_panel_display_Test extends pca_screen_imp_pump_operation_control_panel_display_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_screen_imp_pump_operation_control_panel_display_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Control_Panel.{pca_screen_imp_pump_operation_control_panel_display => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class pca_screen_imp_pump_operation_control_panel_display_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Image: Port[PCA_Types.Image],\n  LightToEye: Port[Base_Types.Boolean],\n  Touch: Port[PCA_Types.Touch],\n  Finger_Press: Port[Base_Types.Boolean]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Image,\n              LightToEye,\n              Touch,\n              Finger_Press),\n\n    dataIns = ISZ(Image),\n\n    dataOuts = ISZ(LightToEye),\n\n    eventIns = ISZ(Finger_Press),\n\n    eventOuts = ISZ(Touch)\n  )\n\n  val initialization_api : pca_screen_imp_Initialization_Api = {\n    val api = pca_screen_imp_Initialization_Api(\n      id,\n      Image.id,\n      LightToEye.id,\n      Touch.id,\n      Finger_Press.id\n    )\n    pca_screen_imp_pump_operation_control_panel_display_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : pca_screen_imp_Operational_Api = {\n    val api = pca_screen_imp_Operational_Api(\n      id,\n      Image.id,\n      LightToEye.id,\n      Touch.id,\n      Finger_Press.id\n    )\n    pca_screen_imp_pump_operation_control_panel_display_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    pca_screen_imp_pump_operation_control_panel_display_Bridge.EntryPoints(\n      id,\n\n      Image.id,\n      LightToEye.id,\n      Touch.id,\n      Finger_Press.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject pca_screen_imp_pump_operation_control_panel_display_Bridge {\n\n  var c_initialization_api: Option[pca_screen_imp_Initialization_Api] = None()\n  var c_operational_api: Option[pca_screen_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    pca_screen_imp_pump_operation_control_panel_display_BridgeId : Art.BridgeId,\n\n    Image_Id : Art.PortId,\n    LightToEye_Id : Art.PortId,\n    Touch_Id : Art.PortId,\n    Finger_Press_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: pca_screen_imp_Initialization_Api,\n    operational_api: pca_screen_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Image_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Finger_Press_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(LightToEye_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Touch_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: pca_screen_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: pca_screen_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_screen_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait pca_screen_imp_Api {\n  def id: Art.BridgeId\n  def Image_Id : Art.PortId\n  def LightToEye_Id : Art.PortId\n  def Touch_Id : Art.PortId\n  def Finger_Press_Id : Art.PortId\n\n  def put_LightToEye(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(LightToEye_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def put_Touch(value : PCA_Types.Touch) : Unit = {\n    Art.putValue(Touch_Id, PCA_Types.Touch_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class pca_screen_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Image_Id : Art.PortId,\n  val LightToEye_Id : Art.PortId,\n  val Touch_Id : Art.PortId,\n  val Finger_Press_Id : Art.PortId) extends pca_screen_imp_Api\n\n@datatype class pca_screen_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Image_Id : Art.PortId,\n  val LightToEye_Id : Art.PortId,\n  val Touch_Id : Art.PortId,\n  val Finger_Press_Id : Art.PortId) extends pca_screen_imp_Api {\n\n  def get_Image() : Option[PCA_Types.Image] = {\n    val value : Option[PCA_Types.Image] = Art.getValue(Image_Id) match {\n      case Some(PCA_Types.Image_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Image.  Expecting 'PCA_Types.Image_Payload' but received ${v}\")\n        None[PCA_Types.Image]()\n      case _ => None[PCA_Types.Image]()\n    }\n    return value\n  }\n\n  def get_Finger_Press() : Option[Base_Types.Boolean] = {\n    val value : Option[Base_Types.Boolean] = Art.getValue(Finger_Press_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Finger_Press.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Control_Panel\/pca_screen_imp_pump_operation_control_panel_display.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject pca_screen_imp_pump_operation_control_panel_display {\n\n  def initialise(api: pca_screen_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_LightToEye(Base_Types.Boolean_example())\n    api.put_Touch(PCA_Types.Touch.example())\n  }\n\n  def timeTriggered(api: pca_screen_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Image: Option[PCA_Types.Image] = api.get_Image()\n    api.logInfo(s\"Received on Image: ${apiUsage_Image}\")\n    val apiUsage_Finger_Press: Option[Base_Types.Boolean] = api.get_Finger_Press()\n    api.logInfo(s\"Received on Finger_Press: ${apiUsage_Finger_Press}\")\n  }\n\n  def activate(api: pca_screen_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: pca_screen_imp_Operational_Api): Unit = { }\n\n  def finalise(api: pca_screen_imp_Operational_Api): Unit = { }\n\n  def recover(api: pca_screen_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Control_Panel\/pca_speaker_imp_pump_operation_control_panel_audible_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class pca_speaker_imp_pump_operation_control_panel_audible_TestApi extends BridgeTestSuite[pca_speaker_imp_pump_operation_control_panel_audible_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_control_panel_audible) {\n\n  \/** helper function to set the values of all input ports.\n   * @param AudioSignal payload for data port AudioSignal\n   *\/\n  def put_concrete_inputs(AudioSignal : PCA_Types.Sound.Type): Unit = {\n    put_AudioSignal(AudioSignal)\n  }\n\n\n  \/** helper function to check pca_speaker_imp_pump_operation_control_panel_audible's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Sound method that will be called with the value of the outgoing data\n   *        port 'Sound'.\n   *\/\n  def check_concrete_output(Sound: PCA_Types.Sound.Type => B = SoundParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val SoundValue: PCA_Types.Sound.Type = get_Sound().get\n    if(!Sound(SoundValue)) {\n      testFailures = testFailures :+ st\"'Sound' did not match expected: value of the outgoing data port is ${SoundValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_AudioSignal(value : PCA_Types.Sound.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AudioSignal_Id, PCA_Types.Sound_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_Sound(): Option[PCA_Types.Sound.Type] = {\n    val value: Option[PCA_Types.Sound.Type] = get_Sound_payload() match {\n      case Some(PCA_Types.Sound_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Sound.  Expecting 'PCA_Types.Sound_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Sound.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Sound_payload(): Option[PCA_Types.Sound_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Sound_Id).asInstanceOf[Option[PCA_Types.Sound_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_speaker_imp_pump_operation_control_panel_audible_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Control_Panel._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass pca_speaker_imp_pump_operation_control_panel_audible_Test extends pca_speaker_imp_pump_operation_control_panel_audible_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_speaker_imp_pump_operation_control_panel_audible_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Control_Panel.{pca_speaker_imp_pump_operation_control_panel_audible => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class pca_speaker_imp_pump_operation_control_panel_audible_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AudioSignal: Port[PCA_Types.Sound.Type],\n  Sound: Port[PCA_Types.Sound.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(AudioSignal,\n              Sound),\n\n    dataIns = ISZ(AudioSignal),\n\n    dataOuts = ISZ(Sound),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : pca_speaker_imp_Initialization_Api = {\n    val api = pca_speaker_imp_Initialization_Api(\n      id,\n      AudioSignal.id,\n      Sound.id\n    )\n    pca_speaker_imp_pump_operation_control_panel_audible_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : pca_speaker_imp_Operational_Api = {\n    val api = pca_speaker_imp_Operational_Api(\n      id,\n      AudioSignal.id,\n      Sound.id\n    )\n    pca_speaker_imp_pump_operation_control_panel_audible_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    pca_speaker_imp_pump_operation_control_panel_audible_Bridge.EntryPoints(\n      id,\n\n      AudioSignal.id,\n      Sound.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject pca_speaker_imp_pump_operation_control_panel_audible_Bridge {\n\n  var c_initialization_api: Option[pca_speaker_imp_Initialization_Api] = None()\n  var c_operational_api: Option[pca_speaker_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    pca_speaker_imp_pump_operation_control_panel_audible_BridgeId : Art.BridgeId,\n\n    AudioSignal_Id : Art.PortId,\n    Sound_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: pca_speaker_imp_Initialization_Api,\n    operational_api: pca_speaker_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(AudioSignal_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Sound_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: pca_speaker_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: pca_speaker_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/pca_speaker_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait pca_speaker_imp_Api {\n  def id: Art.BridgeId\n  def AudioSignal_Id : Art.PortId\n  def Sound_Id : Art.PortId\n\n  def put_Sound(value : PCA_Types.Sound.Type) : Unit = {\n    Art.putValue(Sound_Id, PCA_Types.Sound_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class pca_speaker_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val AudioSignal_Id : Art.PortId,\n  val Sound_Id : Art.PortId) extends pca_speaker_imp_Api\n\n@datatype class pca_speaker_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val AudioSignal_Id : Art.PortId,\n  val Sound_Id : Art.PortId) extends pca_speaker_imp_Api {\n\n  def get_AudioSignal() : Option[PCA_Types.Sound.Type] = {\n    val value : Option[PCA_Types.Sound.Type] = Art.getValue(AudioSignal_Id) match {\n      case Some(PCA_Types.Sound_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AudioSignal.  Expecting 'PCA_Types.Sound_Payload' but received ${v}\")\n        None[PCA_Types.Sound.Type]()\n      case _ => None[PCA_Types.Sound.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Control_Panel\/pca_speaker_imp_pump_operation_control_panel_audible.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject pca_speaker_imp_pump_operation_control_panel_audible {\n\n  def initialise(api: pca_speaker_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Sound(PCA_Types.Sound.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: pca_speaker_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_AudioSignal: Option[PCA_Types.Sound.Type] = api.get_AudioSignal()\n    api.logInfo(s\"Received on AudioSignal: ${apiUsage_AudioSignal}\")\n  }\n\n  def activate(api: pca_speaker_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: pca_speaker_imp_Operational_Api): Unit = { }\n\n  def finalise(api: pca_speaker_imp_Operational_Api): Unit = { }\n\n  def recover(api: pca_speaker_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Control_Panel\/ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_TestApi extends BridgeTestSuite[ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge](Arch.wrap_pca_imp_Instance_pump_operation_control_panel_ui_process_ui_thread) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Remaining_Battery_Time payload for data port Remaining_Battery_Time\n   * @param Using_Battery_Power payload for data port Using_Battery_Power\n   * @param Prescription payload for data port Prescription\n   * @param Infusion_Flow_Rate payload for data port Infusion_Flow_Rate\n   * @param Clinician_Name payload for data port Clinician_Name\n   * @param Patient_Name payload for data port Patient_Name\n   * @param Touch payloads for event data port Touch.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Touch will be used\n   * @param Alarm payloads for event data port Alarm.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Alarm will be used\n   * @param Warning payloads for event data port Warning.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Warning will be used\n   * @param System_Status payloads for event data port System_Status.\n   *   ART currently supports single element event data queues so\n   *   only the last element of System_Status will be used\n   * @param Display_Message payloads for event data port Display_Message.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Display_Message will be used\n   * @param Sound_Type payloads for event data port Sound_Type.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Sound_Type will be used\n   * @param Low_Battery_Warning the number of events to place in the Low_Battery_Warning event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Hard_Limit_Violated the number of events to place in the Hard_Limit_Violated event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Soft_Limit_Warning the number of events to place in the Soft_Limit_Warning event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Patient_Request_Not_Too_Soon the number of events to place in the Patient_Request_Not_Too_Soon event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   * @param Patient_Request_Too_Soon the number of events to place in the Patient_Request_Too_Soon event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Remaining_Battery_Time : BLESS_Types.Time,\n                          Using_Battery_Power : Base_Types.Boolean,\n                          Prescription : PCA_Types.Prescription_imp,\n                          Infusion_Flow_Rate : PCA_Types.Flow_Rate_imp,\n                          Clinician_Name : Base_Types.String,\n                          Patient_Name : Base_Types.String,\n                          Touch : ISZ[PCA_Types.Touch],\n                          Alarm : ISZ[PCA_Types.Alarm_Type.Type],\n                          Warning : ISZ[PCA_Types.Warning_Type.Type],\n                          System_Status : ISZ[PCA_Types.Status_Type.Type],\n                          Display_Message : ISZ[PCA_Types.Message.Type],\n                          Sound_Type : ISZ[PCA_Types.Sound.Type],\n                          Low_Battery_Warning : Z,\n                          Hard_Limit_Violated : Z,\n                          Soft_Limit_Warning : Z,\n                          Patient_Request_Not_Too_Soon : Z,\n                          Patient_Request_Too_Soon : Z): Unit = {\n    put_Remaining_Battery_Time(Remaining_Battery_Time)\n    put_Using_Battery_Power(Using_Battery_Power)\n    put_Prescription(Prescription)\n    put_Infusion_Flow_Rate(Infusion_Flow_Rate)\n    put_Clinician_Name(Clinician_Name)\n    put_Patient_Name(Patient_Name)\n    for(v <- Touch){\n      put_Touch(v)\n    }\n    for(v <- Alarm){\n      put_Alarm(v)\n    }\n    for(v <- Warning){\n      put_Warning(v)\n    }\n    for(v <- System_Status){\n      put_System_Status(v)\n    }\n    for(v <- Display_Message){\n      put_Display_Message(v)\n    }\n    for(v <- Sound_Type){\n      put_Sound_Type(v)\n    }\n    for(i <- 0 until Low_Battery_Warning) {\n      put_Low_Battery_Warning()\n    }\n    for(i <- 0 until Hard_Limit_Violated) {\n      put_Hard_Limit_Violated()\n    }\n    for(i <- 0 until Soft_Limit_Warning) {\n      put_Soft_Limit_Warning()\n    }\n    for(i <- 0 until Patient_Request_Not_Too_Soon) {\n      put_Patient_Request_Not_Too_Soon()\n    }\n    for(i <- 0 until Patient_Request_Too_Soon) {\n      put_Patient_Request_Too_Soon()\n    }\n  }\n\n\n  \/** helper function to check ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Image method that will be called with the value of the outgoing data\n   *        port 'Image'.\n   * @param AudioSignal method that will be called with the value of the outgoing data\n   *        port 'AudioSignal'.\n   * @param Alarm_Inactivation method that will be called with the value of the outgoing data\n   *        port 'Alarm_Inactivation'.\n   * @param Bolus_Duration method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Bolus_Duration'.\n   * @param CP_Reset_Alarm method that will be called with the number of events to be sent\n   *        on the outgoing event port 'CP_Reset_Alarm'.\n   * @param Confirm_Soft_Limit_Exception method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Confirm_Soft_Limit_Exception'.\n   * @param Reject_Soft_Limit_Exception method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Reject_Soft_Limit_Exception'.\n   * @param Stop_Button_Pressed method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Stop_Button_Pressed'.\n   * @param Start_Button_Pressed method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Start_Button_Pressed'.\n   * @param Clinician_Request_Bolus method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Clinician_Request_Bolus'.\n   * @param Pause_Infusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Pause_Infusion'.\n   * @param Resume_Infusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Resume_Infusion'.\n   * @param Turn_Off method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Turn_Off'.\n   *\/\n  def check_concrete_output(Image: PCA_Types.Image => B = ImageParam => {T},\n                            AudioSignal: PCA_Types.Sound.Type => B = AudioSignalParam => {T},\n                            Alarm_Inactivation: ICE_Types.Alarm_Signal.Type => B = Alarm_InactivationParam => {T},\n                            Bolus_Duration: ISZ[ICE_Types.Minute_imp] => B = Bolus_DurationParam => {T},\n                            CP_Reset_Alarm: Z => B = CP_Reset_AlarmParam => {T},\n                            Confirm_Soft_Limit_Exception: Z => B = Confirm_Soft_Limit_ExceptionParam => {T},\n                            Reject_Soft_Limit_Exception: Z => B = Reject_Soft_Limit_ExceptionParam => {T},\n                            Stop_Button_Pressed: Z => B = Stop_Button_PressedParam => {T},\n                            Start_Button_Pressed: Z => B = Start_Button_PressedParam => {T},\n                            Clinician_Request_Bolus: Z => B = Clinician_Request_BolusParam => {T},\n                            Pause_Infusion: Z => B = Pause_InfusionParam => {T},\n                            Resume_Infusion: Z => B = Resume_InfusionParam => {T},\n                            Turn_Off: Z => B = Turn_OffParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val ImageValue: PCA_Types.Image = get_Image().get\n    if(!Image(ImageValue)) {\n      testFailures = testFailures :+ st\"'Image' did not match expected: value of the outgoing data port is ${ImageValue}\"\n    }\n    val AudioSignalValue: PCA_Types.Sound.Type = get_AudioSignal().get\n    if(!AudioSignal(AudioSignalValue)) {\n      testFailures = testFailures :+ st\"'AudioSignal' did not match expected: value of the outgoing data port is ${AudioSignalValue}\"\n    }\n    val Alarm_InactivationValue: ICE_Types.Alarm_Signal.Type = get_Alarm_Inactivation().get\n    if(!Alarm_Inactivation(Alarm_InactivationValue)) {\n      testFailures = testFailures :+ st\"'Alarm_Inactivation' did not match expected: value of the outgoing data port is ${Alarm_InactivationValue}\"\n    }\n    var Bolus_DurationValue: ISZ[ICE_Types.Minute_imp] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Bolus_Duration().nonEmpty) Bolus_DurationValue = Bolus_DurationValue :+ get_Bolus_Duration().get\n    if(!Bolus_Duration(Bolus_DurationValue)) {\n      testFailures = testFailures :+ st\"'Bolus_Duration' did not match expected: received ${Bolus_DurationValue.size} events with the following payloads ${Bolus_DurationValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val CP_Reset_AlarmValue: Z = if(get_CP_Reset_Alarm().nonEmpty) z\"1\" else z\"0\"\n    if(!CP_Reset_Alarm(CP_Reset_AlarmValue)) {\n      testFailures = testFailures :+ st\"'CP_Reset_Alarm' did not match expected: ${CP_Reset_AlarmValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Confirm_Soft_Limit_ExceptionValue: Z = if(get_Confirm_Soft_Limit_Exception().nonEmpty) z\"1\" else z\"0\"\n    if(!Confirm_Soft_Limit_Exception(Confirm_Soft_Limit_ExceptionValue)) {\n      testFailures = testFailures :+ st\"'Confirm_Soft_Limit_Exception' did not match expected: ${Confirm_Soft_Limit_ExceptionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Reject_Soft_Limit_ExceptionValue: Z = if(get_Reject_Soft_Limit_Exception().nonEmpty) z\"1\" else z\"0\"\n    if(!Reject_Soft_Limit_Exception(Reject_Soft_Limit_ExceptionValue)) {\n      testFailures = testFailures :+ st\"'Reject_Soft_Limit_Exception' did not match expected: ${Reject_Soft_Limit_ExceptionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Stop_Button_PressedValue: Z = if(get_Stop_Button_Pressed().nonEmpty) z\"1\" else z\"0\"\n    if(!Stop_Button_Pressed(Stop_Button_PressedValue)) {\n      testFailures = testFailures :+ st\"'Stop_Button_Pressed' did not match expected: ${Stop_Button_PressedValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Start_Button_PressedValue: Z = if(get_Start_Button_Pressed().nonEmpty) z\"1\" else z\"0\"\n    if(!Start_Button_Pressed(Start_Button_PressedValue)) {\n      testFailures = testFailures :+ st\"'Start_Button_Pressed' did not match expected: ${Start_Button_PressedValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Clinician_Request_BolusValue: Z = if(get_Clinician_Request_Bolus().nonEmpty) z\"1\" else z\"0\"\n    if(!Clinician_Request_Bolus(Clinician_Request_BolusValue)) {\n      testFailures = testFailures :+ st\"'Clinician_Request_Bolus' did not match expected: ${Clinician_Request_BolusValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Pause_InfusionValue: Z = if(get_Pause_Infusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Pause_Infusion(Pause_InfusionValue)) {\n      testFailures = testFailures :+ st\"'Pause_Infusion' did not match expected: ${Pause_InfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Resume_InfusionValue: Z = if(get_Resume_Infusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Resume_Infusion(Resume_InfusionValue)) {\n      testFailures = testFailures :+ st\"'Resume_Infusion' did not match expected: ${Resume_InfusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Turn_OffValue: Z = if(get_Turn_Off().nonEmpty) z\"1\" else z\"0\"\n    if(!Turn_Off(Turn_OffValue)) {\n      testFailures = testFailures :+ st\"'Turn_Off' did not match expected: ${Turn_OffValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Remaining_Battery_Time(value : BLESS_Types.Time): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Remaining_Battery_Time_Id, BLESS_Types.Time_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Using_Battery_Power(value : Base_Types.Boolean): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Using_Battery_Power_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Prescription(value : PCA_Types.Prescription_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Prescription_Id, PCA_Types.Prescription_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Infusion_Flow_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Infusion_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Clinician_Name(value : Base_Types.String): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Clinician_Name_Id, Base_Types.String_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Patient_Name(value : Base_Types.String): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Name_Id, Base_Types.String_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Touch(value : PCA_Types.Touch): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Touch_Id, PCA_Types.Touch_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Alarm(value : PCA_Types.Alarm_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Alarm_Id, PCA_Types.Alarm_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Warning(value : PCA_Types.Warning_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Warning_Id, PCA_Types.Warning_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_System_Status(value : PCA_Types.Status_Type.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.System_Status_Id, PCA_Types.Status_Type_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Display_Message(value : PCA_Types.Message.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Display_Message_Id, PCA_Types.Message_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Sound_Type(value : PCA_Types.Sound.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Sound_Type_Id, PCA_Types.Sound_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Low_Battery_Warning(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Low_Battery_Warning_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Hard_Limit_Violated(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Hard_Limit_Violated_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Soft_Limit_Warning(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Soft_Limit_Warning_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Request_Not_Too_Soon(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Request_Not_Too_Soon_Id, Empty())\n  }\n\n  \/\/ setter for in EventPort\n  def put_Patient_Request_Too_Soon(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Patient_Request_Too_Soon_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_Image(): Option[PCA_Types.Image] = {\n    val value: Option[PCA_Types.Image] = get_Image_payload() match {\n      case Some(PCA_Types.Image_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Image.  Expecting 'PCA_Types.Image_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Image]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Image_payload(): Option[PCA_Types.Image_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Image_Id).asInstanceOf[Option[PCA_Types.Image_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_AudioSignal(): Option[PCA_Types.Sound.Type] = {\n    val value: Option[PCA_Types.Sound.Type] = get_AudioSignal_payload() match {\n      case Some(PCA_Types.Sound_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AudioSignal.  Expecting 'PCA_Types.Sound_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Sound.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_AudioSignal_payload(): Option[PCA_Types.Sound_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AudioSignal_Id).asInstanceOf[Option[PCA_Types.Sound_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Alarm_Inactivation(): Option[ICE_Types.Alarm_Signal.Type] = {\n    val value: Option[ICE_Types.Alarm_Signal.Type] = get_Alarm_Inactivation_payload() match {\n      case Some(ICE_Types.Alarm_Signal_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Alarm_Inactivation.  Expecting 'ICE_Types.Alarm_Signal_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Alarm_Signal.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Alarm_Inactivation_payload(): Option[ICE_Types.Alarm_Signal_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Alarm_Inactivation_Id).asInstanceOf[Option[ICE_Types.Alarm_Signal_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Bolus_Duration(): Option[ICE_Types.Minute_imp] = {\n    val value: Option[ICE_Types.Minute_imp] = get_Bolus_Duration_payload() match {\n      case Some(ICE_Types.Minute_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Bolus_Duration.  Expecting 'ICE_Types.Minute_imp_Payload' but received ${v}\")\n      case _ => None[ICE_Types.Minute_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Bolus_Duration_payload(): Option[ICE_Types.Minute_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Bolus_Duration_Id).asInstanceOf[Option[ICE_Types.Minute_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_CP_Reset_Alarm(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_CP_Reset_Alarm_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port CP_Reset_Alarm.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_CP_Reset_Alarm_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.CP_Reset_Alarm_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Confirm_Soft_Limit_Exception(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Confirm_Soft_Limit_Exception_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Confirm_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Confirm_Soft_Limit_Exception_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Confirm_Soft_Limit_Exception_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Reject_Soft_Limit_Exception(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Reject_Soft_Limit_Exception_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Reject_Soft_Limit_Exception.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Reject_Soft_Limit_Exception_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Reject_Soft_Limit_Exception_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Stop_Button_Pressed(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Stop_Button_Pressed_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Stop_Button_Pressed.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Stop_Button_Pressed_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Stop_Button_Pressed_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Start_Button_Pressed(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Start_Button_Pressed_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Start_Button_Pressed.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Start_Button_Pressed_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Start_Button_Pressed_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Clinician_Request_Bolus(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Clinician_Request_Bolus_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Clinician_Request_Bolus.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Clinician_Request_Bolus_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Clinician_Request_Bolus_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Pause_Infusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Pause_Infusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Pause_Infusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Pause_Infusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Pause_Infusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Resume_Infusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Resume_Infusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Resume_Infusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Resume_Infusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Resume_Infusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Turn_Off(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Turn_Off_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Turn_Off.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Turn_Off_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Turn_Off_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Control_Panel._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Test extends ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Control_Panel.{ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Image: Port[PCA_Types.Image],\n  AudioSignal: Port[PCA_Types.Sound.Type],\n  Alarm_Inactivation: Port[ICE_Types.Alarm_Signal.Type],\n  Remaining_Battery_Time: Port[BLESS_Types.Time],\n  Using_Battery_Power: Port[Base_Types.Boolean],\n  Prescription: Port[PCA_Types.Prescription_imp],\n  Infusion_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Clinician_Name: Port[Base_Types.String],\n  Patient_Name: Port[Base_Types.String],\n  Touch: Port[PCA_Types.Touch],\n  Alarm: Port[PCA_Types.Alarm_Type.Type],\n  Warning: Port[PCA_Types.Warning_Type.Type],\n  System_Status: Port[PCA_Types.Status_Type.Type],\n  Display_Message: Port[PCA_Types.Message.Type],\n  Sound_Type: Port[PCA_Types.Sound.Type],\n  Bolus_Duration: Port[ICE_Types.Minute_imp],\n  CP_Reset_Alarm: Port[art.Empty],\n  Low_Battery_Warning: Port[art.Empty],\n  Hard_Limit_Violated: Port[art.Empty],\n  Soft_Limit_Warning: Port[art.Empty],\n  Confirm_Soft_Limit_Exception: Port[art.Empty],\n  Reject_Soft_Limit_Exception: Port[art.Empty],\n  Stop_Button_Pressed: Port[art.Empty],\n  Start_Button_Pressed: Port[art.Empty],\n  Clinician_Request_Bolus: Port[art.Empty],\n  Pause_Infusion: Port[art.Empty],\n  Resume_Infusion: Port[art.Empty],\n  Turn_Off: Port[art.Empty],\n  Patient_Request_Not_Too_Soon: Port[art.Empty],\n  Patient_Request_Too_Soon: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Image,\n              AudioSignal,\n              Alarm_Inactivation,\n              Remaining_Battery_Time,\n              Using_Battery_Power,\n              Prescription,\n              Infusion_Flow_Rate,\n              Clinician_Name,\n              Patient_Name,\n              Touch,\n              Alarm,\n              Warning,\n              System_Status,\n              Display_Message,\n              Sound_Type,\n              Bolus_Duration,\n              CP_Reset_Alarm,\n              Low_Battery_Warning,\n              Hard_Limit_Violated,\n              Soft_Limit_Warning,\n              Confirm_Soft_Limit_Exception,\n              Reject_Soft_Limit_Exception,\n              Stop_Button_Pressed,\n              Start_Button_Pressed,\n              Clinician_Request_Bolus,\n              Pause_Infusion,\n              Resume_Infusion,\n              Turn_Off,\n              Patient_Request_Not_Too_Soon,\n              Patient_Request_Too_Soon),\n\n    dataIns = ISZ(Remaining_Battery_Time,\n                  Using_Battery_Power,\n                  Prescription,\n                  Infusion_Flow_Rate,\n                  Clinician_Name,\n                  Patient_Name),\n\n    dataOuts = ISZ(Image,\n                   AudioSignal,\n                   Alarm_Inactivation),\n\n    eventIns = ISZ(Touch,\n                   Alarm,\n                   Warning,\n                   System_Status,\n                   Display_Message,\n                   Sound_Type,\n                   Low_Battery_Warning,\n                   Hard_Limit_Violated,\n                   Soft_Limit_Warning,\n                   Patient_Request_Not_Too_Soon,\n                   Patient_Request_Too_Soon),\n\n    eventOuts = ISZ(Bolus_Duration,\n                    CP_Reset_Alarm,\n                    Confirm_Soft_Limit_Exception,\n                    Reject_Soft_Limit_Exception,\n                    Stop_Button_Pressed,\n                    Start_Button_Pressed,\n                    Clinician_Request_Bolus,\n                    Pause_Infusion,\n                    Resume_Infusion,\n                    Turn_Off)\n  )\n\n  val initialization_api : ui_thread_imp_Initialization_Api = {\n    val api = ui_thread_imp_Initialization_Api(\n      id,\n      Image.id,\n      AudioSignal.id,\n      Alarm_Inactivation.id,\n      Remaining_Battery_Time.id,\n      Using_Battery_Power.id,\n      Prescription.id,\n      Infusion_Flow_Rate.id,\n      Clinician_Name.id,\n      Patient_Name.id,\n      Touch.id,\n      Alarm.id,\n      Warning.id,\n      System_Status.id,\n      Display_Message.id,\n      Sound_Type.id,\n      Bolus_Duration.id,\n      CP_Reset_Alarm.id,\n      Low_Battery_Warning.id,\n      Hard_Limit_Violated.id,\n      Soft_Limit_Warning.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Clinician_Request_Bolus.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      Turn_Off.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id\n    )\n    ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : ui_thread_imp_Operational_Api = {\n    val api = ui_thread_imp_Operational_Api(\n      id,\n      Image.id,\n      AudioSignal.id,\n      Alarm_Inactivation.id,\n      Remaining_Battery_Time.id,\n      Using_Battery_Power.id,\n      Prescription.id,\n      Infusion_Flow_Rate.id,\n      Clinician_Name.id,\n      Patient_Name.id,\n      Touch.id,\n      Alarm.id,\n      Warning.id,\n      System_Status.id,\n      Display_Message.id,\n      Sound_Type.id,\n      Bolus_Duration.id,\n      CP_Reset_Alarm.id,\n      Low_Battery_Warning.id,\n      Hard_Limit_Violated.id,\n      Soft_Limit_Warning.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Clinician_Request_Bolus.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      Turn_Off.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id\n    )\n    ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge.EntryPoints(\n      id,\n\n      Image.id,\n      AudioSignal.id,\n      Alarm_Inactivation.id,\n      Remaining_Battery_Time.id,\n      Using_Battery_Power.id,\n      Prescription.id,\n      Infusion_Flow_Rate.id,\n      Clinician_Name.id,\n      Patient_Name.id,\n      Touch.id,\n      Alarm.id,\n      Warning.id,\n      System_Status.id,\n      Display_Message.id,\n      Sound_Type.id,\n      Bolus_Duration.id,\n      CP_Reset_Alarm.id,\n      Low_Battery_Warning.id,\n      Hard_Limit_Violated.id,\n      Soft_Limit_Warning.id,\n      Confirm_Soft_Limit_Exception.id,\n      Reject_Soft_Limit_Exception.id,\n      Stop_Button_Pressed.id,\n      Start_Button_Pressed.id,\n      Clinician_Request_Bolus.id,\n      Pause_Infusion.id,\n      Resume_Infusion.id,\n      Turn_Off.id,\n      Patient_Request_Not_Too_Soon.id,\n      Patient_Request_Too_Soon.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_Bridge {\n\n  var c_initialization_api: Option[ui_thread_imp_Initialization_Api] = None()\n  var c_operational_api: Option[ui_thread_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_BridgeId : Art.BridgeId,\n\n    Image_Id : Art.PortId,\n    AudioSignal_Id : Art.PortId,\n    Alarm_Inactivation_Id : Art.PortId,\n    Remaining_Battery_Time_Id : Art.PortId,\n    Using_Battery_Power_Id : Art.PortId,\n    Prescription_Id : Art.PortId,\n    Infusion_Flow_Rate_Id : Art.PortId,\n    Clinician_Name_Id : Art.PortId,\n    Patient_Name_Id : Art.PortId,\n    Touch_Id : Art.PortId,\n    Alarm_Id : Art.PortId,\n    Warning_Id : Art.PortId,\n    System_Status_Id : Art.PortId,\n    Display_Message_Id : Art.PortId,\n    Sound_Type_Id : Art.PortId,\n    Bolus_Duration_Id : Art.PortId,\n    CP_Reset_Alarm_Id : Art.PortId,\n    Low_Battery_Warning_Id : Art.PortId,\n    Hard_Limit_Violated_Id : Art.PortId,\n    Soft_Limit_Warning_Id : Art.PortId,\n    Confirm_Soft_Limit_Exception_Id : Art.PortId,\n    Reject_Soft_Limit_Exception_Id : Art.PortId,\n    Stop_Button_Pressed_Id : Art.PortId,\n    Start_Button_Pressed_Id : Art.PortId,\n    Clinician_Request_Bolus_Id : Art.PortId,\n    Pause_Infusion_Id : Art.PortId,\n    Resume_Infusion_Id : Art.PortId,\n    Turn_Off_Id : Art.PortId,\n    Patient_Request_Not_Too_Soon_Id : Art.PortId,\n    Patient_Request_Too_Soon_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: ui_thread_imp_Initialization_Api,\n    operational_api: ui_thread_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Remaining_Battery_Time_Id,\n                                             Using_Battery_Power_Id,\n                                             Prescription_Id,\n                                             Infusion_Flow_Rate_Id,\n                                             Clinician_Name_Id,\n                                             Patient_Name_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Touch_Id,\n                                              Alarm_Id,\n                                              Warning_Id,\n                                              System_Status_Id,\n                                              Display_Message_Id,\n                                              Sound_Type_Id,\n                                              Low_Battery_Warning_Id,\n                                              Hard_Limit_Violated_Id,\n                                              Soft_Limit_Warning_Id,\n                                              Patient_Request_Not_Too_Soon_Id,\n                                              Patient_Request_Too_Soon_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Image_Id,\n                                              AudioSignal_Id,\n                                              Alarm_Inactivation_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Bolus_Duration_Id,\n                                               CP_Reset_Alarm_Id,\n                                               Confirm_Soft_Limit_Exception_Id,\n                                               Reject_Soft_Limit_Exception_Id,\n                                               Stop_Button_Pressed_Id,\n                                               Start_Button_Pressed_Id,\n                                               Clinician_Request_Bolus_Id,\n                                               Pause_Infusion_Id,\n                                               Resume_Infusion_Id,\n                                               Turn_Off_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Touch_Id){\n          val Some(PCA_Types.Touch_Payload(value)) = Art.getValue(Touch_Id)\n\n          \/\/ implement the following in 'component':  def handle_Touch(api: ui_thread_imp_Operational_Api, value: PCA_Types.Touch): Unit = {}\n          component.handle_Touch(operational_api, value)\n        }\n        else if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: ui_thread_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: ui_thread_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == System_Status_Id){\n          val Some(PCA_Types.Status_Type_Payload(value)) = Art.getValue(System_Status_Id)\n\n          \/\/ implement the following in 'component':  def handle_System_Status(api: ui_thread_imp_Operational_Api, value: PCA_Types.Status_Type.Type): Unit = {}\n          component.handle_System_Status(operational_api, value)\n        }\n        else if(portId == Display_Message_Id){\n          val Some(PCA_Types.Message_Payload(value)) = Art.getValue(Display_Message_Id)\n\n          \/\/ implement the following in 'component':  def handle_Display_Message(api: ui_thread_imp_Operational_Api, value: PCA_Types.Message.Type): Unit = {}\n          component.handle_Display_Message(operational_api, value)\n        }\n        else if(portId == Sound_Type_Id){\n          val Some(PCA_Types.Sound_Payload(value)) = Art.getValue(Sound_Type_Id)\n\n          \/\/ implement the following in 'component':  def handle_Sound_Type(api: ui_thread_imp_Operational_Api, value: PCA_Types.Sound.Type): Unit = {}\n          component.handle_Sound_Type(operational_api, value)\n        }\n        else if(portId == Low_Battery_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Battery_Warning(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Battery_Warning(operational_api)\n        }\n        else if(portId == Hard_Limit_Violated_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violated(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violated(operational_api)\n        }\n        else if(portId == Soft_Limit_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Soft_Limit_Warning(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Soft_Limit_Warning(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Patient_Request_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Too_Soon(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Touch_Id){\n          val Some(PCA_Types.Touch_Payload(value)) = Art.getValue(Touch_Id)\n\n          \/\/ implement the following in 'component':  def handle_Touch(api: ui_thread_imp_Operational_Api, value: PCA_Types.Touch): Unit = {}\n          component.handle_Touch(operational_api, value)\n        }\n        else if(portId == Alarm_Id){\n          val Some(PCA_Types.Alarm_Type_Payload(value)) = Art.getValue(Alarm_Id)\n\n          \/\/ implement the following in 'component':  def handle_Alarm(api: ui_thread_imp_Operational_Api, value: PCA_Types.Alarm_Type.Type): Unit = {}\n          component.handle_Alarm(operational_api, value)\n        }\n        else if(portId == Warning_Id){\n          val Some(PCA_Types.Warning_Type_Payload(value)) = Art.getValue(Warning_Id)\n\n          \/\/ implement the following in 'component':  def handle_Warning(api: ui_thread_imp_Operational_Api, value: PCA_Types.Warning_Type.Type): Unit = {}\n          component.handle_Warning(operational_api, value)\n        }\n        else if(portId == System_Status_Id){\n          val Some(PCA_Types.Status_Type_Payload(value)) = Art.getValue(System_Status_Id)\n\n          \/\/ implement the following in 'component':  def handle_System_Status(api: ui_thread_imp_Operational_Api, value: PCA_Types.Status_Type.Type): Unit = {}\n          component.handle_System_Status(operational_api, value)\n        }\n        else if(portId == Display_Message_Id){\n          val Some(PCA_Types.Message_Payload(value)) = Art.getValue(Display_Message_Id)\n\n          \/\/ implement the following in 'component':  def handle_Display_Message(api: ui_thread_imp_Operational_Api, value: PCA_Types.Message.Type): Unit = {}\n          component.handle_Display_Message(operational_api, value)\n        }\n        else if(portId == Sound_Type_Id){\n          val Some(PCA_Types.Sound_Payload(value)) = Art.getValue(Sound_Type_Id)\n\n          \/\/ implement the following in 'component':  def handle_Sound_Type(api: ui_thread_imp_Operational_Api, value: PCA_Types.Sound.Type): Unit = {}\n          component.handle_Sound_Type(operational_api, value)\n        }\n        else if(portId == Low_Battery_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Low_Battery_Warning(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Low_Battery_Warning(operational_api)\n        }\n        else if(portId == Hard_Limit_Violated_Id) {\n          \/\/ implement the following in 'component':  def handle_Hard_Limit_Violated(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Hard_Limit_Violated(operational_api)\n        }\n        else if(portId == Soft_Limit_Warning_Id) {\n          \/\/ implement the following in 'component':  def handle_Soft_Limit_Warning(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Soft_Limit_Warning(operational_api)\n        }\n        else if(portId == Patient_Request_Not_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Not_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Not_Too_Soon(operational_api)\n        }\n        else if(portId == Patient_Request_Too_Soon_Id) {\n          \/\/ implement the following in 'component':  def handle_Patient_Request_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {}\n          component.handle_Patient_Request_Too_Soon(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: ui_thread_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: ui_thread_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: ui_thread_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: ui_thread_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: ui_thread_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Control_Panel\/ui_thread_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait ui_thread_imp_Api {\n  def id: Art.BridgeId\n  def Image_Id : Art.PortId\n  def AudioSignal_Id : Art.PortId\n  def Alarm_Inactivation_Id : Art.PortId\n  def Remaining_Battery_Time_Id : Art.PortId\n  def Using_Battery_Power_Id : Art.PortId\n  def Prescription_Id : Art.PortId\n  def Infusion_Flow_Rate_Id : Art.PortId\n  def Clinician_Name_Id : Art.PortId\n  def Patient_Name_Id : Art.PortId\n  def Touch_Id : Art.PortId\n  def Alarm_Id : Art.PortId\n  def Warning_Id : Art.PortId\n  def System_Status_Id : Art.PortId\n  def Display_Message_Id : Art.PortId\n  def Sound_Type_Id : Art.PortId\n  def Bolus_Duration_Id : Art.PortId\n  def CP_Reset_Alarm_Id : Art.PortId\n  def Low_Battery_Warning_Id : Art.PortId\n  def Hard_Limit_Violated_Id : Art.PortId\n  def Soft_Limit_Warning_Id : Art.PortId\n  def Confirm_Soft_Limit_Exception_Id : Art.PortId\n  def Reject_Soft_Limit_Exception_Id : Art.PortId\n  def Stop_Button_Pressed_Id : Art.PortId\n  def Start_Button_Pressed_Id : Art.PortId\n  def Clinician_Request_Bolus_Id : Art.PortId\n  def Pause_Infusion_Id : Art.PortId\n  def Resume_Infusion_Id : Art.PortId\n  def Turn_Off_Id : Art.PortId\n  def Patient_Request_Not_Too_Soon_Id : Art.PortId\n  def Patient_Request_Too_Soon_Id : Art.PortId\n\n  def put_Image(value : PCA_Types.Image) : Unit = {\n    Art.putValue(Image_Id, PCA_Types.Image_Payload(value))\n  }\n\n  def put_AudioSignal(value : PCA_Types.Sound.Type) : Unit = {\n    Art.putValue(AudioSignal_Id, PCA_Types.Sound_Payload(value))\n  }\n\n  def put_Alarm_Inactivation(value : ICE_Types.Alarm_Signal.Type) : Unit = {\n    Art.putValue(Alarm_Inactivation_Id, ICE_Types.Alarm_Signal_Payload(value))\n  }\n\n  def put_Bolus_Duration(value : ICE_Types.Minute_imp) : Unit = {\n    Art.putValue(Bolus_Duration_Id, ICE_Types.Minute_imp_Payload(value))\n  }\n\n  def put_CP_Reset_Alarm() : Unit = {\n    Art.putValue(CP_Reset_Alarm_Id, art.Empty())\n  }\n\n  def put_Confirm_Soft_Limit_Exception() : Unit = {\n    Art.putValue(Confirm_Soft_Limit_Exception_Id, art.Empty())\n  }\n\n  def put_Reject_Soft_Limit_Exception() : Unit = {\n    Art.putValue(Reject_Soft_Limit_Exception_Id, art.Empty())\n  }\n\n  def put_Stop_Button_Pressed() : Unit = {\n    Art.putValue(Stop_Button_Pressed_Id, art.Empty())\n  }\n\n  def put_Start_Button_Pressed() : Unit = {\n    Art.putValue(Start_Button_Pressed_Id, art.Empty())\n  }\n\n  def put_Clinician_Request_Bolus() : Unit = {\n    Art.putValue(Clinician_Request_Bolus_Id, art.Empty())\n  }\n\n  def put_Pause_Infusion() : Unit = {\n    Art.putValue(Pause_Infusion_Id, art.Empty())\n  }\n\n  def put_Resume_Infusion() : Unit = {\n    Art.putValue(Resume_Infusion_Id, art.Empty())\n  }\n\n  def put_Turn_Off() : Unit = {\n    Art.putValue(Turn_Off_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class ui_thread_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Image_Id : Art.PortId,\n  val AudioSignal_Id : Art.PortId,\n  val Alarm_Inactivation_Id : Art.PortId,\n  val Remaining_Battery_Time_Id : Art.PortId,\n  val Using_Battery_Power_Id : Art.PortId,\n  val Prescription_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Clinician_Name_Id : Art.PortId,\n  val Patient_Name_Id : Art.PortId,\n  val Touch_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val System_Status_Id : Art.PortId,\n  val Display_Message_Id : Art.PortId,\n  val Sound_Type_Id : Art.PortId,\n  val Bolus_Duration_Id : Art.PortId,\n  val CP_Reset_Alarm_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId,\n  val Soft_Limit_Warning_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Stop_Button_Pressed_Id : Art.PortId,\n  val Start_Button_Pressed_Id : Art.PortId,\n  val Clinician_Request_Bolus_Id : Art.PortId,\n  val Pause_Infusion_Id : Art.PortId,\n  val Resume_Infusion_Id : Art.PortId,\n  val Turn_Off_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId) extends ui_thread_imp_Api\n\n@datatype class ui_thread_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Image_Id : Art.PortId,\n  val AudioSignal_Id : Art.PortId,\n  val Alarm_Inactivation_Id : Art.PortId,\n  val Remaining_Battery_Time_Id : Art.PortId,\n  val Using_Battery_Power_Id : Art.PortId,\n  val Prescription_Id : Art.PortId,\n  val Infusion_Flow_Rate_Id : Art.PortId,\n  val Clinician_Name_Id : Art.PortId,\n  val Patient_Name_Id : Art.PortId,\n  val Touch_Id : Art.PortId,\n  val Alarm_Id : Art.PortId,\n  val Warning_Id : Art.PortId,\n  val System_Status_Id : Art.PortId,\n  val Display_Message_Id : Art.PortId,\n  val Sound_Type_Id : Art.PortId,\n  val Bolus_Duration_Id : Art.PortId,\n  val CP_Reset_Alarm_Id : Art.PortId,\n  val Low_Battery_Warning_Id : Art.PortId,\n  val Hard_Limit_Violated_Id : Art.PortId,\n  val Soft_Limit_Warning_Id : Art.PortId,\n  val Confirm_Soft_Limit_Exception_Id : Art.PortId,\n  val Reject_Soft_Limit_Exception_Id : Art.PortId,\n  val Stop_Button_Pressed_Id : Art.PortId,\n  val Start_Button_Pressed_Id : Art.PortId,\n  val Clinician_Request_Bolus_Id : Art.PortId,\n  val Pause_Infusion_Id : Art.PortId,\n  val Resume_Infusion_Id : Art.PortId,\n  val Turn_Off_Id : Art.PortId,\n  val Patient_Request_Not_Too_Soon_Id : Art.PortId,\n  val Patient_Request_Too_Soon_Id : Art.PortId) extends ui_thread_imp_Api {\n\n  def get_Remaining_Battery_Time() : Option[BLESS_Types.Time] = {\n    val value : Option[BLESS_Types.Time] = Art.getValue(Remaining_Battery_Time_Id) match {\n      case Some(BLESS_Types.Time_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Remaining_Battery_Time.  Expecting 'BLESS_Types.Time_Payload' but received ${v}\")\n        None[BLESS_Types.Time]()\n      case _ => None[BLESS_Types.Time]()\n    }\n    return value\n  }\n\n  def get_Using_Battery_Power() : Option[Base_Types.Boolean] = {\n    val value : Option[Base_Types.Boolean] = Art.getValue(Using_Battery_Power_Id) match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Using_Battery_Power.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n        None[Base_Types.Boolean]()\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  def get_Prescription() : Option[PCA_Types.Prescription_imp] = {\n    val value : Option[PCA_Types.Prescription_imp] = Art.getValue(Prescription_Id) match {\n      case Some(PCA_Types.Prescription_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Prescription.  Expecting 'PCA_Types.Prescription_imp_Payload' but received ${v}\")\n        None[PCA_Types.Prescription_imp]()\n      case _ => None[PCA_Types.Prescription_imp]()\n    }\n    return value\n  }\n\n  def get_Infusion_Flow_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Infusion_Flow_Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Infusion_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Clinician_Name() : Option[Base_Types.String] = {\n    val value : Option[Base_Types.String] = Art.getValue(Clinician_Name_Id) match {\n      case Some(Base_Types.String_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Clinician_Name.  Expecting 'Base_Types.String_Payload' but received ${v}\")\n        None[Base_Types.String]()\n      case _ => None[Base_Types.String]()\n    }\n    return value\n  }\n\n  def get_Patient_Name() : Option[Base_Types.String] = {\n    val value : Option[Base_Types.String] = Art.getValue(Patient_Name_Id) match {\n      case Some(Base_Types.String_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Name.  Expecting 'Base_Types.String_Payload' but received ${v}\")\n        None[Base_Types.String]()\n      case _ => None[Base_Types.String]()\n    }\n    return value\n  }\n\n  def get_Touch() : Option[PCA_Types.Touch] = {\n    val value : Option[PCA_Types.Touch] = Art.getValue(Touch_Id) match {\n      case Some(PCA_Types.Touch_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Touch.  Expecting 'PCA_Types.Touch_Payload' but received ${v}\")\n        None[PCA_Types.Touch]()\n      case _ => None[PCA_Types.Touch]()\n    }\n    return value\n  }\n\n  def get_Alarm() : Option[PCA_Types.Alarm_Type.Type] = {\n    val value : Option[PCA_Types.Alarm_Type.Type] = Art.getValue(Alarm_Id) match {\n      case Some(PCA_Types.Alarm_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Alarm.  Expecting 'PCA_Types.Alarm_Type_Payload' but received ${v}\")\n        None[PCA_Types.Alarm_Type.Type]()\n      case _ => None[PCA_Types.Alarm_Type.Type]()\n    }\n    return value\n  }\n\n  def get_Warning() : Option[PCA_Types.Warning_Type.Type] = {\n    val value : Option[PCA_Types.Warning_Type.Type] = Art.getValue(Warning_Id) match {\n      case Some(PCA_Types.Warning_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Warning.  Expecting 'PCA_Types.Warning_Type_Payload' but received ${v}\")\n        None[PCA_Types.Warning_Type.Type]()\n      case _ => None[PCA_Types.Warning_Type.Type]()\n    }\n    return value\n  }\n\n  def get_System_Status() : Option[PCA_Types.Status_Type.Type] = {\n    val value : Option[PCA_Types.Status_Type.Type] = Art.getValue(System_Status_Id) match {\n      case Some(PCA_Types.Status_Type_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port System_Status.  Expecting 'PCA_Types.Status_Type_Payload' but received ${v}\")\n        None[PCA_Types.Status_Type.Type]()\n      case _ => None[PCA_Types.Status_Type.Type]()\n    }\n    return value\n  }\n\n  def get_Display_Message() : Option[PCA_Types.Message.Type] = {\n    val value : Option[PCA_Types.Message.Type] = Art.getValue(Display_Message_Id) match {\n      case Some(PCA_Types.Message_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Display_Message.  Expecting 'PCA_Types.Message_Payload' but received ${v}\")\n        None[PCA_Types.Message.Type]()\n      case _ => None[PCA_Types.Message.Type]()\n    }\n    return value\n  }\n\n  def get_Sound_Type() : Option[PCA_Types.Sound.Type] = {\n    val value : Option[PCA_Types.Sound.Type] = Art.getValue(Sound_Type_Id) match {\n      case Some(PCA_Types.Sound_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Sound_Type.  Expecting 'PCA_Types.Sound_Payload' but received ${v}\")\n        None[PCA_Types.Sound.Type]()\n      case _ => None[PCA_Types.Sound.Type]()\n    }\n    return value\n  }\n\n  def get_Low_Battery_Warning() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Low_Battery_Warning_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Low_Battery_Warning.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Hard_Limit_Violated() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Hard_Limit_Violated_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Hard_Limit_Violated.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Soft_Limit_Warning() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Soft_Limit_Warning_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Soft_Limit_Warning.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Patient_Request_Not_Too_Soon() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Request_Not_Too_Soon_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Request_Not_Too_Soon.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  def get_Patient_Request_Too_Soon() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Patient_Request_Too_Soon_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Patient_Request_Too_Soon.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Control_Panel\/ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Control_Panel\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject ui_thread_imp_pump_operation_control_panel_ui_process_ui_thread {\n\n  def initialise(api: ui_thread_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Image(PCA_Types.Image.example())\n    api.put_AudioSignal(PCA_Types.Sound.byOrdinal(0).get)\n    api.put_Alarm_Inactivation(ICE_Types.Alarm_Signal.byOrdinal(0).get)\n    api.put_Bolus_Duration(ICE_Types.Minute_imp.example())\n    api.put_CP_Reset_Alarm()\n    api.put_Confirm_Soft_Limit_Exception()\n    api.put_Reject_Soft_Limit_Exception()\n    api.put_Stop_Button_Pressed()\n    api.put_Start_Button_Pressed()\n    api.put_Clinician_Request_Bolus()\n    api.put_Pause_Infusion()\n    api.put_Resume_Infusion()\n    api.put_Turn_Off()\n  }\n\n  def handle_Touch(api: ui_thread_imp_Operational_Api, value : PCA_Types.Touch): Unit = {\n    api.logInfo(\"example handle_Touch implementation\")\n    api.logInfo(s\"received ${value}\")\n    \/\/ example api usage\n\n    val apiUsage_Remaining_Battery_Time: Option[BLESS_Types.Time] = api.get_Remaining_Battery_Time()\n    api.logInfo(s\"Received on Remaining_Battery_Time: ${apiUsage_Remaining_Battery_Time}\")\n    val apiUsage_Using_Battery_Power: Option[Base_Types.Boolean] = api.get_Using_Battery_Power()\n    api.logInfo(s\"Received on Using_Battery_Power: ${apiUsage_Using_Battery_Power}\")\n    val apiUsage_Prescription: Option[PCA_Types.Prescription_imp] = api.get_Prescription()\n    api.logInfo(s\"Received on Prescription: ${apiUsage_Prescription}\")\n    val apiUsage_Infusion_Flow_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Infusion_Flow_Rate()\n    api.logInfo(s\"Received on Infusion_Flow_Rate: ${apiUsage_Infusion_Flow_Rate}\")\n    val apiUsage_Clinician_Name: Option[Base_Types.String] = api.get_Clinician_Name()\n    api.logInfo(s\"Received on Clinician_Name: ${apiUsage_Clinician_Name}\")\n    val apiUsage_Patient_Name: Option[Base_Types.String] = api.get_Patient_Name()\n    api.logInfo(s\"Received on Patient_Name: ${apiUsage_Patient_Name}\")\n    val apiUsage_Touch: Option[PCA_Types.Touch] = api.get_Touch()\n    api.logInfo(s\"Received on Touch: ${apiUsage_Touch}\")\n    val apiUsage_Alarm: Option[PCA_Types.Alarm_Type.Type] = api.get_Alarm()\n    api.logInfo(s\"Received on Alarm: ${apiUsage_Alarm}\")\n    val apiUsage_Warning: Option[PCA_Types.Warning_Type.Type] = api.get_Warning()\n    api.logInfo(s\"Received on Warning: ${apiUsage_Warning}\")\n    val apiUsage_System_Status: Option[PCA_Types.Status_Type.Type] = api.get_System_Status()\n    api.logInfo(s\"Received on System_Status: ${apiUsage_System_Status}\")\n    val apiUsage_Display_Message: Option[PCA_Types.Message.Type] = api.get_Display_Message()\n    api.logInfo(s\"Received on Display_Message: ${apiUsage_Display_Message}\")\n    val apiUsage_Sound_Type: Option[PCA_Types.Sound.Type] = api.get_Sound_Type()\n    api.logInfo(s\"Received on Sound_Type: ${apiUsage_Sound_Type}\")\n    val apiUsage_Low_Battery_Warning: Option[art.Empty] = api.get_Low_Battery_Warning()\n    api.logInfo(s\"Received on Low_Battery_Warning: ${apiUsage_Low_Battery_Warning}\")\n    val apiUsage_Hard_Limit_Violated: Option[art.Empty] = api.get_Hard_Limit_Violated()\n    api.logInfo(s\"Received on Hard_Limit_Violated: ${apiUsage_Hard_Limit_Violated}\")\n    val apiUsage_Soft_Limit_Warning: Option[art.Empty] = api.get_Soft_Limit_Warning()\n    api.logInfo(s\"Received on Soft_Limit_Warning: ${apiUsage_Soft_Limit_Warning}\")\n    val apiUsage_Patient_Request_Not_Too_Soon: Option[art.Empty] = api.get_Patient_Request_Not_Too_Soon()\n    api.logInfo(s\"Received on Patient_Request_Not_Too_Soon: ${apiUsage_Patient_Request_Not_Too_Soon}\")\n    val apiUsage_Patient_Request_Too_Soon: Option[art.Empty] = api.get_Patient_Request_Too_Soon()\n    api.logInfo(s\"Received on Patient_Request_Too_Soon: ${apiUsage_Patient_Request_Too_Soon}\")\n  }\n\n  def handle_Alarm(api: ui_thread_imp_Operational_Api, value : PCA_Types.Alarm_Type.Type): Unit = {\n    api.logInfo(\"example handle_Alarm implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Warning(api: ui_thread_imp_Operational_Api, value : PCA_Types.Warning_Type.Type): Unit = {\n    api.logInfo(\"example handle_Warning implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_System_Status(api: ui_thread_imp_Operational_Api, value : PCA_Types.Status_Type.Type): Unit = {\n    api.logInfo(\"example handle_System_Status implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Display_Message(api: ui_thread_imp_Operational_Api, value : PCA_Types.Message.Type): Unit = {\n    api.logInfo(\"example handle_Display_Message implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Sound_Type(api: ui_thread_imp_Operational_Api, value : PCA_Types.Sound.Type): Unit = {\n    api.logInfo(\"example handle_Sound_Type implementation\")\n    api.logInfo(s\"received ${value}\")\n  }\n\n  def handle_Low_Battery_Warning(api: ui_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Low_Battery_Warning implementation\")\n    api.logInfo(\"received Low_Battery_Warning event\")\n  }\n\n  def handle_Hard_Limit_Violated(api: ui_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Hard_Limit_Violated implementation\")\n    api.logInfo(\"received Hard_Limit_Violated event\")\n  }\n\n  def handle_Soft_Limit_Warning(api: ui_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Soft_Limit_Warning implementation\")\n    api.logInfo(\"received Soft_Limit_Warning event\")\n  }\n\n  def handle_Patient_Request_Not_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Request_Not_Too_Soon implementation\")\n    api.logInfo(\"received Patient_Request_Not_Too_Soon event\")\n  }\n\n  def handle_Patient_Request_Too_Soon(api: ui_thread_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Patient_Request_Too_Soon implementation\")\n    api.logInfo(\"received Patient_Request_Too_Soon event\")\n  }\n\n  def activate(api: ui_thread_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: ui_thread_imp_Operational_Api): Unit = { }\n\n  def finalise(api: ui_thread_imp_Operational_Api): Unit = { }\n\n  def recover(api: ui_thread_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/pump_imp_pump_fluid_mech_pump_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class pump_imp_pump_fluid_mech_pump_TestApi extends BridgeTestSuite[pump_imp_pump_fluid_mech_pump_Bridge](Arch.wrap_pca_imp_Instance_pump_fluid_mech_pump) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Drug_Intake payload for data port Drug_Intake\n   * @param Rate payload for data port Rate\n   * @param Halt the number of events to place in the Halt event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(Drug_Intake : Physical_Types.Fluid_Flow_imp,\n                          Rate : PCA_Types.Flow_Rate_imp,\n                          Halt : Z): Unit = {\n    put_Drug_Intake(Drug_Intake)\n    put_Rate(Rate)\n    for(i <- 0 until Halt) {\n      put_Halt()\n    }\n  }\n\n\n  \/** helper function to check pump_imp_pump_fluid_mech_pump's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Drug_Outlet method that will be called with the value of the outgoing data\n   *        port 'Drug_Outlet'.\n   * @param Pump_Too_Hot method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Pump_Too_Hot'.\n   *\/\n  def check_concrete_output(Drug_Outlet: Physical_Types.Fluid_Flow_imp => B = Drug_OutletParam => {T},\n                            Pump_Too_Hot: Z => B = Pump_Too_HotParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Drug_OutletValue: Physical_Types.Fluid_Flow_imp = get_Drug_Outlet().get\n    if(!Drug_Outlet(Drug_OutletValue)) {\n      testFailures = testFailures :+ st\"'Drug_Outlet' did not match expected: value of the outgoing data port is ${Drug_OutletValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Pump_Too_HotValue: Z = if(get_Pump_Too_Hot().nonEmpty) z\"1\" else z\"0\"\n    if(!Pump_Too_Hot(Pump_Too_HotValue)) {\n      testFailures = testFailures :+ st\"'Pump_Too_Hot' did not match expected: ${Pump_Too_HotValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Drug_Intake(value : Physical_Types.Fluid_Flow_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Intake_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_Rate(value : PCA_Types.Flow_Rate_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_Halt(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Halt_Id, Empty())\n  }\n\n  \/\/ getter for out DataPort\n  def get_Drug_Outlet(): Option[Physical_Types.Fluid_Flow_imp] = {\n    val value: Option[Physical_Types.Fluid_Flow_imp] = get_Drug_Outlet_payload() match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Drug_Outlet.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Drug_Outlet_payload(): Option[Physical_Types.Fluid_Flow_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Drug_Outlet_Id).asInstanceOf[Option[Physical_Types.Fluid_Flow_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Pump_Too_Hot(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Pump_Too_Hot_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Pump_Too_Hot.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Pump_Too_Hot_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Pump_Too_Hot_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/pump_imp_pump_fluid_mech_pump_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass pump_imp_pump_fluid_mech_pump_Test extends pump_imp_pump_fluid_mech_pump_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/pump_imp_pump_fluid_mech_pump_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{pump_imp_pump_fluid_mech_pump => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class pump_imp_pump_fluid_mech_pump_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Drug_Intake: Port[Physical_Types.Fluid_Flow_imp],\n  Rate: Port[PCA_Types.Flow_Rate_imp],\n  Drug_Outlet: Port[Physical_Types.Fluid_Flow_imp],\n  Halt: Port[art.Empty],\n  Pump_Too_Hot: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Drug_Intake,\n              Rate,\n              Drug_Outlet,\n              Halt,\n              Pump_Too_Hot),\n\n    dataIns = ISZ(Drug_Intake,\n                  Rate),\n\n    dataOuts = ISZ(Drug_Outlet),\n\n    eventIns = ISZ(Halt),\n\n    eventOuts = ISZ(Pump_Too_Hot)\n  )\n\n  val initialization_api : pump_imp_Initialization_Api = {\n    val api = pump_imp_Initialization_Api(\n      id,\n      Drug_Intake.id,\n      Rate.id,\n      Drug_Outlet.id,\n      Halt.id,\n      Pump_Too_Hot.id\n    )\n    pump_imp_pump_fluid_mech_pump_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : pump_imp_Operational_Api = {\n    val api = pump_imp_Operational_Api(\n      id,\n      Drug_Intake.id,\n      Rate.id,\n      Drug_Outlet.id,\n      Halt.id,\n      Pump_Too_Hot.id\n    )\n    pump_imp_pump_fluid_mech_pump_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    pump_imp_pump_fluid_mech_pump_Bridge.EntryPoints(\n      id,\n\n      Drug_Intake.id,\n      Rate.id,\n      Drug_Outlet.id,\n      Halt.id,\n      Pump_Too_Hot.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject pump_imp_pump_fluid_mech_pump_Bridge {\n\n  var c_initialization_api: Option[pump_imp_Initialization_Api] = None()\n  var c_operational_api: Option[pump_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    pump_imp_pump_fluid_mech_pump_BridgeId : Art.BridgeId,\n\n    Drug_Intake_Id : Art.PortId,\n    Rate_Id : Art.PortId,\n    Drug_Outlet_Id : Art.PortId,\n    Halt_Id : Art.PortId,\n    Pump_Too_Hot_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: pump_imp_Initialization_Api,\n    operational_api: pump_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Drug_Intake_Id,\n                                             Rate_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Halt_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Drug_Outlet_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Pump_Too_Hot_Id)\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(pump_imp_pump_fluid_mech_pump_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Halt_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt(api: pump_imp_Operational_Api): Unit = {}\n          component.handle_Halt(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(pump_imp_pump_fluid_mech_pump_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == Halt_Id) {\n          \/\/ implement the following in 'component':  def handle_Halt(api: pump_imp_Operational_Api): Unit = {}\n          component.handle_Halt(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: pump_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: pump_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: pump_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: pump_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: pump_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/pump_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait pump_imp_Api {\n  def id: Art.BridgeId\n  def Drug_Intake_Id : Art.PortId\n  def Rate_Id : Art.PortId\n  def Drug_Outlet_Id : Art.PortId\n  def Halt_Id : Art.PortId\n  def Pump_Too_Hot_Id : Art.PortId\n\n  def put_Drug_Outlet(value : Physical_Types.Fluid_Flow_imp) : Unit = {\n    Art.putValue(Drug_Outlet_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  def put_Pump_Too_Hot() : Unit = {\n    Art.putValue(Pump_Too_Hot_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class pump_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Rate_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Halt_Id : Art.PortId,\n  val Pump_Too_Hot_Id : Art.PortId) extends pump_imp_Api\n\n@datatype class pump_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Rate_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Halt_Id : Art.PortId,\n  val Pump_Too_Hot_Id : Art.PortId) extends pump_imp_Api {\n\n  def get_Drug_Intake() : Option[Physical_Types.Fluid_Flow_imp] = {\n    val value : Option[Physical_Types.Fluid_Flow_imp] = Art.getValue(Drug_Intake_Id) match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Intake.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n        None[Physical_Types.Fluid_Flow_imp]()\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n\n  def get_Rate() : Option[PCA_Types.Flow_Rate_imp] = {\n    val value : Option[PCA_Types.Flow_Rate_imp] = Art.getValue(Rate_Id) match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n        None[PCA_Types.Flow_Rate_imp]()\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  def get_Halt() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(Halt_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Halt.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/pump_imp_pump_fluid_mech_pump.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject pump_imp_pump_fluid_mech_pump {\n\n  def initialise(api: pump_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Drug_Outlet(Physical_Types.Fluid_Flow_imp.example())\n    api.put_Pump_Too_Hot()\n  }\n\n  def handle_Halt(api: pump_imp_Operational_Api): Unit = {\n    api.logInfo(\"example handle_Halt implementation\")\n    api.logInfo(\"received Halt event\")\n    \/\/ example api usage\n\n    val apiUsage_Drug_Intake: Option[Physical_Types.Fluid_Flow_imp] = api.get_Drug_Intake()\n    api.logInfo(s\"Received on Drug_Intake: ${apiUsage_Drug_Intake}\")\n    val apiUsage_Rate: Option[PCA_Types.Flow_Rate_imp] = api.get_Rate()\n    api.logInfo(s\"Received on Rate: ${apiUsage_Rate}\")\n    val apiUsage_Halt: Option[art.Empty] = api.get_Halt()\n    api.logInfo(s\"Received on Halt: ${apiUsage_Halt}\")\n  }\n\n  def activate(api: pump_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: pump_imp_Operational_Api): Unit = { }\n\n  def finalise(api: pump_imp_Operational_Api): Unit = { }\n\n  def recover(api: pump_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/upstream_monitor_imp_pump_fluid_upstream_mon_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class upstream_monitor_imp_pump_fluid_upstream_mon_TestApi extends BridgeTestSuite[upstream_monitor_imp_pump_fluid_upstream_mon_Bridge](Arch.wrap_pca_imp_Instance_pump_fluid_upstream_mon) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Drug_Intake payload for data port Drug_Intake\n   *\/\n  def put_concrete_inputs(Drug_Intake : Physical_Types.Fluid_Flow_imp): Unit = {\n    put_Drug_Intake(Drug_Intake)\n  }\n\n\n  \/** helper function to check upstream_monitor_imp_pump_fluid_upstream_mon's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Drug_Outlet method that will be called with the value of the outgoing data\n   *        port 'Drug_Outlet'.\n   * @param Upstream_Flow_Rate method that will be called with the value of the outgoing data\n   *        port 'Upstream_Flow_Rate'.\n   * @param Occlusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Occlusion'.\n   *\/\n  def check_concrete_output(Drug_Outlet: Physical_Types.Fluid_Flow_imp => B = Drug_OutletParam => {T},\n                            Upstream_Flow_Rate: PCA_Types.Flow_Rate_imp => B = Upstream_Flow_RateParam => {T},\n                            Occlusion: Z => B = OcclusionParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Drug_OutletValue: Physical_Types.Fluid_Flow_imp = get_Drug_Outlet().get\n    if(!Drug_Outlet(Drug_OutletValue)) {\n      testFailures = testFailures :+ st\"'Drug_Outlet' did not match expected: value of the outgoing data port is ${Drug_OutletValue}\"\n    }\n    val Upstream_Flow_RateValue: PCA_Types.Flow_Rate_imp = get_Upstream_Flow_Rate().get\n    if(!Upstream_Flow_Rate(Upstream_Flow_RateValue)) {\n      testFailures = testFailures :+ st\"'Upstream_Flow_Rate' did not match expected: value of the outgoing data port is ${Upstream_Flow_RateValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val OcclusionValue: Z = if(get_Occlusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Occlusion(OcclusionValue)) {\n      testFailures = testFailures :+ st\"'Occlusion' did not match expected: ${OcclusionValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Drug_Intake(value : Physical_Types.Fluid_Flow_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Intake_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_Drug_Outlet(): Option[Physical_Types.Fluid_Flow_imp] = {\n    val value: Option[Physical_Types.Fluid_Flow_imp] = get_Drug_Outlet_payload() match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Drug_Outlet.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Drug_Outlet_payload(): Option[Physical_Types.Fluid_Flow_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Drug_Outlet_Id).asInstanceOf[Option[Physical_Types.Fluid_Flow_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Upstream_Flow_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Upstream_Flow_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Upstream_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Upstream_Flow_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Upstream_Flow_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Occlusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Occlusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Occlusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Occlusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Occlusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/upstream_monitor_imp_pump_fluid_upstream_mon_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass upstream_monitor_imp_pump_fluid_upstream_mon_Test extends upstream_monitor_imp_pump_fluid_upstream_mon_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/upstream_monitor_imp_pump_fluid_upstream_mon_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{upstream_monitor_imp_pump_fluid_upstream_mon => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class upstream_monitor_imp_pump_fluid_upstream_mon_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Drug_Intake: Port[Physical_Types.Fluid_Flow_imp],\n  Drug_Outlet: Port[Physical_Types.Fluid_Flow_imp],\n  Upstream_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Occlusion: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Drug_Intake,\n              Drug_Outlet,\n              Upstream_Flow_Rate,\n              Occlusion),\n\n    dataIns = ISZ(Drug_Intake),\n\n    dataOuts = ISZ(Drug_Outlet,\n                   Upstream_Flow_Rate),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Occlusion)\n  )\n\n  val initialization_api : upstream_monitor_imp_Initialization_Api = {\n    val api = upstream_monitor_imp_Initialization_Api(\n      id,\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Upstream_Flow_Rate.id,\n      Occlusion.id\n    )\n    upstream_monitor_imp_pump_fluid_upstream_mon_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : upstream_monitor_imp_Operational_Api = {\n    val api = upstream_monitor_imp_Operational_Api(\n      id,\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Upstream_Flow_Rate.id,\n      Occlusion.id\n    )\n    upstream_monitor_imp_pump_fluid_upstream_mon_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    upstream_monitor_imp_pump_fluid_upstream_mon_Bridge.EntryPoints(\n      id,\n\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Upstream_Flow_Rate.id,\n      Occlusion.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject upstream_monitor_imp_pump_fluid_upstream_mon_Bridge {\n\n  var c_initialization_api: Option[upstream_monitor_imp_Initialization_Api] = None()\n  var c_operational_api: Option[upstream_monitor_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    upstream_monitor_imp_pump_fluid_upstream_mon_BridgeId : Art.BridgeId,\n\n    Drug_Intake_Id : Art.PortId,\n    Drug_Outlet_Id : Art.PortId,\n    Upstream_Flow_Rate_Id : Art.PortId,\n    Occlusion_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: upstream_monitor_imp_Initialization_Api,\n    operational_api: upstream_monitor_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Drug_Intake_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Drug_Outlet_Id,\n                                              Upstream_Flow_Rate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Occlusion_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: upstream_monitor_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: upstream_monitor_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/upstream_monitor_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait upstream_monitor_imp_Api {\n  def id: Art.BridgeId\n  def Drug_Intake_Id : Art.PortId\n  def Drug_Outlet_Id : Art.PortId\n  def Upstream_Flow_Rate_Id : Art.PortId\n  def Occlusion_Id : Art.PortId\n\n  def put_Drug_Outlet(value : Physical_Types.Fluid_Flow_imp) : Unit = {\n    Art.putValue(Drug_Outlet_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  def put_Upstream_Flow_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Upstream_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_Occlusion() : Unit = {\n    Art.putValue(Occlusion_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class upstream_monitor_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Upstream_Flow_Rate_Id : Art.PortId,\n  val Occlusion_Id : Art.PortId) extends upstream_monitor_imp_Api\n\n@datatype class upstream_monitor_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Upstream_Flow_Rate_Id : Art.PortId,\n  val Occlusion_Id : Art.PortId) extends upstream_monitor_imp_Api {\n\n  def get_Drug_Intake() : Option[Physical_Types.Fluid_Flow_imp] = {\n    val value : Option[Physical_Types.Fluid_Flow_imp] = Art.getValue(Drug_Intake_Id) match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Intake.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n        None[Physical_Types.Fluid_Flow_imp]()\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/upstream_monitor_imp_pump_fluid_upstream_mon.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject upstream_monitor_imp_pump_fluid_upstream_mon {\n\n  def initialise(api: upstream_monitor_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Drug_Outlet(Physical_Types.Fluid_Flow_imp.example())\n    api.put_Upstream_Flow_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_Occlusion()\n  }\n\n  def timeTriggered(api: upstream_monitor_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Drug_Intake: Option[Physical_Types.Fluid_Flow_imp] = api.get_Drug_Intake()\n    api.logInfo(s\"Received on Drug_Intake: ${apiUsage_Drug_Intake}\")\n  }\n\n  def activate(api: upstream_monitor_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: upstream_monitor_imp_Operational_Api): Unit = { }\n\n  def finalise(api: upstream_monitor_imp_Operational_Api): Unit = { }\n\n  def recover(api: upstream_monitor_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/downstream_monitor_imp_pump_fluid_downstream_mon_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class downstream_monitor_imp_pump_fluid_downstream_mon_TestApi extends BridgeTestSuite[downstream_monitor_imp_pump_fluid_downstream_mon_Bridge](Arch.wrap_pca_imp_Instance_pump_fluid_downstream_mon) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Drug_Intake payload for data port Drug_Intake\n   *\/\n  def put_concrete_inputs(Drug_Intake : Physical_Types.Fluid_Flow_imp): Unit = {\n    put_Drug_Intake(Drug_Intake)\n  }\n\n\n  \/** helper function to check downstream_monitor_imp_pump_fluid_downstream_mon's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Drug_Outlet method that will be called with the value of the outgoing data\n   *        port 'Drug_Outlet'.\n   * @param Downstream_Flow_Rate method that will be called with the value of the outgoing data\n   *        port 'Downstream_Flow_Rate'.\n   * @param Occlusion method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Occlusion'.\n   * @param Bubble method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Bubble'.\n   *\/\n  def check_concrete_output(Drug_Outlet: Physical_Types.Fluid_Flow_imp => B = Drug_OutletParam => {T},\n                            Downstream_Flow_Rate: PCA_Types.Flow_Rate_imp => B = Downstream_Flow_RateParam => {T},\n                            Occlusion: Z => B = OcclusionParam => {T},\n                            Bubble: Z => B = BubbleParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Drug_OutletValue: Physical_Types.Fluid_Flow_imp = get_Drug_Outlet().get\n    if(!Drug_Outlet(Drug_OutletValue)) {\n      testFailures = testFailures :+ st\"'Drug_Outlet' did not match expected: value of the outgoing data port is ${Drug_OutletValue}\"\n    }\n    val Downstream_Flow_RateValue: PCA_Types.Flow_Rate_imp = get_Downstream_Flow_Rate().get\n    if(!Downstream_Flow_Rate(Downstream_Flow_RateValue)) {\n      testFailures = testFailures :+ st\"'Downstream_Flow_Rate' did not match expected: value of the outgoing data port is ${Downstream_Flow_RateValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val OcclusionValue: Z = if(get_Occlusion().nonEmpty) z\"1\" else z\"0\"\n    if(!Occlusion(OcclusionValue)) {\n      testFailures = testFailures :+ st\"'Occlusion' did not match expected: ${OcclusionValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val BubbleValue: Z = if(get_Bubble().nonEmpty) z\"1\" else z\"0\"\n    if(!Bubble(BubbleValue)) {\n      testFailures = testFailures :+ st\"'Bubble' did not match expected: ${BubbleValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Drug_Intake(value : Physical_Types.Fluid_Flow_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Drug_Intake_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_Drug_Outlet(): Option[Physical_Types.Fluid_Flow_imp] = {\n    val value: Option[Physical_Types.Fluid_Flow_imp] = get_Drug_Outlet_payload() match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Drug_Outlet.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Drug_Outlet_payload(): Option[Physical_Types.Fluid_Flow_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Drug_Outlet_Id).asInstanceOf[Option[Physical_Types.Fluid_Flow_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Downstream_Flow_Rate(): Option[PCA_Types.Flow_Rate_imp] = {\n    val value: Option[PCA_Types.Flow_Rate_imp] = get_Downstream_Flow_Rate_payload() match {\n      case Some(PCA_Types.Flow_Rate_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Downstream_Flow_Rate.  Expecting 'PCA_Types.Flow_Rate_imp_Payload' but received ${v}\")\n      case _ => None[PCA_Types.Flow_Rate_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Downstream_Flow_Rate_payload(): Option[PCA_Types.Flow_Rate_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Downstream_Flow_Rate_Id).asInstanceOf[Option[PCA_Types.Flow_Rate_imp_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Occlusion(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Occlusion_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Occlusion.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Occlusion_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Occlusion_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Bubble(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Bubble_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Bubble.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Bubble_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Bubble_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/downstream_monitor_imp_pump_fluid_downstream_mon_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass downstream_monitor_imp_pump_fluid_downstream_mon_Test extends downstream_monitor_imp_pump_fluid_downstream_mon_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/downstream_monitor_imp_pump_fluid_downstream_mon_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{downstream_monitor_imp_pump_fluid_downstream_mon => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class downstream_monitor_imp_pump_fluid_downstream_mon_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Drug_Intake: Port[Physical_Types.Fluid_Flow_imp],\n  Drug_Outlet: Port[Physical_Types.Fluid_Flow_imp],\n  Downstream_Flow_Rate: Port[PCA_Types.Flow_Rate_imp],\n  Occlusion: Port[art.Empty],\n  Bubble: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Drug_Intake,\n              Drug_Outlet,\n              Downstream_Flow_Rate,\n              Occlusion,\n              Bubble),\n\n    dataIns = ISZ(Drug_Intake),\n\n    dataOuts = ISZ(Drug_Outlet,\n                   Downstream_Flow_Rate),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Occlusion,\n                    Bubble)\n  )\n\n  val initialization_api : downstream_monitor_imp_Initialization_Api = {\n    val api = downstream_monitor_imp_Initialization_Api(\n      id,\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Downstream_Flow_Rate.id,\n      Occlusion.id,\n      Bubble.id\n    )\n    downstream_monitor_imp_pump_fluid_downstream_mon_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : downstream_monitor_imp_Operational_Api = {\n    val api = downstream_monitor_imp_Operational_Api(\n      id,\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Downstream_Flow_Rate.id,\n      Occlusion.id,\n      Bubble.id\n    )\n    downstream_monitor_imp_pump_fluid_downstream_mon_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    downstream_monitor_imp_pump_fluid_downstream_mon_Bridge.EntryPoints(\n      id,\n\n      Drug_Intake.id,\n      Drug_Outlet.id,\n      Downstream_Flow_Rate.id,\n      Occlusion.id,\n      Bubble.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject downstream_monitor_imp_pump_fluid_downstream_mon_Bridge {\n\n  var c_initialization_api: Option[downstream_monitor_imp_Initialization_Api] = None()\n  var c_operational_api: Option[downstream_monitor_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    downstream_monitor_imp_pump_fluid_downstream_mon_BridgeId : Art.BridgeId,\n\n    Drug_Intake_Id : Art.PortId,\n    Drug_Outlet_Id : Art.PortId,\n    Downstream_Flow_Rate_Id : Art.PortId,\n    Occlusion_Id : Art.PortId,\n    Bubble_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: downstream_monitor_imp_Initialization_Api,\n    operational_api: downstream_monitor_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Drug_Intake_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Drug_Outlet_Id,\n                                              Downstream_Flow_Rate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Occlusion_Id,\n                                               Bubble_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: downstream_monitor_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: downstream_monitor_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/downstream_monitor_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait downstream_monitor_imp_Api {\n  def id: Art.BridgeId\n  def Drug_Intake_Id : Art.PortId\n  def Drug_Outlet_Id : Art.PortId\n  def Downstream_Flow_Rate_Id : Art.PortId\n  def Occlusion_Id : Art.PortId\n  def Bubble_Id : Art.PortId\n\n  def put_Drug_Outlet(value : Physical_Types.Fluid_Flow_imp) : Unit = {\n    Art.putValue(Drug_Outlet_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  def put_Downstream_Flow_Rate(value : PCA_Types.Flow_Rate_imp) : Unit = {\n    Art.putValue(Downstream_Flow_Rate_Id, PCA_Types.Flow_Rate_imp_Payload(value))\n  }\n\n  def put_Occlusion() : Unit = {\n    Art.putValue(Occlusion_Id, art.Empty())\n  }\n\n  def put_Bubble() : Unit = {\n    Art.putValue(Bubble_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class downstream_monitor_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Downstream_Flow_Rate_Id : Art.PortId,\n  val Occlusion_Id : Art.PortId,\n  val Bubble_Id : Art.PortId) extends downstream_monitor_imp_Api\n\n@datatype class downstream_monitor_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Drug_Intake_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Downstream_Flow_Rate_Id : Art.PortId,\n  val Occlusion_Id : Art.PortId,\n  val Bubble_Id : Art.PortId) extends downstream_monitor_imp_Api {\n\n  def get_Drug_Intake() : Option[Physical_Types.Fluid_Flow_imp] = {\n    val value : Option[Physical_Types.Fluid_Flow_imp] = Art.getValue(Drug_Intake_Id) match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Drug_Intake.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n        None[Physical_Types.Fluid_Flow_imp]()\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/downstream_monitor_imp_pump_fluid_downstream_mon.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject downstream_monitor_imp_pump_fluid_downstream_mon {\n\n  def initialise(api: downstream_monitor_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Drug_Outlet(Physical_Types.Fluid_Flow_imp.example())\n    api.put_Downstream_Flow_Rate(PCA_Types.Flow_Rate_imp.example())\n    api.put_Occlusion()\n    api.put_Bubble()\n  }\n\n  def timeTriggered(api: downstream_monitor_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Drug_Intake: Option[Physical_Types.Fluid_Flow_imp] = api.get_Drug_Intake()\n    api.logInfo(s\"Received on Drug_Intake: ${apiUsage_Drug_Intake}\")\n  }\n\n  def activate(api: downstream_monitor_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: downstream_monitor_imp_Operational_Api): Unit = { }\n\n  def finalise(api: downstream_monitor_imp_Operational_Api): Unit = { }\n\n  def recover(api: downstream_monitor_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/util\/pca_pump__JVM\/PCA_Mechanical\/drug_reservoir_imp_pump_fluid_reservoir_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport pca_pump__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class drug_reservoir_imp_pump_fluid_reservoir_TestApi extends BridgeTestSuite[drug_reservoir_imp_pump_fluid_reservoir_Bridge](Arch.wrap_pca_imp_Instance_pump_fluid_reservoir) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Fill_Reservoir payload for data port Fill_Reservoir\n   *\/\n  def put_concrete_inputs(Fill_Reservoir : Physical_Types.Fluid_Volume_imp): Unit = {\n    put_Fill_Reservoir(Fill_Reservoir)\n  }\n\n\n  \/** helper function to check drug_reservoir_imp_pump_fluid_reservoir's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Drug_Outlet method that will be called with the value of the outgoing data\n   *        port 'Drug_Outlet'.\n   * @param Door_Open method that will be called with the value of the outgoing data\n   *        port 'Door_Open'.\n   * @param Door_Closed method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Door_Closed'.\n   * @param Low_Reservoir method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Low_Reservoir'.\n   * @param Empty_Reservoir method that will be called with the number of events to be sent\n   *        on the outgoing event port 'Empty_Reservoir'.\n   *\/\n  def check_concrete_output(Drug_Outlet: Physical_Types.Fluid_Flow_imp => B = Drug_OutletParam => {T},\n                            Door_Open: Base_Types.Boolean => B = Door_OpenParam => {T},\n                            Door_Closed: Z => B = Door_ClosedParam => {T},\n                            Low_Reservoir: Z => B = Low_ReservoirParam => {T},\n                            Empty_Reservoir: Z => B = Empty_ReservoirParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val Drug_OutletValue: Physical_Types.Fluid_Flow_imp = get_Drug_Outlet().get\n    if(!Drug_Outlet(Drug_OutletValue)) {\n      testFailures = testFailures :+ st\"'Drug_Outlet' did not match expected: value of the outgoing data port is ${Drug_OutletValue}\"\n    }\n    val Door_OpenValue: Base_Types.Boolean = get_Door_Open().get\n    if(!Door_Open(Door_OpenValue)) {\n      testFailures = testFailures :+ st\"'Door_Open' did not match expected: value of the outgoing data port is ${Door_OpenValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Door_ClosedValue: Z = if(get_Door_Closed().nonEmpty) z\"1\" else z\"0\"\n    if(!Door_Closed(Door_ClosedValue)) {\n      testFailures = testFailures :+ st\"'Door_Closed' did not match expected: ${Door_ClosedValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Low_ReservoirValue: Z = if(get_Low_Reservoir().nonEmpty) z\"1\" else z\"0\"\n    if(!Low_Reservoir(Low_ReservoirValue)) {\n      testFailures = testFailures :+ st\"'Low_Reservoir' did not match expected: ${Low_ReservoirValue} events were in the outgoing event queue\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val Empty_ReservoirValue: Z = if(get_Empty_Reservoir().nonEmpty) z\"1\" else z\"0\"\n    if(!Empty_Reservoir(Empty_ReservoirValue)) {\n      testFailures = testFailures :+ st\"'Empty_Reservoir' did not match expected: ${Empty_ReservoirValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_Fill_Reservoir(value : Physical_Types.Fluid_Volume_imp): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Fill_Reservoir_Id, Physical_Types.Fluid_Volume_imp_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_Drug_Outlet(): Option[Physical_Types.Fluid_Flow_imp] = {\n    val value: Option[Physical_Types.Fluid_Flow_imp] = get_Drug_Outlet_payload() match {\n      case Some(Physical_Types.Fluid_Flow_imp_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Drug_Outlet.  Expecting 'Physical_Types.Fluid_Flow_imp_Payload' but received ${v}\")\n      case _ => None[Physical_Types.Fluid_Flow_imp]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Drug_Outlet_payload(): Option[Physical_Types.Fluid_Flow_imp_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Drug_Outlet_Id).asInstanceOf[Option[Physical_Types.Fluid_Flow_imp_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_Door_Open(): Option[Base_Types.Boolean] = {\n    val value: Option[Base_Types.Boolean] = get_Door_Open_payload() match {\n      case Some(Base_Types.Boolean_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Door_Open.  Expecting 'Base_Types.Boolean_Payload' but received ${v}\")\n      case _ => None[Base_Types.Boolean]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_Door_Open_payload(): Option[Base_Types.Boolean_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Door_Open_Id).asInstanceOf[Option[Base_Types.Boolean_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Door_Closed(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Door_Closed_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Door_Closed.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Door_Closed_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Door_Closed_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Low_Reservoir(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Low_Reservoir_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Low_Reservoir.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Low_Reservoir_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Low_Reservoir_Id).asInstanceOf[Option[Empty]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_Empty_Reservoir(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_Empty_Reservoir_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port Empty_Reservoir.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_Empty_Reservoir_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Empty_Reservoir_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/test\/bridge\/pca_pump__JVM\/PCA_Mechanical\/drug_reservoir_imp_pump_fluid_reservoir_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM.PCA_Mechanical._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass drug_reservoir_imp_pump_fluid_reservoir_Test extends drug_reservoir_imp_pump_fluid_reservoir_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/drug_reservoir_imp_pump_fluid_reservoir_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\nimport pca_pump__JVM.PCA_Mechanical.{drug_reservoir_imp_pump_fluid_reservoir => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class drug_reservoir_imp_pump_fluid_reservoir_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Fill_Reservoir: Port[Physical_Types.Fluid_Volume_imp],\n  Drug_Outlet: Port[Physical_Types.Fluid_Flow_imp],\n  Door_Open: Port[Base_Types.Boolean],\n  Door_Closed: Port[art.Empty],\n  Low_Reservoir: Port[art.Empty],\n  Empty_Reservoir: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Fill_Reservoir,\n              Drug_Outlet,\n              Door_Open,\n              Door_Closed,\n              Low_Reservoir,\n              Empty_Reservoir),\n\n    dataIns = ISZ(Fill_Reservoir),\n\n    dataOuts = ISZ(Drug_Outlet,\n                   Door_Open),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(Door_Closed,\n                    Low_Reservoir,\n                    Empty_Reservoir)\n  )\n\n  val initialization_api : drug_reservoir_imp_Initialization_Api = {\n    val api = drug_reservoir_imp_Initialization_Api(\n      id,\n      Fill_Reservoir.id,\n      Drug_Outlet.id,\n      Door_Open.id,\n      Door_Closed.id,\n      Low_Reservoir.id,\n      Empty_Reservoir.id\n    )\n    drug_reservoir_imp_pump_fluid_reservoir_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : drug_reservoir_imp_Operational_Api = {\n    val api = drug_reservoir_imp_Operational_Api(\n      id,\n      Fill_Reservoir.id,\n      Drug_Outlet.id,\n      Door_Open.id,\n      Door_Closed.id,\n      Low_Reservoir.id,\n      Empty_Reservoir.id\n    )\n    drug_reservoir_imp_pump_fluid_reservoir_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    drug_reservoir_imp_pump_fluid_reservoir_Bridge.EntryPoints(\n      id,\n\n      Fill_Reservoir.id,\n      Drug_Outlet.id,\n      Door_Open.id,\n      Door_Closed.id,\n      Low_Reservoir.id,\n      Empty_Reservoir.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject drug_reservoir_imp_pump_fluid_reservoir_Bridge {\n\n  var c_initialization_api: Option[drug_reservoir_imp_Initialization_Api] = None()\n  var c_operational_api: Option[drug_reservoir_imp_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    drug_reservoir_imp_pump_fluid_reservoir_BridgeId : Art.BridgeId,\n\n    Fill_Reservoir_Id : Art.PortId,\n    Drug_Outlet_Id : Art.PortId,\n    Door_Open_Id : Art.PortId,\n    Door_Closed_Id : Art.PortId,\n    Low_Reservoir_Id : Art.PortId,\n    Empty_Reservoir_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: drug_reservoir_imp_Initialization_Api,\n    operational_api: drug_reservoir_imp_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(Fill_Reservoir_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(Drug_Outlet_Id,\n                                              Door_Open_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Door_Closed_Id,\n                                               Low_Reservoir_Id,\n                                               Empty_Reservoir_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: drug_reservoir_imp_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: drug_reservoir_imp_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/bridge\/pca_pump__JVM\/PCA_Mechanical\/drug_reservoir_imp_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport art._\nimport pca_pump__JVM._\n\n@sig trait drug_reservoir_imp_Api {\n  def id: Art.BridgeId\n  def Fill_Reservoir_Id : Art.PortId\n  def Drug_Outlet_Id : Art.PortId\n  def Door_Open_Id : Art.PortId\n  def Door_Closed_Id : Art.PortId\n  def Low_Reservoir_Id : Art.PortId\n  def Empty_Reservoir_Id : Art.PortId\n\n  def put_Drug_Outlet(value : Physical_Types.Fluid_Flow_imp) : Unit = {\n    Art.putValue(Drug_Outlet_Id, Physical_Types.Fluid_Flow_imp_Payload(value))\n  }\n\n  def put_Door_Open(value : Base_Types.Boolean) : Unit = {\n    Art.putValue(Door_Open_Id, Base_Types.Boolean_Payload(value))\n  }\n\n  def put_Door_Closed() : Unit = {\n    Art.putValue(Door_Closed_Id, art.Empty())\n  }\n\n  def put_Low_Reservoir() : Unit = {\n    Art.putValue(Low_Reservoir_Id, art.Empty())\n  }\n\n  def put_Empty_Reservoir() : Unit = {\n    Art.putValue(Empty_Reservoir_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class drug_reservoir_imp_Initialization_Api (\n  val id: Art.BridgeId,\n  val Fill_Reservoir_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val Door_Closed_Id : Art.PortId,\n  val Low_Reservoir_Id : Art.PortId,\n  val Empty_Reservoir_Id : Art.PortId) extends drug_reservoir_imp_Api\n\n@datatype class drug_reservoir_imp_Operational_Api (\n  val id: Art.BridgeId,\n  val Fill_Reservoir_Id : Art.PortId,\n  val Drug_Outlet_Id : Art.PortId,\n  val Door_Open_Id : Art.PortId,\n  val Door_Closed_Id : Art.PortId,\n  val Low_Reservoir_Id : Art.PortId,\n  val Empty_Reservoir_Id : Art.PortId) extends drug_reservoir_imp_Api {\n\n  def get_Fill_Reservoir() : Option[Physical_Types.Fluid_Volume_imp] = {\n    val value : Option[Physical_Types.Fluid_Volume_imp] = Art.getValue(Fill_Reservoir_Id) match {\n      case Some(Physical_Types.Fluid_Volume_imp_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Fill_Reservoir.  Expecting 'Physical_Types.Fluid_Volume_imp_Payload' but received ${v}\")\n        None[Physical_Types.Fluid_Volume_imp]()\n      case _ => None[Physical_Types.Fluid_Volume_imp]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/component\/pca_pump__JVM\/PCA_Mechanical\/drug_reservoir_imp_pump_fluid_reservoir.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage pca_pump__JVM.PCA_Mechanical\n\nimport org.sireum._\nimport pca_pump__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject drug_reservoir_imp_pump_fluid_reservoir {\n\n  def initialise(api: drug_reservoir_imp_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Drug_Outlet(Physical_Types.Fluid_Flow_imp.example())\n    api.put_Door_Open(Base_Types.Boolean_example())\n    api.put_Door_Closed()\n    api.put_Low_Reservoir()\n    api.put_Empty_Reservoir()\n  }\n\n  def timeTriggered(api: drug_reservoir_imp_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Fill_Reservoir: Option[Physical_Types.Fluid_Volume_imp] = api.get_Fill_Reservoir()\n    api.logInfo(s\"Received on Fill_Reservoir: ${apiUsage_Fill_Reservoir}\")\n  }\n\n  def activate(api: drug_reservoir_imp_Operational_Api): Unit = { }\n\n  def deactivate(api: drug_reservoir_imp_Operational_Api): Unit = { }\n\n  def finalise(api: drug_reservoir_imp_Operational_Api): Unit = { }\n\n  def recover(api: drug_reservoir_imp_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 27\n  val maxPorts: PortId = 276\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, Option[Bridge]] = MS.create[BridgeId, Option[Bridge]](maxComponents, None[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val Some(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n\n  \/\/ JH: Refactored - manually added method to support\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeInPortValue(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = { }\n\n  override def computePhase(): Unit = { }\n\n  override def finalizePhase(): Unit = { }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, Bridge}\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(bridgeId: art.Art.BridgeId, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0,0,DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def setSchedule(spec: DScheduleSpec, bridgeMap: ISZ[Art.BridgeId]) : Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = bridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Z = {\n    \/\/val domainId = slot.domain\n    \/\/val bridgeId = domainToBridgeIdMap(domainId).get\n    val bridgeId = slot.bridgeId\n    return bridgeId\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Z = {\n    val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n    return getBridgeIdFromSlot(slot)\n  }\n\n  def getBridgeId(scheduleState : Explorer.ScheduleState): Z = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  \/\/def getDomain(slotNum: Z): Z = {\n  \/\/  val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n  \/\/  return slot.domain\n  \/\/}\n\n  \/\/def getDomain(scheduleState : Explorer.ScheduleState): Z = {\n  \/\/   return getDomain(scheduleState.slotNum)\n  \/\/}\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    halt(\"TODO\")\n    \/*\n    for (e <- StaticScheduling.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n     *\/\n  }\n\n  def threadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState) : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ --------- helper methods for contracts -------------\n\n  def mySome[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (pred(e)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  def myAll[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (!pred(e)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    checkMaxDomain(dScheduleSpec)\n    checkNoMissingDomain(dScheduleSpec)\n    checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/\/myAll[Slot](dScheduleSpec.schedule.slots, s => s.domain <= dScheduleSpec.maxDomain)\n    \/\/  for (s <- dScheduleSpec.schedule.slots) {\n    \/\/    if (s.domain > dScheduleSpec.maxDomain) {\n    \/\/      return false\n    \/\/    }\n    \/\/  }\n    \/\/  return true\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    for (d <- 0 to dScheduleSpec.maxDomain) {\n      if (!mySome[Slot](dScheduleSpec.schedule.slots, s => s.domain == d)) {\n        return false\n      }\n    }\n    return true\n\n     *\/\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n\n     *\/\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec) : (Z,Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks,remainingHPTicks)\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent }\n\nobject StateObserver {\n\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeInPortValue(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def generatePortContentsInputsCurrent() : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsOutputsCurrent() : String = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState,Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        val result =\n          st\"\"\"****************************\n              |   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n              |****************************\n              | Output Ports\n              | ===============\n              |  ${formatPortInfo(outPortInfo)}\"\"\".render\n        return result\n      }\n      case None() => {\n        return \"(initial state - no previous state to show)\"\n      }\n    }\n  }\n\n  def formatPortInfo(portVals: ISZ[(String,Option[DataContent])]): String = {\n    var result: String = \"\" \/\/ ToDo: Ask Robby if I can do this with a repeating template\n    for (e <- portVals) {\n      result = st\"\"\"$result\n                   |${e._1} = ${e._2}\"\"\".render  \/\/ how do I put in new line?\n    }\n    return result\n  }\n\n  def generatePortContents(bridgeId: Z) : String = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\n          |\n          | Output Ports\n          | ================\n          |  ${formatPortInfo(outPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsByNickName(threadNickName: String) : String = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return generatePortContents(bridgeId)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\n@record class StaticScheduler(bridges: ISZ[art.Bridge],\n                              staticSchedule: DScheduleSpec) extends Scheduler {\n\n  override def initialize(): Unit = {\n    Schedule.dScheduleSpec = staticSchedule\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      art.Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    Explorer.runSystem()\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      art.Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec) : B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return  slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  \/\/ no overloading in Slang\n  \/\/def isHyperPeriodBoundary(): B = {\n  \/\/  return isHyperPeriodBoundary(scheduleState)\n  \/\/}\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState : ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    ScheduleState(0,0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    \/\/val domainId: Z = slot.domain\n    \/\/val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId).get\n    val bridgeId: Art.BridgeId = slot.bridgeId\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if(ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState,dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum,nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState,dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1           \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) {  \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1  \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum,nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP() : Unit = {\n    scheduleState = nextState(scheduleState,dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      halt(\"TODO\")\n      \/\/Cli.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots :Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP : Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n    halt(\"TODO\")\n    \/\/Cli.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods:Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      \/\/ println(\"===== Hyperperiod \", scheduleState.hyperperiodNum, \" ============\")\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    halt(\"TODO\")\n    \/\/Cli.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    \/\/while (scheduleState.hyperperiodNum < hpNum) {\n    \/\/  stepSystemOneSlotIMP(F)\n    \/\/}\n    \/\/Cli.message(\"*********** Run to ... Completed *************\")\n    \/\/Cli.showState(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum:Z, slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    halt(\"TODO\")\n    \/*\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to domain $domainId\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n\n     *\/\n  }\n\n  \/*\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = art.StaticScheduling.bridgeIdToDomainMap(bridgeId)\n    Cli.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n  }\n   *\/\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    \/\/Cli.message (s\"...Running system according to static schedule\")\n    cprintln(F, \"...Running system according to static schedule\")\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\n\n@record class RoundRobin(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  def shouldDispatch(bridge: art.Bridge): B = {\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if(Art.time() - lastDispatch(bridge.id) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridge.id)  \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if(Art.time() - lastSporadic(bridge.id) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridge.id)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while(!RoundRobinExtensions.shouldStop()) {\n      for (bridge <- bridges) {\n        if(shouldDispatch(bridge)) {\n          lastDispatch(bridge.id) = Art.time()\n          bridge.entryPoints.compute()\n\n          if(bridge.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridge.id) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n  def shouldStop(): B = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: ISZ[Bridge],\n                                        connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n\n    def testInitialise(): Unit = { println(\"Default testInitialise\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  \/\/ ** Manually added method by JH to support debugging interface\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport org.sireum.S64._\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < s64\"0\") {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridges(bridgeId).get\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET_PORT,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET_PORT,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when sendOutput transferred message from out port var of producer\n                       var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: ISZ[Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = ISZ()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val inPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val outPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId \/\/ dequeue from infrastructure port\n          inPortVariables(portId) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n          outPortVariables -= srcPortId\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId;\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id).filter(inInfrastructurePorts.get(_).nonEmpty): _*)\n        val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(urgentFifo)\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    Console.out.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/\/ Manually added method to support debugging framework\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\n\nobject ArtSlangMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Art.PortId,\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for(e <- eventIns) {\n          if(inInfrastructurePorts.contains(e.id)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  def lt(a : art.UPort,b : art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if(sorted.isEmpty) { return ISZ(p) }\n      else {\n        if(lt(sorted(0), p)) { return sorted(0) +: insert(p, ops.ISZOps(sorted).tail) }\n        else { return p +: sorted }\n      }\n    }\n    if(ports.isEmpty) { return ports}\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds: ISZ[Art.PortId] =\n          for(p <- Art.bridges(bridgeId).get.ports.eventIns if inInfrastructurePorts.get(p.id).nonEmpty) yield p.id\n\n        if(portIds.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(for(p <- portIds) yield Art.port(p))\n        EventTriggered(for(p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId, data))\n          inPortVariables = inPortVariables + (portId ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = ArtSlangMessage.UNSET_PORT, sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if(inPortVariables.contains(portId)) {\n      return Some(inPortVariables.get(portId).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/github.com\/sireum\/kekinian#installing\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . pca_pump__JVM.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . pca_pump__JVM.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main pca_pump__JVM.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   If you prevented HAMR from running Proyek IVE then first generate the IVE project:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/pca_pump__JVM\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"wrap_pca_imp_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=2a2b989\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20220525.478f969\n\norg.sireum.kekinian%%library%=4.20220526.4bb6bfe\n\norg.scala-lang%scala-library%=2.13.8\norg.scalatest%%scalatest%%=3.2.10\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill pca_pump__JVM.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill pca_pump__JVM.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n pca-pump--JVM ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w pca_pump__JVM.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `pca_pump__JVM` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.8\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.10\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20220525.478f969\n  val sireumScalacVersion = \"4.20220525.478f969\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20220526.4bb6bfe\n  val kekinianVersion = \"4.20220526.4bb6bfe\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"pca_pump__JVM.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"pca_pump__JVM.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/pca_pump__JVM\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val wrap_pca_imp_Instance = slangEmbeddedProject(\"wrap_pca_imp_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.8\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.10\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20220525.478f969\nval sireumScalacVersion = \"4.20220525.478f969\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20220526.4bb6bfe\nval kekinianVersion = \"4.20220526.4bb6bfe\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"pca_pump__JVM.Demo\"),\n\n  mainClass in assembly := Some(\"pca_pump__JVM.Demo\"),\n  assemblyJarName in assembly := \"wrap_pca_imp_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"pca_pump__JVM.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "pca-pump--JVM\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ]
    ]
  }
}