{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/TempUnit.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object TempUnit {\n  \"Fahrenheit\"\n  \"Celsius\"\n  \"Kelvin\"\n}\n\nobject TempUnit_Payload {\n  def example(): TempUnit_Payload = {\n    return TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class TempUnit_Payload(value: BuildingControl.TempUnit.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/Temperature_impl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Temperature_impl {\n  def example(): BuildingControl.Temperature_impl = {\n    return BuildingControl.Temperature_impl(\n      degrees = Base_Types.Float_32_example(),\n      unit = BuildingControl.TempUnit.byOrdinal(0).get)\n  }\n}\n\n@datatype class Temperature_impl(\n  val degrees: F32,\n  val unit: BuildingControl.TempUnit.Type) {\n}\n\nobject Temperature_impl_Payload {\n  def example(): Temperature_impl_Payload = {\n    return Temperature_impl_Payload(BuildingControl.Temperature_impl.example())\n  }\n}\n\n@datatype class Temperature_impl_Payload(value: BuildingControl.Temperature_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/SetPoint_impl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject SetPoint_impl {\n  def example(): BuildingControl.SetPoint_impl = {\n    return BuildingControl.SetPoint_impl(\n      low = BuildingControl.Temperature_impl.example(),\n      high = BuildingControl.Temperature_impl.example())\n  }\n}\n\n@datatype class SetPoint_impl(\n  val low: BuildingControl.Temperature_impl,\n  val high: BuildingControl.Temperature_impl) {\n}\n\nobject SetPoint_impl_Payload {\n  def example(): SetPoint_impl_Payload = {\n    return SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example())\n  }\n}\n\n@datatype class SetPoint_impl_Payload(value: BuildingControl.SetPoint_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/FanAck.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FanAck {\n  \"Ok\"\n  \"Error\"\n}\n\nobject FanAck_Payload {\n  def example(): FanAck_Payload = {\n    return FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanAck_Payload(value: BuildingControl.FanAck.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/BuildingControl\/FanCmd.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object FanCmd {\n  \"On\"\n  \"Off\"\n}\n\nobject FanCmd_Payload {\n  def example(): FanCmd_Payload = {\n    return FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get)\n  }\n}\n\n@datatype class FanCmd_Payload(value: BuildingControl.FanCmd.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = {\n    Contract(Ensures(Res == F))\n    return F\n  }\n\n\n  def Integer_example(): Integer = {\n    Contract(Ensures(Res == z\"0\"))\n    return z\"0\"\n  }\n\n  def Integer_8_example(): Integer_8 = {\n    Contract(Ensures(Res == s8\"0\"))\n    return s8\"0\"\n  }\n\n  def Integer_16_example(): Integer_16 = {\n    Contract(Ensures(Res == s16\"0\"))\n    return s16\"0\"\n  }\n\n  def Integer_32_example(): Integer_32 = {\n    Contract(Ensures(Res == s32\"0\"))\n    return s32\"0\"\n  }\n\n  def Integer_64_example(): Integer_64 = {\n    Contract(Ensures(Res == s64\"0\"))\n    return s64\"0\"\n  }\n\n\n  def Unsigned_8_example(): Unsigned_8 = {\n    Contract(Ensures(Res == u8\"0\"))\n    return u8\"0\"\n  }\n\n  def Unsigned_16_example(): Unsigned_16 = {\n    Contract(Ensures(Res == u16\"0\"))\n    return u16\"0\"\n  }\n\n  def Unsigned_32_example(): Unsigned_32 = {\n    Contract(Ensures(Res == u32\"0\"))\n    return u32\"0\"\n  }\n\n  def Unsigned_64_example(): Unsigned_64 = {\n    Contract(Ensures(Res == u64\"0\"))\n    return u64\"0\"\n  }\n\n\n  def Float_example(): Float = {\n    Contract(Ensures(Res == r\"0\"))\n    return r\"0\"\n  }\n\n  def Float_32_example(): Float_32 = {\n    Contract(Ensures(Res == f32\"0\"))\n    return f32\"0\"\n  }\n\n  def Float_64_example(): Float_64 = {\n    Contract(Ensures(Res == f64\"0\"))\n    return f64\"0\"\n  }\n\n\n  def Character_example(): Character = {\n    Contract(Ensures(Res == ' '))\n    return ' '\n  }\n\n  def String_example(): String = {\n    Contract(Ensures(Res == \"\"))\n    return \"\"\n  }\n\n\n  def Bits_example(): Bits = {\n    Contract(Ensures(Res == ISZ[B]()))\n    return ISZ[B]()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val BuildingControlDemo_i_Instance_tcp_tempSensor : building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp\", mode = DataOut)\n    val tempChanged = Port[art.Empty] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempSensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_tempControl : building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 2, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp\", mode = DataIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 3, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanAck\", mode = EventIn)\n    val setPoint = Port[BuildingControl.SetPoint_impl] (id = 4, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_setPoint\", mode = EventIn)\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 5, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd\", mode = EventOut)\n    val tempChanged = Port[art.Empty] (id = 6, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged\", mode = EventIn)\n\n    building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge(\n      id = 1,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempControl\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      fanAck = fanAck,\n      setPoint = setPoint,\n      fanCmd = fanCmd,\n      tempChanged = tempChanged\n    )\n  }\n  val BuildingControlDemo_i_Instance_tcp_fan : building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge = {\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 7, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanCmd\", mode = EventIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 8, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanAck\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge(\n      id = 2,\n      name = \"BuildingControlDemo_i_Instance_tcp_fan\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      fanCmd = fanCmd,\n      fanAck = fanAck\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n    TranspilerUtil.touch()\n\n    ArchitectureDescription(\n      components = ISZ (BuildingControlDemo_i_Instance_tcp_tempSensor, BuildingControlDemo_i_Instance_tcp_tempControl, BuildingControlDemo_i_Instance_tcp_fan),\n\n      connections = ISZ (Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.currentTemp, to = BuildingControlDemo_i_Instance_tcp_tempControl.currentTemp),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_tempSensor.tempChanged, to = BuildingControlDemo_i_Instance_tcp_tempControl.tempChanged),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_tempControl.fanCmd, to = BuildingControlDemo_i_Instance_tcp_fan.fanCmd),\n                         Connection(from = BuildingControlDemo_i_Instance_tcp_fan.fanAck, to = BuildingControlDemo_i_Instance_tcp_tempControl.fanAck))\n    )\n  }\n}\n\nobject TranspilerUtil {\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch process\/thread timing properties\n      println(Schedulers.BuildingControlDemo_i_Instance_proc_timingProperties)\n      println(Schedulers.BuildingControlDemo_i_Instance_tcp_tempSensor_timingProperties)\n      println(Schedulers.BuildingControlDemo_i_Instance_tcp_tempControl_timingProperties)\n      println(Schedulers.BuildingControlDemo_i_Instance_tcp_fan_timingProperties)\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_example()))\n      printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n      printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.example()))\n      printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example()))\n      printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n      printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      {\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logError(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logError(\"\")\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.put_currentTemp(BuildingControl.Temperature_impl.example())\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.put_currentTemp(BuildingControl.Temperature_impl.example())\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.put_tempChanged()\n        building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.put_tempChanged()\n      }\n      {\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logError(\"\")\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_currentTemp: Option[BuildingControl.Temperature_impl] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_currentTemp()\n        val apiUsage_fanAck: Option[BuildingControl.FanAck.Type] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_fanAck()\n        val apiUsage_setPoint: Option[BuildingControl.SetPoint_impl] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_setPoint()\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.put_fanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n        building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.put_fanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n        val apiUsage_tempChanged: Option[art.Empty] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_tempChanged()\n      }\n      {\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logError(\"\")\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logInfo(\"\")\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logDebug(\"\")\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_fanCmd: Option[BuildingControl.FanCmd.Type] = building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.get_fanCmd()\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.put_fanAck(BuildingControl.FanAck.byOrdinal(0).get)\n        building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.put_fanAck(BuildingControl.FanAck.byOrdinal(0).get)\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticScheduler(None())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n        art.Art.run(Arch.ad, scheduler)\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage building_control_gen_mixed\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec, Slot}\nimport art.scheduling.static.StaticScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val BuildingControlDemo_i_Instance_proc_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = None(),\n    framePeriod = None(),\n    maxDomain = None(),\n    slotTime = None())\n\n  val BuildingControlDemo_i_Instance_tcp_tempSensor_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val BuildingControlDemo_i_Instance_tcp_tempControl_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  val BuildingControlDemo_i_Instance_tcp_fan_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = None(),\n    domain = None())\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[art.Bridge] = Arch.ad.components\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ staticSchedule represents the component dispatch order\n  val staticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Slot(Arch.BuildingControlDemo_i_Instance_tcp_tempSensor.id, maxExecutionTime),\n    Slot(Arch.BuildingControlDemo_i_Instance_tcp_tempControl.id, maxExecutionTime),\n    Slot(Arch.BuildingControlDemo_i_Instance_tcp_fan.id, maxExecutionTime)\n  )))\n\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[art.Bridge]]): RoundRobin = {\n    if(roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  def getStaticScheduler(schedule: Option[DScheduleSpec]): StaticScheduler = {\n    if(staticSchedule.schedule.slots.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return StaticScheduler(Arch.ad.components, s)\n      case _ => return StaticScheduler(Arch.ad.components, ScheduleProviderI.getStaticSchedule())\n    }\n  }\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[art.Bridge] = $\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/architecture\/building_control_gen_mixed\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed\n\nimport org.sireum._\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[art.Bridge] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.staticSchedule\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/inspector\/building_control_gen_mixed\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/data\/building_control_gen_mixed\/sergen.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/util\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class TempSensor_i_tcp_tempSensor_TestApi extends BridgeTestSuite[TempSensor_i_tcp_tempSensor_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_tempSensor) {\n\n  \/** helper function to check TempSensor_i_tcp_tempSensor's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param currentTemp method that will be called with the value of the outgoing data\n   *        port 'currentTemp'.\n   * @param tempChanged method that will be called with the number of events to be sent\n   *        on the outgoing event port 'tempChanged'.\n   *\/\n  def check_concrete_output(currentTemp: BuildingControl.Temperature_impl => B = currentTempParam => {T},\n                            tempChanged: Z => B = tempChangedParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val currentTempValue: BuildingControl.Temperature_impl = get_currentTemp().get\n    if(!currentTemp(currentTempValue)) {\n      testFailures = testFailures :+ st\"'currentTemp' did not match expected: value of the outgoing data port is ${currentTempValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val tempChangedValue: Z = if(get_tempChanged().nonEmpty) z\"1\" else z\"0\"\n    if(!tempChanged(tempChangedValue)) {\n      testFailures = testFailures :+ st\"'tempChanged' did not match expected: ${tempChangedValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_currentTemp(): Option[BuildingControl.Temperature_impl] = {\n    val value: Option[BuildingControl.Temperature_impl] = get_currentTemp_payload() match {\n      case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\")\n      case _ => None[BuildingControl.Temperature_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_currentTemp_payload(): Option[BuildingControl.Temperature_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.currentTemp_Id).asInstanceOf[Option[BuildingControl.Temperature_impl_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_tempChanged(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_tempChanged_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port tempChanged.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_tempChanged_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.tempChanged_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass TempSensor_i_tcp_tempSensor_Test extends TempSensor_i_tcp_tempSensor_TestApi {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.{TempSensor_i_tcp_tempSensor => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class TempSensor_i_tcp_tempSensor_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(currentTemp,\n              tempChanged),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(currentTemp),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(tempChanged)\n  )\n\n  val initialization_api : TempSensor_i_Initialization_Api = {\n    val api = TempSensor_i_Initialization_Api(\n      id,\n      currentTemp.id,\n      tempChanged.id\n    )\n    TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : TempSensor_i_Operational_Api = {\n    val api = TempSensor_i_Operational_Api(\n      id,\n      currentTemp.id,\n      tempChanged.id\n    )\n    TempSensor_i_tcp_tempSensor_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    TempSensor_i_tcp_tempSensor_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject TempSensor_i_tcp_tempSensor_Bridge {\n\n  var c_initialization_api: Option[TempSensor_i_Initialization_Api] = None()\n  var c_operational_api: Option[TempSensor_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    TempSensor_i_tcp_tempSensor_BridgeId : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: TempSensor_i_Initialization_Api,\n    operational_api: TempSensor_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(currentTemp_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(tempChanged_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempSensor_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: TempSensor_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: TempSensor_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: TempSensor_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: TempSensor_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempSensor_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n@sig trait TempSensor_i_Api {\n  def id: Art.BridgeId\n  def currentTemp_Id : Art.PortId\n  def tempChanged_Id : Art.PortId\n\n  def put_currentTemp(value : BuildingControl.Temperature_impl) : Unit = {\n    Art.putValue(currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n  }\n\n  def put_tempChanged() : Unit = {\n    Art.putValue(tempChanged_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class TempSensor_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempSensor_i_Api\n\n@datatype class TempSensor_i_Operational_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempSensor_i_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject TempSensor_i_tcp_tempSensor {\n\n  def initialise(api: TempSensor_i_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: TempSensor_i_Operational_Api): Unit = { }\n\n  def activate(api: TempSensor_i_Operational_Api): Unit = { }\n\n  def deactivate(api: TempSensor_i_Operational_Api): Unit = { }\n\n  def finalise(api: TempSensor_i_Operational_Api): Unit = { }\n\n  def recover(api: TempSensor_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/util\/building_control_gen_mixed\/BridgeTestSuite.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[building_control_gen_mixed.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/util\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class TempControl_i_tcp_tempControl_TestApi extends BridgeTestSuite[TempControl_i_tcp_tempControl_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_tempControl) {\n\n  \/** helper function to set the values of all input ports.\n   * @param currentTemp payload for data port currentTemp\n   * @param fanAck payloads for event data port fanAck.\n   *   ART currently supports single element event data queues so\n   *   only the last element of fanAck will be used\n   * @param setPoint payloads for event data port setPoint.\n   *   ART currently supports single element event data queues so\n   *   only the last element of setPoint will be used\n   * @param tempChanged the number of events to place in the tempChanged event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(currentTemp : BuildingControl.Temperature_impl,\n                          fanAck : ISZ[BuildingControl.FanAck.Type],\n                          setPoint : ISZ[BuildingControl.SetPoint_impl],\n                          tempChanged : Z): Unit = {\n    put_currentTemp(currentTemp)\n    for(v <- fanAck){\n      put_fanAck(v)\n    }\n    for(v <- setPoint){\n      put_setPoint(v)\n    }\n    for(i <- 0 until tempChanged) {\n      put_tempChanged()\n    }\n  }\n\n\n  \/** helper function to check TempControl_i_tcp_tempControl's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param fanCmd method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'fanCmd'.\n   *\/\n  def check_concrete_output(fanCmd: ISZ[BuildingControl.FanCmd.Type] => B = fanCmdParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var fanCmdValue: ISZ[BuildingControl.FanCmd.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_fanCmd().nonEmpty) fanCmdValue = fanCmdValue :+ get_fanCmd().get\n    if(!fanCmd(fanCmdValue)) {\n      testFailures = testFailures :+ st\"'fanCmd' did not match expected: received ${fanCmdValue.size} events with the following payloads ${fanCmdValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_currentTemp(value : BuildingControl.Temperature_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.currentTemp_Id, BuildingControl.Temperature_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_fanAck(value : BuildingControl.FanAck.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.fanAck_Id, BuildingControl.FanAck_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_setPoint(value : BuildingControl.SetPoint_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.setPoint_Id, BuildingControl.SetPoint_impl_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_tempChanged(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.tempChanged_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanCmd(): Option[BuildingControl.FanCmd.Type] = {\n    val value: Option[BuildingControl.FanCmd.Type] = get_fanCmd_payload() match {\n      case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\")\n      case _ => None[BuildingControl.FanCmd.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanCmd_payload(): Option[BuildingControl.FanCmd_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.fanCmd_Id).asInstanceOf[Option[BuildingControl.FanCmd_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass TempControl_i_tcp_tempControl_Test extends TempControl_i_tcp_tempControl_TestApi {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.{TempControl_i_tcp_tempControl => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class TempControl_i_tcp_tempControl_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  currentTemp: Port[BuildingControl.Temperature_impl],\n  fanAck: Port[BuildingControl.FanAck.Type],\n  setPoint: Port[BuildingControl.SetPoint_impl],\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  tempChanged: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(currentTemp,\n              fanAck,\n              setPoint,\n              fanCmd,\n              tempChanged),\n\n    dataIns = ISZ(currentTemp),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(fanAck,\n                   setPoint,\n                   tempChanged),\n\n    eventOuts = ISZ(fanCmd)\n  )\n\n  val initialization_api : TempControl_i_Initialization_Api = {\n    val api = TempControl_i_Initialization_Api(\n      id,\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id\n    )\n    TempControl_i_tcp_tempControl_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : TempControl_i_Operational_Api = {\n    val api = TempControl_i_Operational_Api(\n      id,\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id\n    )\n    TempControl_i_tcp_tempControl_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    TempControl_i_tcp_tempControl_Bridge.EntryPoints(\n      id,\n\n      currentTemp.id,\n      fanAck.id,\n      setPoint.id,\n      fanCmd.id,\n      tempChanged.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject TempControl_i_tcp_tempControl_Bridge {\n\n  var c_initialization_api: Option[TempControl_i_Initialization_Api] = None()\n  var c_operational_api: Option[TempControl_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    TempControl_i_tcp_tempControl_BridgeId : Art.BridgeId,\n    currentTemp_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    setPoint_Id : Art.PortId,\n    fanCmd_Id : Art.PortId,\n    tempChanged_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: TempControl_i_Initialization_Api,\n    operational_api: TempControl_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(currentTemp_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(fanAck_Id,\n                                              setPoint_Id,\n                                              tempChanged_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(fanCmd_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempControl_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_tcp_tempControl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanAck(api: TempControl_i_Operational_Api, value: BuildingControl.FanAck.Type): Unit = {}\n          component.handle_fanAck(operational_api, value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n\n          \/\/ implement the following in 'component':  def handle_setPoint(api: TempControl_i_Operational_Api, value: BuildingControl.SetPoint_impl): Unit = {}\n          component.handle_setPoint(operational_api, value)\n        }\n        else if(portId == tempChanged_Id) {\n          \/\/ implement the following in 'component':  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = {}\n          component.handle_tempChanged(operational_api)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: TempControl_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: TempControl_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: TempControl_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: TempControl_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: TempControl_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(TempControl_i_tcp_tempControl_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanAck_Id){\n          val Some(BuildingControl.FanAck_Payload(value)) = Art.getValue(fanAck_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanAck(api: TempControl_i_Operational_Api, value: BuildingControl.FanAck.Type): Unit = {}\n          component.handle_fanAck(operational_api, value)\n        }\n        else if(portId == setPoint_Id){\n          val Some(BuildingControl.SetPoint_impl_Payload(value)) = Art.getValue(setPoint_Id)\n\n          \/\/ implement the following in 'component':  def handle_setPoint(api: TempControl_i_Operational_Api, value: BuildingControl.SetPoint_impl): Unit = {}\n          component.handle_setPoint(operational_api, value)\n        }\n        else if(portId == tempChanged_Id) {\n          \/\/ implement the following in 'component':  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = {}\n          component.handle_tempChanged(operational_api)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/TempControl_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n@sig trait TempControl_i_Api {\n  def id: Art.BridgeId\n  def currentTemp_Id : Art.PortId\n  def fanAck_Id : Art.PortId\n  def setPoint_Id : Art.PortId\n  def fanCmd_Id : Art.PortId\n  def tempChanged_Id : Art.PortId\n\n  def put_fanCmd(value : BuildingControl.FanCmd.Type) : Unit = {\n    Art.putValue(fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class TempControl_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val fanAck_Id : Art.PortId,\n  val setPoint_Id : Art.PortId,\n  val fanCmd_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempControl_i_Api\n\n@datatype class TempControl_i_Operational_Api (\n  val id: Art.BridgeId,\n  val currentTemp_Id : Art.PortId,\n  val fanAck_Id : Art.PortId,\n  val setPoint_Id : Art.PortId,\n  val fanCmd_Id : Art.PortId,\n  val tempChanged_Id : Art.PortId) extends TempControl_i_Api {\n\n  def get_currentTemp() : Option[BuildingControl.Temperature_impl] = {\n    val value : Option[BuildingControl.Temperature_impl] = Art.getValue(currentTemp_Id) match {\n      case Some(BuildingControl.Temperature_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port currentTemp.  Expecting 'BuildingControl.Temperature_impl_Payload' but received ${v}\")\n        None[BuildingControl.Temperature_impl]()\n      case _ => None[BuildingControl.Temperature_impl]()\n    }\n    return value\n  }\n\n  def get_fanAck() : Option[BuildingControl.FanAck.Type] = {\n    val value : Option[BuildingControl.FanAck.Type] = Art.getValue(fanAck_Id) match {\n      case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\")\n        None[BuildingControl.FanAck.Type]()\n      case _ => None[BuildingControl.FanAck.Type]()\n    }\n    return value\n  }\n\n  def get_setPoint() : Option[BuildingControl.SetPoint_impl] = {\n    val value : Option[BuildingControl.SetPoint_impl] = Art.getValue(setPoint_Id) match {\n      case Some(BuildingControl.SetPoint_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port setPoint.  Expecting 'BuildingControl.SetPoint_impl_Payload' but received ${v}\")\n        None[BuildingControl.SetPoint_impl]()\n      case _ => None[BuildingControl.SetPoint_impl]()\n    }\n    return value\n  }\n\n  def get_tempChanged() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(tempChanged_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port tempChanged.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject TempControl_i_tcp_tempControl {\n\n  def initialise(api: TempControl_i_Initialization_Api): Unit = { }\n\n  def handle_fanAck(api: TempControl_i_Operational_Api, value : BuildingControl.FanAck.Type): Unit = { }\n\n  def handle_setPoint(api: TempControl_i_Operational_Api, value : BuildingControl.SetPoint_impl): Unit = { }\n\n  def handle_tempChanged(api: TempControl_i_Operational_Api): Unit = { }\n\n  def activate(api: TempControl_i_Operational_Api): Unit = { }\n\n  def deactivate(api: TempControl_i_Operational_Api): Unit = { }\n\n  def finalise(api: TempControl_i_Operational_Api): Unit = { }\n\n  def recover(api: TempControl_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/util\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport building_control_gen_mixed._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Fan_i_tcp_fan_TestApi extends BridgeTestSuite[Fan_i_tcp_fan_Bridge](Arch.BuildingControlDemo_i_Instance_tcp_fan) {\n\n  \/** helper function to set the values of all input ports.\n   * @param fanCmd payloads for event data port fanCmd.\n   *   ART currently supports single element event data queues so\n   *   only the last element of fanCmd will be used\n   *\/\n  def put_concrete_inputs(fanCmd : ISZ[BuildingControl.FanCmd.Type]): Unit = {\n    for(v <- fanCmd){\n      put_fanCmd(v)\n    }\n  }\n\n\n  \/** helper function to check Fan_i_tcp_fan's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param fanAck method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'fanAck'.\n   *\/\n  def check_concrete_output(fanAck: ISZ[BuildingControl.FanAck.Type] => B = fanAckParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var fanAckValue: ISZ[BuildingControl.FanAck.Type] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_fanAck().nonEmpty) fanAckValue = fanAckValue :+ get_fanAck().get\n    if(!fanAck(fanAckValue)) {\n      testFailures = testFailures :+ st\"'fanAck' did not match expected: received ${fanAckValue.size} events with the following payloads ${fanAckValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_fanCmd(value : BuildingControl.FanCmd.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.fanCmd_Id, BuildingControl.FanCmd_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_fanAck(): Option[BuildingControl.FanAck.Type] = {\n    val value: Option[BuildingControl.FanAck.Type] = get_fanAck_payload() match {\n      case Some(BuildingControl.FanAck_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port fanAck.  Expecting 'BuildingControl.FanAck_Payload' but received ${v}\")\n      case _ => None[BuildingControl.FanAck.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_fanAck_payload(): Option[BuildingControl.FanAck_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.fanAck_Id).asInstanceOf[Option[BuildingControl.FanAck_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/test\/bridge\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed.BuildingControl._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Fan_i_tcp_fan_Test extends Fan_i_tcp_fan_TestApi {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.{Fan_i_tcp_fan => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class Fan_i_tcp_fan_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  fanCmd: Port[BuildingControl.FanCmd.Type],\n  fanAck: Port[BuildingControl.FanAck.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(fanCmd,\n              fanAck),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(fanCmd),\n\n    eventOuts = ISZ(fanAck)\n  )\n\n  val initialization_api : Fan_i_Initialization_Api = {\n    val api = Fan_i_Initialization_Api(\n      id,\n      fanCmd.id,\n      fanAck.id\n    )\n    Fan_i_tcp_fan_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Fan_i_Operational_Api = {\n    val api = Fan_i_Operational_Api(\n      id,\n      fanCmd.id,\n      fanAck.id\n    )\n    Fan_i_tcp_fan_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Fan_i_tcp_fan_Bridge.EntryPoints(\n      id,\n\n      fanCmd.id,\n      fanAck.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Fan_i_tcp_fan_Bridge {\n\n  var c_initialization_api: Option[Fan_i_Initialization_Api] = None()\n  var c_operational_api: Option[Fan_i_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    Fan_i_tcp_fan_BridgeId : Art.BridgeId,\n    fanCmd_Id : Art.PortId,\n    fanAck_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: Fan_i_Initialization_Api,\n    operational_api: Fan_i_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(fanCmd_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(fanAck_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Fan_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_tcp_fan_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanCmd(api: Fan_i_Operational_Api, value: BuildingControl.FanCmd.Type): Unit = {}\n          component.handle_fanCmd(operational_api, value)\n        }\n      }\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: Fan_i_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: Fan_i_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: Fan_i_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: Fan_i_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: Fan_i_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      \/\/ transpiler friendly filter\n      def filter(receivedEvents: ISZ[Art.PortId], triggers: ISZ[Art.PortId]): ISZ[Art.PortId] = {\n        var r = ISZ[Art.PortId]()\n        val opsTriggers = ops.ISZOps(triggers)\n        for(e <- receivedEvents) {\n          if(opsTriggers.contains(e)) {\n            r = r :+ e\n          }\n        }\n        return r\n      }\n\n      \/\/ fetch received events ordered by highest urgency then earliest arrival-time\n      val EventTriggered(receivedEvents) = Art.dispatchStatus(Fan_i_tcp_fan_BridgeId)\n\n      \/\/ remove non-dispatching event ports\n      val dispatchableEventPorts: ISZ[Art.PortId] =\n        if(dispatchTriggers.isEmpty) receivedEvents\n        else filter(receivedEvents, dispatchTriggers.get)\n\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      for(portId <- dispatchableEventPorts) {\n        if(portId == fanCmd_Id){\n          val Some(BuildingControl.FanCmd_Payload(value)) = Art.getValue(fanCmd_Id)\n\n          \/\/ implement the following in 'component':  def handle_fanCmd(api: Fan_i_Operational_Api, value: BuildingControl.FanCmd.Type): Unit = {}\n          component.handle_fanCmd(operational_api, value)\n        }\n      }\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/bridge\/building_control_gen_mixed\/BuildingControl\/Fan_i_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\n@sig trait Fan_i_Api {\n  def id: Art.BridgeId\n  def fanCmd_Id : Art.PortId\n  def fanAck_Id : Art.PortId\n\n  def put_fanAck(value : BuildingControl.FanAck.Type) : Unit = {\n    Art.putValue(fanAck_Id, BuildingControl.FanAck_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Fan_i_Initialization_Api (\n  val id: Art.BridgeId,\n  val fanCmd_Id : Art.PortId,\n  val fanAck_Id : Art.PortId) extends Fan_i_Api\n\n@datatype class Fan_i_Operational_Api (\n  val id: Art.BridgeId,\n  val fanCmd_Id : Art.PortId,\n  val fanAck_Id : Art.PortId) extends Fan_i_Api {\n\n  def get_fanCmd() : Option[BuildingControl.FanCmd.Type] = {\n    val value : Option[BuildingControl.FanCmd.Type] = Art.getValue(fanCmd_Id) match {\n      case Some(BuildingControl.FanCmd_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port fanCmd.  Expecting 'BuildingControl.FanCmd_Payload' but received ${v}\")\n        None[BuildingControl.FanCmd.Type]()\n      case _ => None[BuildingControl.FanCmd.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport building_control_gen_mixed._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Fan_i_tcp_fan {\n\n  def initialise(api: Fan_i_Initialization_Api): Unit = { }\n\n  def handle_fanCmd(api: Fan_i_Operational_Api, value : BuildingControl.FanCmd.Type): Unit = { }\n\n  def activate(api: Fan_i_Operational_Api): Unit = { }\n\n  def deactivate(api: Fan_i_Operational_Api): Unit = { }\n\n  def finalise(api: Fan_i_Operational_Api): Unit = { }\n\n  def recover(api: Fan_i_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/component\/building_control_gen_mixed\/TranspilerToucher.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/TempSensor_i_tcp_tempSensor\/tempSensor.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.TempSensor_i_tcp_tempSensor\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_seL4Nix\n\nobject tempSensor extends App {\n\n  val tempSensorBridge : building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp\", mode = DataOut)\n    val tempChanged = Port[art.Empty] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempSensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      tempChanged = tempChanged\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = tempSensorBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ currentTemp: Out DataPort BuildingControl.Temperature_impl\n  val currentTemp_id: Art.PortId = tempSensorBridge.currentTemp.id\n  var currentTemp_port: Option[DataContent] = noData\n\n  \/\/ tempChanged: Out EventPort art.Empty\n  val tempChanged_id: Art.PortId = tempSensorBridge.tempChanged.id\n  var tempChanged_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    halt(s\"Unexpected: tempSensor.getValue called with: ${portId}\")\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == currentTemp_id) {\n      currentTemp_port = Some(data)\n    } else if(portId == tempChanged_id) {\n      tempChanged_port = Some(data)\n    } else {\n      halt(s\"Unexpected: tempSensor.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(currentTemp_port.nonEmpty) {\n      TempSensor_i_tcp_tempSensor_seL4Nix.currentTemp_Send(currentTemp_port.get)\n      currentTemp_port = noData\n    }\n\n    if(tempChanged_port.nonEmpty) {\n      TempSensor_i_tcp_tempSensor_seL4Nix.tempChanged_Send(tempChanged_port.get)\n      tempChanged_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_example()))\n      printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n      printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.example()))\n      printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example()))\n      printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n      printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.logError(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.logError(\"\")\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.put_currentTemp(BuildingControl.Temperature_impl.example())\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.put_currentTemp(BuildingControl.Temperature_impl.example())\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_initialization_api.get.put_tempChanged()\n      building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor_Bridge.c_operational_api.get.put_tempChanged()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(tempSensorBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(tempSensorBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(tempSensorBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object TempSensor_i_tcp_tempSensor_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's currentTemp port\n  def currentTemp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's tempChanged port\n  def tempChanged_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempSensor_i_tcp_tempSensor_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject TempSensor_i_tcp_tempSensor_seL4Nix_Ext {\n  def currentTemp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def tempChanged_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPSENSOR_I_TCP_TEMPSENSOR_H\n#define TEMPSENSOR_I_TCP_TEMPSENSOR_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempSensor_i_tcp_tempSensor_api.h>\n#include <TempSensor_i_tcp_tempSensor.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"BuildingControlDemo_i_Instance_tcp_tempSensor\";\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  DeclNewbuilding_control_gen_mixed_BuildingControl_Temperature_impl(t0);\n  building_control_gen_mixed_BuildingControl_Temperature_impl_example(SF &t0);\n  api_put_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(SF &t0);\n\n  api_put_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(SF_LAST);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(SF string(\"Example logInfo\"));\n\n  api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(SF string(\"Example logDebug\"));\n\n  api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise_\", 0);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered_\", 0);\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPSENSOR_I_TCP_TEMPSENSOR_API_H\n#define TEMPSENSOR_I_TCP_TEMPSENSOR_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Temperature_impl value);\n\nvoid api_put_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(STACK_FRAME_ONLY);\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempSensor_i_tcp_tempSensor_api.h>\n#include <TempSensor_i_tcp_tempSensor.h>\n\nstatic bool apis_initialized = false;\nstatic struct building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api initialization_api;\nstatic struct building_control_gen_mixed_BuildingControl_TempSensor_i_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_268D1A = Option[building_control_gen_mixed.BuildingControl.TempSensor_i_Initialization_Api]\n  Option_268D1A_get_(SF (building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api) &initialization_api, building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_D27A05 = Option[building_control_gen_mixed.BuildingControl.TempSensor_i_Operational_Api]\n  Option_D27A05_get_(SF (building_control_gen_mixed_BuildingControl_TempSensor_i_Operational_Api) &operational_api, building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Temperature_impl value) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"api_put_currentTemp__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api_put_currentTemp_(\n    SF\n    &initialization_api,\n    value);\n}\n\nvoid api_put_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"api_put_tempChanged__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api_put_tempChanged_(\n    SF\n    &initialization_api);\n}\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"api_logInfo__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"api_logDebug__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"api_logError__building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_initialise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Operational_Api api) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_finalise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempSensor_i_Operational_Api api) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempSensor_i_tcp_tempSensor_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseArchitecture\", 0);\n\n  building_control_gen_mixed_TempSensor_i_tcp_tempSensor_tempSensor_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseEntryPoint\", 0);\n\n  building_control_gen_mixed_TempSensor_i_tcp_tempSensor_tempSensor_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_computeEntryPoint\", 0);\n\n  building_control_gen_mixed_TempSensor_i_tcp_tempSensor_tempSensor_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempSensor_i_tcp_tempSensor_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_entryPoints\", 0);\n\n  return building_control_gen_mixed_TempSensor_i_tcp_tempSensor_tempSensor_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPSENSOR_I_TCP_TEMPSENSOR_ADAPTER_H\n#define TEMPSENSOR_I_TCP_TEMPSENSOR_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/settings_TempSensor_i_tcp_tempSensor.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(TempSensor_i_tcp_tempSensor\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/TempControl_i_tcp_tempControl\/tempControl.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.TempControl_i_tcp_tempControl\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_seL4Nix\n\nobject tempControl extends App {\n\n  val tempControlBridge : building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge = {\n    val currentTemp = Port[BuildingControl.Temperature_impl] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp\", mode = DataIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanAck\", mode = EventIn)\n    val setPoint = Port[BuildingControl.SetPoint_impl] (id = 2, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_setPoint\", mode = EventIn)\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 3, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd\", mode = EventOut)\n    val tempChanged = Port[art.Empty] (id = 4, name = \"BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged\", mode = EventIn)\n\n    building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_tempControl\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      currentTemp = currentTemp,\n      fanAck = fanAck,\n      setPoint = setPoint,\n      fanCmd = fanCmd,\n      tempChanged = tempChanged\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = tempControlBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ currentTemp: In DataPort BuildingControl.Temperature_impl\n  val currentTemp_id: Art.PortId = tempControlBridge.currentTemp.id\n  var currentTemp_port: Option[DataContent] = noData\n\n  \/\/ fanAck: In EventDataPort BuildingControl.FanAck\n  val fanAck_id: Art.PortId = tempControlBridge.fanAck.id\n  var fanAck_port: Option[DataContent] = noData\n\n  \/\/ setPoint: In EventDataPort BuildingControl.SetPoint_impl\n  val setPoint_id: Art.PortId = tempControlBridge.setPoint.id\n  var setPoint_port: Option[DataContent] = noData\n\n  \/\/ fanCmd: Out EventDataPort BuildingControl.FanCmd\n  val fanCmd_id: Art.PortId = tempControlBridge.fanCmd.id\n  var fanCmd_port: Option[DataContent] = noData\n\n  \/\/ tempChanged: In EventPort art.Empty\n  val tempChanged_id: Art.PortId = tempControlBridge.tempChanged.id\n  var tempChanged_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    var portIds: ISZ[Art.PortId] = ISZ()\n    if(!TempControl_i_tcp_tempControl_seL4Nix.fanAck_IsEmpty()) {\n      portIds = portIds :+ fanAck_id\n    }\n    if(!TempControl_i_tcp_tempControl_seL4Nix.setPoint_IsEmpty()) {\n      portIds = portIds :+ setPoint_id\n    }\n    if(!TempControl_i_tcp_tempControl_seL4Nix.tempChanged_IsEmpty()) {\n      portIds = portIds :+ tempChanged_id\n    }\n    return EventTriggered(portIds)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == currentTemp_id) {\n      return currentTemp_port\n    } else if(portId == fanAck_id) {\n      return fanAck_port\n    } else if(portId == setPoint_id) {\n      return setPoint_port\n    } else if(portId == tempChanged_id) {\n      return tempChanged_port\n    } else {\n      halt(s\"Unexpected: tempControl.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    currentTemp_port = TempControl_i_tcp_tempControl_seL4Nix.currentTemp_Receive()\n\n    fanAck_port = TempControl_i_tcp_tempControl_seL4Nix.fanAck_Receive()\n\n    setPoint_port = TempControl_i_tcp_tempControl_seL4Nix.setPoint_Receive()\n\n    tempChanged_port = TempControl_i_tcp_tempControl_seL4Nix.tempChanged_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == fanCmd_id) {\n      fanCmd_port = Some(data)\n    } else {\n      halt(s\"Unexpected: tempControl.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(fanCmd_port.nonEmpty) {\n      TempControl_i_tcp_tempControl_seL4Nix.fanCmd_Send(fanCmd_port.get)\n      fanCmd_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_example()))\n      printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n      printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.example()))\n      printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example()))\n      printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n      printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.logError(\"\")\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_currentTemp: Option[BuildingControl.Temperature_impl] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_currentTemp()\n      val apiUsage_fanAck: Option[BuildingControl.FanAck.Type] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_fanAck()\n      val apiUsage_setPoint: Option[BuildingControl.SetPoint_impl] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_setPoint()\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_initialization_api.get.put_fanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n      building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.put_fanCmd(BuildingControl.FanCmd.byOrdinal(0).get)\n      val apiUsage_tempChanged: Option[art.Empty] = building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl_Bridge.c_operational_api.get.get_tempChanged()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(tempControlBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(tempControlBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(tempControlBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object TempControl_i_tcp_tempControl_seL4Nix {\n  \/\/ returns T if seL4's currentTemp port is empty, F otherwise \n  def currentTemp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's currentTemp port \n  def currentTemp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's fanAck port is empty, F otherwise \n  def fanAck_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's fanAck port \n  def fanAck_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's setPoint port is empty, F otherwise \n  def setPoint_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's setPoint port \n  def setPoint_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's fanCmd port\n  def fanCmd_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's tempChanged port is empty, F otherwise \n  def tempChanged_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's tempChanged port \n  def tempChanged_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/TempControl_i_tcp_tempControl_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject TempControl_i_tcp_tempControl_seL4Nix_Ext {\n  def currentTemp_IsEmpty(): B = halt(\"stub\")\n\n  def currentTemp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanAck_IsEmpty(): B = halt(\"stub\")\n\n  def fanAck_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def setPoint_IsEmpty(): B = halt(\"stub\")\n\n  def setPoint_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanCmd_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def tempChanged_IsEmpty(): B = halt(\"stub\")\n\n  def tempChanged_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPCONTROL_I_TCP_TEMPCONTROL_H\n#define TEMPCONTROL_I_TCP_TEMPCONTROL_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type value);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempControl_i_tcp_tempControl_api.h>\n#include <TempControl_i_tcp_tempControl.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"BuildingControlDemo_i_Instance_tcp_tempControl\";\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  building_control_gen_mixed_BuildingControl_FanCmd_Type t0 = building_control_gen_mixed_BuildingControl_FanCmd_Type_On;\n  api_put_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF t0);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF string(\"Example logInfo\"));\n\n  api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF string(\"Example logDebug\"));\n\n  api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise_\", 0);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type value) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck called\\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(fanAckString);\n  String__append(SF (String) &fanAckString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl (SF (String) &fanAckString);\n  *\/\n\n  printf(\"%s: Received data on event data port fanAck: \\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(_str);\n  String__append(SF (String) &_str, string(\"Received on fanAck: \"));\n  building_control_gen_mixed_BuildingControl_FanAck_Type_string_(SF (String) &_str, value);\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF (String) &_str);\n  *\/\n\n  \/\/ examples of api getter usage\n\n  DeclNewbuilding_control_gen_mixed_BuildingControl_Temperature_impl(t0);\n  if(api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF &t0)) {\n    printf(\"%s: Received data on data port currentTemp: \\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(currentTemp_str);\n    String__append(SF (String) &currentTemp_str, string(\"Received data on data port currentTemp: \"));\n    building_control_gen_mixed_BuildingControl_Temperature_impl_string_(SF (String) &currentTemp_str, &t0);\n    api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF (String) &currentTemp_str);\n    *\/\n  }\n\n  building_control_gen_mixed_BuildingControl_FanAck_Type t1;\n  if(api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF &t1)) {\n    printf(\"%s: Received data on event data port fanAck: \\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(fanAck_str);\n    String__append(SF (String) &fanAck_str, string(\"Received data on event data port fanAck: \"));\n    building_control_gen_mixed_BuildingControl_FanAck_Type_string_(SF (String) &fanAck_str, t1);\n    api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF (String) &fanAck_str);\n    *\/\n  }\n\n  DeclNewbuilding_control_gen_mixed_BuildingControl_SetPoint_impl(t2);\n  if(api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF &t2)) {\n    printf(\"%s: Received data on event data port setPoint: \\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(setPoint_str);\n    String__append(SF (String) &setPoint_str, string(\"Received data on event data port setPoint: \"));\n    building_control_gen_mixed_BuildingControl_SetPoint_impl_string_(SF (String) &setPoint_str, &t2);\n    api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF (String) &setPoint_str);\n    *\/\n  }\n\n  if(api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF_LAST )){\n    printf(\"%s: Received event on tempChanged\\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    String tempChanged_str = string(\"Received event on event port tempChanged\");\n    api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF tempChanged_str);\n    *\/\n  }\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint called\\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(setPointString);\n  String__append(SF (String) &setPointString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl (SF (String) &setPointString);\n  *\/\n\n  printf(\"%s: Received data on event data port setPoint: \\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(_str);\n  String__append(SF (String) &_str, string(\"Received on setPoint: \"));\n  building_control_gen_mixed_BuildingControl_SetPoint_impl_string_(SF (String) &_str, value);\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF (String) &_str);\n  *\/\n\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged called\\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(tempChangedString);\n  String__append(SF (String) &tempChangedString, string(\"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl (SF (String) &tempChangedString);\n  *\/\n\n  printf(\"%s: Received event on event port tempChanged: \\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  String str = string(\"Received event on tempChanged\");\n  api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(SF str);\n  *\/\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPCONTROL_I_TCP_TEMPCONTROL_API_H\n#define TEMPCONTROL_I_TCP_TEMPCONTROL_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Temperature_impl value);\n\nbool api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type *value);\n\nbool api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value);\n\nvoid api_put_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type value);\n\nbool api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(STACK_FRAME_ONLY);\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempControl_i_tcp_tempControl_api.h>\n#include <TempControl_i_tcp_tempControl.h>\n\nstatic bool apis_initialized = false;\nstatic struct building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api initialization_api;\nstatic struct building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_DF5CF0 = Option[building_control_gen_mixed.BuildingControl.TempControl_i_Initialization_Api]\n  Option_DF5CF0_get_(SF (building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api) &initialization_api, building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_0B5BF7 = Option[building_control_gen_mixed.BuildingControl.TempControl_i_Operational_Api]\n  Option_0B5BF7_get_(SF (building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api) &operational_api, building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Temperature_impl value){\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_get_currentTemp__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_798EF5 = Option[building_control_gen_mixed.BuildingControl.Temperature_impl]\n  \/\/ Some_BE9CDE = Some[building_control_gen_mixed.BuildingControl.Temperature_impl]\n  DeclNewOption_798EF5(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api_get_currentTemp_(\n    SF\n    (Option_798EF5) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_BE9CDE){\n    Type_assign(value, &t_0.Some_BE9CDE.value, sizeof(struct building_control_gen_mixed_BuildingControl_Temperature_impl));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type *value){\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_get_fanAck__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_4CF4EB = Option[building_control_gen_mixed.BuildingControl.FanAck.Type]\n  \/\/ Some_132C1C = Some[building_control_gen_mixed.BuildingControl.FanAck.Type]\n  DeclNewOption_4CF4EB(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api_get_fanAck_(\n    SF\n    (Option_4CF4EB) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_132C1C){\n    *value = t_0.Some_132C1C.value;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value){\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_get_setPoint__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_D2E008 = Option[building_control_gen_mixed.BuildingControl.SetPoint_impl]\n  \/\/ Some_503278 = Some[building_control_gen_mixed.BuildingControl.SetPoint_impl]\n  DeclNewOption_D2E008(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api_get_setPoint_(\n    SF\n    (Option_D2E008) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_503278){\n    Type_assign(value, &t_0.Some_503278.value, sizeof(struct building_control_gen_mixed_BuildingControl_SetPoint_impl));\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type value) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_put_fanCmd__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api_put_fanCmd_(\n    SF\n    &initialization_api,\n    value);\n}\n\nbool api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(STACK_FRAME_ONLY){\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_get_tempChanged__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_C622DB = Option[art.Empty]\n  \/\/ Some_4782C6 = Some[art.Empty]\n  DeclNewOption_C622DB(t_0);\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api_get_tempChanged_(\n    SF\n    (Option_C622DB) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_4782C6){\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_logInfo__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_logDebug__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"api_logError__building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_initialise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api api) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_finalise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api api,\n  building_control_gen_mixed_BuildingControl_FanAck_Type value) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_fanAck_(SF value);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api api,\n  building_control_gen_mixed_BuildingControl_SetPoint_impl value) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_setPoint_(SF value);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_TempControl_i_Operational_Api api) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged\", 0);\n\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_handle_tempChanged_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <TempControl_i_tcp_tempControl_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseArchitecture\", 0);\n\n  building_control_gen_mixed_TempControl_i_tcp_tempControl_tempControl_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseEntryPoint\", 0);\n\n  building_control_gen_mixed_TempControl_i_tcp_tempControl_tempControl_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_computeEntryPoint\", 0);\n\n  building_control_gen_mixed_TempControl_i_tcp_tempControl_tempControl_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"TempControl_i_tcp_tempControl_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_entryPoints\", 0);\n\n  return building_control_gen_mixed_TempControl_i_tcp_tempControl_tempControl_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef TEMPCONTROL_I_TCP_TEMPCONTROL_ADAPTER_H\n#define TEMPCONTROL_I_TCP_TEMPCONTROL_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/settings_TempControl_i_tcp_tempControl.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(TempControl_i_tcp_tempControl\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/Fan_i_tcp_fan\/fan.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.Fan_i_tcp_fan\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport building_control_gen_mixed._\nimport building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_seL4Nix\n\nobject fan extends App {\n\n  val fanBridge : building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge = {\n    val fanCmd = Port[BuildingControl.FanCmd.Type] (id = 0, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanCmd\", mode = EventIn)\n    val fanAck = Port[BuildingControl.FanAck.Type] (id = 1, name = \"BuildingControlDemo_i_Instance_tcp_fan_fanAck\", mode = EventOut)\n\n    building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge(\n      id = 0,\n      name = \"BuildingControlDemo_i_Instance_tcp_fan\",\n      dispatchProtocol = Sporadic(min = 1000),\n      dispatchTriggers = None(),\n\n      fanCmd = fanCmd,\n      fanAck = fanAck\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = fanBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ fanCmd: In EventDataPort BuildingControl.FanCmd\n  val fanCmd_id: Art.PortId = fanBridge.fanCmd.id\n  var fanCmd_port: Option[DataContent] = noData\n\n  \/\/ fanAck: Out EventDataPort BuildingControl.FanAck\n  val fanAck_id: Art.PortId = fanBridge.fanAck.id\n  var fanAck_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    var portIds: ISZ[Art.PortId] = ISZ()\n    if(!Fan_i_tcp_fan_seL4Nix.fanCmd_IsEmpty()) {\n      portIds = portIds :+ fanCmd_id\n    }\n    return EventTriggered(portIds)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == fanCmd_id) {\n      return fanCmd_port\n    } else {\n      halt(s\"Unexpected: fan.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    fanCmd_port = Fan_i_tcp_fan_seL4Nix.fanCmd_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == fanAck_id) {\n      fanAck_port = Some(data)\n    } else {\n      halt(s\"Unexpected: fan.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(fanAck_port.nonEmpty) {\n      Fan_i_tcp_fan_seL4Nix.fanAck_Send(fanAck_port.get)\n      fanAck_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_example()))\n      printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n      printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.example()))\n      printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example()))\n      printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n      printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.logError(\"\")\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logInfo(\"\")\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logDebug(\"\")\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_fanCmd: Option[BuildingControl.FanCmd.Type] = building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.get_fanCmd()\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_initialization_api.get.put_fanAck(BuildingControl.FanAck.byOrdinal(0).get)\n      building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan_Bridge.c_operational_api.get.put_fanAck(BuildingControl.FanAck.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(fanBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(fanBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(fanBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\n@ext object Fan_i_tcp_fan_seL4Nix {\n  \/\/ returns T if seL4's fanCmd port is empty, F otherwise \n  def fanCmd_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's fanCmd port \n  def fanCmd_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's fanAck port\n  def fanAck_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl\/Fan_i_tcp_fan_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package building_control_gen_mixed.BuildingControl\n\nimport org.sireum._\nimport art._\n\nobject Fan_i_tcp_fan_seL4Nix_Ext {\n  def fanCmd_IsEmpty(): B = halt(\"stub\")\n\n  def fanCmd_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def fanAck_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FAN_I_TCP_FAN_H\n#define FAN_I_TCP_FAN_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise_(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type value);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan.c",
        {
          "type" : "ITestResource",
          "content" : "#include <Fan_i_tcp_fan_api.h>\n#include <Fan_i_tcp_fan.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"BuildingControlDemo_i_Instance_tcp_fan\";\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  building_control_gen_mixed_BuildingControl_FanAck_Type t0 = building_control_gen_mixed_BuildingControl_FanAck_Type_Ok;\n  api_put_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF t0);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF string(\"Example logInfo\"));\n\n  api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF string(\"Example logDebug\"));\n\n  api_logError__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise_\", 0);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd_(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type value) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd_\", 0);\n\n  printf(\"%s: building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd called\\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(fanCmdString);\n  String__append(SF (String) &fanCmdString, string(\"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd called\"));\n  api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan (SF (String) &fanCmdString);\n  *\/\n\n  printf(\"%s: Received data on event data port fanCmd: \\n\", component_id);\n\n  \/* alternative using logInfo.  Commented out as the constructed String may be too large\n  DeclNewString(_str);\n  String__append(SF (String) &_str, string(\"Received on fanCmd: \"));\n  building_control_gen_mixed_BuildingControl_FanCmd_Type_string_(SF (String) &_str, value);\n  api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF (String) &_str);\n  *\/\n\n  \/\/ examples of api getter usage\n\n  building_control_gen_mixed_BuildingControl_FanCmd_Type t0;\n  if(api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF &t0)) {\n    printf(\"%s: Received data on event data port fanCmd: \\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(fanCmd_str);\n    String__append(SF (String) &fanCmd_str, string(\"Received data on event data port fanCmd: \"));\n    building_control_gen_mixed_BuildingControl_FanCmd_Type_string_(SF (String) &fanCmd_str, t0);\n    api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(SF (String) &fanCmd_str);\n    *\/\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FAN_I_TCP_FAN_API_H\n#define FAN_I_TCP_FAN_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type *value);\n\nvoid api_put_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type value);\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <Fan_i_tcp_fan_api.h>\n#include <Fan_i_tcp_fan.h>\n\nstatic bool apis_initialized = false;\nstatic struct building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api initialization_api;\nstatic struct building_control_gen_mixed_BuildingControl_Fan_i_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_D50FAD = Option[building_control_gen_mixed.BuildingControl.Fan_i_Initialization_Api]\n  Option_D50FAD_get_(SF (building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api) &initialization_api, building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_764FA1 = Option[building_control_gen_mixed.BuildingControl.Fan_i_Operational_Api]\n  Option_764FA1_get_(SF (building_control_gen_mixed_BuildingControl_Fan_i_Operational_Api) &operational_api, building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanCmd_Type *value){\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"api_get_fanCmd__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_4B44C1 = Option[building_control_gen_mixed.BuildingControl.FanCmd.Type]\n  \/\/ Some_A25D33 = Some[building_control_gen_mixed.BuildingControl.FanCmd.Type]\n  DeclNewOption_4B44C1(t_0);\n  building_control_gen_mixed_BuildingControl_Fan_i_Operational_Api_get_fanCmd_(\n    SF\n    (Option_4B44C1) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_A25D33){\n    *value = t_0.Some_A25D33.value;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_FanAck_Type value) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"api_put_fanAck__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api_put_fanAck_(\n    SF\n    &initialization_api,\n    value);\n}\n\nvoid api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"api_logInfo__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"api_logDebug__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"api_logError__building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Fan_i_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise\", 0);\n\n  building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_initialise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Fan_i_Operational_Api api) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise\", 0);\n\n  building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_finalise_(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd(\n  STACK_FRAME\n  building_control_gen_mixed_BuildingControl_Fan_i_Operational_Api api,\n  building_control_gen_mixed_BuildingControl_FanCmd_Type value) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_api.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd\", 0);\n\n  building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_handle_fanCmd_(SF value);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Fan_i_tcp_fan\/Fan_i_tcp_fan_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <Fan_i_tcp_fan_adapter.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseArchitecture\", 0);\n\n  building_control_gen_mixed_Fan_i_tcp_fan_fan_initialiseArchitecture(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseEntryPoint\", 0);\n\n  building_control_gen_mixed_Fan_i_tcp_fan_fan_initialiseEntryPoint(SF_LAST);\n}\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_computeEntryPoint\", 0);\n\n  building_control_gen_mixed_Fan_i_tcp_fan_fan_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Fan_i_tcp_fan_adapter.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_entryPoints\", 0);\n\n  return building_control_gen_mixed_Fan_i_tcp_fan_fan_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Fan_i_tcp_fan\/Fan_i_tcp_fan_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FAN_I_TCP_FAN_ADAPTER_H\n#define FAN_I_TCP_FAN_ADAPTER_H\n\n#include <all.h>\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/settings_Fan_i_tcp_fan.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Fan_i_tcp_fan\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "ITestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n#endif",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/seL4Nix\/building_control_gen_mixed\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage building_control_gen_mixed.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport building_control_gen_mixed._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_example()))\n    printDataContent(BuildingControl.TempUnit_Payload(BuildingControl.TempUnit.byOrdinal(0).get))\n    printDataContent(BuildingControl.Temperature_impl_Payload(BuildingControl.Temperature_impl.example()))\n    printDataContent(BuildingControl.SetPoint_impl_Payload(BuildingControl.SetPoint_impl.example()))\n    printDataContent(BuildingControl.FanAck_Payload(BuildingControl.FanAck.byOrdinal(0).get))\n    printDataContent(BuildingControl.FanCmd_Payload(BuildingControl.FanCmd.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/transpile-sel4.cmd",
        {
          "type" : "ITestResource",
          "content" : "::#! 2> \/dev\/null                                   #\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\nif [ -z ${SIREUM_HOME} ]; then                      #\n  echo \"Please set SIREUM_HOME env var\"             #\n  exit -1                                           #\nfi                                                  #\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\n:BOF\nsetlocal\nif not defined SIREUM_HOME (\n  echo Please set SIREUM_HOME env var\n  exit \/B -1\n)\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\nexit \/B %errorlevel%\n::!#\n\/\/ #Sireum\n\nimport org.sireum._\n\n\/\/ This file was auto-generated.  Do not edit\n\nval SCRIPT_HOME: Os.Path = Os.slashDir\nval PATH_SEP: String = Os.pathSep\n\nval TempSensor_i_tcp_tempSensor: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/TempSensor_i_tcp_tempSensor\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/TempSensor_i_tcp_tempSensor\",\n  \"--name\", \"TempSensor_i_tcp_tempSensor\",\n  \"--apps\", \"building_control_gen_mixed.TempSensor_i_tcp_tempSensor.tempSensor\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"64\",\n  \"--string-size\", \"300\",\n  \"--sequence-size\", \"2\",\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=2\",\n  \"--constants\", s\"art.Art.maxComponents=1;art.Art.maxPorts=2\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_TempSensor_i_tcp_tempSensor.cmake\",\n  \"--forward\", \"art.ArtNative=building_control_gen_mixed.TempSensor_i_tcp_tempSensor.tempSensor\",\n  \"--stack-size\", \"114688\",\n  \"--stable-type-id\",\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor_adapter.c\",\n  \"--exclude-build\", \"building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor,building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl,building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan\",\n  \"--lib-only\")\n\nval TempControl_i_tcp_tempControl: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/TempControl_i_tcp_tempControl\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/TempControl_i_tcp_tempControl\",\n  \"--name\", \"TempControl_i_tcp_tempControl\",\n  \"--apps\", \"building_control_gen_mixed.TempControl_i_tcp_tempControl.tempControl\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"64\",\n  \"--string-size\", \"300\",\n  \"--sequence-size\", \"5\",\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=5\",\n  \"--constants\", s\"art.Art.maxComponents=1;art.Art.maxPorts=5\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_TempControl_i_tcp_tempControl.cmake\",\n  \"--forward\", \"art.ArtNative=building_control_gen_mixed.TempControl_i_tcp_tempControl.tempControl\",\n  \"--stack-size\", \"114688\",\n  \"--stable-type-id\",\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl_adapter.c\",\n  \"--exclude-build\", \"building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor,building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl,building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan\",\n  \"--lib-only\")\n\nval Fan_i_tcp_fan: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/BuildingControl${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/Fan_i_tcp_fan\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Fan_i_tcp_fan\",\n  \"--name\", \"Fan_i_tcp_fan\",\n  \"--apps\", \"building_control_gen_mixed.Fan_i_tcp_fan.fan\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"64\",\n  \"--string-size\", \"300\",\n  \"--sequence-size\", \"2\",\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=2\",\n  \"--constants\", s\"art.Art.maxComponents=1;art.Art.maxPorts=2\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_Fan_i_tcp_fan.cmake\",\n  \"--forward\", \"art.ArtNative=building_control_gen_mixed.Fan_i_tcp_fan.fan\",\n  \"--stack-size\", \"114688\",\n  \"--stable-type-id\",\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/Fan_i_tcp_fan\/Fan_i_tcp_fan_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Fan_i_tcp_fan\/Fan_i_tcp_fan_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Fan_i_tcp_fan\/Fan_i_tcp_fan_adapter.c\",\n  \"--exclude-build\", \"building_control_gen_mixed.BuildingControl.TempSensor_i_tcp_tempSensor,building_control_gen_mixed.BuildingControl.TempControl_i_tcp_tempControl,building_control_gen_mixed.BuildingControl.Fan_i_tcp_fan\",\n  \"--lib-only\")\n\nval SlangTypeLibrary: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/building_control_gen_mixed\/SlangTypeLibrary\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\",\n  \"--name\", \"SlangTypeLibrary\",\n  \"--apps\", \"building_control_gen_mixed.SlangTypeLibrary.SlangTypeLibrary\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"64\",\n  \"--string-size\", \"300\",\n  \"--sequence-size\", \"1\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\",\n  \"--forward\", \"art.ArtNative=building_control_gen_mixed.SlangTypeLibrary.SlangTypeLibrary\",\n  \"--stack-size\", \"16777216\",\n  \"--stable-type-id\",\n  \"--lib-only\")\n\nval projects: ISZ[ISZ[String]] = ISZ(\n  TempSensor_i_tcp_tempSensor,\n  TempControl_i_tcp_tempControl,\n  Fan_i_tcp_fan,\n  SlangTypeLibrary\n)\n\nprintln(\"Initializing runtime library ...\")\nSireum.initRuntimeLibrary()\n\nfor(p <- projects) {\n  Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\n}\n\n\/\/ops.ISZOps(projects).parMap(p =>\n\/\/  Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\n\/\/)\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: ISZ[Bridge],\n                                        connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n\n    def testInitialise(): Unit = { println(\"Default testInitialise\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 3\n  val maxPorts: PortId = 9\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, Option[Bridge]] = MS.create[BridgeId, Option[Bridge]](maxComponents, None[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val Some(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ call ArtNative to reset the state of the specific thread component\n    ArtNative.initTest(bridge)\n  }\n\n \/**\n * Executes a component (identified by bridge) Initialize Entry Point (application code)\n * for the purposes of unit testing.\n *\n * This infrastructure method is called with automatically generated unit testing support code.\n * The developer-facing version of this method (called by a developer unit test)\n * provided by the unit testing support code hides the bridge argument.  The bridge\n * value is retrieved from the testing infrastructure code before passing the call\n * through to this method.\n *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    ArtNative.testInitialise(bridge)\n  }\n\n \/**\n  * Executes a component (identified by bridge) Compute Entry Point (application code)\n  * for the purposes of unit testing.\n  *\n  * This infrastructure method is called with automatically generated unit testing support code.\n  * The developer-facing version of this method (called by a developer unit test)\n  * provided by the unit testing support code hides the bridge argument.  The bridge\n  * value is retrieved from the testing infrastructure code before passing the call\n  * through to this method.\n  *\/\n  def testCompute(bridge: Bridge): Unit = {\n    ArtNative.testCompute(bridge)\n  }\n\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n\n  \/\/ JH: Refactored - manually added method to support\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeInPortValue(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Initialize Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: testInit() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a postlude to each test.\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  \/\/ ** Manually added method by JH to support debugging interface\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\n\nobject ArtSlangMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Art.PortId,\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for(e <- eventIns) {\n          if(inInfrastructurePorts.contains(e.id)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  def lt(a : art.UPort,b : art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if(sorted.isEmpty) { return ISZ(p) }\n      else {\n        if(lt(sorted(0), p)) { return sorted(0) +: insert(p, ops.ISZOps(sorted).tail) }\n        else { return p +: sorted }\n      }\n    }\n    if(ports.isEmpty) { return ports}\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds: ISZ[Art.PortId] =\n          for(p <- Art.bridges(bridgeId).get.ports.eventIns if inInfrastructurePorts.get(p.id).nonEmpty) yield p.id\n\n        if(portIds.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(for(p <- portIds) yield Art.port(p))\n        EventTriggered(for(p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId, data))\n          inPortVariables = inPortVariables + (portId ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = ArtSlangMessage.UNSET_PORT, sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if(inPortVariables.contains(portId)) {\n      return Some(inPortVariables.get(portId).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET_PORT,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET_PORT,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when sendOutput transferred message from out port var of producer\n                       var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: ISZ[Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = ISZ()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val inPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val outPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId \/\/ dequeue from infrastructure port\n          inPortVariables(portId) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n          outPortVariables -= srcPortId\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId;\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id).filter(inInfrastructurePorts.get(_).nonEmpty): _*)\n        val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(urgentFifo)\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    Console.out.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Sets up the state of a thread component (identified by bridge) for the purpose of\n   * testing.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n \/**\n  * Executes the application code in the Initialize Entry Point for the component (identified\n  * by given bridge) for the purposes of testing.  This is achieved by\n  * calling the testInitialise() method on given bridge.\n  *\n  * Precondition: initTest() has been called prior.\n  *\n  * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n  * This is to ensure no exceptions are overlooked during testing.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    bridge.entryPoints.testInitialise()\n  }\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.  This is achieved by\n   * calling the testCompute() method on given bridge.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ cancel pending ArtTimer callbacks (also done before a test begins)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/\/ Manually added method to support debugging framework\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@sig trait TimerCallback {\n  def callback(): Unit\n}\n\n@ext object ArtTimer {\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = $\n\n  \/\/ if transpiling then use this version as transpiler does not support function passing\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = $\n\n  def cancel(id: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum.S64._\nimport org.sireum.{B, F, String}\n\nimport java.util.concurrent.{Executors, TimeUnit}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtTimer_Ext {\n\n  protected[art] val scheduledCallbacks: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  private val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def cancel(id: String): Unit = {\n    scheduledCallbacks.get(id) match {\n      case Some(b) =>\n        val userRequested = b.get()\n        b.set(false)\n        scheduledCallbacks.remove(id)\n        if (userRequested) {\n          ArtNative.logInfo(Art.logTitle, s\"Callback cleared for $id\")\n        }\n      case _ =>\n    }\n  }\n\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = {\n    schedule(id, replaceExisting, delay, callback.callback _)\n  }\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = {\n    if (scheduledCallbacks.get(id).nonEmpty) {\n      if (!replaceExisting) {\n        ArtNative.logInfo(Art.logTitle, s\"Callback already scheduled for $id\")\n      } else {\n        cancel(id)\n      }\n      return\n    }\n\n    if (delay < s64\"0\") {\n      ArtNative.logInfo(Art.logTitle, s\"Invalid delay time: ${delay}.  Value must be non-negative.\")\n      return\n    }\n\n    val shouldInvokeCallback = new AtomicBoolean(true)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (shouldInvokeCallback.get()) {\n          shouldInvokeCallback.set(F)\n          cancel(id)\n\n          callback()\n        }\n      }\n    }\n\n    scheduledCallbacks.put(id, shouldInvokeCallback)\n\n    val adjusted = delay.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    ArtNative.logInfo(Art.logTitle, s\"Callback scheduled for $id\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = { }\n\n  override def computePhase(): Unit = { }\n\n  override def finalizePhase(): Unit = { }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\n\n@record class RoundRobin(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  def shouldDispatch(bridge: art.Bridge): B = {\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if(Art.time() - lastDispatch(bridge.id) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridge.id)  \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if(Art.time() - lastSporadic(bridge.id) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridge.id)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while(!RoundRobinExtensions.shouldStop()) {\n      for (bridge <- bridges) {\n        if(shouldDispatch(bridge)) {\n          lastDispatch(bridge.id) = Art.time()\n          bridge.entryPoints.compute()\n\n          if(bridge.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridge.id) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n  def shouldStop(): B = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec) : B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return  slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  \/\/ no overloading in Slang\n  \/\/def isHyperPeriodBoundary(): B = {\n  \/\/  return isHyperPeriodBoundary(scheduleState)\n  \/\/}\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState : ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    ScheduleState(0,0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    \/\/val domainId: Z = slot.domain\n    \/\/val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId).get\n    val bridgeId: Art.BridgeId = slot.bridgeId\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if(ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState,dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum,nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState,dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1           \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) {  \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1  \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum,nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP() : Unit = {\n    scheduleState = nextState(scheduleState,dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      halt(\"TODO\")\n      \/\/Cli.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots :Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP : Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n    halt(\"TODO\")\n    \/\/Cli.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods:Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      \/\/ println(\"===== Hyperperiod \", scheduleState.hyperperiodNum, \" ============\")\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    halt(\"TODO\")\n    \/\/Cli.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    \/\/while (scheduleState.hyperperiodNum < hpNum) {\n    \/\/  stepSystemOneSlotIMP(F)\n    \/\/}\n    \/\/Cli.message(\"*********** Run to ... Completed *************\")\n    \/\/Cli.showState(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum:Z, slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    halt(\"TODO\")\n    \/*\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to domain $domainId\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n\n     *\/\n  }\n\n  \/*\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = art.StaticScheduling.bridgeIdToDomainMap(bridgeId)\n    Cli.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n  }\n   *\/\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    \/\/Cli.message (s\"...Running system according to static schedule\")\n    cprintln(F, \"...Running system according to static schedule\")\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, Bridge}\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(bridgeId: art.Art.BridgeId, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0,0,DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def setSchedule(spec: DScheduleSpec, bridgeMap: ISZ[Art.BridgeId]) : Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = bridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Z = {\n    \/\/val domainId = slot.domain\n    \/\/val bridgeId = domainToBridgeIdMap(domainId).get\n    val bridgeId = slot.bridgeId\n    return bridgeId\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Z = {\n    val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n    return getBridgeIdFromSlot(slot)\n  }\n\n  def getBridgeId(scheduleState : Explorer.ScheduleState): Z = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  \/\/def getDomain(slotNum: Z): Z = {\n  \/\/  val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n  \/\/  return slot.domain\n  \/\/}\n\n  \/\/def getDomain(scheduleState : Explorer.ScheduleState): Z = {\n  \/\/   return getDomain(scheduleState.slotNum)\n  \/\/}\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    halt(\"TODO\")\n    \/*\n    for (e <- StaticScheduling.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n     *\/\n  }\n\n  def threadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState) : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ --------- helper methods for contracts -------------\n\n  def mySome[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (pred(e)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  def myAll[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (!pred(e)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    checkMaxDomain(dScheduleSpec)\n    checkNoMissingDomain(dScheduleSpec)\n    checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/\/myAll[Slot](dScheduleSpec.schedule.slots, s => s.domain <= dScheduleSpec.maxDomain)\n    \/\/  for (s <- dScheduleSpec.schedule.slots) {\n    \/\/    if (s.domain > dScheduleSpec.maxDomain) {\n    \/\/      return false\n    \/\/    }\n    \/\/  }\n    \/\/  return true\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    for (d <- 0 to dScheduleSpec.maxDomain) {\n      if (!mySome[Slot](dScheduleSpec.schedule.slots, s => s.domain == d)) {\n        return false\n      }\n    }\n    return true\n\n     *\/\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n\n     *\/\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec) : (Z,Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks,remainingHPTicks)\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent }\n\nobject StateObserver {\n\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeInPortValue(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def generatePortContentsInputsCurrent() : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsOutputsCurrent() : String = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState,Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        val result =\n          st\"\"\"****************************\n              |   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n              |****************************\n              | Output Ports\n              | ===============\n              |  ${formatPortInfo(outPortInfo)}\"\"\".render\n        return result\n      }\n      case None() => {\n        return \"(initial state - no previous state to show)\"\n      }\n    }\n  }\n\n  def formatPortInfo(portVals: ISZ[(String,Option[DataContent])]): String = {\n    var result: String = \"\" \/\/ ToDo: Ask Robby if I can do this with a repeating template\n    for (e <- portVals) {\n      result = st\"\"\"$result\n                   |${e._1} = ${e._2}\"\"\".render  \/\/ how do I put in new line?\n    }\n    return result\n  }\n\n  def generatePortContents(bridgeId: Z) : String = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\n          |\n          | Output Ports\n          | ================\n          |  ${formatPortInfo(outPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsByNickName(threadNickName: String) : String = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return generatePortContents(bridgeId)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\n@record class StaticScheduler(bridges: ISZ[art.Bridge],\n                              staticSchedule: DScheduleSpec) extends Scheduler {\n\n  override def initialize(): Unit = {\n    Schedule.dScheduleSpec = staticSchedule\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      art.Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    Explorer.runSystem()\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      art.Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/github.com\/sireum\/kekinian#installing\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . building_control_gen_mixed.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . building_control_gen_mixed.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main building_control_gen_mixed.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   If you prevented HAMR from running Proyek IVE then first generate the IVE project:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/building_control_gen_mixed\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"BuildingControlDemo_i_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=337fc26\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20221207.b303d55\n\norg.sireum.kekinian%%library%=4.20221130.c350258\n\norg.scala-lang%scala-library%=2.13.10\norg.scalatest%%scalatest%%=3.2.14\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill building_control_gen_mixed.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill building_control_gen_mixed.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang-embedded ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w building_control_gen_mixed.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `building_control_gen_mixed` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.10\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.14\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20221207.b303d55\n  val sireumScalacVersion = \"4.20221207.b303d55\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20221130.c350258\n  val kekinianVersion = \"4.20221130.c350258\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-release:8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"building_control_gen_mixed.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"building_control_gen_mixed.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(os.Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/building_control_gen_mixed\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val BuildingControlDemo_i_Instance = slangEmbeddedProject(\"BuildingControlDemo_i_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.10\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.14\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20221207.b303d55\nval sireumScalacVersion = \"4.20221207.b303d55\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20221130.c350258\nval kekinianVersion = \"4.20221130.c350258\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-release:8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Resolver.sonatypeOssRepos(\"public\") ++ Seq(\"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"building_control_gen_mixed.Demo\"),\n\n  mainClass in assembly := Some(\"building_control_gen_mixed.Demo\"),\n  assemblyJarName in assembly := \"BuildingControlDemo_i_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"building_control_gen_mixed.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.8.0\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import <std_connector.camkes>;\ncomponent TempSensor_i_tcp_tempSensor {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_tempChanged;\n  consumes Notification sb_periodic_dispatch_notification;\n  dataport sp_union_art_DataContent_t sb_currentTemp;\n  dataport sb_event_counter_t sb_tempChanged_counter;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.camkes",
        {
          "type" : "ITestResource",
          "content" : "component TempControl_i_tcp_tempControl {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_fanCmd_1_notification;\n  consumes ReceiveEvent sb_fanAck_notification;\n  consumes ReceiveEvent sb_tempChanged;\n  dataport sp_union_art_DataContent_t sb_currentTemp;\n  dataport sb_queue_union_art_DataContent_1_t sb_fanAck_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_fanCmd_queue_1;\n  dataport sb_event_counter_t sb_tempChanged_counter;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/Fan_i_tcp_fan\/Fan_i_tcp_fan.camkes",
        {
          "type" : "ITestResource",
          "content" : "component Fan_i_tcp_fan {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_fanAck_1_notification;\n  consumes ReceiveEvent sb_fanCmd_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_fanCmd_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_fanAck_queue_1;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/dispatch_periodic\/dispatch_periodic.camkes",
        {
          "type" : "ITestResource",
          "content" : "import <global-connectors.camkes>;\ncomponent dispatch_periodic {\n  control;\n  uses Timer timer;\n  emits Notification sb_tcp_tempSensor_periodic_dispatch_notification;\n  consumes Notification timer_complete;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/BuildingControlDemo_i_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <TimeServer\/TimeServer.camkes>;;\nimport \"components\/TempSensor_i_tcp_tempSensor\/TempSensor_i_tcp_tempSensor.camkes\";\nimport \"components\/TempControl_i_tcp_tempControl\/TempControl_i_tcp_tempControl.camkes\";\nimport \"components\/Fan_i_tcp_fan\/Fan_i_tcp_fan.camkes\";\nimport \"components\/dispatch_periodic\/dispatch_periodic.camkes\";\n\nassembly {\n  composition {\n    component TempSensor_i_tcp_tempSensor tcp_tempSensor;\n    component TempControl_i_tcp_tempControl tcp_tempControl;\n    component Fan_i_tcp_fan tcp_fan;\n    component dispatch_periodic dispatch_periodic_inst;\n    component TimeServer time_server;\n\n    connection seL4SharedData conn1(from tcp_tempSensor.sb_currentTemp, to tcp_tempControl.sb_currentTemp);\n    connection seL4Notification conn2(from tcp_tempSensor.sb_tempChanged, to tcp_tempControl.sb_tempChanged);\n    connection seL4SharedData conn3(from tcp_tempSensor.sb_tempChanged_counter, to tcp_tempControl.sb_tempChanged_counter);\n    connection seL4Notification conn4(from tcp_tempControl.sb_fanCmd_1_notification, to tcp_fan.sb_fanCmd_notification);\n    connection seL4SharedData conn5(from tcp_tempControl.sb_fanCmd_queue_1, to tcp_fan.sb_fanCmd_queue);\n    connection seL4Notification conn6(from tcp_fan.sb_fanAck_1_notification, to tcp_tempControl.sb_fanAck_notification);\n    connection seL4SharedData conn7(from tcp_fan.sb_fanAck_queue_1, to tcp_tempControl.sb_fanAck_queue);\n    connection seL4Notification conn8(from dispatch_periodic_inst.sb_tcp_tempSensor_periodic_dispatch_notification, to tcp_tempSensor.sb_periodic_dispatch_notification);\n    connection seL4TimeServer conn9(from dispatch_periodic_inst.timer, to time_server.the_timer);\n    connection seL4GlobalAsynchCallback conn10(from time_server.timer_notification, to dispatch_periodic_inst.timer_complete);\n  }\n\n  configuration {\n    tcp_tempSensor._stack_size = 114688;\n    tcp_tempControl._stack_size = 114688;\n    tcp_fan._stack_size = 114688;\n    tcp_tempSensor.sb_currentTemp_access = \"W\";\n    tcp_tempControl.sb_currentTemp_access = \"R\";\n    tcp_tempSensor.sb_tempChanged_counter_access = \"W\";\n    tcp_tempControl.sb_tempChanged_counter_access = \"R\";\n    tcp_tempControl.sb_fanCmd_queue_1_access = \"W\";\n    tcp_fan.sb_fanCmd_queue_access = \"R\";\n    tcp_fan.sb_fanAck_queue_1_access = \"W\";\n    tcp_tempControl.sb_fanAck_queue_access = \"R\";\n    time_server.timers_per_client = 1;\n    dispatch_periodic_inst.timer_attributes = 1;\n    dispatch_periodic_inst.priority = 201;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/includes\/seqNum.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef _SEQNUM_H_\n#define _SEQNUM_H_\n\n\/\/ Typedef for seqNum to make it easy to change the type. Keep these consistent!\ntypedef uintmax_t seqNum_t;\n#define SEQNUM_MAX UINTMAX_MAX\n#define PRIseqNum PRIuMAX\n\n\/\/ DIRTY_SEQ_NUM is used to mark a sampling port message as dirty while it is\n\/\/ being writen. DIRTY_SEQ_NUM is not a valid sequence number. Valid sequence\n\/\/ numbers are from 0 to DIRTY_SEQ_NUM-1 is never a valid sequence number.\nstatic const seqNum_t DIRTY_SEQ_NUM = SEQNUM_MAX;\n\n#endif",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/includes\/sp_union_art_DataContent.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SP_UNION_ART_DATACONTENT_H\n#define SP_UNION_ART_DATACONTENT_H\n\n#include <sb_types.h>\n#include <seqNum.h>\n\n\/\/ Sampling port message with bool data\ntypedef struct sp_union_art_DataContent {\n\n  \/\/ The sampling port message data.\n  \/\/\n  union_art_DataContent data;\n\n  \/\/ Sequence number incremented by the writer every time the sampling port is\n  \/\/ written. Read by the receiver to detect dropped messages and incoherent\n  \/\/ message reads.  An incoherent message is one that is formed of parts of\n  \/\/ more than one message.  An incoherent message can occur when writing\n  \/\/ happens during read. If the component runs long enough, this counter\n  \/\/ will wrap back to zero.  This causes no problems unless the receiver is\n  \/\/ delayed for the wrap time. In that case the receiver may not detect\n  \/\/ dropped or incoherent message. But if the receiver is delayed for that\n  \/\/ long the system is probably in a very bad state. Also see DIRTY_SEQ_NUM\n  \/\/ above.\n  \/\/\n  \/\/ TODO: Currently using ggc builtin _Atomic. Would like to use c11 std, but\n  \/\/ have not figured out how to do this int the seL4 cmake build environment.\n  _Atomic seqNum_t seqNum;  \n\n} sp_union_art_DataContent_t;\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum);\n\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum);\n\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum);\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/src\/sp_union_art_DataContent.c",
        {
          "type" : "ITestResource",
          "content" : "#include <sp_union_art_DataContent.h>\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum) {\n  *seqNum = 0; \/\/ First message sequence number will be 1.\n  port->seqNum = DIRTY_SEQ_NUM;\n}\n\n\/\/ Write message to a sampling port (data type: int)\n\/\/\n\/\/ Returns true when successful. Otherwise returns false. Currently there is no\n\/\/ way to fail and true is always returned. But this may change in the\n\/\/ future. seqNum is incremented when a message is successfully sent. seqNum\n\/\/ should not be modified otherwise.\n\/\/\n\/\/ TODO: Encapsulate this better. seqNum state should be maintained internally. Possible solutions:\n\/\/\n\/\/    - Allow write to have read access to dataport. Then seqNum is simply in the data port.\n\/\/\n\/\/    - Create a wrapper struct.\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_RELEASE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum) {\n  \/\/ Mark the message dirty BEFORE we start writing.\n  port->seqNum = DIRTY_SEQ_NUM;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Write the data\n  port->data = *data;\n  \/\/ Increment the sequence number. We are the only writer of seqNum, so\n  \/\/ increment does not have to be atomic.\n  *seqNum = (*seqNum + 1) % DIRTY_SEQ_NUM;\n  port->seqNum = *seqNum;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE continuing\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Can't fail for now.\n  return true;\n}\n\n\/\/ Read a message from a sampling port (data type: int)\n\/\/\n\/\/ Return true upon successful read. Data is updated with the read\n\/\/ message. The sequence number of the message is also returned. The message,\n\/\/ might be tha same previously read. The sequences number can be used to\n\/\/ detect rereading the same message or dropped messages.\n\/\/\n\/\/ Return false if we fail to read a message. For now the only way to fail is\n\/\/ when we detect the possibility of a write during read. In this case data\n\/\/ may be incoherent and should not be used. Sequence number is set to\n\/\/ DIRTY_SEQ_NUM;\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_ACQUIRE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum) {\n  seqNum_t newSeqNum = port->seqNum;\n  \/\/ Acquire memory fence - Read seqNum BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  *data = port->data;\n  \/\/ Acquire memory fence - Read data BEFORE reading seqNum again \n  \/\/atomic_thread_fence(memory_order_acquire);\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  \/\/ The following logic will NOT catch case where the writer wrapped\n  \/\/ sequence numbers since our last read. For this to happen, this reader\n  \/\/ would have to be delayed for the entire time to wrap. \n  if (newSeqNum != DIRTY_SEQ_NUM && newSeqNum == port->seqNum) {\n    \/\/ Message data is good.  Write did not occur during read. \n    *seqNum = newSeqNum;\n    return true;\n  } else {\n    \/\/ Writer may have updated data while we were reading. Do not use possibly incoherent data.\n    *seqNum = DIRTY_SEQ_NUM;\n    return false;\n  }\n}\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port) {\n  return port->seqNum == DIRTY_SEQ_NUM;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "ITestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (BuildingControlDemo_i_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nincludeGlobalComponents()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/TempSensor_i_tcp_tempSensor)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/TempControl_i_tcp_tempControl)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Fan_i_tcp_fan)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(TempSensor_i_tcp_tempSensor\n  SOURCES components\/TempSensor_i_tcp_tempSensor\/src\/sb_TempSensor_i.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/TempSensor_i_tcp_tempSensor\/includes\/ types\/includes types\/includes\n  LIBS TempSensor_i_tcp_tempSensor\n)\n\nDeclareCAmkESComponent(TempControl_i_tcp_tempControl\n  SOURCES components\/TempControl_i_tcp_tempControl\/src\/sb_TempControl_i.c types\/src\/sp_union_art_DataContent.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/TempControl_i_tcp_tempControl\/includes\/ types\/includes types\/includes\n  LIBS TempControl_i_tcp_tempControl\n)\n\nDeclareCAmkESComponent(Fan_i_tcp_fan\n  SOURCES components\/Fan_i_tcp_fan\/src\/sb_Fan_i.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/Fan_i_tcp_fan\/includes\/ types\/includes\n  LIBS Fan_i_tcp_fan\n)\n\nDeclareCAmkESComponent(dispatch_periodic\n  SOURCES components\/dispatch_periodic\/src\/sb_dispatch_periodic.c\n  LIBS SB_Type_Library SlangTypeLibrary\n)\n\nDeclareCAmkESRootserver(BuildingControlDemo_i_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempSensor_i_tcp_tempSensor\/src\/sb_TempSensor_i.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_TempSensor_i.h>\n#include <sb_event_counter.h>\n#include <TempSensor_i_tcp_tempSensor_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic bool sb_occurred_periodic_dispatcher;\nstatic int64_t sb_time_periodic_dispatcher;\n\n\/************************************************************************\n * periodic_dispatcher_write_int64_t\n * Invoked from remote periodic dispatch thread.\n *\n * This function records the current time and triggers the active thread\n * dispatch from a periodic event.  Note that the periodic dispatch\n * thread is the *only* thread that triggers a dispatch, so we do not\n * mutex lock the function.\n *\n ************************************************************************\/\n\nbool periodic_dispatcher_write_int64_t(const int64_t * arg) {\n    sb_occurred_periodic_dispatcher = true;\n    sb_time_periodic_dispatcher = *arg;\n    MUTEXOP(sb_dispatch_sem_post());\n    return true;\n}\n\nvoid sb_periodic_dispatch_notification_callback(void *_ UNUSED) {\n   \/\/ we want time in microseconds, not nanoseconds, so we divide by 1000.\n   int64_t sb_time_periodic_dispatcher = 0; \/\/ sb_timer_time() \/ 1000LL -- timer connection disabled;\n   (void)periodic_dispatcher_write_int64_t(&sb_time_periodic_dispatcher);\n   CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n}\n\n\nseqNum_t sb_currentTemp_seqNum;\n\nbool sb_currentTemp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_currentTemp, value, &sb_currentTemp_seqNum);\n}\n\n\/************************************************************************\n * sb_tempChanged_enqueue\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to send to a remote event port.\n *\n ************************************************************************\/\nbool sb_tempChanged_enqueue(void) {\n  \/\/ sb_tempChanged_counter is a dataport (shared memory) that is written by the sender\n  \/\/ and read by the receiver(s). This counter is monotonicly increasing,\n  \/\/ but can wrap.\n  (*sb_tempChanged_counter)++;\n\n  \/\/ Release memory fence - ensure subsequent write occurs after any preceeding read or write\n  sb_tempChanged_counter_release();\n\n  sb_tempChanged_emit();\n\n  return true;\n}\n\n\n\/\/ send currentTemp: Out DataPort BuildingControl__Temperature_impl\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_seL4Nix_currentTemp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_TempSensor_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_seL4Nix_currentTemp_Send\", 0);\n\n  sb_currentTemp_write(d);\n}\n\n\/\/ send tempChanged: Out EventPort\nUnit building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_seL4Nix_tempChanged_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_TempSensor_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_seL4Nix_tempChanged_Send\", 0);\n\n  \/\/ event port - can ignore the Slang Empty payload\n  art_Empty payload = (art_Empty) d;\n\n  \/\/ send event via CAmkES\n  sb_tempChanged_enqueue();\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_TempSensor_i.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of TempSensor_i_tcp_tempSensor\\n\");\n\n  \/\/ initialise data structure for data port currentTemp\n  init_sp_union_art_DataContent(sb_currentTemp, &sb_currentTemp_seqNum);\n\n  \/\/ initialise shared counter for event port tempChanged\n  *sb_tempChanged_counter = 0;\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of TempSensor_i_tcp_tempSensor\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_TempSensor_i.c\", \"\", \"run\", 0);\n\n\n  CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_TempSensor_i_tcp_tempSensor_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempSensor_i_tcp_tempSensor\/includes\/sb_TempSensor_i.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_TEMPSENSOR_I_H\n#define SB_TEMPSENSOR_I_H\n\n#include <sb_types.h>\n\nbool sb_currentTemp_write(const union_art_DataContent * value);\n\nbool sb_tempChanged_enqueue(void);\n\n#endif \/\/ SB_TEMPSENSOR_I_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempControl_i_tcp_tempControl\/src\/sb_TempControl_i.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_TempControl_i.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <TempControl_i_tcp_tempControl_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_currentTemp_seqNum;\n\n\/*****************************************************************\n * sb_currentTemp_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_currentTemp_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_currentTemp);\n}\n\nbool sb_currentTemp_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_currentTemp, value, &new_seqNum) ) {\n    sb_currentTemp_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_fanAck_recv_queue;\n\n\/************************************************************************\n * sb_fanAck_dequeue_poll:\n ************************************************************************\/\nbool sb_fanAck_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_fanAck_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_fanAck_dequeue:\n ************************************************************************\/\nbool sb_fanAck_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_fanAck_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_fanAck_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_fanAck_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_fanAck_recv_queue);\n}\n\n\/************************************************************************\n * sb_fanAck_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_fanAck\n *\n ************************************************************************\/\nstatic void sb_fanAck_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_fanAck_notification_reg_callback(sb_fanAck_notification_handler, NULL));\n}\n\nbool sb_fanCmd_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_fanCmd_queue_1, (union_art_DataContent*) data);\n  sb_fanCmd_1_notification_emit();\n\n  return true;\n}\n\n\/************************************************************************\n *\n * Static variables and queue management functions for event port:\n *     tempChanged\n *\n ************************************************************************\/\nstatic sb_event_counter_t sb_tempChanged_received_events = 0;\nstatic sb_event_counter_t sb_tempChanged_last_counter = 0;\n\n\/************************************************************************\n * sb_tempChanged_dequeue:\n * Invoked from local active thread.\n *\n * This is the function invoked by the active thread to decrement the\n * input event index.\n *\n ************************************************************************\/\nbool sb_tempChanged_dequeue() {\n  if(sb_tempChanged_received_events > 0) {\n    sb_tempChanged_received_events--;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\/************************************************************************\n * sb_tempChanged_is_empty;\n *\n * Helper method to determine if infrastructure port has not received\n * any new events since the last dispatch\n *\n ************************************************************************\/\nbool sb_tempChanged_is_empty() {\n  return sb_tempChanged_received_events == 0;\n}\n\nvoid sb_freeze_event_port_tempChanged() {\n  sb_event_counter_t current_sb_tempChanged_counter;\n\n  sb_tempChanged_received_events = 0; \/\/ drop any events not handled during last dispatch\n\n  \/\/ get current shared counter value\n  current_sb_tempChanged_counter = *sb_tempChanged_counter;\n\n  \/\/ Acquire memory fence - ensure preceding read occurs before any subsequent read or write\n  sb_tempChanged_counter_acquire();\n\n  \/\/ NOTE: Counters can wrap, so we must use != below instead of >\n  while(current_sb_tempChanged_counter != sb_tempChanged_last_counter){\n    sb_tempChanged_last_counter++;\n    sb_tempChanged_received_events++;\n  }\n\n  if(sb_tempChanged_received_events > 0) {\n\n    \/\/ tempChanged's queue size is 1\n    if(sb_tempChanged_received_events > 1) {\n      \/\/printf(\"TempControl_i: dropping %i event(s) from incoming event port tempChanged\\n\", (sb_tempChanged_received_events - 1));\n\n      \/\/ drop events\n      sb_tempChanged_received_events = 1;\n    }\n  }\n}\n\n\/************************************************************************\n * sb_tempChanged_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * tempChanged\n *\n ************************************************************************\/\nstatic void sb_tempChanged_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_tempChanged_reg_callback(sb_tempChanged_handler, NULL));\n}\n\n\/\/ send fanCmd: Out EventDataPort BuildingControl__FanCmd\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_fanCmd_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_TempControl_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_fanCmd_Send\", 0);\n\n  sb_fanCmd_enqueue(d);\n}\n\n\/\/ is_empty currentTemp: In DataPort\nB building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_currentTemp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_currentTemp_is_empty();\n}\n\n\/\/ receive currentTemp: In DataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_currentTemp_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_TempControl_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_currentTemp_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_currentTemp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty fanAck: In EventDataPort\nB building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_fanAck_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_fanAck_is_empty();\n}\n\n\/\/ receive fanAck: In EventDataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_fanAck_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_TempControl_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_fanAck_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_fanAck_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty tempChanged: In EventPort\nB building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_tempChanged_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_tempChanged_is_empty();\n}\n\n\/\/ receive tempChanged: In EventPort\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_tempChanged_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_TempControl_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_tempChanged_Receive\", 0);\n\n  if(sb_tempChanged_dequeue()) {\n    \/\/ event port - ART requires an Empty payload be sent\n    DeclNewart_Empty(payload);\n\n    \/\/ wrap it in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &payload);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n} \n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_setPoint_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_setPoint_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_TempControl_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_seL4Nix_setPoint_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_TempControl_i.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of TempControl_i_tcp_tempControl\\n\");\n\n  \/\/ initialise data structure for incoming event data port fanAck\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_fanAck_recv_queue, sb_fanAck_queue);\n\n  \/\/ initialise data structure for outgoing event data port fanCmd\n  sb_queue_union_art_DataContent_1_init(sb_fanCmd_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of TempControl_i_tcp_tempControl\\n\");\n}\n\nvoid post_init(void) {\n  DeclNewStackFrame(NULL, \"sb_TempControl_i.c\", \"\", \"post_init\", 0);\n\n  \/\/ register callback for EventDataPort port fanAck\n  CALLBACKOP(sb_fanAck_notification_reg_callback(sb_fanAck_notification_handler, NULL));\n\n  \/\/ register callback for EventPort port tempChanged\n  CALLBACKOP(sb_tempChanged_reg_callback(sb_tempChanged_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_TempControl_i.c\", \"\", \"run\", 0);\n\n\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    sb_freeze_event_port_tempChanged();\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_TempControl_i_tcp_tempControl_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/TempControl_i_tcp_tempControl\/includes\/sb_TempControl_i.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_TEMPCONTROL_I_H\n#define SB_TEMPCONTROL_I_H\n\n#include <sb_types.h>\n\nbool sb_currentTemp_read(union_art_DataContent * value);\n\nbool sb_fanAck_dequeue(union_art_DataContent *);\n\nbool sb_fanCmd_enqueue(const union_art_DataContent *);\n\nbool sb_tempChanged_dequeue(void);\n\n#endif \/\/ SB_TEMPCONTROL_I_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/Fan_i_tcp_fan\/src\/sb_Fan_i.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Fan_i.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <Fan_i_tcp_fan_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_fanCmd_recv_queue;\n\n\/************************************************************************\n * sb_fanCmd_dequeue_poll:\n ************************************************************************\/\nbool sb_fanCmd_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_fanCmd_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_fanCmd_dequeue:\n ************************************************************************\/\nbool sb_fanCmd_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_fanCmd_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_fanCmd_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_fanCmd_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_fanCmd_recv_queue);\n}\n\n\/************************************************************************\n * sb_fanCmd_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_fanCmd\n *\n ************************************************************************\/\nstatic void sb_fanCmd_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_fanCmd_notification_reg_callback(sb_fanCmd_notification_handler, NULL));\n}\n\nbool sb_fanAck_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_fanAck_queue_1, (union_art_DataContent*) data);\n  sb_fanAck_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send fanAck: Out EventDataPort BuildingControl__FanAck\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_seL4Nix_fanAck_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Fan_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_seL4Nix_fanAck_Send\", 0);\n\n  sb_fanAck_enqueue(d);\n}\n\n\/\/ is_empty fanCmd: In EventDataPort\nB building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_seL4Nix_fanCmd_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_fanCmd_is_empty();\n}\n\n\/\/ receive fanCmd: In EventDataPort union_art_DataContent\nUnit building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_seL4Nix_fanCmd_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Fan_i.c\", \"\", \"building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_seL4Nix_fanCmd_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_fanCmd_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Fan_i.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Fan_i_tcp_fan\\n\");\n\n  \/\/ initialise data structure for incoming event data port fanCmd\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_fanCmd_recv_queue, sb_fanCmd_queue);\n\n  \/\/ initialise data structure for outgoing event data port fanAck\n  sb_queue_union_art_DataContent_1_init(sb_fanAck_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Fan_i_tcp_fan\\n\");\n}\n\nvoid post_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Fan_i.c\", \"\", \"post_init\", 0);\n\n  \/\/ register callback for EventDataPort port fanCmd\n  CALLBACKOP(sb_fanCmd_notification_reg_callback(sb_fanCmd_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Fan_i.c\", \"\", \"run\", 0);\n\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    \/\/ call the component's compute entrypoint\n    building_control_gen_mixed_BuildingControl_Fan_i_tcp_fan_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/Fan_i_tcp_fan\/includes\/sb_Fan_i.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_FAN_I_H\n#define SB_FAN_I_H\n\n#include <sb_types.h>\n\nbool sb_fanCmd_dequeue(union_art_DataContent *);\n\nbool sb_fanAck_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_FAN_I_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/components\/dispatch_periodic\/src\/sb_dispatch_periodic.c",
        {
          "type" : "ITestResource",
          "content" : "#include <string.h>\n#include <camkes.h>\n#include <sb_types.h>\n\n\/\/ prototypes for clock functions\nvoid clock_init();\nvoid clock_set_interval_in_ms(uint32_t interval);\nvoid clock_start_timer(void);\nvoid clock_irq_callback(void);\nuint64_t clock_get_time();\n\n\/\/ Declarations for managing periodic thread dispatch\nconst uint32_t aadl_tick_interval = 1;\nuint32_t aadl_calendar_counter = 0;\n\nvoid sb_thread_calendar() {\n  if ((aadl_calendar_counter % (1000 \/ aadl_tick_interval)) == 0) {\n    sb_tcp_tempSensor_periodic_dispatch_notification_emit();\n  }\n\n  aadl_calendar_counter++;\n}\n\nvoid timer_complete_callback() {\n  sb_thread_calendar();\n}\n\n\/\/ no op under the new time server scheme.\nvoid clock_init() { }\n\n\/\/ Set interrupt interval, in milliseconds.\nvoid clock_set_interval_in_ms(uint32_t interval) {\n  timer_periodic(0, ((uint64_t)interval) * NS_IN_MS);\n}\n\n\/\/ no op under the new time server scheme\nvoid clock_start_timer(void) { }\n\n\/\/ defer to time server\nuint64_t clock_get_time() {\n  return (timer_time() \/ NS_IN_MS);\n}\n\nint run(void) {\n  clock_init();\n  clock_set_interval_in_ms(1);\n  clock_start_timer();\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/includes\/sb_queue_union_art_DataContent_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE-1 elements.\n#define SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_union_art_DataContent_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type union_art_DataContent\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  union_art_DataContent elt[SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE];\n\n} sb_queue_union_art_DataContent_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue,\n  union_art_DataContent *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_union_art_DataContent_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_union_art_DataContent_1_t *queue;\n\n} sb_queue_union_art_DataContent_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_union_art_DataContent_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_union_art_DataContent_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  union_art_DataContent *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/src\/sb_queue_union_art_DataContent_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_union_art_DataContent_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue,\n  union_art_DataContent *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_queue_union_art_DataContent_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  union_art_DataContent *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_union_art_DataContent_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/includes\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_union_art_DataContent_1.c\n            src\/sp_union_art_DataContent.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ],
      [
        "building_control_gen_mixed--SeL4\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n(declare-datatypes ((Option 1))\n  ((par (T) ((Some (value T))\n             (None)))))\n\n(declare-datatypes ((Mode 0)) ((\n  (SeL4)\n  (SeL4_Only)\n  (SeL4_TB))))\n\n(declare-datatypes ((ComponentCategory 0)) ((\n  (Abstract)\n  (Bus)\n  (Data)\n  (Device)\n  (Memory)\n  (Process)\n  (Processor)\n  (Subprogram)\n  (SubprogramGroup)\n  (System)\n  (Thread)\n  (ThreadGroup)\n  (VirtualBus)\n  (VirtualProcessor))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out)\n  (InOut))))\n\n(declare-datatypes ((FeatureCategory 0)) ((\n  (AbstractFeature)\n  (BusAccess)\n  (DataAccess)\n  (DataPort)\n  (EventPort)\n  (EventDataPort)\n  (FeatureGroup)\n  (Parameter)\n  (SubprogramAccess)\n  (SubprogramAccessGroup))))\n\n\n(declare-const CodegenMode Mode)\n(assert (= CodegenMode SeL4))\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType PeriodicDispatching))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                                AADL Model                              ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare-datatypes ((AadlComponent 0)) ((\n  (BuildingControlDemo_i_Instance_tcp_tempSensor)\n  (BuildingControlDemo_i_Instance_proc)\n  (BuildingControlDemo_i_Instance_tcp_tempControl)\n  (BuildingControlDemo_i_Instance_tcp_fan)\n)))\n(declare-const AadlComponent_count Int)\n(assert (= 4 AadlComponent_count))\n\n(declare-const AadlComponentCategory (Array AadlComponent (Option ComponentCategory)))\n  (assert (= (Some Thread) (select AadlComponentCategory BuildingControlDemo_i_Instance_tcp_tempSensor)))\n  (assert (= (Some Processor) (select AadlComponentCategory BuildingControlDemo_i_Instance_proc)))\n  (assert (= (Some Thread) (select AadlComponentCategory BuildingControlDemo_i_Instance_tcp_tempControl)))\n  (assert (= (Some Processor) (select AadlComponentCategory BuildingControlDemo_i_Instance_proc)))\n  (assert (= (Some Thread) (select AadlComponentCategory BuildingControlDemo_i_Instance_tcp_fan)))\n  (assert (= (Some Processor) (select AadlComponentCategory BuildingControlDemo_i_Instance_proc)))\n\n(declare-const ProcessorBindings (Array AadlComponent (Option AadlComponent)))\n  (assert (= (Some BuildingControlDemo_i_Instance_proc) (select ProcessorBindings BuildingControlDemo_i_Instance_tcp_tempSensor)))\n  (assert (= (Some BuildingControlDemo_i_Instance_proc) (select ProcessorBindings BuildingControlDemo_i_Instance_tcp_tempControl)))\n  (assert (= (Some BuildingControlDemo_i_Instance_proc) (select ProcessorBindings BuildingControlDemo_i_Instance_tcp_fan)))\n\n(declare-const AadlDispatchProtocol (Array AadlComponent (Option DispatchProtocol)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol BuildingControlDemo_i_Instance_tcp_tempSensor)))\n  (assert (= (Some Sporadic) (select AadlDispatchProtocol BuildingControlDemo_i_Instance_tcp_tempControl)))\n  (assert (= (Some Sporadic) (select AadlDispatchProtocol BuildingControlDemo_i_Instance_tcp_fan)))\n(declare-const AadlDispatchProtocol_size Int)\n(assert (= 3 AadlDispatchProtocol_size))\n\n(declare-datatypes ((AadlPort 0)) ((\n  (BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp)\n  (BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged)\n  (BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp)\n  (BuildingControlDemo_i_Instance_tcp_tempControl_fanAck)\n  (BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd)\n  (BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged)\n  (BuildingControlDemo_i_Instance_tcp_fan_fanCmd)\n  (BuildingControlDemo_i_Instance_tcp_fan_fanAck))))\n(declare-const AadlPort_count Int)\n(assert (= 8 AadlPort_count))\n\n(declare-const AadlPortComponent (Array AadlPort (Option AadlComponent)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempSensor) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempSensor) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempControl) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempControl) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempControl_fanAck)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempControl) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_tempControl) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_fan) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_fan_fanCmd)))\n  (assert (= (Some BuildingControlDemo_i_Instance_tcp_fan) (select AadlPortComponent BuildingControlDemo_i_Instance_tcp_fan_fanAck)))\n(declare-const AadlPortComponent_size Int)\n(assert (= 8 AadlPortComponent_size))\n\n(declare-const AadlFeatureCategory (Array AadlPort FeatureCategory))\n  (assert (= DataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp)))\n  (assert (= EventPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged)))\n  (assert (= DataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp)))\n  (assert (= EventDataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempControl_fanAck)))\n  (assert (= EventDataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd)))\n  (assert (= EventPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged)))\n  (assert (= EventDataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_fan_fanCmd)))\n  (assert (= EventDataPort (select AadlFeatureCategory BuildingControlDemo_i_Instance_tcp_fan_fanAck)))\n(declare-const AadlFeatureCategory_size Int)\n(assert (= 8 AadlFeatureCategory_size))\n\n(declare-const AadlPortDirection (Array AadlPort Direction))\n  (assert (= Out (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp)))\n  (assert (= Out (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged)))\n  (assert (= In (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp)))\n  (assert (= In (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempControl_fanAck)))\n  (assert (= Out (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd)))\n  (assert (= In (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged)))\n  (assert (= In (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_fan_fanCmd)))\n  (assert (= Out (select AadlPortDirection BuildingControlDemo_i_Instance_tcp_fan_fanAck)))\n(declare-const AadlPortDirection_size Int)\n(assert (= 8 AadlPortDirection_size))\n\n(define-fun AadlConnectionFlowTos ((p1 AadlPort) (p2 AadlPort)) Bool\n  (or\n    (and (= p1 BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp) (= p2 BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp))\n    (and (= p1 BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged) (= p2 BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged))\n    (and (= p1 BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd) (= p2 BuildingControlDemo_i_Instance_tcp_fan_fanCmd))\n    (and (= p1 BuildingControlDemo_i_Instance_tcp_fan_fanAck) (= p2 BuildingControlDemo_i_Instance_tcp_tempControl_fanAck))\n    false))\n(declare-const AadlConnectionFlowsTos_count Int)\n(assert (= 4 AadlConnectionFlowsTos_count))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                              CAmkES Model                              ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare-datatypes ((AccessType 0)) ((\n  (R)\n  (W)\n  (RW))))\n\n(declare-datatypes ((seL4ConnectorType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4RPCDataport)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4SerialServer)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (tcp_tempSensor)\n  (tcp_tempControl)\n  (tcp_fan)\n  (dispatch_periodic_inst)\n  (time_server))))\n(declare-const CAmkESComponent_count Int)\n(assert (= 5 CAmkESComponent_count))\n\n(define-fun isPeriodicDispatcher ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (= _component dispatch_periodic_inst)))\n\n(define-fun isPacer ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType Pacing)\n       false))\n\n(define-fun isFileServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a file server is expected\n       false))\n\n(define-fun isTimeServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a time server is expected\n       (= _component time_server)))\n\n(define-fun isSerialServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a serial server is expected\n       false))\n\n(declare-datatypes ((CAmkESPort 0)) ((\n  (tcp_tempSensor_sb_currentTemp)\n  (tcp_tempSensor_sb_tempChanged_counter)\n  (tcp_tempSensor_sb_tempChanged)\n  (tcp_tempSensor_sb_periodic_dispatch_notification)\n  (tcp_tempControl_sb_currentTemp)\n  (tcp_tempControl_sb_fanAck_queue)\n  (tcp_tempControl_sb_fanCmd_queue_1)\n  (tcp_tempControl_sb_tempChanged_counter)\n  (tcp_tempControl_sb_fanCmd_1_notification)\n  (tcp_tempControl_sb_fanAck_notification)\n  (tcp_tempControl_sb_tempChanged)\n  (tcp_fan_sb_fanCmd_queue)\n  (tcp_fan_sb_fanAck_queue_1)\n  (tcp_fan_sb_fanAck_1_notification)\n  (tcp_fan_sb_fanCmd_notification)\n  (dispatch_periodic_inst_sb_tcp_tempSensor_periodic_dispatch_notification)\n  (dispatch_periodic_inst_timer)\n  (dispatch_periodic_inst_timer_complete)\n  (time_server_timer_notification)\n  (time_server_the_timer))))\n(declare-const CAmkESPort_count Int)\n(assert (= 20 CAmkESPort_count))\n\n(declare-const CAmkESAccessRestrictions (Array CAmkESPort AccessType))\n  (assert (= W (select CAmkESAccessRestrictions tcp_tempSensor_sb_currentTemp)))\n  (assert (= R (select CAmkESAccessRestrictions tcp_tempControl_sb_currentTemp)))\n  (assert (= W (select CAmkESAccessRestrictions tcp_tempSensor_sb_tempChanged_counter)))\n  (assert (= R (select CAmkESAccessRestrictions tcp_tempControl_sb_tempChanged_counter)))\n  (assert (= W (select CAmkESAccessRestrictions tcp_tempControl_sb_fanCmd_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions tcp_fan_sb_fanCmd_queue)))\n  (assert (= W (select CAmkESAccessRestrictions tcp_fan_sb_fanAck_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions tcp_tempControl_sb_fanAck_queue)))\n(declare-const CAmkESAccessRestrictions_size Int)\n(assert (= 8 CAmkESAccessRestrictions_size))\n\n(declare-datatypes ((CAmkESConnection 0)) ((\n  (conn1)\n  (conn2)\n  (conn3)\n  (conn4)\n  (conn5)\n  (conn6)\n  (conn7)\n  (conn8)\n  (conn9)\n  (conn10))))\n(declare-const CAmkESConnection_count Int)\n(assert (= 10 CAmkESConnection_count))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or \n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or (= _conn conn8)\n           (= _conn conn9)\n           (= _conn conn10)\n           false)))\n(declare-const PeriodicDispatchingConnection_count Int)\n(assert (= 3 PeriodicDispatchingConnection_count))\n\n; non Aadl connection refinement connections required by a VM\n(define-fun isVMAuxConnection ((_conn CAmkESConnection)) Bool\n  (or \n      false))\n\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4ConnectorType))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn1)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn2)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn3)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn4)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn5)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn6)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn7)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn8)))\n  (assert (= seL4TimeServer (select CAmkESConnectionType conn9)))\n  (assert (= seL4GlobalAsynchCallback (select CAmkESConnectionType conn10)))\n(declare-const CAmkESConnectionType_count Int)\n(assert (= 10 CAmkESConnectionType_count))\n\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n  (assert (= tcp_tempSensor (select CAmkESPortComponent tcp_tempSensor_sb_currentTemp)))\n  (assert (= tcp_tempSensor (select CAmkESPortComponent tcp_tempSensor_sb_tempChanged_counter)))\n  (assert (= tcp_tempSensor (select CAmkESPortComponent tcp_tempSensor_sb_tempChanged)))\n  (assert (= tcp_tempSensor (select CAmkESPortComponent tcp_tempSensor_sb_periodic_dispatch_notification)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_currentTemp)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_fanAck_queue)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_fanCmd_queue_1)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_tempChanged_counter)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_fanCmd_1_notification)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_fanAck_notification)))\n  (assert (= tcp_tempControl (select CAmkESPortComponent tcp_tempControl_sb_tempChanged)))\n  (assert (= tcp_fan (select CAmkESPortComponent tcp_fan_sb_fanCmd_queue)))\n  (assert (= tcp_fan (select CAmkESPortComponent tcp_fan_sb_fanAck_queue_1)))\n  (assert (= tcp_fan (select CAmkESPortComponent tcp_fan_sb_fanAck_1_notification)))\n  (assert (= tcp_fan (select CAmkESPortComponent tcp_fan_sb_fanCmd_notification)))\n  (assert (= dispatch_periodic_inst (select CAmkESPortComponent dispatch_periodic_inst_sb_tcp_tempSensor_periodic_dispatch_notification)))\n  (assert (= dispatch_periodic_inst (select CAmkESPortComponent dispatch_periodic_inst_timer)))\n  (assert (= dispatch_periodic_inst (select CAmkESPortComponent dispatch_periodic_inst_timer_complete)))\n  (assert (= time_server (select CAmkESPortComponent time_server_timer_notification)))\n  (assert (= time_server (select CAmkESPortComponent time_server_the_timer)))\n(declare-const CAmkESPortComponent_size Int)\n(assert (= 20 CAmkESPortComponent_size))\n\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    (and (= _conn conn1) (= _p1 tcp_tempSensor_sb_currentTemp) (= _p2 tcp_tempControl_sb_currentTemp))\n    (and (= _conn conn2) (= _p1 tcp_tempSensor_sb_tempChanged) (= _p2 tcp_tempControl_sb_tempChanged))\n    (and (= _conn conn3) (= _p1 tcp_tempSensor_sb_tempChanged_counter) (= _p2 tcp_tempControl_sb_tempChanged_counter))\n    (and (= _conn conn4) (= _p1 tcp_tempControl_sb_fanCmd_1_notification) (= _p2 tcp_fan_sb_fanCmd_notification))\n    (and (= _conn conn5) (= _p1 tcp_tempControl_sb_fanCmd_queue_1) (= _p2 tcp_fan_sb_fanCmd_queue))\n    (and (= _conn conn6) (= _p1 tcp_fan_sb_fanAck_1_notification) (= _p2 tcp_tempControl_sb_fanAck_notification))\n    (and (= _conn conn7) (= _p1 tcp_fan_sb_fanAck_queue_1) (= _p2 tcp_tempControl_sb_fanAck_queue))\n    (and (= _conn conn8) (= _p1 dispatch_periodic_inst_sb_tcp_tempSensor_periodic_dispatch_notification) (= _p2 tcp_tempSensor_sb_periodic_dispatch_notification))\n    (and (= _conn conn9) (= _p1 dispatch_periodic_inst_timer) (= _p2 time_server_the_timer))\n    (and (= _conn conn10) (= _p1 time_server_timer_notification) (= _p2 dispatch_periodic_inst_timer_complete))\n    false))\n(declare-const CAmkESConnectionFlowTos_count Int)\n(assert (= 10 CAmkESConnectionFlowTos_count))\n\n(define-fun ComponentRefinement ((ac (Option AadlComponent)) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac (Some BuildingControlDemo_i_Instance_tcp_tempSensor)) (= cc tcp_tempSensor))\n    (and (= ac (Some BuildingControlDemo_i_Instance_tcp_tempControl)) (= cc tcp_tempControl))\n    (and (= ac (Some BuildingControlDemo_i_Instance_tcp_fan)) (= cc tcp_fan))\n    false))\n(declare-const ComponentRefinement_count Int)\n(assert (= 3 ComponentRefinement_count))\n\n(define-fun PortRefinement ((ap AadlPort) (cp CAmkESPort)) Bool\n  (or\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempSensor_currentTemp) (= cp tcp_tempSensor_sb_currentTemp))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged) (= cp tcp_tempSensor_sb_tempChanged_counter))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempSensor_tempChanged) (= cp tcp_tempSensor_sb_tempChanged))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_currentTemp) (= cp tcp_tempControl_sb_currentTemp))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_fanAck) (= cp tcp_tempControl_sb_fanAck_queue))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd) (= cp tcp_tempControl_sb_fanCmd_queue_1))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged) (= cp tcp_tempControl_sb_tempChanged_counter))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_fanCmd) (= cp tcp_tempControl_sb_fanCmd_1_notification))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_fanAck) (= cp tcp_tempControl_sb_fanAck_notification))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_tempControl_tempChanged) (= cp tcp_tempControl_sb_tempChanged))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_fan_fanCmd) (= cp tcp_fan_sb_fanCmd_queue))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_fan_fanAck) (= cp tcp_fan_sb_fanAck_queue_1))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_fan_fanAck) (= cp tcp_fan_sb_fanAck_1_notification))\n    (and (= ap BuildingControlDemo_i_Instance_tcp_fan_fanCmd) (= cp tcp_fan_sb_fanCmd_notification))\n    false))\n(declare-const PortRefinement_count Int)\n(assert (= 14 PortRefinement_count))\n\n(define-fun isVMAuxPort ((cp CAmkESPort)) Bool\n  (exists ((cc CAmkESComponent))\n    (and (= cc (select CAmkESPortComponent cp))\n         (or \n             false))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                             Proof Functions                            ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define-fun isVMComponent ((cc CAmkESComponent)) Bool\n  (exists ((ap AadlComponent))\n    (and (ComponentRefinement (Some ap) cc)                   ; cc refines ap\n         (= (Some Process) (select AadlComponentCategory ap)) ; ap is a process\n         (match (select ProcessorBindings ap) (\n           ((Some x) (= (Some VirtualProcessor) (select AadlComponentCategory x))) ; ap is bound to virtual processor\n           (None false))))))\n\n(define-fun AadlFlowDirectionality () Bool\n  (forall ((p1 AadlPort) (p2 AadlPort))\n    (=> (AadlConnectionFlowTos p1 p2)\n        (and (= Out (select AadlPortDirection p1)) (= In (select AadlPortDirection p2))))))\n\n(define-fun AadlFlowNoSelfConnection () Bool\n  (forall ((p1 AadlPort) (p2 AadlPort))\n    (=> (AadlConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AadlConnectedPortTypeMatch () Bool\n  (forall ((src AadlPort) (dst AadlPort))\n    (=> (AadlConnectionFlowTos src dst)\n        (or (and (= AbstractFeature (select AadlFeatureCategory src)) (= AbstractFeature (select AadlFeatureCategory dst)))\n            (and (= BusAccess (select AadlFeatureCategory src)) (= BusAccess (select AadlFeatureCategory dst)))\n            (and (= DataAccess (select AadlFeatureCategory src)) (= DataAccess (select AadlFeatureCategory dst)))\n            (and (= DataPort (select AadlFeatureCategory src)) (= DataPort (select AadlFeatureCategory dst)))\n            (and (= EventPort (select AadlFeatureCategory src)) (= EventPort (select AadlFeatureCategory dst)))\n            (and (= EventDataPort (select AadlFeatureCategory src)) (= EventDataPort (select AadlFeatureCategory dst)))\n            (and (= FeatureGroup (select AadlFeatureCategory src)) (= FeatureGroup (select AadlFeatureCategory dst)))\n            (and (= Parameter (select AadlFeatureCategory src)) (= Parameter (select AadlFeatureCategory dst)))\n            (and (= SubprogramAccess (select AadlFeatureCategory src)) (= SubprogramAccess (select AadlFeatureCategory dst)))\n            (and (= SubprogramAccessGroup (select AadlFeatureCategory src)) (= SubprogramAccessGroup (select AadlFeatureCategory dst)))\n             false))))\n(declare-const AadlConnectedPortTypeMatch_count Int)\n(assert (= 10 AadlConnectedPortTypeMatch_count))\n\n(define-fun AadlDispatchProtocolSpecified () Bool\n  (forall ((_comp AadlComponent))\n    (match (select AadlComponentCategory _comp) (\n      ((Some _category_) (\n        ; threads and virtual processors must have an assigned dispatch protocol, all others are 'don't care'\n        match _category_ (\n          (Thread (not (= (as None (Option DispatchProtocol)) (select AadlDispatchProtocol _comp))))\n          (VirtualProcessor (not (= (as None (Option DispatchProtocol)) (select AadlDispatchProtocol _comp))))\n          (_z_ true)\n        )))\n      (None false) ; sanity check: all AADL components must have an assigned component category\n      ))))\n\n(define-fun AadlAllPortsAssigned () Bool\n  (forall ((_p AadlPort))\n    (not (= (as None (Option AadlComponent)) (select AadlPortComponent _p)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    (= AadlPort_count AadlPortComponent_size) ; all Aadl ports belong to an Aadl component\n    AadlAllPortsAssigned\n    AadlDispatchProtocolSpecified\n    AadlFlowDirectionality\n    AadlFlowNoSelfConnection\n    AadlConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun CAmkESDataPortAccess () Bool\n  (forall ((_conn CAmkESConnection) (_src CAmkESPort) (_dst CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _src _dst)\n        (and\n             (=> (= seL4SharedData (select CAmkESConnectionType _conn))\n                 (and (= W (select CAmkESAccessRestrictions _src))\n                      (= R (select CAmkESAccessRestrictions _dst))))\n             (=> (= seL4SharedDataWithCaps (select CAmkESConnectionType _conn))\n                 (and (ite (isVMComponent (select CAmkESPortComponent _src))\n                           (= RW (select CAmkESAccessRestrictions _src))\n                           (= W (select CAmkESAccessRestrictions _src)))\n                      (= R (select CAmkESAccessRestrictions _dst))))))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AadlComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement (Some aadlComponent1) camkesComponent)\n        (not (exists ((aadlComponent2 AadlComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement (Some aadlComponent2) camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AadlPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AadlPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    (= CAmkESPort_count CAmkESPortComponent_size) ; all CAmkES ports belong to a CAmkES component\n    CAmkESDataPortAccess\n    CAmkESFlowNoSelfConnection))\n\n; helper method: if either port belongs to a VM component then any data connection between the two of them\n; must be seL4SharedDataWithCaps, seL4SharedData otherwise\n(define-fun getExpectedDataConnectionType ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) seL4ConnectorType\n  (ite (or (isVMComponent (select CAmkESPortComponent camkesSource))\n           (isVMComponent (select CAmkESPortComponent camkesDest))\n           false)\n       seL4SharedDataWithCaps\n       seL4SharedData))\n\n; helper method: if the destination port belongs to a VM component than any event connection between the two ports\n; must be seL4GlobalAsynch, seL4Notification otherwise\n(define-fun getExpectedEventConnectionType ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) seL4ConnectorType\n  (ite (isVMComponent (select CAmkESPortComponent camkesDest))\n       seL4GlobalAsynch\n       seL4Notification))\n\n(define-fun SB_DataPortRefinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) (getExpectedDataConnectionType camkesSource camkesDest)) ; actual connector type must match expected\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_EventPortRefinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) (getExpectedEventConnectionType camkesSource camkesDest)) ; actual connector type must match expected\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_Refinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (or\n         (and\n           (= DataPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)) ; payload\n         (and\n           (= EventPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; event counter\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         (and\n           (= EventDataPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; payload\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         false)))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AadlPort) (aadlDest AadlPort))\n    (=> (AadlConnectionFlowTos aadlSource aadlDest)\n        (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n             (SB_Refinement aadlSource aadlDest)))))\n\n\n(define-fun isAadl_SB_ConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (exists ((aadlSource AadlPort) (aadlDest AadlPort))\n         (and\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest camkesDest)\n           (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n           (AadlConnectionFlowTos aadlSource aadlDest)))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun isVirtualMachineInducedConnection ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (or\n    (and (isVMAuxConnection conn)\n         (or (isVMAuxPort camkesSource)\n             (isVMAuxPort camkesDest)\n             false))\n    (and (isSerialServer (select CAmkESPortComponent camkesSource)) ; connection b\/w serial and time server\n         (isTimeServer (select CAmkESPortComponent camkesDest)))\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAadl_SB_ConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        (isVirtualMachineInducedConnection conn camkesSource camkesDest)\n        false))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                              Proof                                     ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "markers" : [
          ]
        }
      ]
    ]
  }
}