{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "slang\/src\/main\/data\/uav_june_step6__SeL4\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = {\n    Contract(Ensures(Res == F))\n    return F\n  }\n\n\n  def Integer_example(): Integer = {\n    Contract(Ensures(Res == z\"0\"))\n    return z\"0\"\n  }\n\n  def Integer_8_example(): Integer_8 = {\n    Contract(Ensures(Res == s8\"0\"))\n    return s8\"0\"\n  }\n\n  def Integer_16_example(): Integer_16 = {\n    Contract(Ensures(Res == s16\"0\"))\n    return s16\"0\"\n  }\n\n  def Integer_32_example(): Integer_32 = {\n    Contract(Ensures(Res == s32\"0\"))\n    return s32\"0\"\n  }\n\n  def Integer_64_example(): Integer_64 = {\n    Contract(Ensures(Res == s64\"0\"))\n    return s64\"0\"\n  }\n\n\n  def Unsigned_8_example(): Unsigned_8 = {\n    Contract(Ensures(Res == u8\"0\"))\n    return u8\"0\"\n  }\n\n  def Unsigned_16_example(): Unsigned_16 = {\n    Contract(Ensures(Res == u16\"0\"))\n    return u16\"0\"\n  }\n\n  def Unsigned_32_example(): Unsigned_32 = {\n    Contract(Ensures(Res == u32\"0\"))\n    return u32\"0\"\n  }\n\n  def Unsigned_64_example(): Unsigned_64 = {\n    Contract(Ensures(Res == u64\"0\"))\n    return u64\"0\"\n  }\n\n\n  def Float_example(): Float = {\n    Contract(Ensures(Res == r\"0\"))\n    return r\"0\"\n  }\n\n  def Float_32_example(): Float_32 = {\n    Contract(Ensures(Res == f32\"0\"))\n    return f32\"0\"\n  }\n\n  def Float_64_example(): Float_64 = {\n    Contract(Ensures(Res == f64\"0\"))\n    return f64\"0\"\n  }\n\n\n  def Character_example(): Character = {\n    Contract(Ensures(Res == ' '))\n    return ' '\n  }\n\n  def String_example(): String = {\n    Contract(Ensures(Res == \"\"))\n    return \"\"\n  }\n\n\n  def Bits_example(): Bits = {\n    Contract(Ensures(Res == ISZ[B]()))\n    return ISZ[B]()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/architecture\/uav_june_step6__SeL4\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject Arch {\n  val UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver : uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_recv_data\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_send_data\", mode = EventOut)\n    val AirVehicleState_WPM = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM\", mode = EventOut)\n    val AirVehicleState_UXAS = Port[Base_Types.Bits] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS\", mode = EventOut)\n\n    uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      MissionCommand = MissionCommand,\n      send_data = send_data,\n      AirVehicleState_WPM = AirVehicleState_WPM,\n      AirVehicleState_UXAS = AirVehicleState_UXAS\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation : uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = portId\"5\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_recv_data\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = portId\"6\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_send_data\", mode = EventOut)\n    val trusted_ids = Port[Base_Types.Bits] (id = portId\"7\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_trusted_ids\", mode = EventOut)\n    val AutomationRequest = Port[Base_Types.Bits] (id = portId\"8\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_AutomationRequest\", mode = EventOut)\n    val OperatingRegion = Port[Base_Types.Bits] (id = portId\"9\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_OperatingRegion\", mode = EventOut)\n    val LineSearchTask = Port[Base_Types.Bits] (id = portId\"10\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_LineSearchTask\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge(\n      id = bridgeId\"1\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      send_data = send_data,\n      trusted_ids = trusted_ids,\n      AutomationRequest = AutomationRequest,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase : uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = portId\"11\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones\", mode = DataOut)\n    val keep_out_zones = Port[Base_Types.Bits] (id = portId\"12\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones\", mode = DataOut)\n\n    uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge(\n      id = bridgeId\"2\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS : uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge = {\n    val AutomationRequest = Port[Base_Types.Bits] (id = portId\"13\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationRequest\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = portId\"14\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AirVehicleState\", mode = EventIn)\n    val OperatingRegion = Port[Base_Types.Bits] (id = portId\"15\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_OperatingRegion\", mode = EventIn)\n    val LineSearchTask = Port[Base_Types.Bits] (id = portId\"16\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_LineSearchTask\", mode = EventIn)\n    val AutomationResponse_MON_GEO = Port[Base_Types.Bits] (id = portId\"17\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_GEO\", mode = EventOut)\n    val AutomationResponse_MON_REQ = Port[Base_Types.Bits] (id = portId\"18\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_REQ\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge(\n      id = bridgeId\"3\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationRequest = AutomationRequest,\n      AirVehicleState = AirVehicleState,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask,\n      AutomationResponse_MON_GEO = AutomationResponse_MON_GEO,\n      AutomationResponse_MON_REQ = AutomationResponse_MON_REQ\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService : uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge = {\n    val AutomationResponse = Port[Base_Types.Bits] (id = portId\"19\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = portId\"20\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = portId\"21\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand\", mode = EventOut)\n    val ReturnHome = Port[art.Empty] (id = portId\"22\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome\", mode = EventIn)\n\n    uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge(\n      id = bridgeId\"4\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationResponse = AutomationResponse,\n      AirVehicleState = AirVehicleState,\n      MissionCommand = MissionCommand,\n      ReturnHome = ReturnHome\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate : uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge = {\n    val trusted_ids = Port[Base_Types.Bits] (id = portId\"23\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids\", mode = EventIn)\n    val AutomationRequest_in = Port[Base_Types.Bits] (id = portId\"24\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in\", mode = EventIn)\n    val AutomationRequest_out_UXAS = Port[Base_Types.Bits] (id = portId\"25\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS\", mode = EventOut)\n    val AutomationRequest_out_MON_REQ = Port[Base_Types.Bits] (id = portId\"26\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ\", mode = EventOut)\n    val OperatingRegion_in = Port[Base_Types.Bits] (id = portId\"27\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in\", mode = EventIn)\n    val OperatingRegion_out = Port[Base_Types.Bits] (id = portId\"28\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out\", mode = EventOut)\n    val LineSearchTask_in = Port[Base_Types.Bits] (id = portId\"29\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in\", mode = EventIn)\n    val LineSearchTask_out = Port[Base_Types.Bits] (id = portId\"30\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge(\n      id = bridgeId\"5\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      trusted_ids = trusted_ids,\n      AutomationRequest_in = AutomationRequest_in,\n      AutomationRequest_out_UXAS = AutomationRequest_out_UXAS,\n      AutomationRequest_out_MON_REQ = AutomationRequest_out_MON_REQ,\n      OperatingRegion_in = OperatingRegion_in,\n      OperatingRegion_out = OperatingRegion_out,\n      LineSearchTask_in = LineSearchTask_in,\n      LineSearchTask_out = LineSearchTask_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST : uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge = {\n    val filter_in = Port[Base_Types.Bits] (id = portId\"31\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in\", mode = EventIn)\n    val filter_out = Port[Base_Types.Bits] (id = portId\"32\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge(\n      id = bridgeId\"6\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      filter_in = filter_in,\n      filter_out = filter_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req : uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge = {\n    val observed = Port[Base_Types.Bits] (id = portId\"33\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed\", mode = EventIn)\n    val reference_1 = Port[Base_Types.Bits] (id = portId\"34\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1\", mode = EventIn)\n\n    uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge(\n      id = bridgeId\"7\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      observed = observed,\n      reference_1 = reference_1\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo : uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = portId\"35\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones\", mode = DataIn)\n    val keep_out_zones = Port[Base_Types.Bits] (id = portId\"36\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones\", mode = DataIn)\n    val observed = Port[Base_Types.Bits] (id = portId\"37\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed\", mode = EventIn)\n    val output = Port[Base_Types.Bits] (id = portId\"38\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output\", mode = EventOut)\n    val alert = Port[art.Empty] (id = portId\"39\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge(\n      id = bridgeId\"8\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones,\n      observed = observed,\n      output = output,\n      alert = alert\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n    TranspilerUtil.touch()\n\n    ArchitectureDescription(\n      components = IS[Art.BridgeId, Bridge] (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver, UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation, UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase, UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS, UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService, UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate, UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST, UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req, UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo),\n\n      connections = IS[Art.ConnectionId, UConnection] (Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_WPM, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AirVehicleState),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_UXAS, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AirVehicleState),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.trusted_ids, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.trusted_ids),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.AutomationRequest, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_in),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.OperatingRegion, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_in),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.LineSearchTask, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_in),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_in_zones, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_in_zones),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_out_zones, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_out_zones),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_GEO, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.observed),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_REQ, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.observed),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.MissionCommand, to = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.MissionCommand),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_UXAS, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationRequest),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_MON_REQ, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.reference_1),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_out, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.OperatingRegion),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_out, to = UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_in),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_out, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.LineSearchTask),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.output, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AutomationResponse),\n                                                       Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.alert, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.ReturnHome))\n    )\n  }\n}\n\nobject TranspilerUtil {\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch process\/thread timing properties\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_HW_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timingProperties)\n      println(Schedulers.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timingProperties)\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      {\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_recv_data()\n        val apiUsage_MissionCommand: Option[Base_Types.Bits] = uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_MissionCommand()\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n        uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.get_recv_data()\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_trusted_ids(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_trusted_ids(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_AutomationRequest(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_AutomationRequest(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_OperatingRegion(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_OperatingRegion(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_LineSearchTask(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_LineSearchTask(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_in_zones(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_in_zones(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_out_zones(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_out_zones(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_AutomationRequest: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AutomationRequest()\n        val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AirVehicleState()\n        val apiUsage_OperatingRegion: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_OperatingRegion()\n        val apiUsage_LineSearchTask: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_LineSearchTask()\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_AutomationResponse: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AutomationResponse()\n        val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AirVehicleState()\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.put_MissionCommand(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.put_MissionCommand(Base_Types.Bits_example())\n        val apiUsage_ReturnHome: Option[art.Empty] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_ReturnHome()\n      }\n      {\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_trusted_ids: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_trusted_ids()\n        val apiUsage_AutomationRequest_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_AutomationRequest_in()\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n        val apiUsage_OperatingRegion_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_OperatingRegion_in()\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n        val apiUsage_LineSearchTask_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_LineSearchTask_in()\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_filter_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.get_filter_in()\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.put_filter_out(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.put_filter_out(Base_Types.Bits_example())\n      }\n      {\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_observed()\n        val apiUsage_reference_1: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_reference_1()\n      }\n      {\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logError(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logInfo(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logDebug(\"\")\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_keep_in_zones: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_in_zones()\n        val apiUsage_keep_out_zones: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_out_zones()\n        val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_observed()\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_output(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_output(Base_Types.Bits_example())\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_alert()\n        uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_alert()\n      }\n    }\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/uav_june_step6__SeL4\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticSchedulerH(MNone())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n\n        Platform.setup()\n\n        art.Art.run(Arch.ad, scheduler)\n\n        Platform.tearDown()\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/uav_june_step6__SeL4\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage uav_june_step6__SeL4\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec}\nimport art.scheduling.static._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val threadNickNames: Map[String, Art.BridgeId] = Map(\n    ISZ(\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.id,\n      Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.name ~> Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.id)\n  )\n\n  val revThreadNickNames: Map[Art.BridgeId, String] = Map.empty[Art.BridgeId, String] ++ (for (e <- threadNickNames.entries) yield e._2 ~> e._1)\n\n  val UAV_Impl_Instance_MCMP_PROC_HW_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = Some(2),\n    framePeriod = Some(1000),\n    maxDomain = Some(15),\n    slotTime = None())\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((6, 6)),\n    domain = Some(3))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(2))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(10))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(9))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(14))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(5))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(7))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(11))\n\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((2, 2)),\n    domain = Some(13))\n\n\n  \/**********************************************************************\n   * Round Robin Scheduler\n   *********************************************************************\/\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[Art.BridgeId] = {\n    \/\/ convert IS[Art.BridgeId, art.Bridge] to an IS[Z, Art.BridgeId] to allow bridges to be dispatched\n    \/\/ multiple times during a hyper-period\n    var ret: ISZ[Art.BridgeId] = ISZ()\n    for (e <- Arch.ad.components) {\n      ret = ret :+ e.id\n    }\n    ret\n  }\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[Art.BridgeId]]): RoundRobin = {\n    if (roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  \/**********************************************************************\n   * Static Scheduler\n   *********************************************************************\/\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ defaultStaticSchedule represents the component dispatch order\n  val defaultStaticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Schedule.Slot(0, maxExecutionTime),\n    Schedule.Slot(1, maxExecutionTime),\n    Schedule.Slot(2, maxExecutionTime),\n    Schedule.Slot(3, maxExecutionTime),\n    Schedule.Slot(4, maxExecutionTime),\n    Schedule.Slot(5, maxExecutionTime),\n    Schedule.Slot(6, maxExecutionTime),\n    Schedule.Slot(7, maxExecutionTime),\n    Schedule.Slot(8, maxExecutionTime)\n  )))\n\n  val defaultDomainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ(\n    \/* domain 0 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.id,\n    \/* domain 1 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.id,\n    \/* domain 2 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.id,\n    \/* domain 3 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.id,\n    \/* domain 4 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.id,\n    \/* domain 5 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.id,\n    \/* domain 6 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.id,\n    \/* domain 7 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.id,\n    \/* domain 8 *\/ Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.id\n  )\n\n  def getStaticSchedulerH(userProvided: MOption[(DScheduleSpec, ISZ[Art.BridgeId], Map[String, Art.BridgeId], CommandProvider)]): StaticScheduler = {\n    if (defaultStaticSchedule.schedule.slots.isEmpty && defaultDomainToBridgeIdMap.isEmpty && threadNickNames.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    userProvided match {\n      case MSome((schedule_, domainToBridgeIdMap_, threadNickNames_, commandProvider)) =>\n        return getStaticScheduler(schedule_, domainToBridgeIdMap_, threadNickNames_, commandProvider)\n      case _ =>\n        return getStaticScheduler(\n          ScheduleProviderI.getStaticSchedule(),\n          \/\/ TODO: get the following from extension so they can be customized via C\n          defaultDomainToBridgeIdMap,\n          threadNickNames,\n          DefaultCommandProvider())\n    }\n  }\n\n  def getStaticScheduler(schedule: DScheduleSpec,\n                         domainToBridgeIdMap: ISZ[Art.BridgeId],\n                         threadNickNames: Map[String, Art.BridgeId],\n                         commandProvider: CommandProvider): StaticScheduler = {\n    return StaticScheduler(schedule, Arch.ad.components, domainToBridgeIdMap, threadNickNames,\n      if (commandProvider.isInstanceOf[InfoCommandProvider])\n        commandProvider.asInstanceOf[InfoCommandProvider].init(\n          threadNickNames,\n          schedule.schedule.slots.size,\n          domainToBridgeIdMap\n        )\n      else commandProvider)\n  }\n\n\n  \/**********************************************************************\n   * Legacy Scheduler\n   *********************************************************************\/\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n\/\/ the purpose of this extension is to allow users to provide custom schedules\n\/\/ at the C level after transpiling\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = $\n\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/uav_june_step6__SeL4\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[Art.BridgeId] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.defaultStaticSchedule\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/inspector\/uav_june_step6__SeL4\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param recv_data payloads for event data port recv_data.\n   *   ART currently supports single element event data queues so\n   *   only the last element of recv_data will be used\n   * @param MissionCommand payloads for event data port MissionCommand.\n   *   ART currently supports single element event data queues so\n   *   only the last element of MissionCommand will be used\n   *\/\n  def put_concrete_inputs(recv_data : ISZ[Base_Types.Bits],\n                          MissionCommand : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- recv_data){\n      put_recv_data(v)\n    }\n    for(v <- MissionCommand){\n      put_MissionCommand(v)\n    }\n  }\n\n\n  \/** helper function to check UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param send_data method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'send_data'.\n   * @param AirVehicleState_WPM method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AirVehicleState_WPM'.\n   * @param AirVehicleState_UXAS method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AirVehicleState_UXAS'.\n   *\/\n  def check_concrete_output(send_data: ISZ[Base_Types.Bits] => B,\n                            AirVehicleState_WPM: ISZ[Base_Types.Bits] => B,\n                            AirVehicleState_UXAS: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var send_dataValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_send_data().nonEmpty) { send_dataValue = send_dataValue :+ get_send_data().get }\n    if(!send_data(send_dataValue)) {\n      testFailures = testFailures :+ st\"'send_data' did not match expected: received ${send_dataValue.size} events with the following payloads ${send_dataValue}\"\n    }\n    var AirVehicleState_WPMValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AirVehicleState_WPM().nonEmpty) { AirVehicleState_WPMValue = AirVehicleState_WPMValue :+ get_AirVehicleState_WPM().get }\n    if(!AirVehicleState_WPM(AirVehicleState_WPMValue)) {\n      testFailures = testFailures :+ st\"'AirVehicleState_WPM' did not match expected: received ${AirVehicleState_WPMValue.size} events with the following payloads ${AirVehicleState_WPMValue}\"\n    }\n    var AirVehicleState_UXASValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AirVehicleState_UXAS().nonEmpty) { AirVehicleState_UXASValue = AirVehicleState_UXASValue :+ get_AirVehicleState_UXAS().get }\n    if(!AirVehicleState_UXAS(AirVehicleState_UXASValue)) {\n      testFailures = testFailures :+ st\"'AirVehicleState_UXAS' did not match expected: received ${AirVehicleState_UXASValue.size} events with the following payloads ${AirVehicleState_UXASValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_recv_data(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.operational_api.recv_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_MissionCommand(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.operational_api.MissionCommand_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_send_data(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_send_data_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port send_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_send_data_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.initialization_api.send_data_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AirVehicleState_WPM(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AirVehicleState_WPM_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AirVehicleState_WPM.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AirVehicleState_WPM_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.initialization_api.AirVehicleState_WPM_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AirVehicleState_UXAS(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AirVehicleState_UXAS_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AirVehicleState_UXAS.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AirVehicleState_UXAS_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.initialization_api.AirVehicleState_UXAS_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.Drivers\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport uav_june_step6__SeL4.Drivers._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Test extends UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.Drivers.{UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_data: Port[Base_Types.Bits],\n  MissionCommand: Port[Base_Types.Bits],\n  send_data: Port[Base_Types.Bits],\n  AirVehicleState_WPM: Port[Base_Types.Bits],\n  AirVehicleState_UXAS: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](recv_data,\n                              MissionCommand),\n\n    eventOuts = ISZ[art.UPort](send_data,\n                               AirVehicleState_WPM,\n                               AirVehicleState_UXAS)\n  )\n\n  val initialization_api : UARTDriver_Impl_Initialization_Api = {\n    val api = UARTDriver_Impl_Initialization_Api(\n      id,\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id\n    )\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : UARTDriver_Impl_Operational_Api = {\n    val api = UARTDriver_Impl_Operational_Api(\n      id,\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id\n    )\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.EntryPoints(\n      id,\n\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge {\n\n  var c_initialization_api: Option[UARTDriver_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[UARTDriver_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_BridgeId : Art.BridgeId,\n    recv_data_Id : Art.PortId,\n    MissionCommand_Id : Art.PortId,\n    send_data_Id : Art.PortId,\n    AirVehicleState_WPM_Id : Art.PortId,\n    AirVehicleState_UXAS_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: UARTDriver_Impl_Initialization_Api,\n    operational_api: UARTDriver_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(recv_data_Id,\n                                             MissionCommand_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(send_data_Id,\n                                              AirVehicleState_WPM_Id,\n                                              AirVehicleState_UXAS_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UARTDriver_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UARTDriver_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait UARTDriver_Impl_Api {\n  def id: Art.BridgeId\n  def recv_data_Id : Art.PortId\n  def MissionCommand_Id : Art.PortId\n  def send_data_Id : Art.PortId\n  def AirVehicleState_WPM_Id : Art.PortId\n  def AirVehicleState_UXAS_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var send_data: Option[Base_Types.Bits] = $\n\n  def put_send_data(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(send_data),\n      Ensures(\n        send_data == Some(value)\n      )\n    )\n    Spec {\n      send_data = Some(value)\n    }\n\n    Art.putValue(send_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AirVehicleState_WPM: Option[Base_Types.Bits] = $\n\n  def put_AirVehicleState_WPM(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AirVehicleState_WPM),\n      Ensures(\n        AirVehicleState_WPM == Some(value)\n      )\n    )\n    Spec {\n      AirVehicleState_WPM = Some(value)\n    }\n\n    Art.putValue(AirVehicleState_WPM_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AirVehicleState_UXAS: Option[Base_Types.Bits] = $\n\n  def put_AirVehicleState_UXAS(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AirVehicleState_UXAS),\n      Ensures(\n        AirVehicleState_UXAS == Some(value)\n      )\n    )\n    Spec {\n      AirVehicleState_UXAS = Some(value)\n    }\n\n    Art.putValue(AirVehicleState_UXAS_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class UARTDriver_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val AirVehicleState_WPM_Id : Art.PortId,\n  val AirVehicleState_UXAS_Id : Art.PortId) extends UARTDriver_Impl_Api\n\n@datatype class UARTDriver_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val AirVehicleState_WPM_Id : Art.PortId,\n  val AirVehicleState_UXAS_Id : Art.PortId) extends UARTDriver_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var recv_data: Option[Base_Types.Bits] = $\n\n  def get_recv_data() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == recv_data\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(recv_data_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port recv_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var MissionCommand: Option[Base_Types.Bits] = $\n\n  def get_MissionCommand() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == MissionCommand\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(MissionCommand_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port MissionCommand.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver {\n\n  def initialise(api: UARTDriver_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: UARTDriver_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param recv_data payloads for event data port recv_data.\n   *   ART currently supports single element event data queues so\n   *   only the last element of recv_data will be used\n   *\/\n  def put_concrete_inputs(recv_data : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- recv_data){\n      put_recv_data(v)\n    }\n  }\n\n\n  \/** helper function to check RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param send_data method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'send_data'.\n   * @param trusted_ids method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'trusted_ids'.\n   * @param AutomationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest'.\n   * @param OperatingRegion method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'OperatingRegion'.\n   * @param LineSearchTask method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'LineSearchTask'.\n   *\/\n  def check_concrete_output(send_data: ISZ[Base_Types.Bits] => B,\n                            trusted_ids: ISZ[Base_Types.Bits] => B,\n                            AutomationRequest: ISZ[Base_Types.Bits] => B,\n                            OperatingRegion: ISZ[Base_Types.Bits] => B,\n                            LineSearchTask: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var send_dataValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_send_data().nonEmpty) { send_dataValue = send_dataValue :+ get_send_data().get }\n    if(!send_data(send_dataValue)) {\n      testFailures = testFailures :+ st\"'send_data' did not match expected: received ${send_dataValue.size} events with the following payloads ${send_dataValue}\"\n    }\n    var trusted_idsValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_trusted_ids().nonEmpty) { trusted_idsValue = trusted_idsValue :+ get_trusted_ids().get }\n    if(!trusted_ids(trusted_idsValue)) {\n      testFailures = testFailures :+ st\"'trusted_ids' did not match expected: received ${trusted_idsValue.size} events with the following payloads ${trusted_idsValue}\"\n    }\n    var AutomationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest().nonEmpty) { AutomationRequestValue = AutomationRequestValue :+ get_AutomationRequest().get }\n    if(!AutomationRequest(AutomationRequestValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest' did not match expected: received ${AutomationRequestValue.size} events with the following payloads ${AutomationRequestValue}\"\n    }\n    var OperatingRegionValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_OperatingRegion().nonEmpty) { OperatingRegionValue = OperatingRegionValue :+ get_OperatingRegion().get }\n    if(!OperatingRegion(OperatingRegionValue)) {\n      testFailures = testFailures :+ st\"'OperatingRegion' did not match expected: received ${OperatingRegionValue.size} events with the following payloads ${OperatingRegionValue}\"\n    }\n    var LineSearchTaskValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_LineSearchTask().nonEmpty) { LineSearchTaskValue = LineSearchTaskValue :+ get_LineSearchTask().get }\n    if(!LineSearchTask(LineSearchTaskValue)) {\n      testFailures = testFailures :+ st\"'LineSearchTask' did not match expected: received ${LineSearchTaskValue.size} events with the following payloads ${LineSearchTaskValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_recv_data(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.operational_api.recv_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_send_data(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_send_data_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port send_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_send_data_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.initialization_api.send_data_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_trusted_ids(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_trusted_ids_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port trusted_ids.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_trusted_ids_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.initialization_api.trusted_ids_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AutomationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.initialization_api.AutomationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_OperatingRegion(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_OperatingRegion_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port OperatingRegion.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_OperatingRegion_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.initialization_api.OperatingRegion_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_LineSearchTask(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_LineSearchTask_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port LineSearchTask.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_LineSearchTask_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.initialization_api.LineSearchTask_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Test extends RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_data: Port[Base_Types.Bits],\n  send_data: Port[Base_Types.Bits],\n  trusted_ids: Port[Base_Types.Bits],\n  AutomationRequest: Port[Base_Types.Bits],\n  OperatingRegion: Port[Base_Types.Bits],\n  LineSearchTask: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](recv_data),\n\n    eventOuts = ISZ[art.UPort](send_data,\n                               trusted_ids,\n                               AutomationRequest,\n                               OperatingRegion,\n                               LineSearchTask)\n  )\n\n  val initialization_api : RadioDriver_Attestation_thr_Impl_Initialization_Api = {\n    val api = RadioDriver_Attestation_thr_Impl_Initialization_Api(\n      id,\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id\n    )\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : RadioDriver_Attestation_thr_Impl_Operational_Api = {\n    val api = RadioDriver_Attestation_thr_Impl_Operational_Api(\n      id,\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id\n    )\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.EntryPoints(\n      id,\n\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge {\n\n  var c_initialization_api: Option[RadioDriver_Attestation_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[RadioDriver_Attestation_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_BridgeId : Art.BridgeId,\n    recv_data_Id : Art.PortId,\n    send_data_Id : Art.PortId,\n    trusted_ids_Id : Art.PortId,\n    AutomationRequest_Id : Art.PortId,\n    OperatingRegion_Id : Art.PortId,\n    LineSearchTask_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: RadioDriver_Attestation_thr_Impl_Initialization_Api,\n    operational_api: RadioDriver_Attestation_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(recv_data_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(send_data_Id,\n                                              trusted_ids_Id,\n                                              AutomationRequest_Id,\n                                              OperatingRegion_Id,\n                                              LineSearchTask_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: RadioDriver_Attestation_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: RadioDriver_Attestation_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait RadioDriver_Attestation_thr_Impl_Api {\n  def id: Art.BridgeId\n  def recv_data_Id : Art.PortId\n  def send_data_Id : Art.PortId\n  def trusted_ids_Id : Art.PortId\n  def AutomationRequest_Id : Art.PortId\n  def OperatingRegion_Id : Art.PortId\n  def LineSearchTask_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var send_data: Option[Base_Types.Bits] = $\n\n  def put_send_data(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(send_data),\n      Ensures(\n        send_data == Some(value)\n      )\n    )\n    Spec {\n      send_data = Some(value)\n    }\n\n    Art.putValue(send_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var trusted_ids: Option[Base_Types.Bits] = $\n\n  def put_trusted_ids(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(trusted_ids),\n      Ensures(\n        trusted_ids == Some(value)\n      )\n    )\n    Spec {\n      trusted_ids = Some(value)\n    }\n\n    Art.putValue(trusted_ids_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AutomationRequest: Option[Base_Types.Bits] = $\n\n  def put_AutomationRequest(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AutomationRequest),\n      Ensures(\n        AutomationRequest == Some(value)\n      )\n    )\n    Spec {\n      AutomationRequest = Some(value)\n    }\n\n    Art.putValue(AutomationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var OperatingRegion: Option[Base_Types.Bits] = $\n\n  def put_OperatingRegion(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(OperatingRegion),\n      Ensures(\n        OperatingRegion == Some(value)\n      )\n    )\n    Spec {\n      OperatingRegion = Some(value)\n    }\n\n    Art.putValue(OperatingRegion_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var LineSearchTask: Option[Base_Types.Bits] = $\n\n  def put_LineSearchTask(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(LineSearchTask),\n      Ensures(\n        LineSearchTask == Some(value)\n      )\n    )\n    Spec {\n      LineSearchTask = Some(value)\n    }\n\n    Art.putValue(LineSearchTask_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class RadioDriver_Attestation_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId) extends RadioDriver_Attestation_thr_Impl_Api\n\n@datatype class RadioDriver_Attestation_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId) extends RadioDriver_Attestation_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var recv_data: Option[Base_Types.Bits] = $\n\n  def get_recv_data() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == recv_data\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(recv_data_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port recv_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation {\n\n  def initialise(api: RadioDriver_Attestation_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  }\n\n  \/** helper function to check FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param keep_in_zones method that will be called with the value of the outgoing data\n   *        port 'keep_in_zones'.\n   * @param keep_out_zones method that will be called with the value of the outgoing data\n   *        port 'keep_out_zones'.\n   *\/\n  def check_concrete_output(keep_in_zones: Base_Types.Bits => B,\n                            keep_out_zones: Base_Types.Bits => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val keep_in_zonesValue: Base_Types.Bits = get_keep_in_zones().get\n    if(!keep_in_zones(keep_in_zonesValue)) {\n      testFailures = testFailures :+ st\"'keep_in_zones' did not match expected: value of the outgoing data port is ${keep_in_zonesValue}\"\n    }\n    val keep_out_zonesValue: Base_Types.Bits = get_keep_out_zones().get\n    if(!keep_out_zones(keep_out_zonesValue)) {\n      testFailures = testFailures :+ st\"'keep_out_zones' did not match expected: value of the outgoing data port is ${keep_out_zonesValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_keep_in_zones(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_keep_in_zones_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port keep_in_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_keep_in_zones_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.initialization_api.keep_in_zones_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_keep_out_zones(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_keep_out_zones_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port keep_out_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_keep_out_zones_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.initialization_api.keep_out_zones_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Test extends FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  keep_in_zones: Port[Base_Types.Bits],\n  keep_out_zones: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](keep_in_zones,\n                              keep_out_zones),\n\n    eventIns = ISZ[art.UPort](),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : FlyZonesDatabase_thr_Impl_Initialization_Api = {\n    val api = FlyZonesDatabase_thr_Impl_Initialization_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id\n    )\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : FlyZonesDatabase_thr_Impl_Operational_Api = {\n    val api = FlyZonesDatabase_thr_Impl_Operational_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id\n    )\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.EntryPoints(\n      id,\n\n      keep_in_zones.id,\n      keep_out_zones.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge {\n\n  var c_initialization_api: Option[FlyZonesDatabase_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[FlyZonesDatabase_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_BridgeId : Art.BridgeId,\n    keep_in_zones_Id : Art.PortId,\n    keep_out_zones_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: FlyZonesDatabase_thr_Impl_Initialization_Api,\n    operational_api: FlyZonesDatabase_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS()\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS(keep_in_zones_Id,\n                                             keep_out_zones_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: FlyZonesDatabase_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: FlyZonesDatabase_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait FlyZonesDatabase_thr_Impl_Api {\n  def id: Art.BridgeId\n  def keep_in_zones_Id : Art.PortId\n  def keep_out_zones_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var keep_in_zones: Base_Types.Bits = $\n\n  def put_keep_in_zones(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(keep_in_zones),\n      Ensures(\n        keep_in_zones == value\n      )\n    )\n    Spec {\n      keep_in_zones = value\n    }\n\n    Art.putValue(keep_in_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing data port\n  @spec var keep_out_zones: Base_Types.Bits = $\n\n  def put_keep_out_zones(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(keep_out_zones),\n      Ensures(\n        keep_out_zones == value\n      )\n    )\n    Spec {\n      keep_out_zones = value\n    }\n\n    Art.putValue(keep_out_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class FlyZonesDatabase_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId) extends FlyZonesDatabase_thr_Impl_Api\n\n@datatype class FlyZonesDatabase_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId) extends FlyZonesDatabase_thr_Impl_Api {\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase {\n\n  def initialise(api: FlyZonesDatabase_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param AutomationRequest payloads for event data port AutomationRequest.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationRequest will be used\n   * @param AirVehicleState payloads for event data port AirVehicleState.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AirVehicleState will be used\n   * @param OperatingRegion payloads for event data port OperatingRegion.\n   *   ART currently supports single element event data queues so\n   *   only the last element of OperatingRegion will be used\n   * @param LineSearchTask payloads for event data port LineSearchTask.\n   *   ART currently supports single element event data queues so\n   *   only the last element of LineSearchTask will be used\n   *\/\n  def put_concrete_inputs(AutomationRequest : ISZ[Base_Types.Bits],\n                          AirVehicleState : ISZ[Base_Types.Bits],\n                          OperatingRegion : ISZ[Base_Types.Bits],\n                          LineSearchTask : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- AutomationRequest){\n      put_AutomationRequest(v)\n    }\n    for(v <- AirVehicleState){\n      put_AirVehicleState(v)\n    }\n    for(v <- OperatingRegion){\n      put_OperatingRegion(v)\n    }\n    for(v <- LineSearchTask){\n      put_LineSearchTask(v)\n    }\n  }\n\n\n  \/** helper function to check UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AutomationResponse_MON_GEO method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationResponse_MON_GEO'.\n   * @param AutomationResponse_MON_REQ method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationResponse_MON_REQ'.\n   *\/\n  def check_concrete_output(AutomationResponse_MON_GEO: ISZ[Base_Types.Bits] => B,\n                            AutomationResponse_MON_REQ: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AutomationResponse_MON_GEOValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationResponse_MON_GEO().nonEmpty) { AutomationResponse_MON_GEOValue = AutomationResponse_MON_GEOValue :+ get_AutomationResponse_MON_GEO().get }\n    if(!AutomationResponse_MON_GEO(AutomationResponse_MON_GEOValue)) {\n      testFailures = testFailures :+ st\"'AutomationResponse_MON_GEO' did not match expected: received ${AutomationResponse_MON_GEOValue.size} events with the following payloads ${AutomationResponse_MON_GEOValue}\"\n    }\n    var AutomationResponse_MON_REQValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationResponse_MON_REQ().nonEmpty) { AutomationResponse_MON_REQValue = AutomationResponse_MON_REQValue :+ get_AutomationResponse_MON_REQ().get }\n    if(!AutomationResponse_MON_REQ(AutomationResponse_MON_REQValue)) {\n      testFailures = testFailures :+ st\"'AutomationResponse_MON_REQ' did not match expected: received ${AutomationResponse_MON_REQValue.size} events with the following payloads ${AutomationResponse_MON_REQValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationRequest(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.operational_api.AutomationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AirVehicleState(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.operational_api.AirVehicleState_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_OperatingRegion(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.operational_api.OperatingRegion_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_LineSearchTask(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.operational_api.LineSearchTask_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationResponse_MON_GEO(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationResponse_MON_GEO_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AutomationResponse_MON_GEO.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationResponse_MON_GEO_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.initialization_api.AutomationResponse_MON_GEO_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationResponse_MON_REQ(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationResponse_MON_REQ_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AutomationResponse_MON_REQ.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationResponse_MON_REQ_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.initialization_api.AutomationResponse_MON_REQ_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Test extends UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AutomationRequest: Port[Base_Types.Bits],\n  AirVehicleState: Port[Base_Types.Bits],\n  OperatingRegion: Port[Base_Types.Bits],\n  LineSearchTask: Port[Base_Types.Bits],\n  AutomationResponse_MON_GEO: Port[Base_Types.Bits],\n  AutomationResponse_MON_REQ: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](AutomationRequest,\n                              AirVehicleState,\n                              OperatingRegion,\n                              LineSearchTask),\n\n    eventOuts = ISZ[art.UPort](AutomationResponse_MON_GEO,\n                               AutomationResponse_MON_REQ)\n  )\n\n  val initialization_api : UxAS_thr_Impl_Initialization_Api = {\n    val api = UxAS_thr_Impl_Initialization_Api(\n      id,\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id\n    )\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : UxAS_thr_Impl_Operational_Api = {\n    val api = UxAS_thr_Impl_Operational_Api(\n      id,\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id\n    )\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.EntryPoints(\n      id,\n\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge {\n\n  var c_initialization_api: Option[UxAS_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[UxAS_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_BridgeId : Art.BridgeId,\n    AutomationRequest_Id : Art.PortId,\n    AirVehicleState_Id : Art.PortId,\n    OperatingRegion_Id : Art.PortId,\n    LineSearchTask_Id : Art.PortId,\n    AutomationResponse_MON_GEO_Id : Art.PortId,\n    AutomationResponse_MON_REQ_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: UxAS_thr_Impl_Initialization_Api,\n    operational_api: UxAS_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(AutomationRequest_Id,\n                                             AirVehicleState_Id,\n                                             OperatingRegion_Id,\n                                             LineSearchTask_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(AutomationResponse_MON_GEO_Id,\n                                              AutomationResponse_MON_REQ_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UxAS_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UxAS_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait UxAS_thr_Impl_Api {\n  def id: Art.BridgeId\n  def AutomationRequest_Id : Art.PortId\n  def AirVehicleState_Id : Art.PortId\n  def OperatingRegion_Id : Art.PortId\n  def LineSearchTask_Id : Art.PortId\n  def AutomationResponse_MON_GEO_Id : Art.PortId\n  def AutomationResponse_MON_REQ_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AutomationResponse_MON_GEO: Option[Base_Types.Bits] = $\n\n  def put_AutomationResponse_MON_GEO(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AutomationResponse_MON_GEO),\n      Ensures(\n        AutomationResponse_MON_GEO == Some(value)\n      )\n    )\n    Spec {\n      AutomationResponse_MON_GEO = Some(value)\n    }\n\n    Art.putValue(AutomationResponse_MON_GEO_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AutomationResponse_MON_REQ: Option[Base_Types.Bits] = $\n\n  def put_AutomationResponse_MON_REQ(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AutomationResponse_MON_REQ),\n      Ensures(\n        AutomationResponse_MON_REQ == Some(value)\n      )\n    )\n    Spec {\n      AutomationResponse_MON_REQ = Some(value)\n    }\n\n    Art.putValue(AutomationResponse_MON_REQ_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class UxAS_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AutomationRequest_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId,\n  val AutomationResponse_MON_GEO_Id : Art.PortId,\n  val AutomationResponse_MON_REQ_Id : Art.PortId) extends UxAS_thr_Impl_Api\n\n@datatype class UxAS_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AutomationRequest_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId,\n  val AutomationResponse_MON_GEO_Id : Art.PortId,\n  val AutomationResponse_MON_REQ_Id : Art.PortId) extends UxAS_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var AutomationRequest: Option[Base_Types.Bits] = $\n\n  def get_AutomationRequest() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == AutomationRequest\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationRequest_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var AirVehicleState: Option[Base_Types.Bits] = $\n\n  def get_AirVehicleState() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == AirVehicleState\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(AirVehicleState_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AirVehicleState.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var OperatingRegion: Option[Base_Types.Bits] = $\n\n  def get_OperatingRegion() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == OperatingRegion\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(OperatingRegion_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port OperatingRegion.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var LineSearchTask: Option[Base_Types.Bits] = $\n\n  def get_LineSearchTask() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == LineSearchTask\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(LineSearchTask_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port LineSearchTask.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS {\n\n  def initialise(api: UxAS_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param AutomationResponse payloads for event data port AutomationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationResponse will be used\n   * @param AirVehicleState payloads for event data port AirVehicleState.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AirVehicleState will be used\n   * @param ReturnHome the number of events to place in the ReturnHome event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(AutomationResponse : ISZ[Base_Types.Bits],\n                          AirVehicleState : ISZ[Base_Types.Bits],\n                          ReturnHome : Z): Unit = {\n    for(v <- AutomationResponse){\n      put_AutomationResponse(v)\n    }\n    for(v <- AirVehicleState){\n      put_AirVehicleState(v)\n    }\n    for(i <- 0 until ReturnHome) {\n      put_ReturnHome()\n    }\n  }\n\n\n  \/** helper function to check WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param MissionCommand method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'MissionCommand'.\n   *\/\n  def check_concrete_output(MissionCommand: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var MissionCommandValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_MissionCommand().nonEmpty) { MissionCommandValue = MissionCommandValue :+ get_MissionCommand().get }\n    if(!MissionCommand(MissionCommandValue)) {\n      testFailures = testFailures :+ st\"'MissionCommand' did not match expected: received ${MissionCommandValue.size} events with the following payloads ${MissionCommandValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationResponse(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.operational_api.AutomationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AirVehicleState(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.operational_api.AirVehicleState_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_ReturnHome(): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.operational_api.ReturnHome_Id, art.Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_MissionCommand(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_MissionCommand_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port MissionCommand.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_MissionCommand_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.initialization_api.MissionCommand_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Test extends WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AutomationResponse: Port[Base_Types.Bits],\n  AirVehicleState: Port[Base_Types.Bits],\n  MissionCommand: Port[Base_Types.Bits],\n  ReturnHome: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](AutomationResponse,\n                              AirVehicleState,\n                              ReturnHome),\n\n    eventOuts = ISZ[art.UPort](MissionCommand)\n  )\n\n  val initialization_api : WaypointPlanManagerService_thr_Impl_Initialization_Api = {\n    val api = WaypointPlanManagerService_thr_Impl_Initialization_Api(\n      id,\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id\n    )\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : WaypointPlanManagerService_thr_Impl_Operational_Api = {\n    val api = WaypointPlanManagerService_thr_Impl_Operational_Api(\n      id,\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id\n    )\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.EntryPoints(\n      id,\n\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge {\n\n  var c_initialization_api: Option[WaypointPlanManagerService_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[WaypointPlanManagerService_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_BridgeId : Art.BridgeId,\n    AutomationResponse_Id : Art.PortId,\n    AirVehicleState_Id : Art.PortId,\n    MissionCommand_Id : Art.PortId,\n    ReturnHome_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: WaypointPlanManagerService_thr_Impl_Initialization_Api,\n    operational_api: WaypointPlanManagerService_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(AutomationResponse_Id,\n                                             AirVehicleState_Id,\n                                             ReturnHome_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(MissionCommand_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: WaypointPlanManagerService_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: WaypointPlanManagerService_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait WaypointPlanManagerService_thr_Impl_Api {\n  def id: Art.BridgeId\n  def AutomationResponse_Id : Art.PortId\n  def AirVehicleState_Id : Art.PortId\n  def MissionCommand_Id : Art.PortId\n  def ReturnHome_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var MissionCommand: Option[Base_Types.Bits] = $\n\n  def put_MissionCommand(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(MissionCommand),\n      Ensures(\n        MissionCommand == Some(value)\n      )\n    )\n    Spec {\n      MissionCommand = Some(value)\n    }\n\n    Art.putValue(MissionCommand_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class WaypointPlanManagerService_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AutomationResponse_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val ReturnHome_Id : Art.PortId) extends WaypointPlanManagerService_thr_Impl_Api\n\n@datatype class WaypointPlanManagerService_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AutomationResponse_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val ReturnHome_Id : Art.PortId) extends WaypointPlanManagerService_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var AutomationResponse: Option[Base_Types.Bits] = $\n\n  def get_AutomationResponse() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == AutomationResponse\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var AirVehicleState: Option[Base_Types.Bits] = $\n\n  def get_AirVehicleState() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == AirVehicleState\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(AirVehicleState_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AirVehicleState.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event port\n  @spec var ReturnHome: Option[art.Empty] = $\n\n  def get_ReturnHome() : Option[art.Empty] = {\n    Contract(\n      Ensures(\n        Res == ReturnHome\n      )\n    )\n    val value : Option[art.Empty] = Art.getValue(ReturnHome_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ReturnHome.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService {\n\n  def initialise(api: WaypointPlanManagerService_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param trusted_ids payloads for event data port trusted_ids.\n   *   ART currently supports single element event data queues so\n   *   only the last element of trusted_ids will be used\n   * @param AutomationRequest_in payloads for event data port AutomationRequest_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationRequest_in will be used\n   * @param OperatingRegion_in payloads for event data port OperatingRegion_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of OperatingRegion_in will be used\n   * @param LineSearchTask_in payloads for event data port LineSearchTask_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of LineSearchTask_in will be used\n   *\/\n  def put_concrete_inputs(trusted_ids : ISZ[Base_Types.Bits],\n                          AutomationRequest_in : ISZ[Base_Types.Bits],\n                          OperatingRegion_in : ISZ[Base_Types.Bits],\n                          LineSearchTask_in : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- trusted_ids){\n      put_trusted_ids(v)\n    }\n    for(v <- AutomationRequest_in){\n      put_AutomationRequest_in(v)\n    }\n    for(v <- OperatingRegion_in){\n      put_OperatingRegion_in(v)\n    }\n    for(v <- LineSearchTask_in){\n      put_LineSearchTask_in(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AutomationRequest_out_UXAS method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest_out_UXAS'.\n   * @param AutomationRequest_out_MON_REQ method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest_out_MON_REQ'.\n   * @param OperatingRegion_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'OperatingRegion_out'.\n   * @param LineSearchTask_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'LineSearchTask_out'.\n   *\/\n  def check_concrete_output(AutomationRequest_out_UXAS: ISZ[Base_Types.Bits] => B,\n                            AutomationRequest_out_MON_REQ: ISZ[Base_Types.Bits] => B,\n                            OperatingRegion_out: ISZ[Base_Types.Bits] => B,\n                            LineSearchTask_out: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AutomationRequest_out_UXASValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest_out_UXAS().nonEmpty) { AutomationRequest_out_UXASValue = AutomationRequest_out_UXASValue :+ get_AutomationRequest_out_UXAS().get }\n    if(!AutomationRequest_out_UXAS(AutomationRequest_out_UXASValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest_out_UXAS' did not match expected: received ${AutomationRequest_out_UXASValue.size} events with the following payloads ${AutomationRequest_out_UXASValue}\"\n    }\n    var AutomationRequest_out_MON_REQValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest_out_MON_REQ().nonEmpty) { AutomationRequest_out_MON_REQValue = AutomationRequest_out_MON_REQValue :+ get_AutomationRequest_out_MON_REQ().get }\n    if(!AutomationRequest_out_MON_REQ(AutomationRequest_out_MON_REQValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest_out_MON_REQ' did not match expected: received ${AutomationRequest_out_MON_REQValue.size} events with the following payloads ${AutomationRequest_out_MON_REQValue}\"\n    }\n    var OperatingRegion_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_OperatingRegion_out().nonEmpty) { OperatingRegion_outValue = OperatingRegion_outValue :+ get_OperatingRegion_out().get }\n    if(!OperatingRegion_out(OperatingRegion_outValue)) {\n      testFailures = testFailures :+ st\"'OperatingRegion_out' did not match expected: received ${OperatingRegion_outValue.size} events with the following payloads ${OperatingRegion_outValue}\"\n    }\n    var LineSearchTask_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_LineSearchTask_out().nonEmpty) { LineSearchTask_outValue = LineSearchTask_outValue :+ get_LineSearchTask_out().get }\n    if(!LineSearchTask_out(LineSearchTask_outValue)) {\n      testFailures = testFailures :+ st\"'LineSearchTask_out' did not match expected: received ${LineSearchTask_outValue.size} events with the following payloads ${LineSearchTask_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_trusted_ids(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.operational_api.trusted_ids_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationRequest_in(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.operational_api.AutomationRequest_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_OperatingRegion_in(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.operational_api.OperatingRegion_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_LineSearchTask_in(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.operational_api.LineSearchTask_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest_out_UXAS(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_out_UXAS_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AutomationRequest_out_UXAS.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_out_UXAS_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.initialization_api.AutomationRequest_out_UXAS_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest_out_MON_REQ(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_out_MON_REQ_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port AutomationRequest_out_MON_REQ.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_out_MON_REQ_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.initialization_api.AutomationRequest_out_MON_REQ_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_OperatingRegion_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_OperatingRegion_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port OperatingRegion_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_OperatingRegion_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.initialization_api.OperatingRegion_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_LineSearchTask_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_LineSearchTask_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port LineSearchTask_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_LineSearchTask_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.initialization_api.LineSearchTask_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Test extends CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  trusted_ids: Port[Base_Types.Bits],\n  AutomationRequest_in: Port[Base_Types.Bits],\n  AutomationRequest_out_UXAS: Port[Base_Types.Bits],\n  AutomationRequest_out_MON_REQ: Port[Base_Types.Bits],\n  OperatingRegion_in: Port[Base_Types.Bits],\n  OperatingRegion_out: Port[Base_Types.Bits],\n  LineSearchTask_in: Port[Base_Types.Bits],\n  LineSearchTask_out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](trusted_ids,\n                              AutomationRequest_in,\n                              OperatingRegion_in,\n                              LineSearchTask_in),\n\n    eventOuts = ISZ[art.UPort](AutomationRequest_out_UXAS,\n                               AutomationRequest_out_MON_REQ,\n                               OperatingRegion_out,\n                               LineSearchTask_out)\n  )\n\n  val initialization_api : CASE_AttestationGate_thr_Impl_Initialization_Api = {\n    val api = CASE_AttestationGate_thr_Impl_Initialization_Api(\n      id,\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id\n    )\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationGate_thr_Impl_Operational_Api = {\n    val api = CASE_AttestationGate_thr_Impl_Operational_Api(\n      id,\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id\n    )\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.EntryPoints(\n      id,\n\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationGate_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationGate_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_BridgeId : Art.BridgeId,\n    trusted_ids_Id : Art.PortId,\n    AutomationRequest_in_Id : Art.PortId,\n    AutomationRequest_out_UXAS_Id : Art.PortId,\n    AutomationRequest_out_MON_REQ_Id : Art.PortId,\n    OperatingRegion_in_Id : Art.PortId,\n    OperatingRegion_out_Id : Art.PortId,\n    LineSearchTask_in_Id : Art.PortId,\n    LineSearchTask_out_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CASE_AttestationGate_thr_Impl_Initialization_Api,\n    operational_api: CASE_AttestationGate_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(trusted_ids_Id,\n                                             AutomationRequest_in_Id,\n                                             OperatingRegion_in_Id,\n                                             LineSearchTask_in_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(AutomationRequest_out_UXAS_Id,\n                                              AutomationRequest_out_MON_REQ_Id,\n                                              OperatingRegion_out_Id,\n                                              LineSearchTask_out_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationGate_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationGate_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait CASE_AttestationGate_thr_Impl_Api {\n  def id: Art.BridgeId\n  def trusted_ids_Id : Art.PortId\n  def AutomationRequest_in_Id : Art.PortId\n  def AutomationRequest_out_UXAS_Id : Art.PortId\n  def AutomationRequest_out_MON_REQ_Id : Art.PortId\n  def OperatingRegion_in_Id : Art.PortId\n  def OperatingRegion_out_Id : Art.PortId\n  def LineSearchTask_in_Id : Art.PortId\n  def LineSearchTask_out_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AutomationRequest_out_UXAS: Option[Base_Types.Bits] = $\n\n  def put_AutomationRequest_out_UXAS(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AutomationRequest_out_UXAS),\n      Ensures(\n        AutomationRequest_out_UXAS == Some(value)\n      )\n    )\n    Spec {\n      AutomationRequest_out_UXAS = Some(value)\n    }\n\n    Art.putValue(AutomationRequest_out_UXAS_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var AutomationRequest_out_MON_REQ: Option[Base_Types.Bits] = $\n\n  def put_AutomationRequest_out_MON_REQ(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(AutomationRequest_out_MON_REQ),\n      Ensures(\n        AutomationRequest_out_MON_REQ == Some(value)\n      )\n    )\n    Spec {\n      AutomationRequest_out_MON_REQ = Some(value)\n    }\n\n    Art.putValue(AutomationRequest_out_MON_REQ_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var OperatingRegion_out: Option[Base_Types.Bits] = $\n\n  def put_OperatingRegion_out(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(OperatingRegion_out),\n      Ensures(\n        OperatingRegion_out == Some(value)\n      )\n    )\n    Spec {\n      OperatingRegion_out = Some(value)\n    }\n\n    Art.putValue(OperatingRegion_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var LineSearchTask_out: Option[Base_Types.Bits] = $\n\n  def put_LineSearchTask_out(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(LineSearchTask_out),\n      Ensures(\n        LineSearchTask_out == Some(value)\n      )\n    )\n    Spec {\n      LineSearchTask_out = Some(value)\n    }\n\n    Art.putValue(LineSearchTask_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationGate_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_in_Id : Art.PortId,\n  val AutomationRequest_out_UXAS_Id : Art.PortId,\n  val AutomationRequest_out_MON_REQ_Id : Art.PortId,\n  val OperatingRegion_in_Id : Art.PortId,\n  val OperatingRegion_out_Id : Art.PortId,\n  val LineSearchTask_in_Id : Art.PortId,\n  val LineSearchTask_out_Id : Art.PortId) extends CASE_AttestationGate_thr_Impl_Api\n\n@datatype class CASE_AttestationGate_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_in_Id : Art.PortId,\n  val AutomationRequest_out_UXAS_Id : Art.PortId,\n  val AutomationRequest_out_MON_REQ_Id : Art.PortId,\n  val OperatingRegion_in_Id : Art.PortId,\n  val OperatingRegion_out_Id : Art.PortId,\n  val LineSearchTask_in_Id : Art.PortId,\n  val LineSearchTask_out_Id : Art.PortId) extends CASE_AttestationGate_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var trusted_ids: Option[Base_Types.Bits] = $\n\n  def get_trusted_ids() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == trusted_ids\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(trusted_ids_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port trusted_ids.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var AutomationRequest_in: Option[Base_Types.Bits] = $\n\n  def get_AutomationRequest_in() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == AutomationRequest_in\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationRequest_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationRequest_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var OperatingRegion_in: Option[Base_Types.Bits] = $\n\n  def get_OperatingRegion_in() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == OperatingRegion_in\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(OperatingRegion_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port OperatingRegion_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var LineSearchTask_in: Option[Base_Types.Bits] = $\n\n  def get_LineSearchTask_in() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == LineSearchTask_in\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(LineSearchTask_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port LineSearchTask_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate {\n\n  def initialise(api: CASE_AttestationGate_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param filter_in payloads for event data port filter_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of filter_in will be used\n   *\/\n  def put_concrete_inputs(filter_in : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- filter_in){\n      put_filter_in(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param filter_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'filter_out'.\n   *\/\n  def check_concrete_output(filter_out: ISZ[Base_Types.Bits] => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var filter_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_filter_out().nonEmpty) { filter_outValue = filter_outValue :+ get_filter_out().get }\n    if(!filter_out(filter_outValue)) {\n      testFailures = testFailures :+ st\"'filter_out' did not match expected: received ${filter_outValue.size} events with the following payloads ${filter_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_filter_in(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.operational_api.filter_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_filter_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_filter_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port filter_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_filter_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.initialization_api.filter_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Test extends CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  filter_in: Port[Base_Types.Bits],\n  filter_out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](filter_in),\n\n    eventOuts = ISZ[art.UPort](filter_out)\n  )\n\n  val initialization_api : CASE_Filter_LST_thr_Impl_Initialization_Api = {\n    val api = CASE_Filter_LST_thr_Impl_Initialization_Api(\n      id,\n      filter_in.id,\n      filter_out.id\n    )\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Filter_LST_thr_Impl_Operational_Api = {\n    val api = CASE_Filter_LST_thr_Impl_Operational_Api(\n      id,\n      filter_in.id,\n      filter_out.id\n    )\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.EntryPoints(\n      id,\n\n      filter_in.id,\n      filter_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge {\n\n  var c_initialization_api: Option[CASE_Filter_LST_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Filter_LST_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_BridgeId : Art.BridgeId,\n    filter_in_Id : Art.PortId,\n    filter_out_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CASE_Filter_LST_thr_Impl_Initialization_Api,\n    operational_api: CASE_Filter_LST_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(filter_in_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(filter_out_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Filter_LST_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Filter_LST_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait CASE_Filter_LST_thr_Impl_Api {\n  def id: Art.BridgeId\n  def filter_in_Id : Art.PortId\n  def filter_out_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var filter_out: Option[Base_Types.Bits] = $\n\n  def put_filter_out(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(filter_out),\n      Ensures(\n        filter_out == Some(value)\n      )\n    )\n    Spec {\n      filter_out = Some(value)\n    }\n\n    Art.putValue(filter_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Filter_LST_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val filter_in_Id : Art.PortId,\n  val filter_out_Id : Art.PortId) extends CASE_Filter_LST_thr_Impl_Api\n\n@datatype class CASE_Filter_LST_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val filter_in_Id : Art.PortId,\n  val filter_out_Id : Art.PortId) extends CASE_Filter_LST_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var filter_in: Option[Base_Types.Bits] = $\n\n  def get_filter_in() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == filter_in\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(filter_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port filter_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST {\n\n  def initialise(api: CASE_Filter_LST_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param observed payloads for event data port observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of observed will be used\n   * @param reference_1 payloads for event data port reference_1.\n   *   ART currently supports single element event data queues so\n   *   only the last element of reference_1 will be used\n   *\/\n  def put_concrete_inputs(observed : ISZ[Base_Types.Bits],\n                          reference_1 : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- observed){\n      put_observed(v)\n    }\n    for(v <- reference_1){\n      put_reference_1(v)\n    }\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_observed(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.operational_api.observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_reference_1(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.operational_api.reference_1_Id, Base_Types.Bits_Payload(value))\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Test extends CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  observed: Port[Base_Types.Bits],\n  reference_1: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](observed,\n                              reference_1),\n\n    eventOuts = ISZ[art.UPort]()\n  )\n\n  val initialization_api : CASE_Monitor_Req_thr_Impl_Initialization_Api = {\n    val api = CASE_Monitor_Req_thr_Impl_Initialization_Api(\n      id,\n      observed.id,\n      reference_1.id\n    )\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor_Req_thr_Impl_Operational_Api = {\n    val api = CASE_Monitor_Req_thr_Impl_Operational_Api(\n      id,\n      observed.id,\n      reference_1.id\n    )\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.EntryPoints(\n      id,\n\n      observed.id,\n      reference_1.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor_Req_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor_Req_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_BridgeId : Art.BridgeId,\n    observed_Id : Art.PortId,\n    reference_1_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CASE_Monitor_Req_thr_Impl_Initialization_Api,\n    operational_api: CASE_Monitor_Req_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS()\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(observed_Id,\n                                             reference_1_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS()\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Req_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Req_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait CASE_Monitor_Req_thr_Impl_Api {\n  def id: Art.BridgeId\n  def observed_Id : Art.PortId\n  def reference_1_Id : Art.PortId\n\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor_Req_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val observed_Id : Art.PortId,\n  val reference_1_Id : Art.PortId) extends CASE_Monitor_Req_thr_Impl_Api\n\n@datatype class CASE_Monitor_Req_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val observed_Id : Art.PortId,\n  val reference_1_Id : Art.PortId) extends CASE_Monitor_Req_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var observed: Option[Base_Types.Bits] = $\n\n  def get_observed() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == observed\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var reference_1: Option[Base_Types.Bits] = $\n\n  def get_reference_1() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == reference_1\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(reference_1_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port reference_1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req {\n\n  def initialise(api: CASE_Monitor_Req_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art.Art\nimport uav_june_step6__SeL4._\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n@msig trait CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi {\n\n  def BeforeEntrypoint(): Unit = {\n    Art.initTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n  }\n\n  def AfterEntrypoint(): Unit = {\n    Art.finalizeTest(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n  }\n\n  def testCompute(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testCompute(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n  }\n\n  def testInitialise(): Unit = {\n    Art.manuallyClearOutput()\n    Art.testInitialise(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n  }\n\n  \/** helper function to set the values of all input ports.\n   * @param keep_in_zones payload for data port keep_in_zones\n   * @param keep_out_zones payload for data port keep_out_zones\n   * @param observed payloads for event data port observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of observed will be used\n   *\/\n  def put_concrete_inputs(keep_in_zones : Base_Types.Bits,\n                          keep_out_zones : Base_Types.Bits,\n                          observed : ISZ[Base_Types.Bits]): Unit = {\n    put_keep_in_zones(keep_in_zones)\n    put_keep_out_zones(keep_out_zones)\n    for(v <- observed){\n      put_observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param output method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'output'.\n   * @param alert method that will be called with the number of events to be sent\n   *        on the outgoing event port 'alert'.\n   *\/\n  def check_concrete_output(output: ISZ[Base_Types.Bits] => B,\n                            alert: Z => B): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var outputValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_output().nonEmpty) { outputValue = outputValue :+ get_output().get }\n    if(!output(outputValue)) {\n      testFailures = testFailures :+ st\"'output' did not match expected: received ${outputValue.size} events with the following payloads ${outputValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val alertValue: Z = if(get_alert().nonEmpty) z\"1\" else z\"0\"\n    if(!alert(alertValue)) {\n      testFailures = testFailures :+ st\"'alert' did not match expected: ${alertValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_keep_in_zones(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.operational_api.keep_in_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_keep_out_zones(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.operational_api.keep_out_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_observed(value : Base_Types.Bits): Unit = {\n    Art.insertInInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.operational_api.observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_output(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_output_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => halt(s\"Unexpected payload on port output.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_output_payload(): Option[Base_Types.Bits_Payload] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.initialization_api.output_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_alert(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_alert_payload() match {\n      case Some(art.Empty()) => Some(art.Empty())\n      case Some(v) => halt(s\"Unexpected payload on port alert.  Expecting 'art.Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_alert_payload(): Option[art.Empty] = {\n    return Art.observeOutInfrastructurePort(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.initialization_api.alert_Id).asInstanceOf[Option[art.Empty]]\n  }\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/util\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_ScalaTest.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\nimport org.sireum.$internal.MutableMarker\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\nabstract class CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_ScalaTest extends\n  AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach with\n  CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi {\n\n  var clonable: Boolean = true\n  var owned: Boolean = false\n\n  override def string: org.sireum.String = {\n    this.toString()\n  }\n\n  override def $clonable: Boolean = {\n    return clonable\n  }\n\n  override def $clonable_=(b: Boolean): MutableMarker = {\n    clonable = b\n    return this\n  }\n\n  override def $owned: Boolean = {\n    return owned\n  }\n\n  override def $owned_=(b: Boolean): MutableMarker = {\n    owned = b\n    return this\n  }\n\n  override def $clone: MutableMarker = {\n    \/\/ not expecting users to want to clone realizations of this abstract class\n    return this\n  }\n\n  override def beforeEach(): Unit = {\n    BeforeEntrypoint()\n  }\n\n  override def afterEach(): Unit = {\n    AfterEntrypoint()\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/test\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Test extends CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_ScalaTest {\n\n  test(\"Example Unit Test for Initialise Entry Point\"){\n    \/\/ Initialise Entry Point doesn't read input port values, so just proceed with\n    \/\/ launching the entry point code\n    testInitialise()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n\n  test(\"Example Unit Test for Compute Entry Point\"){\n    \/\/ use put_XXX methods from test\/util\/..\/YYY_TestApi to seed input ports with values\n    testCompute()\n    \/\/ use get_XXX methods and check_concrete_output() from test\/util\/..\/YYY_TestApi\n    \/\/ retrieve values from output ports and check against expected results\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.{CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo => component}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n@datatype class CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  keep_in_zones: Port[Base_Types.Bits],\n  keep_out_zones: Port[Base_Types.Bits],\n  observed: Port[Base_Types.Bits],\n  output: Port[Base_Types.Bits],\n  alert: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    dataIns = ISZ[art.UPort](keep_in_zones,\n                             keep_out_zones),\n\n    dataOuts = ISZ[art.UPort](),\n\n    eventIns = ISZ[art.UPort](observed),\n\n    eventOuts = ISZ[art.UPort](output,\n                               alert)\n  )\n\n  val initialization_api : CASE_Monitor_Geo_thr_Impl_Initialization_Api = {\n    val api = CASE_Monitor_Geo_thr_Impl_Initialization_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id\n    )\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor_Geo_thr_Impl_Operational_Api = {\n    val api = CASE_Monitor_Geo_thr_Impl_Operational_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id\n    )\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.EntryPoints(\n      id,\n\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor_Geo_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor_Geo_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_BridgeId : Art.BridgeId,\n    keep_in_zones_Id : Art.PortId,\n    keep_out_zones_Id : Art.PortId,\n    observed_Id : Art.PortId,\n    output_Id : Art.PortId,\n    alert_Id : Art.PortId,\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n    initialization_api: CASE_Monitor_Geo_thr_Impl_Initialization_Api,\n    operational_api: CASE_Monitor_Geo_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = IS(keep_in_zones_Id,\n                                            keep_out_zones_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = IS(observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = IS()\n\n    val eventOutPortIds: ISZ[Art.PortId] = IS(output_Id,\n                                              alert_Id)\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Geo_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    override\n    def testInitialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Geo_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/bridge\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\n@sig trait CASE_Monitor_Geo_thr_Impl_Api {\n  def id: Art.BridgeId\n  def keep_in_zones_Id : Art.PortId\n  def keep_out_zones_Id : Art.PortId\n  def observed_Id : Art.PortId\n  def output_Id : Art.PortId\n  def alert_Id : Art.PortId\n\n  \/\/ Logika spec var representing port state for outgoing event data port\n  @spec var output: Option[Base_Types.Bits] = $\n\n  def put_output(value : Base_Types.Bits) : Unit = {\n    Contract(\n      Modifies(output),\n      Ensures(\n        output == Some(value)\n      )\n    )\n    Spec {\n      output = Some(value)\n    }\n\n    Art.putValue(output_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ Logika spec var representing port state for outgoing event port\n  @spec var alert: Option[art.Empty] = $\n\n  def put_alert() : Unit = {\n    Contract(\n      Modifies(alert),\n      Ensures(\n        alert == Some(Empty())\n      )\n    )\n    Spec {\n      alert = Some(Empty())\n    }\n\n    Art.putValue(alert_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor_Geo_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId,\n  val observed_Id : Art.PortId,\n  val output_Id : Art.PortId,\n  val alert_Id : Art.PortId) extends CASE_Monitor_Geo_thr_Impl_Api\n\n@datatype class CASE_Monitor_Geo_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId,\n  val observed_Id : Art.PortId,\n  val output_Id : Art.PortId,\n  val alert_Id : Art.PortId) extends CASE_Monitor_Geo_thr_Impl_Api {\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var keep_in_zones: Base_Types.Bits = $\n\n  def get_keep_in_zones() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == Some(keep_in_zones)\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(keep_in_zones_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port keep_in_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming data port\n  @spec var keep_out_zones: Base_Types.Bits = $\n\n  def get_keep_out_zones() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == Some(keep_out_zones)\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(keep_out_zones_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port keep_out_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ Logika spec var representing port state for incoming event data port\n  @spec var observed: Option[Base_Types.Bits] = $\n\n  def get_observed() : Option[Base_Types.Bits] = {\n    Contract(\n      Ensures(\n        Res == observed\n      )\n    )\n    val value : Option[Base_Types.Bits] = Art.getValue(observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport uav_june_step6__SeL4._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo {\n\n  def initialise(api: CASE_Monitor_Geo_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/component\/uav_june_step6__SeL4\/TranspilerToucher.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix\n\nobject UARTDriver extends App {\n\n  val UARTDriverBridge : uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_recv_data\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_send_data\", mode = EventOut)\n    val AirVehicleState_WPM = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM\", mode = EventOut)\n    val AirVehicleState_UXAS = Port[Base_Types.Bits] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS\", mode = EventOut)\n\n    uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      MissionCommand = MissionCommand,\n      send_data = send_data,\n      AirVehicleState_WPM = AirVehicleState_WPM,\n      AirVehicleState_UXAS = AirVehicleState_UXAS\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = UARTDriverBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ recv_data: In EventDataPort Base_Types.Bits\n  val recv_data_id: Art.PortId = UARTDriverBridge.recv_data.id\n  var recv_data_port: Option[DataContent] = noData\n\n  \/\/ MissionCommand: In EventDataPort Base_Types.Bits\n  val MissionCommand_id: Art.PortId = UARTDriverBridge.MissionCommand.id\n  var MissionCommand_port: Option[DataContent] = noData\n\n  \/\/ send_data: Out EventDataPort Base_Types.Bits\n  val send_data_id: Art.PortId = UARTDriverBridge.send_data.id\n  var send_data_port: Option[DataContent] = noData\n\n  \/\/ AirVehicleState_WPM: Out EventDataPort Base_Types.Bits\n  val AirVehicleState_WPM_id: Art.PortId = UARTDriverBridge.AirVehicleState_WPM.id\n  var AirVehicleState_WPM_port: Option[DataContent] = noData\n\n  \/\/ AirVehicleState_UXAS: Out EventDataPort Base_Types.Bits\n  val AirVehicleState_UXAS_id: Art.PortId = UARTDriverBridge.AirVehicleState_UXAS.id\n  var AirVehicleState_UXAS_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == recv_data_id) {\n      return recv_data_port\n    } else if(portId == MissionCommand_id) {\n      return MissionCommand_port\n    } else {\n      halt(s\"Unexpected: UARTDriver.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    recv_data_port = UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.recv_data_Receive()\n\n    MissionCommand_port = UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.MissionCommand_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == send_data_id) {\n      send_data_port = Some(data)\n    } else if(portId == AirVehicleState_WPM_id) {\n      AirVehicleState_WPM_port = Some(data)\n    } else if(portId == AirVehicleState_UXAS_id) {\n      AirVehicleState_UXAS_port = Some(data)\n    } else {\n      halt(s\"Unexpected: UARTDriver.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(send_data_port.nonEmpty) {\n      UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.send_data_Send(send_data_port.get)\n      send_data_port = noData\n    }\n\n    if(AirVehicleState_WPM_port.nonEmpty) {\n      UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.AirVehicleState_WPM_Send(AirVehicleState_WPM_port.get)\n      AirVehicleState_WPM_port = noData\n    }\n\n    if(AirVehicleState_UXAS_port.nonEmpty) {\n      UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.AirVehicleState_UXAS_Send(AirVehicleState_UXAS_port.get)\n      AirVehicleState_UXAS_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_recv_data()\n      val apiUsage_MissionCommand: Option[Base_Types.Bits] = uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_MissionCommand()\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n      uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(UARTDriverBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(UARTDriverBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(UARTDriverBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport art._\n\n@ext object UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix {\n  \/\/ returns T if seL4's recv_data port is empty, F otherwise \n  def recv_data_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's recv_data port \n  def recv_data_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's MissionCommand port is empty, F otherwise \n  def MissionCommand_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's MissionCommand port \n  def MissionCommand_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's send_data port\n  def send_data_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AirVehicleState_WPM port\n  def AirVehicleState_WPM_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AirVehicleState_UXAS port\n  def AirVehicleState_UXAS_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.Drivers\n\nimport org.sireum._\nimport art._\n\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_Ext {\n  def recv_data_IsEmpty(): B = halt(\"stub\")\n\n  def recv_data_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def MissionCommand_IsEmpty(): B = halt(\"stub\")\n\n  def MissionCommand_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def send_data_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AirVehicleState_WPM_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AirVehicleState_UXAS_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_H\n#define UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h>\n#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver\";\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl);\n  api_put_send_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n  api_put_AirVehicleState_WPM__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n  api_put_AirVehicleState_UXAS__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, t2);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl];\n  size_t t0_numBits;\n  if(api_get_recv_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port recv_data: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(recv_data_str);\n    String__append(SF (String) &recv_data_str, string(\"Received data on event data port recv_data: \"));\n    byte_array_string(SF (String) &recv_data_str, t0, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl);\n    api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF (String) &recv_data_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i];\n  size_t t1_numBits;\n  if(api_get_MissionCommand__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_MissionCommand_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port MissionCommand: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(MissionCommand_str);\n    String__append(SF (String) &MissionCommand_str, string(\"Received data on event data port MissionCommand: \"));\n    byte_array_string(SF (String) &MissionCommand_str, t1, numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i);\n    api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF (String) &MissionCommand_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_API_H\n#define UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_recv_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_MissionCommand__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_send_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AirVehicleState_WPM__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AirVehicleState_UXAS__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h>\n#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_61A0BF = Option[uav_june_step6__SeL4.Drivers.UARTDriver_Impl_Initialization_Api]\n  Option_61A0BF_get_(SF (uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_57503A = Option[uav_june_step6__SeL4.Drivers.UARTDriver_Impl_Operational_Api]\n  Option_57503A_get_(SF (uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_recv_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_get_recv_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api_get_recv_data_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_MissionCommand__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_get_MissionCommand__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api_get_MissionCommand_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_send_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_send_data__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_put_send_data_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_AirVehicleState_WPM__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_AirVehicleState_WPM__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_put_AirVehicleState_WPM_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_AirVehicleState_UXAS__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_AirVehicleState_UXAS__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_put_AirVehicleState_UXAS_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise\", 0);\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise\", 0);\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.h>\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_UARTDriver_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_UARTDriver_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_UARTDriver_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_UARTDriver_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_ADAPTER_H\n#define UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix\n\nobject RadioDriver_Attestation extends App {\n\n  val RadioDriver_AttestationBridge : uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_recv_data\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_send_data\", mode = EventOut)\n    val trusted_ids = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_trusted_ids\", mode = EventOut)\n    val AutomationRequest = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_AutomationRequest\", mode = EventOut)\n    val OperatingRegion = Port[Base_Types.Bits] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_OperatingRegion\", mode = EventOut)\n    val LineSearchTask = Port[Base_Types.Bits] (id = portId\"5\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_LineSearchTask\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      send_data = send_data,\n      trusted_ids = trusted_ids,\n      AutomationRequest = AutomationRequest,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = RadioDriver_AttestationBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ recv_data: In EventDataPort Base_Types.Bits\n  val recv_data_id: Art.PortId = RadioDriver_AttestationBridge.recv_data.id\n  var recv_data_port: Option[DataContent] = noData\n\n  \/\/ send_data: Out EventDataPort Base_Types.Bits\n  val send_data_id: Art.PortId = RadioDriver_AttestationBridge.send_data.id\n  var send_data_port: Option[DataContent] = noData\n\n  \/\/ trusted_ids: Out EventDataPort Base_Types.Bits\n  val trusted_ids_id: Art.PortId = RadioDriver_AttestationBridge.trusted_ids.id\n  var trusted_ids_port: Option[DataContent] = noData\n\n  \/\/ AutomationRequest: Out EventDataPort Base_Types.Bits\n  val AutomationRequest_id: Art.PortId = RadioDriver_AttestationBridge.AutomationRequest.id\n  var AutomationRequest_port: Option[DataContent] = noData\n\n  \/\/ OperatingRegion: Out EventDataPort Base_Types.Bits\n  val OperatingRegion_id: Art.PortId = RadioDriver_AttestationBridge.OperatingRegion.id\n  var OperatingRegion_port: Option[DataContent] = noData\n\n  \/\/ LineSearchTask: Out EventDataPort Base_Types.Bits\n  val LineSearchTask_id: Art.PortId = RadioDriver_AttestationBridge.LineSearchTask.id\n  var LineSearchTask_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == recv_data_id) {\n      return recv_data_port\n    } else {\n      halt(s\"Unexpected: RadioDriver_Attestation.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    recv_data_port = RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.recv_data_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == send_data_id) {\n      send_data_port = Some(data)\n    } else if(portId == trusted_ids_id) {\n      trusted_ids_port = Some(data)\n    } else if(portId == AutomationRequest_id) {\n      AutomationRequest_port = Some(data)\n    } else if(portId == OperatingRegion_id) {\n      OperatingRegion_port = Some(data)\n    } else if(portId == LineSearchTask_id) {\n      LineSearchTask_port = Some(data)\n    } else {\n      halt(s\"Unexpected: RadioDriver_Attestation.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(send_data_port.nonEmpty) {\n      RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.send_data_Send(send_data_port.get)\n      send_data_port = noData\n    }\n\n    if(trusted_ids_port.nonEmpty) {\n      RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.trusted_ids_Send(trusted_ids_port.get)\n      trusted_ids_port = noData\n    }\n\n    if(AutomationRequest_port.nonEmpty) {\n      RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.AutomationRequest_Send(AutomationRequest_port.get)\n      AutomationRequest_port = noData\n    }\n\n    if(OperatingRegion_port.nonEmpty) {\n      RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.OperatingRegion_Send(OperatingRegion_port.get)\n      OperatingRegion_port = noData\n    }\n\n    if(LineSearchTask_port.nonEmpty) {\n      RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.LineSearchTask_Send(LineSearchTask_port.get)\n      LineSearchTask_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.get_recv_data()\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_trusted_ids(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_trusted_ids(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_AutomationRequest(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_AutomationRequest(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_OperatingRegion(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_OperatingRegion(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_LineSearchTask(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_LineSearchTask(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(RadioDriver_AttestationBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(RadioDriver_AttestationBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(RadioDriver_AttestationBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix {\n  \/\/ returns T if seL4's recv_data port is empty, F otherwise \n  def recv_data_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's recv_data port \n  def recv_data_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's send_data port\n  def send_data_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's trusted_ids port\n  def trusted_ids_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AutomationRequest port\n  def AutomationRequest_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's OperatingRegion port\n  def OperatingRegion_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's LineSearchTask port\n  def LineSearchTask_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_seL4Nix_Ext {\n  def recv_data_IsEmpty(): B = halt(\"stub\")\n\n  def recv_data_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def send_data_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def trusted_ids_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AutomationRequest_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def OperatingRegion_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def LineSearchTask_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_H\n#define RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c",
        {
          "type" : "ITestResource",
          "content" : "#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h>\n#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\";\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl);\n  api_put_send_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__SeL4_CMASI_AddressArray_i, numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i);\n  api_put_trusted_ids__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__SeL4_CMASI_AddressArray_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n  api_put_AutomationRequest__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, t2);\n\n  uint8_t t3[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t3, numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n  api_put_OperatingRegion__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, t3);\n\n  uint8_t t4[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t4, numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n  api_put_LineSearchTask__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, t4);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl];\n  size_t t0_numBits;\n  if(api_get_recv_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port recv_data: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(recv_data_str);\n    String__append(SF (String) &recv_data_str, string(\"Received data on event data port recv_data: \"));\n    byte_array_string(SF (String) &recv_data_str, t0, numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl);\n    api_logInfo__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF (String) &recv_data_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_API_H\n#define RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_recv_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_send_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_trusted_ids__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_OperatingRegion__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_LineSearchTask__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h>\n#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_57379D = Option[uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  Option_57379D_get_(SF (uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_27C33E = Option[uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_Operational_Api]\n  Option_27C33E_get_(SF (uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_recv_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_get_recv_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Operational_Api_get_recv_data_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_send_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_send_data__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_send_data_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_trusted_ids__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_trusted_ids__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_trusted_ids_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_AutomationRequest__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_AutomationRequest__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_AutomationRequest_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_OperatingRegion__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_OperatingRegion__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_OperatingRegion_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_LineSearchTask__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_LineSearchTask__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_LineSearchTask_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_RadioDriver_Attestation_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_RadioDriver_Attestation_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_RadioDriver_Attestation_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_RadioDriver_Attestation_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_ADAPTER_H\n#define RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix\n\nobject FlyZonesDatabase extends App {\n\n  val FlyZonesDatabaseBridge : uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones\", mode = DataOut)\n    val keep_out_zones = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones\", mode = DataOut)\n\n    uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = FlyZonesDatabaseBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ keep_in_zones: Out DataPort Base_Types.Bits\n  val keep_in_zones_id: Art.PortId = FlyZonesDatabaseBridge.keep_in_zones.id\n  var keep_in_zones_port: Option[DataContent] = noData\n\n  \/\/ keep_out_zones: Out DataPort Base_Types.Bits\n  val keep_out_zones_id: Art.PortId = FlyZonesDatabaseBridge.keep_out_zones.id\n  var keep_out_zones_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    halt(s\"Unexpected: FlyZonesDatabase.getValue called with: ${portId}\")\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == keep_in_zones_id) {\n      keep_in_zones_port = Some(data)\n    } else if(portId == keep_out_zones_id) {\n      keep_out_zones_port = Some(data)\n    } else {\n      halt(s\"Unexpected: FlyZonesDatabase.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(keep_in_zones_port.nonEmpty) {\n      FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix.keep_in_zones_Send(keep_in_zones_port.get)\n      keep_in_zones_port = noData\n    }\n\n    if(keep_out_zones_port.nonEmpty) {\n      FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix.keep_out_zones_Send(keep_out_zones_port.get)\n      keep_out_zones_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_in_zones(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_in_zones(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_out_zones(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_out_zones(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(FlyZonesDatabaseBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(FlyZonesDatabaseBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(FlyZonesDatabaseBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's keep_in_zones port\n  def keep_in_zones_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's keep_out_zones port\n  def keep_out_zones_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_Ext {\n  def keep_in_zones_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def keep_out_zones_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_H\n#define FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c",
        {
          "type" : "ITestResource",
          "content" : "#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h>\n#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\";\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_Polygon_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_Polygon_i, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n  api_put_keep_in_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF numBits_uav_june_step6__SeL4_CMASI_Polygon_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_Polygon_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__SeL4_CMASI_Polygon_i, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n  api_put_keep_out_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF numBits_uav_june_step6__SeL4_CMASI_Polygon_i, t1);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_\", 0);\n\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_API_H\n#define FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nvoid api_put_keep_in_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_keep_out_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h>\n#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_79381A = Option[uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  Option_79381A_get_(SF (uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_E5BAAE = Option[uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_Operational_Api]\n  Option_E5BAAE_get_(SF (uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nvoid api_put_keep_in_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_put_keep_in_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_put_keep_in_zones_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_keep_out_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_put_keep_out_zones__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_put_keep_out_zones_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_FlyZonesDatabase_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_FlyZonesDatabase_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_FlyZonesDatabase_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_FlyZonesDatabase_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_ADAPTER_H\n#define FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix\n\nobject UxAS extends App {\n\n  val UxASBridge : uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge = {\n    val AutomationRequest = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationRequest\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AirVehicleState\", mode = EventIn)\n    val OperatingRegion = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_OperatingRegion\", mode = EventIn)\n    val LineSearchTask = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_LineSearchTask\", mode = EventIn)\n    val AutomationResponse_MON_GEO = Port[Base_Types.Bits] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_GEO\", mode = EventOut)\n    val AutomationResponse_MON_REQ = Port[Base_Types.Bits] (id = portId\"5\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_REQ\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationRequest = AutomationRequest,\n      AirVehicleState = AirVehicleState,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask,\n      AutomationResponse_MON_GEO = AutomationResponse_MON_GEO,\n      AutomationResponse_MON_REQ = AutomationResponse_MON_REQ\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = UxASBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ AutomationRequest: In EventDataPort Base_Types.Bits\n  val AutomationRequest_id: Art.PortId = UxASBridge.AutomationRequest.id\n  var AutomationRequest_port: Option[DataContent] = noData\n\n  \/\/ AirVehicleState: In EventDataPort Base_Types.Bits\n  val AirVehicleState_id: Art.PortId = UxASBridge.AirVehicleState.id\n  var AirVehicleState_port: Option[DataContent] = noData\n\n  \/\/ OperatingRegion: In EventDataPort Base_Types.Bits\n  val OperatingRegion_id: Art.PortId = UxASBridge.OperatingRegion.id\n  var OperatingRegion_port: Option[DataContent] = noData\n\n  \/\/ LineSearchTask: In EventDataPort Base_Types.Bits\n  val LineSearchTask_id: Art.PortId = UxASBridge.LineSearchTask.id\n  var LineSearchTask_port: Option[DataContent] = noData\n\n  \/\/ AutomationResponse_MON_GEO: Out EventDataPort Base_Types.Bits\n  val AutomationResponse_MON_GEO_id: Art.PortId = UxASBridge.AutomationResponse_MON_GEO.id\n  var AutomationResponse_MON_GEO_port: Option[DataContent] = noData\n\n  \/\/ AutomationResponse_MON_REQ: Out EventDataPort Base_Types.Bits\n  val AutomationResponse_MON_REQ_id: Art.PortId = UxASBridge.AutomationResponse_MON_REQ.id\n  var AutomationResponse_MON_REQ_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == AutomationRequest_id) {\n      return AutomationRequest_port\n    } else if(portId == AirVehicleState_id) {\n      return AirVehicleState_port\n    } else if(portId == OperatingRegion_id) {\n      return OperatingRegion_port\n    } else if(portId == LineSearchTask_id) {\n      return LineSearchTask_port\n    } else {\n      halt(s\"Unexpected: UxAS.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    AutomationRequest_port = UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.AutomationRequest_Receive()\n\n    AirVehicleState_port = UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.AirVehicleState_Receive()\n\n    OperatingRegion_port = UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.OperatingRegion_Receive()\n\n    LineSearchTask_port = UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.LineSearchTask_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == AutomationResponse_MON_GEO_id) {\n      AutomationResponse_MON_GEO_port = Some(data)\n    } else if(portId == AutomationResponse_MON_REQ_id) {\n      AutomationResponse_MON_REQ_port = Some(data)\n    } else {\n      halt(s\"Unexpected: UxAS.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(AutomationResponse_MON_GEO_port.nonEmpty) {\n      UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.AutomationResponse_MON_GEO_Send(AutomationResponse_MON_GEO_port.get)\n      AutomationResponse_MON_GEO_port = noData\n    }\n\n    if(AutomationResponse_MON_REQ_port.nonEmpty) {\n      UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.AutomationResponse_MON_REQ_Send(AutomationResponse_MON_REQ_port.get)\n      AutomationResponse_MON_REQ_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_AutomationRequest: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AutomationRequest()\n      val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AirVehicleState()\n      val apiUsage_OperatingRegion: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_OperatingRegion()\n      val apiUsage_LineSearchTask: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_LineSearchTask()\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(UxASBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(UxASBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(UxASBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix {\n  \/\/ returns T if seL4's AutomationRequest port is empty, F otherwise \n  def AutomationRequest_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AutomationRequest port \n  def AutomationRequest_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's AirVehicleState port is empty, F otherwise \n  def AirVehicleState_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AirVehicleState port \n  def AirVehicleState_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's OperatingRegion port is empty, F otherwise \n  def OperatingRegion_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's OperatingRegion port \n  def OperatingRegion_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's LineSearchTask port is empty, F otherwise \n  def LineSearchTask_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's LineSearchTask port \n  def LineSearchTask_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's AutomationResponse_MON_GEO port\n  def AutomationResponse_MON_GEO_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AutomationResponse_MON_REQ port\n  def AutomationResponse_MON_REQ_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_seL4Nix_Ext {\n  def AutomationRequest_IsEmpty(): B = halt(\"stub\")\n\n  def AutomationRequest_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AirVehicleState_IsEmpty(): B = halt(\"stub\")\n\n  def AirVehicleState_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def OperatingRegion_IsEmpty(): B = halt(\"stub\")\n\n  def OperatingRegion_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def LineSearchTask_IsEmpty(): B = halt(\"stub\")\n\n  def LineSearchTask_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AutomationResponse_MON_GEO_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AutomationResponse_MON_REQ_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_H\n#define UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h>\n#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS\";\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n  api_put_AutomationResponse_MON_GEO__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n  api_put_AutomationResponse_MON_REQ__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, t1);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i];\n  size_t t0_numBits;\n  if(api_get_AutomationRequest__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port AutomationRequest: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(AutomationRequest_str);\n    String__append(SF (String) &AutomationRequest_str, string(\"Received data on event data port AutomationRequest: \"));\n    byte_array_string(SF (String) &AutomationRequest_str, t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n    api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &AutomationRequest_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i];\n  size_t t1_numBits;\n  if(api_get_AirVehicleState__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port AirVehicleState: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(AirVehicleState_str);\n    String__append(SF (String) &AirVehicleState_str, string(\"Received data on event data port AirVehicleState: \"));\n    byte_array_string(SF (String) &AirVehicleState_str, t1, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n    api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &AirVehicleState_str);\n    *\/\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i];\n  size_t t2_numBits;\n  if(api_get_OperatingRegion__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert((Z) t2_numBits == numBits_uav_june_step6__SeL4_CMASI_OperatingRegion_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port OperatingRegion: \\n\", component_id);\n    hex_dump(SF t2, numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(OperatingRegion_str);\n    String__append(SF (String) &OperatingRegion_str, string(\"Received data on event data port OperatingRegion: \"));\n    byte_array_string(SF (String) &OperatingRegion_str, t2, numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i);\n    api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &OperatingRegion_str);\n    *\/\n  }\n\n  uint8_t t3[numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i];\n  size_t t3_numBits;\n  if(api_get_LineSearchTask__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert((Z) t3_numBits == numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port LineSearchTask: \\n\", component_id);\n    hex_dump(SF t3, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(LineSearchTask_str);\n    String__append(SF (String) &LineSearchTask_str, string(\"Received data on event data port LineSearchTask: \"));\n    byte_array_string(SF (String) &LineSearchTask_str, t3, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n    api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &LineSearchTask_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_API_H\n#define UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_AutomationRequest__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AirVehicleState__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_OperatingRegion__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_LineSearchTask__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationResponse_MON_GEO__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationResponse_MON_REQ__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h>\n#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_FD162D = Option[uav_june_step6__SeL4.SW.UxAS_thr_Impl_Initialization_Api]\n  Option_FD162D_get_(SF (uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_946314 = Option[uav_june_step6__SeL4.SW.UxAS_thr_Impl_Operational_Api]\n  Option_946314_get_(SF (uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_AutomationRequest__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_AutomationRequest__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api_get_AutomationRequest_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AirVehicleState__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_AirVehicleState__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api_get_AirVehicleState_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_OperatingRegion__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_OperatingRegion__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api_get_OperatingRegion_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_LineSearchTask__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_LineSearchTask__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api_get_LineSearchTask_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_AutomationResponse_MON_GEO__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_put_AutomationResponse_MON_GEO__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api_put_AutomationResponse_MON_GEO_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_AutomationResponse_MON_REQ__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_put_AutomationResponse_MON_REQ__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api_put_AutomationResponse_MON_REQ_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_UxAS_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_UxAS_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_UxAS_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_UxAS_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_ADAPTER_H\n#define UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix\n\nobject WaypointPlanManagerService extends App {\n\n  val WaypointPlanManagerServiceBridge : uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge = {\n    val AutomationResponse = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand\", mode = EventOut)\n    val ReturnHome = Port[art.Empty] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome\", mode = EventIn)\n\n    uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationResponse = AutomationResponse,\n      AirVehicleState = AirVehicleState,\n      MissionCommand = MissionCommand,\n      ReturnHome = ReturnHome\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = WaypointPlanManagerServiceBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ AutomationResponse: In EventDataPort Base_Types.Bits\n  val AutomationResponse_id: Art.PortId = WaypointPlanManagerServiceBridge.AutomationResponse.id\n  var AutomationResponse_port: Option[DataContent] = noData\n\n  \/\/ AirVehicleState: In EventDataPort Base_Types.Bits\n  val AirVehicleState_id: Art.PortId = WaypointPlanManagerServiceBridge.AirVehicleState.id\n  var AirVehicleState_port: Option[DataContent] = noData\n\n  \/\/ MissionCommand: Out EventDataPort Base_Types.Bits\n  val MissionCommand_id: Art.PortId = WaypointPlanManagerServiceBridge.MissionCommand.id\n  var MissionCommand_port: Option[DataContent] = noData\n\n  \/\/ ReturnHome: In EventPort art.Empty\n  val ReturnHome_id: Art.PortId = WaypointPlanManagerServiceBridge.ReturnHome.id\n  var ReturnHome_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == AutomationResponse_id) {\n      return AutomationResponse_port\n    } else if(portId == AirVehicleState_id) {\n      return AirVehicleState_port\n    } else if(portId == ReturnHome_id) {\n      return ReturnHome_port\n    } else {\n      halt(s\"Unexpected: WaypointPlanManagerService.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    AutomationResponse_port = WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix.AutomationResponse_Receive()\n\n    AirVehicleState_port = WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix.AirVehicleState_Receive()\n\n    ReturnHome_port = WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix.ReturnHome_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == MissionCommand_id) {\n      MissionCommand_port = Some(data)\n    } else {\n      halt(s\"Unexpected: WaypointPlanManagerService.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(MissionCommand_port.nonEmpty) {\n      WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix.MissionCommand_Send(MissionCommand_port.get)\n      MissionCommand_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_AutomationResponse: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AutomationResponse()\n      val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AirVehicleState()\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.put_MissionCommand(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.put_MissionCommand(Base_Types.Bits_example())\n      val apiUsage_ReturnHome: Option[art.Empty] = uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_ReturnHome()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(WaypointPlanManagerServiceBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(WaypointPlanManagerServiceBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(WaypointPlanManagerServiceBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix {\n  \/\/ returns T if seL4's AutomationResponse port is empty, F otherwise \n  def AutomationResponse_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AutomationResponse port \n  def AutomationResponse_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's AirVehicleState port is empty, F otherwise \n  def AirVehicleState_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AirVehicleState port \n  def AirVehicleState_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's MissionCommand port\n  def MissionCommand_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's ReturnHome port is empty, F otherwise \n  def ReturnHome_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's ReturnHome port \n  def ReturnHome_Receive(): Option[DataContent] = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_Ext {\n  def AutomationResponse_IsEmpty(): B = halt(\"stub\")\n\n  def AutomationResponse_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AirVehicleState_IsEmpty(): B = halt(\"stub\")\n\n  def AirVehicleState_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def MissionCommand_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def ReturnHome_IsEmpty(): B = halt(\"stub\")\n\n  def ReturnHome_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_H\n#define WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c",
        {
          "type" : "ITestResource",
          "content" : "#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h>\n#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService\";\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_MissionCommand_i, numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i);\n  api_put_MissionCommand__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF numBits_uav_june_step6__SeL4_CMASI_MissionCommand_i, t0);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  size_t t0_numBits;\n  if(api_get_AutomationResponse__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port AutomationResponse: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(AutomationResponse_str);\n    String__append(SF (String) &AutomationResponse_str, string(\"Received data on event data port AutomationResponse: \"));\n    byte_array_string(SF (String) &AutomationResponse_str, t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF (String) &AutomationResponse_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i];\n  size_t t1_numBits;\n  if(api_get_AirVehicleState__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port AirVehicleState: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(AirVehicleState_str);\n    String__append(SF (String) &AirVehicleState_str, string(\"Received data on event data port AirVehicleState: \"));\n    byte_array_string(SF (String) &AirVehicleState_str, t1, numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i);\n    api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF (String) &AirVehicleState_str);\n    *\/\n  }\n\n  if(api_get_ReturnHome__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF_LAST )){\n    printf(\"%s: Received event on ReturnHome\\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    String ReturnHome_str = string(\"Received event on event port ReturnHome\");\n    api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF ReturnHome_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_API_H\n#define WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_AutomationResponse__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AirVehicleState__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_MissionCommand__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_ReturnHome__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(STACK_FRAME_ONLY);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h>\n#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_0000E1 = Option[uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_Initialization_Api]\n  Option_0000E1_get_(SF (uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_AC6ED8 = Option[uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_Operational_Api]\n  Option_AC6ED8_get_(SF (uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_AutomationResponse__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_AutomationResponse__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_AutomationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AirVehicleState__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_AirVehicleState__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_AirVehicleState_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_MissionCommand__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_put_MissionCommand__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_put_MissionCommand_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nbool api_get_ReturnHome__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(STACK_FRAME_ONLY){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_ReturnHome__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_C622DB = Option[art.Empty]\n  \/\/ Some_4782C6 = Some[art.Empty]\n  DeclNewOption_C622DB(t_0);\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_ReturnHome_(\n    SF\n    (Option_C622DB) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_4782C6){\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_WaypointPlanManagerService_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_WaypointPlanManagerService_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_WaypointPlanManagerService_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_WaypointPlanManagerService_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_ADAPTER_H\n#define WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix\n\nobject CASE_AttestationGate extends App {\n\n  val CASE_AttestationGateBridge : uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge = {\n    val trusted_ids = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids\", mode = EventIn)\n    val AutomationRequest_in = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in\", mode = EventIn)\n    val AutomationRequest_out_UXAS = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS\", mode = EventOut)\n    val AutomationRequest_out_MON_REQ = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ\", mode = EventOut)\n    val OperatingRegion_in = Port[Base_Types.Bits] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in\", mode = EventIn)\n    val OperatingRegion_out = Port[Base_Types.Bits] (id = portId\"5\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out\", mode = EventOut)\n    val LineSearchTask_in = Port[Base_Types.Bits] (id = portId\"6\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in\", mode = EventIn)\n    val LineSearchTask_out = Port[Base_Types.Bits] (id = portId\"7\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      trusted_ids = trusted_ids,\n      AutomationRequest_in = AutomationRequest_in,\n      AutomationRequest_out_UXAS = AutomationRequest_out_UXAS,\n      AutomationRequest_out_MON_REQ = AutomationRequest_out_MON_REQ,\n      OperatingRegion_in = OperatingRegion_in,\n      OperatingRegion_out = OperatingRegion_out,\n      LineSearchTask_in = LineSearchTask_in,\n      LineSearchTask_out = LineSearchTask_out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_AttestationGateBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ trusted_ids: In EventDataPort Base_Types.Bits\n  val trusted_ids_id: Art.PortId = CASE_AttestationGateBridge.trusted_ids.id\n  var trusted_ids_port: Option[DataContent] = noData\n\n  \/\/ AutomationRequest_in: In EventDataPort Base_Types.Bits\n  val AutomationRequest_in_id: Art.PortId = CASE_AttestationGateBridge.AutomationRequest_in.id\n  var AutomationRequest_in_port: Option[DataContent] = noData\n\n  \/\/ AutomationRequest_out_UXAS: Out EventDataPort Base_Types.Bits\n  val AutomationRequest_out_UXAS_id: Art.PortId = CASE_AttestationGateBridge.AutomationRequest_out_UXAS.id\n  var AutomationRequest_out_UXAS_port: Option[DataContent] = noData\n\n  \/\/ AutomationRequest_out_MON_REQ: Out EventDataPort Base_Types.Bits\n  val AutomationRequest_out_MON_REQ_id: Art.PortId = CASE_AttestationGateBridge.AutomationRequest_out_MON_REQ.id\n  var AutomationRequest_out_MON_REQ_port: Option[DataContent] = noData\n\n  \/\/ OperatingRegion_in: In EventDataPort Base_Types.Bits\n  val OperatingRegion_in_id: Art.PortId = CASE_AttestationGateBridge.OperatingRegion_in.id\n  var OperatingRegion_in_port: Option[DataContent] = noData\n\n  \/\/ OperatingRegion_out: Out EventDataPort Base_Types.Bits\n  val OperatingRegion_out_id: Art.PortId = CASE_AttestationGateBridge.OperatingRegion_out.id\n  var OperatingRegion_out_port: Option[DataContent] = noData\n\n  \/\/ LineSearchTask_in: In EventDataPort Base_Types.Bits\n  val LineSearchTask_in_id: Art.PortId = CASE_AttestationGateBridge.LineSearchTask_in.id\n  var LineSearchTask_in_port: Option[DataContent] = noData\n\n  \/\/ LineSearchTask_out: Out EventDataPort Base_Types.Bits\n  val LineSearchTask_out_id: Art.PortId = CASE_AttestationGateBridge.LineSearchTask_out.id\n  var LineSearchTask_out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == trusted_ids_id) {\n      return trusted_ids_port\n    } else if(portId == AutomationRequest_in_id) {\n      return AutomationRequest_in_port\n    } else if(portId == OperatingRegion_in_id) {\n      return OperatingRegion_in_port\n    } else if(portId == LineSearchTask_in_id) {\n      return LineSearchTask_in_port\n    } else {\n      halt(s\"Unexpected: CASE_AttestationGate.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    trusted_ids_port = CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.trusted_ids_Receive()\n\n    AutomationRequest_in_port = CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.AutomationRequest_in_Receive()\n\n    OperatingRegion_in_port = CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.OperatingRegion_in_Receive()\n\n    LineSearchTask_in_port = CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.LineSearchTask_in_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == AutomationRequest_out_UXAS_id) {\n      AutomationRequest_out_UXAS_port = Some(data)\n    } else if(portId == AutomationRequest_out_MON_REQ_id) {\n      AutomationRequest_out_MON_REQ_port = Some(data)\n    } else if(portId == OperatingRegion_out_id) {\n      OperatingRegion_out_port = Some(data)\n    } else if(portId == LineSearchTask_out_id) {\n      LineSearchTask_out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_AttestationGate.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(AutomationRequest_out_UXAS_port.nonEmpty) {\n      CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.AutomationRequest_out_UXAS_Send(AutomationRequest_out_UXAS_port.get)\n      AutomationRequest_out_UXAS_port = noData\n    }\n\n    if(AutomationRequest_out_MON_REQ_port.nonEmpty) {\n      CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.AutomationRequest_out_MON_REQ_Send(AutomationRequest_out_MON_REQ_port.get)\n      AutomationRequest_out_MON_REQ_port = noData\n    }\n\n    if(OperatingRegion_out_port.nonEmpty) {\n      CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.OperatingRegion_out_Send(OperatingRegion_out_port.get)\n      OperatingRegion_out_port = noData\n    }\n\n    if(LineSearchTask_out_port.nonEmpty) {\n      CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.LineSearchTask_out_Send(LineSearchTask_out_port.get)\n      LineSearchTask_out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_trusted_ids: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_trusted_ids()\n      val apiUsage_AutomationRequest_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_AutomationRequest_in()\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n      val apiUsage_OperatingRegion_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_OperatingRegion_in()\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n      val apiUsage_LineSearchTask_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_LineSearchTask_in()\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(CASE_AttestationGateBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(CASE_AttestationGateBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(CASE_AttestationGateBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix {\n  \/\/ returns T if seL4's trusted_ids port is empty, F otherwise \n  def trusted_ids_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's trusted_ids port \n  def trusted_ids_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's AutomationRequest_in port is empty, F otherwise \n  def AutomationRequest_in_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AutomationRequest_in port \n  def AutomationRequest_in_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's AutomationRequest_out_UXAS port\n  def AutomationRequest_out_UXAS_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AutomationRequest_out_MON_REQ port\n  def AutomationRequest_out_MON_REQ_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's OperatingRegion_in port is empty, F otherwise \n  def OperatingRegion_in_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's OperatingRegion_in port \n  def OperatingRegion_in_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's OperatingRegion_out port\n  def OperatingRegion_out_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's LineSearchTask_in port is empty, F otherwise \n  def LineSearchTask_in_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's LineSearchTask_in port \n  def LineSearchTask_in_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's LineSearchTask_out port\n  def LineSearchTask_out_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_Ext {\n  def trusted_ids_IsEmpty(): B = halt(\"stub\")\n\n  def trusted_ids_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AutomationRequest_in_IsEmpty(): B = halt(\"stub\")\n\n  def AutomationRequest_in_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AutomationRequest_out_UXAS_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AutomationRequest_out_MON_REQ_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def OperatingRegion_in_IsEmpty(): B = halt(\"stub\")\n\n  def OperatingRegion_in_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def OperatingRegion_out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def LineSearchTask_in_IsEmpty(): B = halt(\"stub\")\n\n  def LineSearchTask_in_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def LineSearchTask_out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_H\n#define CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\";\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n  api_put_AutomationRequest_out_UXAS__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n  api_put_AutomationRequest_out_MON_REQ__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__SeL4_CMASI_OperatingRegion_i, numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i);\n  api_put_OperatingRegion_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__SeL4_CMASI_OperatingRegion_i, t2);\n\n  uint8_t t3[numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i];\n  byte_array_default(SF t3, numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n  api_put_LineSearchTask_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, t3);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i];\n  size_t t0_numBits;\n  if(api_get_trusted_ids__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_AddressArray_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port trusted_ids: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(trusted_ids_str);\n    String__append(SF (String) &trusted_ids_str, string(\"Received data on event data port trusted_ids: \"));\n    byte_array_string(SF (String) &trusted_ids_str, t0, numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &trusted_ids_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  size_t t1_numBits;\n  if(api_get_AutomationRequest_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port AutomationRequest_in: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(AutomationRequest_in_str);\n    String__append(SF (String) &AutomationRequest_in_str, string(\"Received data on event data port AutomationRequest_in: \"));\n    byte_array_string(SF (String) &AutomationRequest_in_str, t1, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &AutomationRequest_in_str);\n    *\/\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  size_t t2_numBits;\n  if(api_get_OperatingRegion_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert((Z) t2_numBits == numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port OperatingRegion_in: \\n\", component_id);\n    hex_dump(SF t2, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(OperatingRegion_in_str);\n    String__append(SF (String) &OperatingRegion_in_str, string(\"Received data on event data port OperatingRegion_in: \"));\n    byte_array_string(SF (String) &OperatingRegion_in_str, t2, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &OperatingRegion_in_str);\n    *\/\n  }\n\n  uint8_t t3[numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i];\n  size_t t3_numBits;\n  if(api_get_LineSearchTask_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert((Z) t3_numBits == numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port LineSearchTask_in: \\n\", component_id);\n    hex_dump(SF t3, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(LineSearchTask_in_str);\n    String__append(SF (String) &LineSearchTask_in_str, string(\"Received data on event data port LineSearchTask_in: \"));\n    byte_array_string(SF (String) &LineSearchTask_in_str, t3, numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &LineSearchTask_in_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_API_H\n#define CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_trusted_ids__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AutomationRequest_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest_out_UXAS__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest_out_MON_REQ__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_OperatingRegion_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_OperatingRegion_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_LineSearchTask_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_LineSearchTask_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_42AD32 = Option[uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  Option_42AD32_get_(SF (uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_8C5380 = Option[uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_Operational_Api]\n  Option_8C5380_get_(SF (uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_trusted_ids__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_trusted_ids__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_trusted_ids_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AutomationRequest_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_AutomationRequest_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_AutomationRequest_in_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_AutomationRequest_out_UXAS__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_AutomationRequest_out_UXAS__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_AutomationRequest_out_UXAS_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_AutomationRequest_out_MON_REQ__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_AutomationRequest_out_MON_REQ__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_AutomationRequest_out_MON_REQ_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nbool api_get_OperatingRegion_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_OperatingRegion_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_OperatingRegion_in_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_OperatingRegion_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_OperatingRegion_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_OperatingRegion_out_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nbool api_get_LineSearchTask_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_LineSearchTask_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_LineSearchTask_in_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_LineSearchTask_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_LineSearchTask_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_LineSearchTask_out_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_CASE_AttestationGate_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_CASE_AttestationGate_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_CASE_AttestationGate_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_CASE_AttestationGate_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_ADAPTER_H\n#define CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix\n\nobject CASE_Filter_LST extends App {\n\n  val CASE_Filter_LSTBridge : uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge = {\n    val filter_in = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in\", mode = EventIn)\n    val filter_out = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      filter_in = filter_in,\n      filter_out = filter_out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Filter_LSTBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ filter_in: In EventDataPort Base_Types.Bits\n  val filter_in_id: Art.PortId = CASE_Filter_LSTBridge.filter_in.id\n  var filter_in_port: Option[DataContent] = noData\n\n  \/\/ filter_out: Out EventDataPort Base_Types.Bits\n  val filter_out_id: Art.PortId = CASE_Filter_LSTBridge.filter_out.id\n  var filter_out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == filter_in_id) {\n      return filter_in_port\n    } else {\n      halt(s\"Unexpected: CASE_Filter_LST.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    filter_in_port = CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix.filter_in_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == filter_out_id) {\n      filter_out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_Filter_LST.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(filter_out_port.nonEmpty) {\n      CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix.filter_out_Send(filter_out_port.get)\n      filter_out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_filter_in: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.get_filter_in()\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.put_filter_out(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.put_filter_out(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(CASE_Filter_LSTBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(CASE_Filter_LSTBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(CASE_Filter_LSTBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix {\n  \/\/ returns T if seL4's filter_in port is empty, F otherwise \n  def filter_in_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's filter_in port \n  def filter_in_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's filter_out port\n  def filter_out_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_Ext {\n  def filter_in_IsEmpty(): B = halt(\"stub\")\n\n  def filter_in_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def filter_out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_H\n#define CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\";\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n  api_put_filter_out__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, t0);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i];\n  size_t t0_numBits;\n  if(api_get_filter_in__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port filter_in: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(filter_in_str);\n    String__append(SF (String) &filter_in_str, string(\"Received data on event data port filter_in: \"));\n    byte_array_string(SF (String) &filter_in_str, t0, numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF (String) &filter_in_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_API_H\n#define CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_filter_in__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_filter_out__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_5883C0 = Option[uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_Initialization_Api]\n  Option_5883C0_get_(SF (uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_3239DD = Option[uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_Operational_Api]\n  Option_3239DD_get_(SF (uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_filter_in__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_get_filter_in__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Operational_Api_get_filter_in_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_filter_out__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_put_filter_out__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_put_filter_out_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_CASE_Filter_LST_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_CASE_Filter_LST_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_CASE_Filter_LST_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_CASE_Filter_LST_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_ADAPTER_H\n#define CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix\n\nobject CASE_Monitor_Req extends App {\n\n  val CASE_Monitor_ReqBridge : uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge = {\n    val observed = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed\", mode = EventIn)\n    val reference_1 = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1\", mode = EventIn)\n\n    uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      observed = observed,\n      reference_1 = reference_1\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Monitor_ReqBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ observed: In EventDataPort Base_Types.Bits\n  val observed_id: Art.PortId = CASE_Monitor_ReqBridge.observed.id\n  var observed_port: Option[DataContent] = noData\n\n  \/\/ reference_1: In EventDataPort Base_Types.Bits\n  val reference_1_id: Art.PortId = CASE_Monitor_ReqBridge.reference_1.id\n  var reference_1_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == observed_id) {\n      return observed_port\n    } else if(portId == reference_1_id) {\n      return reference_1_port\n    } else {\n      halt(s\"Unexpected: CASE_Monitor_Req.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    observed_port = CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix.observed_Receive()\n\n    reference_1_port = CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix.reference_1_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    halt(s\"Unexpected: CASE_Monitor_Req.putValue called with: ${portId}\")\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_observed()\n      val apiUsage_reference_1: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_reference_1()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(CASE_Monitor_ReqBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(CASE_Monitor_ReqBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(CASE_Monitor_ReqBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix {\n  \/\/ returns T if seL4's observed port is empty, F otherwise \n  def observed_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's observed port \n  def observed_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's reference_1 port is empty, F otherwise \n  def reference_1_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's reference_1 port \n  def reference_1_Receive(): Option[DataContent] = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_Ext {\n  def observed_IsEmpty(): B = halt(\"stub\")\n\n  def observed_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def reference_1_IsEmpty(): B = halt(\"stub\")\n\n  def reference_1_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_H\n#define CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h>\n#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\";\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  size_t t0_numBits;\n  if(api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port observed: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(observed_str);\n    String__append(SF (String) &observed_str, string(\"Received data on event data port observed: \"));\n    byte_array_string(SF (String) &observed_str, t0, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF (String) &observed_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i];\n  size_t t1_numBits;\n  if(api_get_reference_1__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port reference_1: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(reference_1_str);\n    String__append(SF (String) &reference_1_str, string(\"Received data on event data port reference_1: \"));\n    byte_array_string(SF (String) &reference_1_str, t1, numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF (String) &reference_1_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_API_H\n#define CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_reference_1__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h>\n#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_D2133A = Option[uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_Initialization_Api]\n  Option_D2133A_get_(SF (uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_5BDB08 = Option[uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_Operational_Api]\n  Option_5BDB08_get_(SF (uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api_get_observed_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_reference_1__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_get_reference_1__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api_get_reference_1_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_CASE_Monitor_Req_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_CASE_Monitor_Req_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_CASE_Monitor_Req_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_CASE_Monitor_Req_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_ADAPTER_H\n#define CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\n\nimport org.sireum._\nimport art._\nimport art.Art.BridgeId._\nimport art.Art.PortId._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport uav_june_step6__SeL4._\nimport uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix\n\nobject CASE_Monitor_Geo extends App {\n\n  val CASE_Monitor_GeoBridge : uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = portId\"0\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones\", mode = DataIn)\n    val keep_out_zones = Port[Base_Types.Bits] (id = portId\"1\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones\", mode = DataIn)\n    val observed = Port[Base_Types.Bits] (id = portId\"2\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed\", mode = EventIn)\n    val output = Port[Base_Types.Bits] (id = portId\"3\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output\", mode = EventOut)\n    val alert = Port[art.Empty] (id = portId\"4\", name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert\", mode = EventOut)\n\n    uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge(\n      id = bridgeId\"0\",\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones,\n      observed = observed,\n      output = output,\n      alert = alert\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Monitor_GeoBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ keep_in_zones: In DataPort Base_Types.Bits\n  val keep_in_zones_id: Art.PortId = CASE_Monitor_GeoBridge.keep_in_zones.id\n  var keep_in_zones_port: Option[DataContent] = noData\n\n  \/\/ keep_out_zones: In DataPort Base_Types.Bits\n  val keep_out_zones_id: Art.PortId = CASE_Monitor_GeoBridge.keep_out_zones.id\n  var keep_out_zones_port: Option[DataContent] = noData\n\n  \/\/ observed: In EventDataPort Base_Types.Bits\n  val observed_id: Art.PortId = CASE_Monitor_GeoBridge.observed.id\n  var observed_port: Option[DataContent] = noData\n\n  \/\/ output: Out EventDataPort Base_Types.Bits\n  val output_id: Art.PortId = CASE_Monitor_GeoBridge.output.id\n  var output_port: Option[DataContent] = noData\n\n  \/\/ alert: Out EventPort art.Empty\n  val alert_id: Art.PortId = CASE_Monitor_GeoBridge.alert.id\n  var alert_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == keep_in_zones_id) {\n      return keep_in_zones_port\n    } else if(portId == keep_out_zones_id) {\n      return keep_out_zones_port\n    } else if(portId == observed_id) {\n      return observed_port\n    } else {\n      halt(s\"Unexpected: CASE_Monitor_Geo.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    keep_in_zones_port = CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.keep_in_zones_Receive()\n\n    keep_out_zones_port = CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.keep_out_zones_Receive()\n\n    observed_port = CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.observed_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == output_id) {\n      output_port = Some(data)\n    } else if(portId == alert_id) {\n      alert_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_Monitor_Geo.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(output_port.nonEmpty) {\n      CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.output_Send(output_port.get)\n      output_port = noData\n    }\n\n    if(alert_port.nonEmpty) {\n      CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.alert_Send(alert_port.get)\n      alert_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(portId\"0\", Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(portId\"0\", None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_keep_in_zones: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_in_zones()\n      val apiUsage_keep_out_zones: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_out_zones()\n      val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_observed()\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_output(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_output(Base_Types.Bits_example())\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_alert()\n      uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_alert()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(CASE_Monitor_GeoBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(CASE_Monitor_GeoBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(CASE_Monitor_GeoBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\npackage uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix {\n  \/\/ returns T if seL4's keep_in_zones port is empty, F otherwise \n  def keep_in_zones_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's keep_in_zones port \n  def keep_in_zones_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's keep_out_zones port is empty, F otherwise \n  def keep_out_zones_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's keep_out_zones port \n  def keep_out_zones_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's observed port is empty, F otherwise \n  def observed_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's observed port \n  def observed_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's output port\n  def output_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's alert port\n  def alert_Send(d: DataContent): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package uav_june_step6__SeL4.SW\n\nimport org.sireum._\nimport art._\n\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_Ext {\n  def keep_in_zones_IsEmpty(): B = halt(\"stub\")\n\n  def keep_in_zones_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def keep_out_zones_IsEmpty(): B = halt(\"stub\")\n\n  def keep_out_zones_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def observed_IsEmpty(): B = halt(\"stub\")\n\n  def observed_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def output_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def alert_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_H\n#define CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\";\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_\", 0);\n\n  printf(\"%s: uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n  api_put_output__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, t0);\n\n  api_put_alert__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF_LAST);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_\", 0);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__SeL4_CMASI_Polygon_i];\n  size_t t0_numBits;\n  if(api_get_keep_in_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert((Z) t0_numBits == numBits_uav_june_step6__SeL4_CMASI_Polygon_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on data port keep_in_zones: \\n\", component_id);\n    hex_dump(SF t0, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(keep_in_zones_str);\n    String__append(SF (String) &keep_in_zones_str, string(\"Received data on data port keep_in_zones: \"));\n    byte_array_string(SF (String) &keep_in_zones_str, t0, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &keep_in_zones_str);\n    *\/\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__SeL4_CMASI_Polygon_i];\n  size_t t1_numBits;\n  if(api_get_keep_out_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert((Z) t1_numBits == numBits_uav_june_step6__SeL4_CMASI_Polygon_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on data port keep_out_zones: \\n\", component_id);\n    hex_dump(SF t1, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(keep_out_zones_str);\n    String__append(SF (String) &keep_out_zones_str, string(\"Received data on data port keep_out_zones: \"));\n    byte_array_string(SF (String) &keep_out_zones_str, t1, numBytes_uav_june_step6__SeL4_CMASI_Polygon_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &keep_out_zones_str);\n    *\/\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i];\n  size_t t2_numBits;\n  if(api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert((Z) t2_numBits == numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i, \"numBits received does not match expected\")\n\n    printf(\"%s: Received data on event data port observed: \\n\", component_id);\n    hex_dump(SF t2, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    DeclNewString(observed_str);\n    String__append(SF (String) &observed_str, string(\"Received data on event data port observed: \"));\n    byte_array_string(SF (String) &observed_str, t2, numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &observed_str);\n    *\/\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_API_H\n#define CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_API_H\n\n#include <all.h>\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_keep_in_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_keep_out_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_output__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_alert__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(STACK_FRAME_ONLY);\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h>\n\nstatic bool apis_initialized = false;\nstatic struct uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api initialization_api;\nstatic struct uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_37E6D7 = Option[uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  Option_37E6D7_get_(SF (uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &initialization_api, uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_BEE96A = Option[uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_Operational_Api]\n  Option_BEE96A_get_(SF (uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api) &operational_api, uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nbool api_get_keep_in_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_keep_in_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_keep_in_zones_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_keep_out_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_keep_out_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_keep_out_zones_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_observed_(\n    SF\n    (Option_30119F) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_output__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_put_output__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  sfAssert((Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\")\n  sfAssert((Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\")\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_put_output_(\n    SF\n    &initialization_api,\n    &t_0);\n}\n\nvoid api_put_alert__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_put_alert__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_put_alert_(\n    SF\n    &initialization_api);\n}\n\nvoid api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered\", 0);\n\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseArchitecture\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_CASE_Monitor_Geo_initialiseArchitecture(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_CASE_Monitor_Geo_initialiseEntryPoint(SF_LAST);\n}\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_computeEntryPoint\", 0);\n\n  uav_june_step6__SeL4_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_CASE_Monitor_Geo_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_entryPoints\", 0);\n\n  return uav_june_step6__SeL4_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_CASE_Monitor_Geo_entryPoints(SF_LAST);\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_ADAPTER_H\n#define CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_ADAPTER_H\n\n#include <all.h>\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/ext.c",
        {
          "type" : "ITestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n\/\/ example method that sets the first numBits bits of byteArray to 1\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_default\", 0);\n\n  sfAssert((numBits - 1) \/ 8  + 1 <= numBytes, \"byte_array_default: numBytes * 8 must be at least numBits\")\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    uint8_t v = 0;\n    for(uint8_t bit = 0; bit < 8; bit++) {\n      if(byte * 8 + bit < numBits) {\n        v |= 1UL << bit;\n      }\n    }\n    byteArray[byte] = v;\n  }\n}\n\n\/\/ example method that places the hex value of the bytes in byteArray into str\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_string\", 0);\n\n  sfAssert((str->size + numBytes) <= MaxString, \"byte_array_string: Insufficient maximum for String characters, consider increasing the --max-string-size option\")\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    U8_string_(SF str, byteArray[byte]);\n    String__append(SF str, string(\" \"));\n  }\n}\n\n\/\/ example method that directly prints the hex values of the bytes in byte_array\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"hex_dump\", 0);\n\n  printf(\"[ \");\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    if(byte != 0 && byte % 16 == 0) { printf(\"\\n  \"); }\n    printf(\"%02X \", byte_array[byte]);\n  }\n  printf(\"]\\n\");\n}",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/c\/ext-c\/ext.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl\n#define numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl 1024\n#define numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl ((numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_UART_Msg_Impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_MissionCommand_i\n#define numBits_uav_june_step6__SeL4_CMASI_MissionCommand_i 16384\n#define numBytes_uav_june_step6__SeL4_CMASI_MissionCommand_i ((numBits_uav_june_step6__SeL4_CMASI_MissionCommand_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_AirVehicleState_i\n#define numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i 4096\n#define numBytes_uav_june_step6__SeL4_CMASI_AirVehicleState_i ((numBits_uav_june_step6__SeL4_CMASI_AirVehicleState_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl\n#define numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl 1024\n#define numBytes_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl ((numBits_uav_june_step6__SeL4_CASE_Model_Transformations_CASE_RF_Msg_Impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_AddressArray_i\n#define numBits_uav_june_step6__SeL4_CMASI_AddressArray_i 96\n#define numBytes_uav_june_step6__SeL4_CMASI_AddressArray_i ((numBits_uav_june_step6__SeL4_CMASI_AddressArray_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i\n#define numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i 131072\n#define numBytes_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i ((numBits_uav_june_step6__SeL4_CMASI_AddressAttributedMessage_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_Polygon_i\n#define numBits_uav_june_step6__SeL4_CMASI_Polygon_i 1024\n#define numBytes_uav_june_step6__SeL4_CMASI_Polygon_i ((numBits_uav_june_step6__SeL4_CMASI_Polygon_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_AutomationRequest_i\n#define numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i 2048\n#define numBytes_uav_june_step6__SeL4_CMASI_AutomationRequest_i ((numBits_uav_june_step6__SeL4_CMASI_AutomationRequest_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_OperatingRegion_i\n#define numBits_uav_june_step6__SeL4_CMASI_OperatingRegion_i 2048\n#define numBytes_uav_june_step6__SeL4_CMASI_OperatingRegion_i ((numBits_uav_june_step6__SeL4_CMASI_OperatingRegion_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_LineSearchTask_i\n#define numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i 65536\n#define numBytes_uav_june_step6__SeL4_CMASI_LineSearchTask_i ((numBits_uav_june_step6__SeL4_CMASI_LineSearchTask_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__SeL4_CMASI_AutomationResponse_i\n#define numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i 262144\n#define numBytes_uav_june_step6__SeL4_CMASI_AutomationResponse_i ((numBits_uav_june_step6__SeL4_CMASI_AutomationResponse_i - 1) \/ 8 + 1)\n\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes);\n\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes);\n\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes);\n#endif",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__SeL4._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/transpile-sel4.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\r\n\r\nval SCRIPT_HOME: Os.Path = Os.slashDir\r\nval PATH_SEP: String = Os.pathSep\r\n\r\nval UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/Drivers${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\",\r\n  \"--name\", \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\",\r\n  \"--apps\", \"uav_june_step6__SeL4.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.UARTDriver\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=3;IS[Z,art.Art.PortId]=3;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=5;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.UARTDriver\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\r\n  \"--name\", \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\r\n  \"--apps\", \"uav_june_step6__SeL4.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.RadioDriver_Attestation\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.Art.PortId]=5;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=6;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.RadioDriver_Attestation\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\r\n  \"--name\", \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\r\n  \"--apps\", \"uav_june_step6__SeL4.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.FlyZonesDatabase\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.Art.PortId]=2;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=2;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.FlyZonesDatabase\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\",\r\n  \"--name\", \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\",\r\n  \"--apps\", \"uav_june_step6__SeL4.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.UxAS\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=4;IS[Z,art.Art.PortId]=4;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=6;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.UxAS\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\r\n  \"--name\", \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\r\n  \"--apps\", \"uav_june_step6__SeL4.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.WaypointPlanManagerService\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=3;IS[Z,art.Art.PortId]=3;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=4;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.WaypointPlanManagerService\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\r\n  \"--name\", \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\r\n  \"--apps\", \"uav_june_step6__SeL4.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.CASE_AttestationGate\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=4;IS[Z,art.Art.PortId]=4;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=8;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.CASE_AttestationGate\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\r\n  \"--name\", \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\r\n  \"--apps\", \"uav_june_step6__SeL4.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.CASE_Filter_LST\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=1;IS[Z,art.Art.PortId]=1;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=2;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.CASE_Filter_LST\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\r\n  \"--name\", \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\r\n  \"--apps\", \"uav_june_step6__SeL4.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.CASE_Monitor_Req\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.Art.PortId]=2;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=2;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.CASE_Monitor_Req\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SW${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--name\", \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--apps\", \"uav_june_step6__SeL4.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.CASE_Monitor_Geo\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=3;IS[Z,art.Art.PortId]=3;IS[Z,B]=262144\",\r\n  \"--constants\", s\"art.Art.numComponents=1;art.Art.numPorts=5;art.Art.numConnections=1\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.CASE_Monitor_Geo\",\r\n  \"--stack-size\", \"524288\",\r\n  \"--stable-type-id\",\r\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.c\",\r\n  \"--exclude-build\", \"uav_june_step6__SeL4.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__SeL4.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__SeL4.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__SeL4.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__SeL4.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__SeL4.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__SeL4.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__SeL4.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__SeL4.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\r\n  \"--lib-only\")\r\n\r\nval SlangTypeLibrary: ISZ[String] = ISZ(\r\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/uav_june_step6__SeL4\/SlangTypeLibrary\",\r\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/camkes\/slang_libraries\/SlangTypeLibrary\",\r\n  \"--name\", \"SlangTypeLibrary\",\r\n  \"--apps\", \"uav_june_step6__SeL4.SlangTypeLibrary.SlangTypeLibrary\",\r\n  \"--fingerprint\", \"3\",\r\n  \"--bits\", \"32\",\r\n  \"--string-size\", \"256\",\r\n  \"--sequence-size\", \"1\",\r\n  \"--sequence\", s\"IS[Z,B]=262144\",\r\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\",\r\n  \"--forward\", \"art.ArtNative=uav_june_step6__SeL4.SlangTypeLibrary.SlangTypeLibrary\",\r\n  \"--stack-size\", \"16777216\",\r\n  \"--stable-type-id\",\r\n  \"--lib-only\")\r\n\r\nval projects: ISZ[ISZ[String]] = ISZ(\r\n  UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,\r\n  RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,\r\n  FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,\r\n  UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,\r\n  WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,\r\n  CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,\r\n  CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,\r\n  CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,\r\n  CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo,\r\n  SlangTypeLibrary\r\n)\r\n\r\nprintln(\"Initializing runtime library ...\")\r\nSireum.initRuntimeLibrary()\r\n\r\nvar result = 0\r\nfor(p <- projects if result == 0) {\r\n  result = Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\r\n}\r\n\r\n\/\/ops.ISZOps(projects).parMap(p =>\r\n\/\/  Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\r\n\/\/)\r\n\r\nOs.exit(result)\r\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/architecture\/uav_june_step6__SeL4\/Platform.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Platform {\n\n  def setup(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM SETUP\n    \/\/ END MARKER PLATFORM SETUP\n  }\n\n  def tearDown(): Unit = {\n    \/\/ BEGIN MARKER PLATFORM TEARDOWN\n    \/\/ END MARKER PLATFORM TEARDOWN\n  }\n}",
          "markers" : [
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM SETUP",
              "endMarker" : "\/\/ END MARKER PLATFORM SETUP"
            },
            {
              "type" : "TestMarker",
              "beginMarker" : "\/\/ BEGIN MARKER PLATFORM TEARDOWN",
              "endMarker" : "\/\/ END MARKER PLATFORM TEARDOWN"
            }
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/sireum.org\/getting-started\/\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . uav_june_step6__SeL4.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . uav_june_step6__SeL4.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main uav_june_step6__SeL4.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   Create the IVE project if Codegen was not run locally or if its no-proyek-ive\r\n\/\/   option was used:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/uav_june_step6__SeL4\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"UAV_Impl_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\",\r\n                \"org.sireum.kekinian::hamr-vision:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\", \"util\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"system\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "isDatatype" : false
        }
      ],
      [
        "slang\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=94cf914\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\norg.sireum.kekinian%%hamr-vision%=5990efb6ca\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20240329.e93e5db\n\norg.sireum.kekinian%%library%=5990efb6ca\n\norg.scala-lang%scala-library%=2.13.13\norg.scalatest%%scalatest%%=3.2.18\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ A custom mill build for Sireum can be obtained from https:\/\/github.com\/sireum\/rolling\/releases\/tag\/mill\n\/\/ On Windows, rename 'mill' to 'mill.bat'\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   mill uav_june_step6__SeL4.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   mill uav_june_step6__SeL4.tests\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w uav_june_step6__SeL4.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `uav_june_step6__SeL4` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.13\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.18\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20240329.e93e5db\n  val sireumScalacVersion = \"4.20240329.e93e5db\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/5990efb6ca\n  val kekinianVersion = \"5990efb6ca\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-release:8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n    ivy\"org.sireum.kekinian::hamr-vision::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"uav_june_step6__SeL4.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"util\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"system\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"uav_june_step6__SeL4.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(os.Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE: Installation instructions available at https:\/\/sireum.org\/getting-started\/\n\/\/\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/uav_june_step6__SeL4\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val UAV_Impl_Instance = slangEmbeddedProject(\"UAV_Impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.13\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.18\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20240329.e93e5db\nval sireumScalacVersion = \"4.20240329.e93e5db\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/5990efb6ca\nval kekinianVersion = \"5990efb6ca\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-release:8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Resolver.sonatypeOssRepos(\"public\") ++ Seq(\"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  ThisBuild \/ evictionErrorLevel := Level.Warn,\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources(),\n    \"org.sireum.kekinian\" %% \"hamr-vision\" % kekinianVersion withSources()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/util\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/system\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"uav_june_step6__SeL4.Demo\"),\n\n  mainClass in assembly := Some(\"uav_june_step6__SeL4.Demo\"),\n  assemblyJarName in assembly := \"UAV_Impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"uav_june_step6__SeL4.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.9.0\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: IS[Art.BridgeId, Bridge],\n                                        connections: IS[Art.ConnectionId, UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def compute(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = {\n      println(\"Default testCompute\")\n    }\n\n    def testInitialise(): Unit = {\n      println(\"Default testInitialise\")\n    }\n  }\n\n  @datatype class Ports(dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n\n  @range(min = 0, max = 8, index = T) class BridgeId\n\n  @range(min = 0, max = 39, index = T) class PortId\n\n  @range(min = 0, max = 17, index = T) class ConnectionId\n\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val numComponents: Z = 9\n  val numPorts: Z = 40\n  val numConnections: Z = 18\n\n  val logTitle: String = \"Art\"\n\n  val bridges: MSZ[Option[Bridge]] = MS.create(numComponents, None[Bridge]())\n  val ports: MS[Art.PortId, Option[UPort]] = MS.create[Art.PortId, Option[UPort]](numPorts, None[UPort]())\n  val connections: MS[Art.PortId, IS[Art.ConnectionId, Art.PortId]] = MS.create[Art.PortId, IS[Art.ConnectionId, Art.PortId]](numPorts, IS())\n\n  \/\/ Note on transpiling:\n  \/\/ ports and connections are not touched\/transpiled when targeting seL4. Bridges\n  \/\/ are isolated when transpiling so BridgeId.Max could be 0, but changing Min\/Max is\n  \/\/ not currently supported by the transpiler so instead bridges is defined as an MSZ\n  \/\/ so that that its size can be set to 1 and thus reduce stack space requirements\n\n\n  @pure def bridge(bridgeId: Art.BridgeId): Bridge = {\n    return bridges(bridgeId.toZ).get\n  }\n\n  @pure def port(p: Art.PortId): UPort = {\n    return ports(p).get\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id.toZ) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n\n    def r(uports: ISZ[UPort]): Unit = {\n      for (port <- uports) {\n        ports(port.id) = Some(port)\n        \/* transpiler does not emit an extractor for matches in nested functions\n        port.mode match {\n          case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n          case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n          case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n          case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n        }\n        *\/\n        val typ: String = if (port.mode == PortMode.DataIn) \"(data in)\" else if (port.mode == PortMode.DataOut) \"(data out)\" else if (port.mode == PortMode.EventOut) \"(event out)\" else if (port.mode == PortMode.EventIn) \"(event in)\" else \"(infeasible)\"\n        ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} $typ\")\n      }\n    }\n\n    r(bridge.ports.dataIns)\n    r(bridge.ports.dataOuts)\n    r(bridge.ports.eventIns)\n    r(bridge.ports.eventOuts)\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if (bridges(bridgeId.toZ).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId.toZ).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all connections\n    for (i <- connections.indices) {\n      connections(i) = IS()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ call ArtNative to reset the state of the specific thread component\n    ArtNative.initTest(bridge)\n  }\n\n  \/**\n  * Executes a component (identified by bridge) Initialize Entry Point (application code)\n  * for the purposes of unit testing.\n  *\n  * This infrastructure method is called with automatically generated unit testing support code.\n  * The developer-facing version of this method (called by a developer unit test)\n  * provided by the unit testing support code hides the bridge argument.  The bridge\n  * value is retrieved from the testing infrastructure code before passing the call\n  * through to this method.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    ArtNative.testInitialise(bridge)\n  }\n\n  \/**\n   * Executes a component (identified by bridge) Compute Entry Point (application code)\n   * for the purposes of unit testing.\n   *\n   * This infrastructure method is called with automatically generated unit testing support code.\n   * The developer-facing version of this method (called by a developer unit test)\n   * provided by the unit testing support code hides the bridge argument.  The bridge\n   * value is retrieved from the testing infrastructure code before passing the call\n   * through to this method.\n   *\/\n  def testCompute(bridge: Bridge): Unit = {\n    ArtNative.testCompute(bridge)\n  }\n\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all connections\n    for (i <- connections.indices) {\n      connections(i) = IS()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInInfrastructurePort(dstPortId, data)\n  }\n\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeInInfrastructurePort(portId)\n  }\n\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeOutInfrastructurePort(portId)\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeInPortVariable(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    return ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n\n    val bridge = Art.bridges(bridgeId.toZ).get\n\n    if (bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if (bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port.toZ) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port.toZ) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Initialize Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: testInit() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n  *\/\n  def testInitialise(bridge: Bridge): Unit = $\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * the it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a postlude to each test.\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an infrastructure in port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n     * Returns the value of an application in port.\n     *\n     * @param portId the id of the INPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = $\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport org.sireum.S64._\n\nobject ArtSlangMessage {\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Option[Art.PortId],\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Z, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Z, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Z, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Z, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId.toZ).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId.toZ).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for (e <- eventIns) {\n          if (inInfrastructurePorts.contains(e.id.toZ)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  \/\/ transpiler friendly comparator\n  def lt(a: art.UPort, b: art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id.toZ).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id.toZ).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id.toZ).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id.toZ).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  \/\/ transpiler friendly sort\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if (sorted.isEmpty) {\n        return ISZ[UPort](p)\n      }\n      else {\n        if (lt(sorted(0), p)) {\n          return sorted(0) +: insert(p, ops.ISZOps(sorted).tail)\n        }\n        else {\n          return p +: sorted\n        }\n      }\n    }\n\n    if (ports.isEmpty) {\n      return ports\n    }\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val uports: ISZ[UPort] =\n          for (p <- Art.bridges(bridgeId.toZ).get.ports.eventIns if inInfrastructurePorts.get(p.id.toZ).nonEmpty) yield p\n\n        if (uports.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(uports)\n        EventTriggered(for (p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ remove any old events from previous dispatch\n    for (portId <- eventPortIds if inPortVariables.contains(portId.toZ)) {\n      inPortVariables = inPortVariables - ((portId.toZ, inPortVariables.get(portId.toZ).get))\n    }\n\n    \/\/ transfer received data\/events from the infrastructure ports to the port variables\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId.toZ, data))\n          inPortVariables = inPortVariables + (portId.toZ ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId.toZ ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId.toZ ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = None(), sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if (inPortVariables.contains(portId.toZ)) {\n      return Some(inPortVariables.get(portId.toZ).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId.toZ ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId.toZ, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for (dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = Some(dstPortId), sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId.toZ ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId.toZ, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        return None()\n      }\n    }\n  }\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outInfrastructurePorts.get(portId.toZ) match {\n      case Some(value) => return Some(value.data)\n      case _ => return None()\n    }\n  }\n\n  \/**\n   * Returns the value of an application in port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId.toZ) match {\n          case Some(value) => return Some(value.data)\n          case _ => return None()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        return None()\n      }\n    }\n  }\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId.toZ) match {\n      case Some(value) => return Some(value.data)\n      case _ => return None()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage(data: DataContent,\n\n                      var srcPortId: Option[Art.PortId] = None(),\n                      var dstPortId: Option[Art.PortId] = None(),\n\n                      \/\/ when putValue was called by producer\n                      var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when sendOutput transferred message from out port var of producer\n                      var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when message arrived via transport layer\n                      var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                      \/\/ when receiveInput transferred message to in port vars of consumer\n                      var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                     )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: IS[Art.BridgeId, Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = IS[Art.BridgeId, Art.BridgeId]()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Z, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Z, ArtMessage] = concMap()\n  val inPortVariables: MMap[Z, ArtMessage] = concMap()\n  val outPortVariables: MMap[Z, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ remove any old events from previous dispatch\n    for (portId <- eventPortIds if inPortVariables.contains(portId.toZ)) {\n      inPortVariables -= portId.toZ\n    }\n\n    \/\/ transfer received data\/events from the infrastructure ports to the port variables\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId.toZ \/\/ dequeue from infrastructure port\n          inPortVariables(portId.toZ) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId.toZ) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId.toZ) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId.toZ) = ArtMessage(data = data, srcPortId = Some(portId), putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId.toZ) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId.toZ) = outPortVariables(srcPortId.toZ)\n          outPortVariables -= srcPortId.toZ\n\n          \/\/ simulate sending msg via transport middleware\n          for (dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = Some(dstPortId), sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId.toZ) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId.toZ) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId.toZ\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId.toZ).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId.toZ).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId.toZ;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId.toZ).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId.toZ).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId.toZ\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId.toZ).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId.toZ).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id.toZ))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId.toZ).get.ports.eventIns.map((u: UPort) => u.id).elements.filter((i: Art.PortId) => inInfrastructurePorts.get(i.toZ).nonEmpty): _*)\n        val urgentFifo: Seq[Art.PortId] = portIds.map((pid: Art.PortId) => Art.port(pid)).elements.sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) => Z\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id.toZ).dstArrivalTimestamp < inInfrastructurePorts(p2.id.toZ).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id.toZ).dstArrivalTimestamp < inInfrastructurePorts(p2.id.toZ).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(ISZ[Art.PortId](urgentFifo: _*))\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  var logStream: java.io.PrintStream = System.out\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    logStream.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    logStream.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Sets up the state of a thread component (identified by bridge) for the purpose of\n   * testing.\n   *\n   * An analogue to this method does not show up in developer-written unit tests because\n   * it's invoked behind the scenes by the automatically generated unit test infrastructure\n   * as a prelude to each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ cancel pending ArtTimer callbacks (also done after a test completes)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Executes the application code in the Initialize Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.  This is achieved by\n   * calling the testInitialise() method on given bridge.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testInitialise(bridge: Bridge): Unit = {\n    bridge.entryPoints.testInitialise()\n  }\n\n  \/**\n   * Executes the application code in the Compute Entry Point for the component (identified\n   * by given bridge) for the purposes of testing.  This is achieved by\n   * calling the testCompute() method on given bridge.\n   *\n   * Precondition: initTest() has been called prior.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def testCompute(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ cancel pending ArtTimer callbacks (also done before a test begins)\n    ArtTimer_Ext.scheduledCallbacks.keys.foreach(ArtTimer_Ext.cancel)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId.toZ) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId.toZ) = outPortVariables(srcPortId.toZ)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInInfrastructurePort(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = Some(dstPortId), dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId.toZ) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId.toZ) = artMessage\n    }\n  }\n\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  \/**\n   * Returns the value of an infrastructure out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutInfrastructurePort(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outInfrastructurePorts.get(portId.toZ) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/**\n   * Returns the value of an application in port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId.toZ) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  \/**\n     * Returns the value of an application out port.\n     *\n     * @param portId the id of the OUTPUT port to return a value from\n     * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n     *\/\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId.toZ) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait TimerCallback {\n  def callback(): Unit\n}\n\n@ext object ArtTimer {\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = $\n\n  \/\/ if transpiling then use this version as transpiler does not support function passing\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = $\n\n  def cancel(id: String): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum.S64._\nimport org.sireum.{B, F, String, T}\n\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.{Executors, TimeUnit}\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtTimer_Ext {\n\n  protected[art] val scheduledCallbacks: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  private val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def cancel(id: String): Unit = {\n    scheduledCallbacks.get(id) match {\n      case Some(b) =>\n        val userRequested = b.get()\n        b.set(F)\n        scheduledCallbacks.remove(id)\n        if (userRequested) {\n          ArtNative.logInfo(Art.logTitle, s\"Callback cleared for $id\")\n        }\n      case _ =>\n    }\n  }\n\n  def scheduleTrait(id: String, replaceExisting: B, delay: Art.Time, callback: TimerCallback): Unit = {\n    schedule(id, replaceExisting, delay, callback.callback _)\n  }\n\n  def schedule(id: String, replaceExisting: B, delay: Art.Time, callback: () => Unit): Unit = {\n    if (scheduledCallbacks.get(id).nonEmpty) {\n      if (!replaceExisting) {\n        ArtNative.logInfo(Art.logTitle, s\"Callback already scheduled for $id\")\n        return\n      } else {\n        cancel(id)\n      }\n    }\n\n    if (delay < s64\"0\") {\n      ArtNative.logInfo(Art.logTitle, s\"Invalid delay time: ${delay}.  Value must be non-negative.\")\n      return\n    }\n\n    \/\/ the below runnable will be run in a separate thread when it's\n    \/\/ dispatched by the executor. If the user requests to cancel the\n    \/\/ timeout before that then shouldInvokeCallback will be set to\n    \/\/ false and therefore the callback will not be invoked\n    val shouldInvokeCallback = new AtomicBoolean(T)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (shouldInvokeCallback.get()) {\n          shouldInvokeCallback.set(F)\n          cancel(id)\n\n          callback()\n        }\n      }\n    }\n\n    scheduledCallbacks.put(id, shouldInvokeCallback)\n\n    val adjusted = delay.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    ArtNative.logInfo(Art.logTitle, s\"Callback scheduled for $id: $delay ms\")\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: IS[Art.BridgeId, art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = {}\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: IS[Art.BridgeId, art.Bridge]): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: IS[Art.BridgeId, art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x: Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = {}\n\n  override def initializationPhase(): Unit = {}\n\n  override def computePhase(): Unit = {}\n\n  override def finalizePhase(): Unit = {}\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\nimport org.sireum.S64._\n\n@record class RoundRobin(schedule: ISZ[Art.BridgeId]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create[Art.BridgeId, Art.Time](schedule.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create[Art.BridgeId, Art.Time](schedule.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridgeId <- schedule) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.initialise()\n      Art.logInfo(bridgeId, s\"Initialized bridge: ${Art.bridges(bridgeId.toZ).get.name}\")\n    }\n  }\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    Art.bridges(bridgeId.toZ).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if (Art.time() - lastDispatch(bridgeId) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridgeId) \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if (Art.time() - lastSporadic(bridgeId) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridgeId)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while (!RoundRobinExtensions.shouldStop()) {\n      for (bridgeId <- schedule) {\n        if (shouldDispatch(bridgeId)) {\n          lastDispatch(bridgeId) = Art.time()\n          Art.bridges(bridgeId.toZ).get.entryPoints.compute()\n\n          if (Art.bridges(bridgeId.toZ).get.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridgeId) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridgeId <- schedule) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.finalise()\n      Art.logInfo(bridgeId, s\"Finalized bridge: ${Art.bridges(bridgeId.toZ).get.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n\n  def shouldStop(): B = $\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/CliCommandProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\n\n@record class CliCommandProvider extends CommandProvider {\n  override def nextCommand(): Command = {\n    return getCommand()\n  }\n\n  def getCommand(): Command = {\n    val cmdString: String = StaticSchedulerIO.getCommand(\"HAMR> \")\n    val args: ISZ[String] = ops.StringOps(cmdString).split(c => c == ' ')\n    val arg0: String = args(0)\n    if (arg0 == \"x\") {\n      return Stop()\n    } else if (arg0 == \"s\") {\n      var numSteps: Z = 1\n      if (args.size > 1) {\n        Z(args(1)) match {\n          case Some(numStepsCli) => numSteps = numStepsCli\n          case None() => return Unsupported()\n        }\n      }\n      return Sstep(numSteps)\n    } else if (arg0 == \"help\") {\n      return Help()\n    } else if (arg0 == \"h\") {\n      var numSteps: Z = 1\n      if (args.size > 1) {\n        Z(args(1)) match {\n          case Some(numStepsCli) => numSteps = numStepsCli\n          case None() => return Unsupported()\n        }\n      }\n      return Hstep(numSteps)\n    } else if (arg0 == \"i\") {\n      if (args.size < 2) {\n        println(\"i requires a second option\")\n        return Help()\n      }\n      \/\/ need to insert a check for size greater than 1\n      if (args(1) == \"st\") {\n        return Infostate()\n      } else if (args(1) == \"sc\") {\n        return Infoschedule()\n      } else if (args(1) == \"out\") {\n        return InfoOutputs()\n      } else if (args(1) == \"in\") {\n        return InfoInputs()\n      } else if (args(1) == \"cpn\") {\n        if (args.size > 2) {\n          Z(args(2)) match {\n            case Some(bridgeId) => return InfoComponentStateId(bridgeId)\n            case None() => return Unsupported() \/\/ expected bridgeId arg is not an integer\n          }\n        }\n        return Unsupported() \/\/ incorrect number of arguments for \"i cp\" (missing bridge id arg)\n      } else if (args(1) == \"cp\") {\n        if (args.size > 2) {\n          return InfoComponentState(args(2))\n        }\n        return Unsupported() \/\/ incorrect number of arguments for \"i cp\" (missing bridge id arg)\n      } else if (args(1) == \"nn\") {\n        return InfoThreadNickNames()\n      } \/\/ incorrect number of arguments for \"i cp\" (missing bridge id arg)\n      else { \/\/ ... no other info commands supported\n        return Unsupported()\n      }\n    } else if (arg0 == \"rh\") {\n      Z(args(1)) match {\n        case Some(hpTarget) => return RunToHP(hpTarget)\n        case None() => return Unsupported()\n      }\n    } else if (arg0 == \"rd\") {\n      Z(args(1)) match {\n        case Some(domainIdTarget) => return RunToDomain(domainIdTarget)\n        case None() => return Unsupported()\n      }\n    } else if (arg0 == \"rt\") {\n      val threadNickName = args(1)\n      return RunToThread(threadNickName)\n    } else if (arg0 == \"rs\") {\n      if (args.size == 2) { \/\/ run to slot\n        Z(args(1)) match {\n          case Some(slotNumTarget) => return RunToSlot(slotNumTarget)\n          case None() => return Unsupported()\n        }\n      } else if (args.size == 3) { \/\/ run to state\n        (Z(args(1)), Z(args(2))) match {\n          case (Some(hpNum), Some(slotNum)) => return RunToState(hpNum, slotNum)\n          case _ => return Unsupported()\n        }\n      } else {\n        return Unsupported()\n      }\n    } else {\n      return Unsupported()\n    }\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/CliInfoProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art.BridgeId\nimport art.scheduling.static.Schedule.DScheduleSpec\n\nobject CliInfoProvider {\n\n  \/\/ prototyping APIs that any HAMR debugging interface should support\n  def message(m: String): Unit = {\n    StaticSchedulerIO.message(m)\n  }\n\n  def printHelpMessage(): Unit = {\n    println(\"s <n?>     - step n slots (default 0)\")\n    println(\"h <n?>     - step n hyper-periods (default 0)\")\n    println(\"rs <n>     - run to slot n (wrap to next hyper-period if needed)\")\n    println(\"rs <h> <n> - run to state hyperperiod h and slot n (do nothing if past this state)\")\n    println(\"rh <n>     - run to hyper-period n (do nothing if already past the beginning of hyper-period n)\")\n    println(\"rt <name>  - run to slot containing thread with nickname <name>\")\n    println(\"i st       - show current state\")\n    println(\"i sc       - show schedule and current position\")\n    println(\"i out      - show output port values of most recently run thread\")\n    println(\"i in       - show input  port values of next thread to run\")\n    println(\"i cp <nickname> - show port values of component with given nickname\")\n    println(\"i nn       - show thread nicknames\")\n    println(\"x          - exit\")\n    println()\n  }\n\n  def formatState(scheduleState: Explorer.ScheduleState, domain: Z, bridgeId: BridgeId, threadNickName: String): String = {\n    \/\/ val outString = \"STATE: slot#: \" + scheduleState.slotNum.toString + \" ; HP#: \" + scheduleState.hyperperiodNum.toString\n    return s\"STATE: HP#: ${scheduleState.hyperperiodNum} slot#: ${scheduleState.slotNum} domain: $domain  thread: $threadNickName ($bridgeId)\"\n  }\n\n  def formatStateH(scheduleState: Explorer.ScheduleState): String = {\n    val domain = Schedule.getDomainFromScheduleState(scheduleState)\n    val bridgeId = Schedule.getBridgeIdFromScheduleState(scheduleState)\n    val threadNickName = Schedule.getThreadNickNameFromScheduleState(scheduleState)\n    return formatState(scheduleState, domain, bridgeId, threadNickName)\n  }\n\n  \/\/ The \"show\" methods below need to be refactored to better support MVC\n\n  def showNickNames(): Unit = {\n    message(\" Thread Nicknames\")\n    message(\"-------------------\")\n    for (e <- StaticScheduler.threadNickNames.keys) {\n      message(e)\n    }\n  }\n\n  def showState(scheduleState: Explorer.ScheduleState, domain: Z, bridgeId: BridgeId, threadNickName: String): Unit = {\n    message(formatState(scheduleState, domain, bridgeId, threadNickName))\n  }\n\n  def showStateH(scheduleState: Explorer.ScheduleState): Unit = {\n    message(formatStateH(scheduleState))\n  }\n\n  def showSchedule(scheduleState: Explorer.ScheduleState, dScheduleSpec: Schedule.DScheduleSpec): Unit = {\n    val slots = dScheduleSpec.schedule.slots\n    val hyperPeriodLength = dScheduleSpec.hyperPeriod\n    val hyperPeriodNum = scheduleState.hyperperiodNum\n    val stateSlotNum = scheduleState.slotNum\n    message(s\" Schedule ($hyperPeriodLength tot ticks) HP#: $hyperPeriodNum\")\n    message(\"-------------------------------------------------\")\n    var slotNum: Z = 0\n    for (s <- slots) {\n      var prefix: String = \"  \"\n      var suffix: String = \"\"\n      if (slotNum == stateSlotNum) {\n        val (elaspedHPTicks, remainingHPTicks) = Schedule.computeElaspedRemainingHPTicks(slotNum, dScheduleSpec)\n        prefix = \" *\"\n        suffix = s\"(elapsed= $elaspedHPTicks, remaining=$remainingHPTicks)\"\n      }\n      message(s\"${prefix}$slotNum [domain=${s.domain},length=${s.length}] $suffix\")\n      slotNum = slotNum + 1\n    }\n    message(\"-------------------------------------------------\")\n  }\n\n  def showStep(preScheduleState: Explorer.ScheduleState,\n               postScheduleState: Explorer.ScheduleState,\n               dScheduleSpec: DScheduleSpec): Unit = {\n    val slotNum = preScheduleState.slotNum\n    val slot = dScheduleSpec.schedule.slots(slotNum)\n    val domain = slot.domain\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(slotNum)\n    val length = slot.length\n    message(\"============= S t e p =============\")\n    message(s\"PRE-${formatState(preScheduleState, Schedule.getDomainFromScheduleState(preScheduleState), Schedule.getBridgeIdFromScheduleState(preScheduleState), Schedule.getThreadNickNameFromScheduleState(preScheduleState))}\")\n    message(s\"   Executing:  Domain#: $domain   Max Duration: $length\")\n    message(s\"POST-${formatState(postScheduleState, Schedule.getDomainFromScheduleState(postScheduleState), Schedule.getBridgeIdFromScheduleState(postScheduleState), Schedule.getThreadNickNameFromScheduleState(postScheduleState))}\")\n  }\n\n  def showHyperPeriodBoundary(scheduleState: Explorer.ScheduleState): Unit = {\n    message(s\"********* Hyper-Period ${scheduleState.hyperperiodNum} (beginning) **********\")\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/Command.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\n\n@msig trait CommandProvider {\n  def nextCommand(): Command\n}\n\n@msig trait InfoCommandProvider extends CommandProvider {\n  def threadNickNames: Map[String, art.Art.BridgeId]\n  def numSlots: Z\n  def displayOrder: ISZ[art.Art.BridgeId]\n\n  def init(threadNickNames: Map[String, art.Art.BridgeId], numSlots: Z, displayOrder: ISZ[art.Art.BridgeId]): CommandProvider\n}\n\n@datatype trait Command\n\n@datatype class Unrecognized extends Command\n\n@datatype class Unsupported extends Command\n\n\/\/ end debugging session\n@datatype class Stop extends Command\n\n\/\/ display support commands\n@datatype class Help extends Command\n\n\/\/ step numSteps of slots\n@datatype class Sstep(numSteps: Z) extends Command\n\n\/\/ step numSteps of hyper-periods\n@datatype class Hstep(numSteps: Z) extends Command\n\n\/\/ run to hp#\n@datatype class RunToHP(hpNum: Z) extends Command\n\n\/\/ run to scheduler state (hp#,slot#)\n@datatype class RunToState(hpNum: Z, slotNum: Z) extends Command\n\n\/\/ run to domain\n@datatype class RunToDomain(domainId: Z) extends Command\n\n\/\/ run to thread\n@datatype class RunToSlot(slotNum: Z) extends Command\n\n\/\/ run to thread\n@datatype class RunToThread(ThreadId: String) extends Command\n\n\/\/ get info current state (hyper-period number, slot number)\n@datatype class Infostate extends Command\n\n\/\/ get info of domain schedule with next slot to be executed marked\n@datatype class Infoschedule extends Command\n\n\/\/ get values of input ports of component to be executed in the next slot\n@datatype class InfoInputs extends Command\n\n\/\/ get values of output ports of component that was executed in the previous slot\n@datatype class InfoOutputs extends Command\n\n\/\/ get values of input and outputs ports for the given component the last time that it was executed\n@datatype class InfoComponentStateId(bridgeId: Z) extends Command\n\n@datatype class InfoComponentState(threadNickName: String) extends Command\n\n\/\/ show thread nicknames\n@datatype class InfoThreadNickNames extends Command\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/CommandInterpreter.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art.BridgeId\n\nobject CommandInterpreter {\n\n  def message(str: String): Unit = {\n    CliInfoProvider.message(str)\n  }\n\n  def interpretCmd(cmd: Command): B = {\n    var done: B = false\n    cmd match {\n      case _: Help =>\n        CliInfoProvider.printHelpMessage()\n\n      case Sstep(n) =>\n        assert(n >= 1)\n        message(s\"...Stepping $n slot(s)\")\n        Explorer.stepSystemNSlotsIMP(n)\n\n      case Hstep(n) =>\n        assert(n >= 1)\n        message(s\"...Stepping $n hyper-period(s)\")\n        if (n == 1) {\n          Explorer.stepSystemOneHPIMP()\n        } else if (Explorer.isHyperPeriodBoundaryH()) {\n          Explorer.stepSystemNHPIMP(n)\n        } else {\n          message(\"Command not applicable: not on hyper-period boundary\")\n        }\n\n      case RunToHP(hpNum) =>\n        assert(hpNum >= 0 & hpNum <= 1000)\n        Explorer.runToHP(hpNum)\n\n      case RunToSlot(slotNum) =>\n        assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n        message(s\"...Running to slot# $slotNum\")\n        Explorer.runToSlot(slotNum)\n\n      case RunToThread(threadNickName) =>\n        Explorer.runToThread(threadNickName)\n\n      case RunToState(hpNum, slotNum) =>\n        assert(hpNum >= 0 & hpNum <= 1000)\n        assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n        Explorer.runToState(hpNum, slotNum)\n\n      case RunToDomain(domainId) =>\n        assert(0 <= domainId & domainId <= Schedule.dScheduleSpec.maxDomain)\n        Explorer.runToDomain(domainId)\n\n      case _: Stop => done = T\n\n      case _: Infostate =>\n        val s = Explorer.scheduleState\n        CliInfoProvider.showState(s, Schedule.getDomainFromScheduleState(s), Schedule.getBridgeIdFromScheduleState(s), Schedule.threadNickName(Schedule.getBridgeIdFromScheduleState(s)))\n\n      case _: Infoschedule =>\n        CliInfoProvider.showSchedule(Explorer.scheduleState, Schedule.dScheduleSpec)\n\n      case _: InfoInputs =>\n        StateObserver.printPortContentsInputsCurrent()\n\n      case _: InfoOutputs =>\n        StateObserver.printPortContentsOutputsCurrent()\n\n      case InfoComponentStateId(bridgId) =>\n        StateObserver.printPortContents(BridgeId.fromZ(bridgId))\n\n      case InfoComponentState(threadNickName) =>\n        StateObserver.printPortContentsByNickName(threadNickName)\n\n      case _: InfoThreadNickNames =>\n        CliInfoProvider.showNickNames()\n\n      case _: Unrecognized => message(\"Unrecognized command\")\n\n      case _: Unsupported => message(\"Unsupported command\")\n\n      case _ =>\n    }\n    return done\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/DefaultCommandProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\n\n@record class DefaultCommandProvider extends CommandProvider {\n  override def nextCommand(): Command = {\n    return Hstep(1)\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec): B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  def isHyperPeriodBoundaryH(): B = {\n    return isHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState: ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    return ScheduleState(0, 0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    val domainId: Z = slot.domain\n    val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId)\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if (ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId.toZ).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState, dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum, nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState, dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1 \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) { \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1 \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum, nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP(): Unit = {\n    scheduleState = nextState(scheduleState, dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      CliInfoProvider.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots: Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP: Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n\n    CliInfoProvider.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods: Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum: Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    CliInfoProvider.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n\n    CliInfoProvider.message(\"*********** Run to ... Completed *************\")\n\n    CliInfoProvider.showStateH(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum: Z, slotNum: Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n\n    CliInfoProvider.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n\n    CliInfoProvider.message(\"*********** Run to ... Completed *************\")\n\n    CliInfoProvider.showStateH(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum: Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n\n    CliInfoProvider.message(\"*********** Run to ... Completed *************\")\n\n    CliInfoProvider.showStateH(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId: Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    CliInfoProvider.message(s\"...Running to domain $domainId\")\n\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n\n    CliInfoProvider.message(\"*********** Run to ... Completed *************\")\n\n    CliInfoProvider.showStateH(scheduleState)\n  }\n\n\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = StaticScheduler.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = StaticScheduler.bridgeIdToDomainMap(bridgeId)\n\n    CliInfoProvider.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    CliInfoProvider.message(\"*********** Run to ... Completed *************\")\n\n    CliInfoProvider.showStateH(scheduleState)\n  }\n\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    CliInfoProvider.message (s\"...Running system according to static schedule\")\n\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/ISZCommandProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\n\n@record class ISZCommandProvider(commands: ISZ[Command]) extends CommandProvider {\n\n  var index: Z = 0\n\n  override def nextCommand(): Command = {\n    assert(commands.nonEmpty, \"commands must be non-empty\")\n    assert(index >= 0 && index < commands.size, s\"index must be >= 0 and < ${commands.size}\")\n\n    if (index == commands.size - 1 && !commands(index).isInstanceOf[Stop]) {\n      assert(F, \"Last command must be Stop\")\n      halt(\"Last command must be Stop\")\n    }\n    index = index + 1\n    return commands(index - 1)\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.static.Explorer.ScheduleState\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(domain: Z, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def setSchedule(spec: DScheduleSpec,\n                  domainsToBridgeMap: ISZ[Art.BridgeId]): Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = domainsToBridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Art.BridgeId = {\n    return domainToBridgeIdMap(slot.domain)\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Art.BridgeId = {\n    return getBridgeIdFromSlot(dScheduleSpec.schedule.slots(slotNum))\n  }\n\n  def getBridgeIdFromScheduleState(scheduleState: ScheduleState): Art.BridgeId = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  def getDomainFromSlotNum(slotNum: Z): Z = {\n    return dScheduleSpec.schedule.slots(slotNum).domain\n  }\n\n  def getDomainFromScheduleState(scheduleState: Explorer.ScheduleState): Z = {\n    return getDomainFromSlotNum(scheduleState.slotNum)\n  }\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    for (e <- StaticScheduler.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n  }\n\n  def getThreadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState): String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    return checkMaxDomain(dScheduleSpec) &&\n      checkNoMissingDomain(dScheduleSpec) &&\n      checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    \/\/ Note: transpiler doesn't current support function passing\n    \/\/return All(dScheduleSpec.schedule.slots)(s => s.domain <= dScheduleSpec.maxDomain)\n    for (s <- dScheduleSpec.schedule.slots if s.domain > dScheduleSpec.maxDomain) {\n      return F\n    }\n    return T\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    \/\/ NOTE: transpiler doesn't currently support function passing\n    \/\/return All(0 until dScheduleSpec.maxDomain)(d =>\n    \/\/  Exists(dScheduleSpec.schedule.slots)(s => s.domain == d)\n    \/\/)\n    for (d <- 0 until dScheduleSpec.maxDomain) {\n      var exists: B = F\n      for (s <- dScheduleSpec.schedule.slots if !exists) {\n        exists = exists || s.domain == d\n      }\n      if (!exists) {\n        return F\n      }\n    }\n    return T\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec): (Z, Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks, remainingHPTicks)\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent}\n\nobject StateObserver {\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    return Art.observeInInfrastructurePort(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    return Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String, Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId.toZ).get\n    var portValues: ISZ[(String, Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInInfrastructurePort(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInInfrastructurePort(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String, Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId.toZ).get\n    var portValues: ISZ[(String, Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String, Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String, Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def printPortContentsInputsCurrent(): Unit = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n\n    println(\"****************************\")\n    println(s\"   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\")\n    println(\"****************************\")\n    println(\" Input Ports\")\n    println(\" ===============\")\n    printPortInfo(inPortInfo)\n  }\n\n  def printPortContentsOutputsCurrent(): Unit = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState, Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        println(\"****************************\")\n        println(s\"   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\")\n        println(\"****************************\")\n        println(\" Output Ports\")\n        println(\" ===============\")\n        printPortInfo(outPortInfo)\n      }\n      case None() => {\n        println(\"(initial state - no previous state to show)\")\n      }\n    }\n  }\n\n  def printPortInfo(portVals: ISZ[(String, Option[DataContent])]): Unit = {\n    for (e <- portVals) {\n      println(s\"${e._1} = ${e._2}\")\n    }\n  }\n\n  def printPortContents(bridgeId: Art.BridgeId): Unit = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    println(\"****************************\")\n    println(s\"   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\")\n    println(\"****************************\")\n    println(\" Input Ports\")\n    println(\" ===============\")\n    printPortInfo(inPortInfo)\n    println()\n    println(\" Output Ports\")\n    println(\" ================\")\n    printPortInfo(outPortInfo)\n  }\n\n  def printPortContentsByNickName(threadNickName: String): Unit = {\n    val bridgeId = StaticScheduler.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    printPortContents(bridgeId)\n  }\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\nobject StaticScheduler {\n  var threadNickNames: Map[String, Art.BridgeId] = Map.empty\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def bridgeIdToDomainMap(bridgeId: Art.BridgeId): Z = {\n    for (i <- 0 until domainToBridgeIdMap.size if bridgeId == domainToBridgeIdMap(i)) {\n      return i\n    }\n    assert(F, s\"domain for $bridgeId not found\")\n    halt(s\"domain for $bridgeId not found\")\n  }\n}\n\n@record class StaticScheduler(staticSchedule: DScheduleSpec,\n                              bridges: IS[Art.BridgeId, art.Bridge],\n                              domainToBridgeIdMap: ISZ[Art.BridgeId],\n                              threadNickNames: Map[String, Art.BridgeId],\n                              commandProvider: CommandProvider) extends Scheduler {\n\n  override def initialize(): Unit = {\n    StaticScheduler.threadNickNames = threadNickNames\n    StaticScheduler.domainToBridgeIdMap = domainToBridgeIdMap\n\n    Schedule.setSchedule(staticSchedule, domainToBridgeIdMap)\n\n    Explorer.initializeScheduleStateIMP()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridgeId <- domainToBridgeIdMap) {\n      bridges(bridgeId).entryPoints.initialise()\n      art.Art.logInfo(bridgeId, s\"Initialized bridge: ${bridges(bridgeId).name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    var done: B = F\n    while (!done) {\n      done = CommandInterpreter.interpretCmd(commandProvider.nextCommand())\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridgeId <- domainToBridgeIdMap) {\n      bridges(bridgeId).entryPoints.finalise()\n      art.Art.logInfo(bridgeId, s\"Finalized bridge: ${bridges(bridgeId).name}\")\n    }\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StaticSchedulerIO.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\n\n@ext object StaticSchedulerIO {\n  def getCommand(prompt: String): String = $\n\n  def message(m: String): Unit = $\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/art\/art\/scheduling\/static\/StaticSchedulerIO_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.static\n\nimport org.sireum._\n\nimport scala.io.StdIn.readLine\n\nobject StaticSchedulerIO_Ext {\n  var logStream: java.io.PrintStream = System.out\n\n  def getCommand(prompt: String): String = {\n    print(prompt)\n    val command = readLine()\n    return command\n  }\n\n  def message(m: String): Unit = {\n    logStream.println(m)\n    logStream.flush()\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "slang\/src\/main\/data\/uav_june_step6__SeL4\/Aux_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__SeL4\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ Any datatype definitions placed in this file will be processed by sergen and SlangCheck\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : true
        }
      ],
      [
        "slang\/bin\/sergen.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\nval sireum = Os.path(Os.env(\"SIREUM_HOME\").get) \/ \"bin\" \/ (if (Os.isWin) \"sireum.bat\" else \"sireum\")\r\n\r\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\r\n\r\n\/\/ create serializers\/deserializers for the Slang types used in the project\r\n\r\nval files: ISZ[String] = ISZ(\"..\/src\/main\/data\/uav_june_step6__SeL4\/Base_Types.scala\",\r\n                             \"..\/src\/main\/art\/art\/DataContent.scala\",\r\n                             \"..\/src\/main\/data\/uav_june_step6__SeL4\/Aux_Types.scala\")\r\n\r\nval toolargs: String = st\"${(files, \" \")}\".render\r\n\r\n(Os.slashDir.up \/ \"src\" \/ \"main\" \/ \"util\" \/ \"uav_june_step6__SeL4\").mkdirAll()\r\n\r\nproc\"$sireum tools sergen -p uav_june_step6__SeL4 -m json,msgpack -o ${Os.slashDir.up}\/src\/main\/util\/uav_june_step6__SeL4 $toolargs\".at(Os.slashDir).console.runCheck()\r\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "isDatatype" : false
        }
      ],
      [
        "slang\/bin\/slangcheck.cmd",
        {
          "type" : "ITestResource",
          "content" : "::\/*#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF           #\r\nif [ -z ${SIREUM_HOME} ]; then                        #\r\n  echo \"Please set SIREUM_HOME env var\"               #\r\n  exit -1                                             #\r\nfi                                                    #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"    #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#*\/\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\nval sireum = Os.path(Os.env(\"SIREUM_HOME\").get) \/ \"bin\" \/ (if (Os.isWin) \"sireum.bat\" else \"sireum\")\r\n\r\n\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\r\n\r\n\/\/ create SlangCheck artifacts for the Slang types used in the project\r\n\r\nval files: ISZ[String] = ISZ(\"..\/src\/main\/data\/uav_june_step6__SeL4\/Base_Types.scala\",\r\n                             \"..\/src\/main\/art\/art\/DataContent.scala\",\r\n                             \"..\/src\/main\/data\/uav_june_step6__SeL4\/Aux_Types.scala\")\r\n\r\nval toolargs: String = st\"${(files, \" \")}\".render\r\n\r\n(Os.slashDir.up \/ \"src\" \/ \"main\" \/ \"util\" \/ \"uav_june_step6__SeL4\").mkdirAll()\r\n\r\nproc\"$sireum proyek slangcheck -p uav_june_step6__SeL4 -o ${Os.slashDir.up}\/src\/main\/util\/uav_june_step6__SeL4 ${Os.slashDir.up} $toolargs\".at(Os.slashDir).console.runCheck()\r\n\r\n\/\/ call to the tools version of SlangCheck which does not invoke Tipe\r\n\/\/proc\"$sireum tools slangcheck generator -p uav_june_step6__SeL4 -o ${Os.slashDir.up}\/src\/main\/util\/uav_june_step6__SeL4 $toolargs\".at(Os.slashDir).console.runCheck()\r\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.camkes",
        {
          "type" : "ITestResource",
          "content" : "component UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_AirVehicleState_WPM_1_notification;\n  emits ReceiveEvent sb_AirVehicleState_UXAS_1_notification;\n  consumes ReceiveEvent sb_MissionCommand_notification;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_MissionCommand_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AirVehicleState_WPM_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AirVehicleState_UXAS_queue_1;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO\/VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO.camkes",
        {
          "type" : "ITestResource",
          "content" : "component VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO {\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_queue_int8_t_1.h>;\n  control;\n  provides VMDTBPassthrough dtb;\n  uses FileServerInterface fs;\n  maybe uses Batch batch;\n  maybe uses PutChar guest_putchar;\n  maybe uses GetChar serial_getchar;\n  maybe uses VirtQueueDev recv;\n  maybe uses VirtQueueDrv send;\n  maybe uses VMDTBPassthrough dtb_self;\n  emits HaveNotification notification_ready_connector;\n  emits ReceiveEvent sb_trusted_ids_1_notification;\n  emits ReceiveEvent sb_AutomationRequest_1_notification;\n  emits ReceiveEvent sb_OperatingRegion_1_notification;\n  emits ReceiveEvent sb_LineSearchTask_1_notification;\n  maybe consumes restart restart_event;\n  consumes HaveNotification notification_ready;\n  consumes Period_VM sb_pacer_period_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_trusted_ids_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationRequest_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_OperatingRegion_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_LineSearchTask_queue_1;\n  dataport sb_queue_int8_t_1_t sb_pacer_period_queue;\n  has semaphore vm_sem;\n  \/\/ expanding attributes in VM_INIT_DEF()\n  \/\/ https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L70-111\n  attribute int base_prio;\n  attribute int num_vcpus = 1;\n  attribute int num_extra_frame_caps;\n  attribute int extra_frame_map_address;\n  attribute {\n    string ram_base;\n    string ram_paddr_base;\n    string ram_size;\n    string dtb_addr;\n    string initrd_addr;\n    string kernel_entry_addr = \"-1\";\n  } vm_address_config;\n  attribute {\n    string kernel_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string kernel_bootcmdline = \"\";\n    string kernel_stdout = \"\";\n    string dtb_base_name = \"\";\n    int provide_dtb = true;\n    int generate_dtb = false;\n    int provide_initrd = true;\n    int clean_cache = false;\n    int map_one_to_one = false;\n  } vm_image_config;\n  attribute {\n    string linux_ram_base;\n    string linux_ram_paddr_base;\n    string linux_ram_size;\n    string linux_ram_offset = \"0\"; \/* obsolete *\/\n    string dtb_addr;\n    string initrd_max_size = \"-1\"; \/* obsolete *\/\n    string initrd_addr;\n  } linux_address_config;\n  attribute {\n    string linux_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string linux_bootcmdline = \"\";\n    string linux_stdout = \"\";\n    string dtb_base_name = \"\";\n  } linux_image_config;\n  attribute {\n    int send_id;\n    int recv_id;\n  } serial_layout[] = [];\n  \/\/ end of attribute expansion in VM_INIT_DEF()\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.camkes",
        {
          "type" : "ITestResource",
          "content" : "component FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  consumes Period sb_pacer_notification;\n  dataport sp_union_art_DataContent_t sb_keep_in_zones;\n  dataport sp_union_art_DataContent_t sb_keep_out_zones;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM_UxAS_Impl_MCMP_PROC_SW_UXAS\/VM_UxAS_Impl_MCMP_PROC_SW_UXAS.camkes",
        {
          "type" : "ITestResource",
          "content" : "component VM_UxAS_Impl_MCMP_PROC_SW_UXAS {\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_queue_int8_t_1.h>;\n  control;\n  provides VMDTBPassthrough dtb;\n  uses FileServerInterface fs;\n  maybe uses Batch batch;\n  maybe uses PutChar guest_putchar;\n  maybe uses GetChar serial_getchar;\n  maybe uses VirtQueueDev recv;\n  maybe uses VirtQueueDrv send;\n  maybe uses VMDTBPassthrough dtb_self;\n  emits HaveNotification notification_ready_connector;\n  emits ReceiveEvent sb_AutomationResponse_MON_GEO_1_notification;\n  emits ReceiveEvent sb_AutomationResponse_MON_REQ_1_notification;\n  maybe consumes restart restart_event;\n  consumes HaveNotification notification_ready;\n  consumes ReceiveEvent sb_AirVehicleState_notification;\n  consumes ReceiveEvent sb_AutomationRequest_notification;\n  consumes ReceiveEvent sb_OperatingRegion_notification;\n  consumes ReceiveEvent sb_LineSearchTask_notification;\n  consumes Period_VM sb_pacer_period_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_AirVehicleState_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationResponse_MON_GEO_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationResponse_MON_REQ_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationRequest_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_OperatingRegion_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_LineSearchTask_queue;\n  dataport sb_queue_int8_t_1_t sb_pacer_period_queue;\n  has semaphore vm_sem;\n  \/\/ expanding attributes in VM_INIT_DEF()\n  \/\/ https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L70-111\n  attribute int base_prio;\n  attribute int num_vcpus = 1;\n  attribute int num_extra_frame_caps;\n  attribute int extra_frame_map_address;\n  attribute {\n    string ram_base;\n    string ram_paddr_base;\n    string ram_size;\n    string dtb_addr;\n    string initrd_addr;\n    string kernel_entry_addr = \"-1\";\n  } vm_address_config;\n  attribute {\n    string kernel_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string kernel_bootcmdline = \"\";\n    string kernel_stdout = \"\";\n    string dtb_base_name = \"\";\n    int provide_dtb = true;\n    int generate_dtb = false;\n    int provide_initrd = true;\n    int clean_cache = false;\n    int map_one_to_one = false;\n  } vm_image_config;\n  attribute {\n    string linux_ram_base;\n    string linux_ram_paddr_base;\n    string linux_ram_size;\n    string linux_ram_offset = \"0\"; \/* obsolete *\/\n    string dtb_addr;\n    string initrd_max_size = \"-1\"; \/* obsolete *\/\n    string initrd_addr;\n  } linux_address_config;\n  attribute {\n    string linux_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string linux_bootcmdline = \"\";\n    string linux_stdout = \"\";\n    string dtb_base_name = \"\";\n  } linux_image_config;\n  attribute {\n    int send_id;\n    int recv_id;\n  } serial_layout[] = [];\n  \/\/ end of attribute expansion in VM_INIT_DEF()\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.camkes",
        {
          "type" : "ITestResource",
          "content" : "component WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_MissionCommand_1_notification;\n  consumes ReceiveEvent sb_AutomationResponse_notification;\n  consumes ReceiveEvent sb_AirVehicleState_notification;\n  consumes ReceiveEvent sb_ReturnHome;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationResponse_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AirVehicleState_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_MissionCommand_queue_1;\n  dataport sb_event_counter_t sb_ReturnHome_counter;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.camkes",
        {
          "type" : "ITestResource",
          "content" : "component CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_AutomationRequest_out_UXAS_1_notification;\n  emits ReceiveEvent sb_AutomationRequest_out_MON_REQ_1_notification;\n  emits ReceiveEvent sb_OperatingRegion_out_1_notification;\n  emits ReceiveEvent sb_LineSearchTask_out_1_notification;\n  consumes ReceiveEvent sb_trusted_ids_notification;\n  consumes ReceiveEvent sb_AutomationRequest_in_notification;\n  consumes ReceiveEvent sb_OperatingRegion_in_notification;\n  consumes ReceiveEvent sb_LineSearchTask_in_notification;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_trusted_ids_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationRequest_in_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationRequest_out_UXAS_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AutomationRequest_out_MON_REQ_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_OperatingRegion_in_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_OperatingRegion_out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_LineSearchTask_in_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_LineSearchTask_out_queue_1;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.camkes",
        {
          "type" : "ITestResource",
          "content" : "component CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_filter_out_1_notification;\n  consumes ReceiveEvent sb_filter_in_notification;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_filter_in_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_filter_out_queue_1;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.camkes",
        {
          "type" : "ITestResource",
          "content" : "component CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  consumes ReceiveEvent sb_observed_notification;\n  consumes ReceiveEvent sb_reference_1_notification;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_observed_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_reference_1_queue;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.camkes",
        {
          "type" : "ITestResource",
          "content" : "component CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_output_1_notification;\n  emits ReceiveEvent sb_alert;\n  consumes ReceiveEvent sb_observed_notification;\n  consumes Period sb_pacer_notification;\n  dataport sp_union_art_DataContent_t sb_keep_in_zones;\n  dataport sp_union_art_DataContent_t sb_keep_out_zones;\n  dataport sb_queue_union_art_DataContent_1_t sb_observed_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_output_queue_1;\n  dataport sb_event_counter_t sb_alert_counter;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/Pacer\/Pacer.camkes",
        {
          "type" : "ITestResource",
          "content" : "component Pacer {\n  include <sb_queue_int8_t_1.h>;\n  control;\n  emits Period_VM period_to_vmRADIO_notification;\n  emits Period_VM period_to_vmUXAS_notification;\n  emits Period period;\n  emits TickTock tick;\n  consumes TickTock tock;\n  dataport sb_queue_int8_t_1_t period_to_vmRADIO_queue;\n  dataport sb_queue_int8_t_1_t period_to_vmUXAS_queue;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/UAV_Impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\nimport <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <seL4VMDTBPassthrough.idl4>;\nimport <FileServerInterface.camkes>;\nimport <FileServer\/FileServer.camkes>;\nimport <SerialServer\/SerialServer.camkes>;\nimport <TimeServer\/TimeServer.camkes>;\nimport <vm-connectors.camkes>;\nimport <devices.camkes>;\nimport \"components\/Pacer\/Pacer.camkes\";\nimport \"components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.camkes\";\nimport \"components\/VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO\/VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO.camkes\";\nimport \"components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.camkes\";\nimport \"components\/VM_UxAS_Impl_MCMP_PROC_SW_UXAS\/VM_UxAS_Impl_MCMP_PROC_SW_UXAS.camkes\";\nimport \"components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.camkes\";\nimport \"components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.camkes\";\nimport \"components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.camkes\";\nimport \"components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.camkes\";\nimport \"components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.camkes\";\n\nassembly {\n  composition {\n    component UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver MCMP_PROC_SW_FC_UART_UARTDriver;\n    component VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO vmRADIO;\n    component FileServer fserv; \/\/ expansion of macro VM_GENERAL_COMPOSITION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L124\n\n    \/\/ expansion of macro VM_VIRTUAL_SERIAL_COMPONENTS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L147\n    component SerialServer serial;\n    component TimeServer time_server;\n\n    component FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase MCMP_PROC_SW_FlyZones_FlyZonesDatabase;\n    component VM_UxAS_Impl_MCMP_PROC_SW_UXAS vmUXAS;\n    component WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService MCMP_PROC_SW_WPM_WaypointPlanManagerService;\n    component CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate MCMP_PROC_SW_AM_Gate_CASE_AttestationGate;\n    component CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST MCMP_PROC_SW_FLT_LST_CASE_Filter_LST;\n    component CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req;\n    component CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo;\n    component Pacer pacer;\n\n    \/\/ expansion of macro VM_COMPONENT_CONNECTIONS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L117\n    connection seL4RPCDataport conn1(from vmRADIO.fs, to fserv.fs_ctrl);\n    connection seL4GlobalAsynch conn2(from vmRADIO.notification_ready_connector, to vmRADIO.notification_ready);\n\n    connection seL4VMDTBPassthrough conn3(from vmRADIO.dtb_self, to vmRADIO.dtb);\n\n    \/\/ expansion of macro VM_VIRTUAL_SERIAL_COMPONENTS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L149\n    connection seL4TimeServer conn4(from serial.timeout, to time_server.the_timer);\n\n    \/\/ expansion of macro PER_VM_VIRTUAL_SERIAL_CONNECTIONS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L151\n    connection seL4SerialServer conn5(from vmRADIO.batch, to serial.processed_batch);\n    connection seL4SerialServer conn6(from vmRADIO.serial_getchar, to serial.getchar);\n\n    \/\/ expansion of macro VM_COMPONENT_CONNECTIONS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L117\n    connection seL4RPCDataport conn7(from vmUXAS.fs, to fserv.fs_ctrl);\n    connection seL4GlobalAsynch conn8(from vmUXAS.notification_ready_connector, to vmUXAS.notification_ready);\n\n    connection seL4VMDTBPassthrough conn9(from vmUXAS.dtb_self, to vmUXAS.dtb);\n    \/\/ expansion of macro PER_VM_VIRTUAL_SERIAL_CONNECTIONS_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L151\n    connection seL4SerialServer conn10(from vmUXAS.batch, to serial.processed_batch);\n    connection seL4SerialServer conn11(from vmUXAS.serial_getchar, to serial.getchar);\n\n    connection seL4Notification conn12(from MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_WPM_1_notification, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AirVehicleState_notification);\n    connection seL4SharedData conn13(from MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_WPM_queue_1, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AirVehicleState_queue);\n    connection seL4GlobalAsynch conn14(from MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_UXAS_1_notification, to vmUXAS.sb_AirVehicleState_notification);\n    connection seL4SharedDataWithCaps conn15(from MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_UXAS_queue_1, to vmUXAS.sb_AirVehicleState_queue);\n    connection seL4Notification conn16(from vmRADIO.sb_trusted_ids_1_notification, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_trusted_ids_notification);\n    connection seL4SharedDataWithCaps conn17(from vmRADIO.sb_trusted_ids_queue_1, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_trusted_ids_queue);\n    connection seL4Notification conn18(from vmRADIO.sb_AutomationRequest_1_notification, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_in_notification);\n    connection seL4SharedDataWithCaps conn19(from vmRADIO.sb_AutomationRequest_queue_1, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_in_queue);\n    connection seL4Notification conn20(from vmRADIO.sb_OperatingRegion_1_notification, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_in_notification);\n    connection seL4SharedDataWithCaps conn21(from vmRADIO.sb_OperatingRegion_queue_1, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_in_queue);\n    connection seL4Notification conn22(from vmRADIO.sb_LineSearchTask_1_notification, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_in_notification);\n    connection seL4SharedDataWithCaps conn23(from vmRADIO.sb_LineSearchTask_queue_1, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_in_queue);\n    connection seL4SharedData conn24(from MCMP_PROC_SW_FlyZones_FlyZonesDatabase.sb_keep_in_zones, to MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_keep_in_zones);\n    connection seL4SharedData conn25(from MCMP_PROC_SW_FlyZones_FlyZonesDatabase.sb_keep_out_zones, to MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_keep_out_zones);\n    connection seL4Notification conn26(from vmUXAS.sb_AutomationResponse_MON_GEO_1_notification, to MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_observed_notification);\n    connection seL4SharedDataWithCaps conn27(from vmUXAS.sb_AutomationResponse_MON_GEO_queue_1, to MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_observed_queue);\n    connection seL4Notification conn28(from vmUXAS.sb_AutomationResponse_MON_REQ_1_notification, to MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_observed_notification);\n    connection seL4SharedDataWithCaps conn29(from vmUXAS.sb_AutomationResponse_MON_REQ_queue_1, to MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_observed_queue);\n    connection seL4Notification conn30(from MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_MissionCommand_1_notification, to MCMP_PROC_SW_FC_UART_UARTDriver.sb_MissionCommand_notification);\n    connection seL4SharedData conn31(from MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_MissionCommand_queue_1, to MCMP_PROC_SW_FC_UART_UARTDriver.sb_MissionCommand_queue);\n    connection seL4GlobalAsynch conn32(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_UXAS_1_notification, to vmUXAS.sb_AutomationRequest_notification);\n    connection seL4SharedDataWithCaps conn33(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_UXAS_queue_1, to vmUXAS.sb_AutomationRequest_queue);\n    connection seL4Notification conn34(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_MON_REQ_1_notification, to MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_reference_1_notification);\n    connection seL4SharedData conn35(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_MON_REQ_queue_1, to MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_reference_1_queue);\n    connection seL4GlobalAsynch conn36(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_out_1_notification, to vmUXAS.sb_OperatingRegion_notification);\n    connection seL4SharedDataWithCaps conn37(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_out_queue_1, to vmUXAS.sb_OperatingRegion_queue);\n    connection seL4Notification conn38(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_out_1_notification, to MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_in_notification);\n    connection seL4SharedData conn39(from MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_out_queue_1, to MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_in_queue);\n    connection seL4GlobalAsynch conn40(from MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_out_1_notification, to vmUXAS.sb_LineSearchTask_notification);\n    connection seL4SharedDataWithCaps conn41(from MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_out_queue_1, to vmUXAS.sb_LineSearchTask_queue);\n    connection seL4Notification conn42(from MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_output_1_notification, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AutomationResponse_notification);\n    connection seL4SharedData conn43(from MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_output_queue_1, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AutomationResponse_queue);\n    connection seL4Notification conn44(from MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_alert, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_ReturnHome);\n    connection seL4SharedData conn45(from MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_alert_counter, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_ReturnHome_counter);\n    connection seL4Notification conn46(from pacer.tick, to pacer.tock);\n    connection seL4Notification conn47(from pacer.period, to MCMP_PROC_SW_FC_UART_UARTDriver.sb_pacer_notification);\n    connection seL4GlobalAsynch conn48(from pacer.period_to_vmRADIO_notification, to vmRADIO.sb_pacer_period_notification);\n    connection seL4SharedDataWithCaps conn49(from pacer.period_to_vmRADIO_queue, to vmRADIO.sb_pacer_period_queue);\n    connection seL4Notification conn50(from pacer.period, to MCMP_PROC_SW_FlyZones_FlyZonesDatabase.sb_pacer_notification);\n    connection seL4GlobalAsynch conn51(from pacer.period_to_vmUXAS_notification, to vmUXAS.sb_pacer_period_notification);\n    connection seL4SharedDataWithCaps conn52(from pacer.period_to_vmUXAS_queue, to vmUXAS.sb_pacer_period_queue);\n    connection seL4Notification conn53(from pacer.period, to MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_pacer_notification);\n    connection seL4Notification conn54(from pacer.period, to MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_pacer_notification);\n    connection seL4Notification conn55(from pacer.period, to MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_pacer_notification);\n    connection seL4Notification conn56(from pacer.period, to MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_pacer_notification);\n    connection seL4Notification conn57(from pacer.period, to MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_pacer_notification);\n  }\n\n  configuration {\n    MCMP_PROC_SW_FC_UART_UARTDriver._stack_size = 524288;\n    MCMP_PROC_SW_FC_UART_UARTDriver._domain = 3;\n\n    \/\/ expansion of macro VM_VIRTUAL_SERIAL_GENERAL_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L155\n    time_server.timers_per_client = 1;\n    time_server.priority = 255;\n    time_server.simple = true;\n\n    vmRADIO.num_extra_frame_caps = 0;\n    vmRADIO.extra_frame_map_address = 0;\n    vmRADIO.cnode_size_bits = 23;\n    vmRADIO.simple_untyped24_pool = 12;\n    fserv.heap_size = 0x30000; \/\/ expansion of macro VM_GENERAL_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L128\n\n    \/\/ expansion of macro VM_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L131\n    vmRADIO.fs_shmem_size = 0x100000;\n    vmRADIO.global_endpoint_base = 1 << 27;\n    vmRADIO.asid_pool = true;\n    vmRADIO.simple = true;\n    vmRADIO.base_prio = 100;\n    vmRADIO._priority = 101;\n    vmRADIO.sem_value = 0;\n    vmRADIO.heap_size = 0x300000;\n\n\n    \/\/ expansion of macro PER_VM_VIRTUAL_SERIAL_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L164\n    vmRADIO.serial_getchar_shmem_size = 0x1000;\n    vmRADIO.batch_shmem_size = 0x1000;\n\n    vmRADIO._stack_size = 524288;\n    vmRADIO._domain = 2;\n    MCMP_PROC_SW_FlyZones_FlyZonesDatabase._stack_size = 524288;\n    MCMP_PROC_SW_FlyZones_FlyZonesDatabase._domain = 10;\n    vmUXAS.num_extra_frame_caps = 0;\n    vmUXAS.extra_frame_map_address = 0;\n    vmUXAS.cnode_size_bits = 23;\n    vmUXAS.simple_untyped24_pool = 12;\n\n    \/\/ expansion of macro VM_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L131\n    vmUXAS.fs_shmem_size = 0x100000;\n    vmUXAS.global_endpoint_base = 1 << 27;\n    vmUXAS.asid_pool = true;\n    vmUXAS.simple = true;\n    vmUXAS.base_prio = 100;\n    vmUXAS._priority = 101;\n    vmUXAS.sem_value = 0;\n    vmUXAS.heap_size = 0x300000;\n\n\n    \/\/ expansion of macro PER_VM_VIRTUAL_SERIAL_CONFIGURATION_DEF. See https:\/\/github.com\/seL4\/camkes-vm\/blob\/64690e8db397f69ece88866e79a9f2942c3c7015\/components\/VM_Arm\/configurations\/vm.h#L164\n    vmUXAS.serial_getchar_shmem_size = 0x1000;\n    vmUXAS.batch_shmem_size = 0x1000;\n\n    vmUXAS._stack_size = 524288;\n    vmUXAS._domain = 9;\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService._stack_size = 524288;\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService._domain = 14;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate._stack_size = 524288;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate._domain = 5;\n    MCMP_PROC_SW_FLT_LST_CASE_Filter_LST._stack_size = 524288;\n    MCMP_PROC_SW_FLT_LST_CASE_Filter_LST._domain = 7;\n    MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req._stack_size = 524288;\n    MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req._domain = 11;\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo._stack_size = 524288;\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo._domain = 13;\n    conn13.size = 262144;\n    MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_WPM_queue_1_access = \"W\";\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AirVehicleState_queue_access = \"R\";\n    conn15.size = 262144;\n    MCMP_PROC_SW_FC_UART_UARTDriver.sb_AirVehicleState_UXAS_queue_1_access = \"W\";\n    vmUXAS.sb_AirVehicleState_queue_access = \"R\";\n    vmUXAS.sb_AirVehicleState_notification_domain = 9;\n    conn17.size = 262144;\n    vmRADIO.sb_trusted_ids_queue_1_access = \"RW\";\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_trusted_ids_queue_access = \"R\";\n    conn19.size = 262144;\n    vmRADIO.sb_AutomationRequest_queue_1_access = \"RW\";\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_in_queue_access = \"R\";\n    conn21.size = 262144;\n    vmRADIO.sb_OperatingRegion_queue_1_access = \"RW\";\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_in_queue_access = \"R\";\n    conn23.size = 262144;\n    vmRADIO.sb_LineSearchTask_queue_1_access = \"RW\";\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_in_queue_access = \"R\";\n    conn24.size = 262144;\n    MCMP_PROC_SW_FlyZones_FlyZonesDatabase.sb_keep_in_zones_access = \"W\";\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_keep_in_zones_access = \"R\";\n    conn25.size = 262144;\n    MCMP_PROC_SW_FlyZones_FlyZonesDatabase.sb_keep_out_zones_access = \"W\";\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_keep_out_zones_access = \"R\";\n    conn27.size = 262144;\n    vmUXAS.sb_AutomationResponse_MON_GEO_queue_1_access = \"RW\";\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_observed_queue_access = \"R\";\n    conn29.size = 262144;\n    vmUXAS.sb_AutomationResponse_MON_REQ_queue_1_access = \"RW\";\n    MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_observed_queue_access = \"R\";\n    conn31.size = 262144;\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_MissionCommand_queue_1_access = \"W\";\n    MCMP_PROC_SW_FC_UART_UARTDriver.sb_MissionCommand_queue_access = \"R\";\n    conn33.size = 262144;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_UXAS_queue_1_access = \"W\";\n    vmUXAS.sb_AutomationRequest_queue_access = \"R\";\n    vmUXAS.sb_AutomationRequest_notification_domain = 9;\n    conn35.size = 262144;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_AutomationRequest_out_MON_REQ_queue_1_access = \"W\";\n    MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.sb_reference_1_queue_access = \"R\";\n    conn37.size = 262144;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_OperatingRegion_out_queue_1_access = \"W\";\n    vmUXAS.sb_OperatingRegion_queue_access = \"R\";\n    vmUXAS.sb_OperatingRegion_notification_domain = 9;\n    conn39.size = 262144;\n    MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.sb_LineSearchTask_out_queue_1_access = \"W\";\n    MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_in_queue_access = \"R\";\n    conn41.size = 262144;\n    MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.sb_filter_out_queue_1_access = \"W\";\n    vmUXAS.sb_LineSearchTask_queue_access = \"R\";\n    vmUXAS.sb_LineSearchTask_notification_domain = 9;\n    conn43.size = 262144;\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_output_queue_1_access = \"W\";\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_AutomationResponse_queue_access = \"R\";\n    MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.sb_alert_counter_access = \"W\";\n    MCMP_PROC_SW_WPM_WaypointPlanManagerService.sb_ReturnHome_counter_access = \"R\";\n    pacer._domain = 1;\n    pacer.period_to_vmRADIO_queue_access = \"W\";\n    vmRADIO.sb_pacer_period_queue_access = \"R\";\n    pacer.period_to_vmUXAS_queue_access = \"W\";\n    vmUXAS.sb_pacer_period_queue_access = \"R\";\n  }\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/seqNum.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef _SEQNUM_H_\n#define _SEQNUM_H_\n\n\/\/ Typedef for seqNum to make it easy to change the type. Keep these consistent!\ntypedef uintmax_t seqNum_t;\n#define SEQNUM_MAX UINTMAX_MAX\n#define PRIseqNum PRIuMAX\n\n\/\/ DIRTY_SEQ_NUM is used to mark a sampling port message as dirty while it is\n\/\/ being writen. DIRTY_SEQ_NUM is not a valid sequence number. Valid sequence\n\/\/ numbers are from 0 to DIRTY_SEQ_NUM-1 is never a valid sequence number.\nstatic const seqNum_t DIRTY_SEQ_NUM = SEQNUM_MAX;\n\n#endif",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/sp_union_art_DataContent.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SP_UNION_ART_DATACONTENT_H\n#define SP_UNION_ART_DATACONTENT_H\n\n#include <sb_types.h>\n#include <seqNum.h>\n\n\/\/ Sampling port message with bool data\ntypedef struct sp_union_art_DataContent {\n\n  \/\/ The sampling port message data.\n  \/\/\n  union_art_DataContent data;\n\n  \/\/ Sequence number incremented by the writer every time the sampling port is\n  \/\/ written. Read by the receiver to detect dropped messages and incoherent\n  \/\/ message reads.  An incoherent message is one that is formed of parts of\n  \/\/ more than one message.  An incoherent message can occur when writing\n  \/\/ happens during read. If the component runs long enough, this counter\n  \/\/ will wrap back to zero.  This causes no problems unless the receiver is\n  \/\/ delayed for the wrap time. In that case the receiver may not detect\n  \/\/ dropped or incoherent message. But if the receiver is delayed for that\n  \/\/ long the system is probably in a very bad state. Also see DIRTY_SEQ_NUM\n  \/\/ above.\n  \/\/\n  \/\/ TODO: Currently using ggc builtin _Atomic. Would like to use c11 std, but\n  \/\/ have not figured out how to do this int the seL4 cmake build environment.\n  _Atomic seqNum_t seqNum;  \n\n} sp_union_art_DataContent_t;\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum);\n\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum);\n\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum);\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port);\n\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/src\/sp_union_art_DataContent.c",
        {
          "type" : "ITestResource",
          "content" : "#include <sp_union_art_DataContent.h>\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum) {\n  *seqNum = 0; \/\/ First message sequence number will be 1.\n  port->seqNum = DIRTY_SEQ_NUM;\n}\n\n\/\/ Write message to a sampling port (data type: int)\n\/\/\n\/\/ Returns true when successful. Otherwise returns false. Currently there is no\n\/\/ way to fail and true is always returned. But this may change in the\n\/\/ future. seqNum is incremented when a message is successfully sent. seqNum\n\/\/ should not be modified otherwise.\n\/\/\n\/\/ TODO: Encapsulate this better. seqNum state should be maintained internally. Possible solutions:\n\/\/\n\/\/    - Allow write to have read access to dataport. Then seqNum is simply in the data port.\n\/\/\n\/\/    - Create a wrapper struct.\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_RELEASE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum) {\n  \/\/ Mark the message dirty BEFORE we start writing.\n  port->seqNum = DIRTY_SEQ_NUM;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Write the data\n  port->data = *data;\n  \/\/ Increment the sequence number. We are the only writer of seqNum, so\n  \/\/ increment does not have to be atomic.\n  *seqNum = (*seqNum + 1) % DIRTY_SEQ_NUM;\n  port->seqNum = *seqNum;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE continuing\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Can't fail for now.\n  return true;\n}\n\n\/\/ Read a message from a sampling port (data type: int)\n\/\/\n\/\/ Return true upon successful read. Data is updated with the read\n\/\/ message. The sequence number of the message is also returned. The message,\n\/\/ might be tha same previously read. The sequences number can be used to\n\/\/ detect rereading the same message or dropped messages.\n\/\/\n\/\/ Return false if we fail to read a message. For now the only way to fail is\n\/\/ when we detect the possibility of a write during read. In this case data\n\/\/ may be incoherent and should not be used. Sequence number is set to\n\/\/ DIRTY_SEQ_NUM;\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_ACQUIRE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum) {\n  seqNum_t newSeqNum = port->seqNum;\n  \/\/ Acquire memory fence - Read seqNum BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  *data = port->data;\n  \/\/ Acquire memory fence - Read data BEFORE reading seqNum again \n  \/\/atomic_thread_fence(memory_order_acquire);\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  \/\/ The following logic will NOT catch case where the writer wrapped\n  \/\/ sequence numbers since our last read. For this to happen, this reader\n  \/\/ would have to be delayed for the entire time to wrap. \n  if (newSeqNum != DIRTY_SEQ_NUM && newSeqNum == port->seqNum) {\n    \/\/ Message data is good.  Write did not occur during read. \n    *seqNum = newSeqNum;\n    return true;\n  } else {\n    \/\/ Writer may have updated data while we were reading. Do not use possibly incoherent data.\n    *seqNum = DIRTY_SEQ_NUM;\n    return false;\n  }\n}\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port) {\n  return port->seqNum == DIRTY_SEQ_NUM;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/CMake_CakeMLOptions.cmake",
        {
          "type" : "ITestResource",
          "content" : "option(CAKEML_DUMP_BUFFERS\n       \"Print the contents of byte-arrays being sent to CakeML\"\n       OFF)\n\nif(CAKEML_DUMP_BUFFERS OR \"$ENV{CAKEML_DUMP_BUFFERS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_DUMP_BUFFERS)\nendif()\n\noption(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n       \"Print warning messages if byte-arrays being sent to CakeML are larger than expected\"\n       OFF)\n\nif(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS OR \"$ENV{CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS)\nendif()\n\noption(CAKEML_ASSEMBLIES_PRESENT\n       \"Enable if CakeML assembly files have been included\"\n       OFF)\n\nif(CAKEML_ASSEMBLIES_PRESENT OR \"$ENV{CAKEML_ASSEMBLIES_PRESENT}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_ASSEMBLIES_PRESENT)\nendif()",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/CMake_TranspilerOptions.cmake",
        {
          "type" : "ITestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/CMake_CAmkES_VM_Options.cmake",
        {
          "type" : "ITestResource",
          "content" : "option(BUILD_CROSSVM\n       \"Checkout and configure linux to build crossvm module instead of using pre-configured rootfs\"\n       OFF)\n\nif(\"$ENV{BUILD_CROSSVM}\" STREQUAL \"ON\")\n   set(BUILD_CROSSVM ON)\nendif()",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (UAV_Impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_CakeMLOptions.cmake)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_CAmkES_VM_Options.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/components\/VM)\n\nDeclareCAmkESComponent(UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\n  SOURCES components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/src\/sb_UARTDriver_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/includes\/ types\/includes\n  LIBS UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\n)\n\nDeclareCAmkESComponent(FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\n  SOURCES components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/src\/sb_FlyZonesDatabase_thr_Impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/includes\/ types\/includes types\/includes types\/includes\n  LIBS FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\n)\n\nDeclareCAmkESComponent(WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\n  SOURCES components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/src\/sb_WaypointPlanManagerService_thr_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/includes\/ types\/includes\n  LIBS WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\n)\n\nDeclareCAmkESComponent(CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\n  SOURCES components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl_ffi.c components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl.S components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/includes\/ types\/includes\n  LIBS CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\n)\n\nDeclareCAmkESComponent(CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\n  SOURCES components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl_ffi.c components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl.S components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/includes\/ types\/includes\n  LIBS CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\n)\n\nDeclareCAmkESComponent(CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\n  SOURCES components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/src\/sb_CASE_Monitor_Req_thr_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/includes\/ types\/includes\n  LIBS CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\n)\n\nDeclareCAmkESComponent(CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\n  SOURCES components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl_ffi.c components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl.S components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/includes\/ types\/includes types\/includes types\/includes\n  LIBS CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\n)\n\nDeclareCAmkESComponent(Pacer\n  SOURCES components\/Pacer\/src\/Pacer.c\n  LIBS SB_Type_Library SlangTypeLibrary\n)\n\nDeclareCAmkESRootserver(UAV_Impl_Instance.camkes)\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes-vm-examples\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes-vm-examples\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes-vm-examples project directory.\"\n  echo \"See https:\/\/github.com\/camkes-vm-examples\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/vm-examples\/apps\/Arm\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -svf $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} \\\n    -DPLATFORM=qemu-arm-virt \\\n    -DQEMU_MEMORY=2048 \\\n    -DARM_HYP=ON \\\n    -DCAMKES_VM_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-aarch64 \\\\\n    -machine virt,virtualization=on,highmem=off,secure=off \\\\\n    -cpu cortex-a53 \\\\\n    -nographic \\\\\n    -m size=2048 \\\\\n    -kernel images\/capdl-loader-image-arm-qemu-arm-virt\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/src\/sb_UARTDriver_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_UARTDriver_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_MissionCommand_recv_queue;\n\n\/************************************************************************\n * sb_MissionCommand_dequeue_poll:\n ************************************************************************\/\nbool sb_MissionCommand_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_MissionCommand_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_MissionCommand_dequeue:\n ************************************************************************\/\nbool sb_MissionCommand_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_MissionCommand_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_MissionCommand_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_MissionCommand_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_MissionCommand_recv_queue);\n}\n\nbool sb_AirVehicleState_WPM_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AirVehicleState_WPM_queue_1, (union_art_DataContent*) data);\n  sb_AirVehicleState_WPM_1_notification_emit();\n\n  return true;\n}\n\nbool sb_AirVehicleState_UXAS_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AirVehicleState_UXAS_queue_1, (union_art_DataContent*) data);\n  sb_AirVehicleState_UXAS_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send AirVehicleState_WPM: Out EventDataPort CMASI__AirVehicleState_i\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_AirVehicleState_WPM_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_UARTDriver_Impl.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_AirVehicleState_WPM_Send\", 0);\n\n  sb_AirVehicleState_WPM_enqueue(d);\n}\n\n\/\/ send AirVehicleState_UXAS: Out EventDataPort CMASI__AirVehicleState_i\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_AirVehicleState_UXAS_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_UARTDriver_Impl.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_AirVehicleState_UXAS_Send\", 0);\n\n  sb_AirVehicleState_UXAS_enqueue(d);\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_send_data_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_UARTDriver_Impl.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_send_data_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ is_empty MissionCommand: In EventDataPort\nB uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_MissionCommand_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_MissionCommand_is_empty();\n}\n\n\/\/ receive MissionCommand: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_MissionCommand_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_UARTDriver_Impl.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_MissionCommand_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_MissionCommand_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_recv_data_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_recv_data_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_UARTDriver_Impl.c\", \"\", \"uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_seL4Nix_recv_data_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_UARTDriver_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\\n\");\n\n  \/\/ initialise data structure for incoming event data port MissionCommand\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_MissionCommand_recv_queue, sb_MissionCommand_queue);\n\n  \/\/ initialise data structure for outgoing event data port AirVehicleState_WPM\n  sb_queue_union_art_DataContent_1_init(sb_AirVehicleState_WPM_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port AirVehicleState_UXAS\n  sb_queue_union_art_DataContent_1_init(sb_AirVehicleState_UXAS_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_UARTDriver_Impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/includes\/sb_UARTDriver_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_UARTDRIVER_IMPL_H\n#define SB_UARTDRIVER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_MissionCommand_dequeue(union_art_DataContent *);\n\nbool sb_AirVehicleState_WPM_enqueue(const union_art_DataContent *);\n\nbool sb_AirVehicleState_UXAS_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_UARTDRIVER_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/src\/sb_FlyZonesDatabase_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_FlyZonesDatabase_thr_Impl.h>\n#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_keep_out_zones_seqNum;\n\nseqNum_t sb_keep_in_zones_seqNum;\n\nbool sb_keep_in_zones_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_keep_in_zones, value, &sb_keep_in_zones_seqNum);\n}\n\nbool sb_keep_out_zones_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_keep_out_zones, value, &sb_keep_out_zones_seqNum);\n}\n\n\/\/ send keep_in_zones: Out DataPort CMASI__Polygon_i\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_keep_in_zones_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_FlyZonesDatabase_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_keep_in_zones_Send\", 0);\n\n  sb_keep_in_zones_write(d);\n}\n\n\/\/ send keep_out_zones: Out DataPort CMASI__Polygon_i\nUnit uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_keep_out_zones_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_FlyZonesDatabase_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_seL4Nix_keep_out_zones_Send\", 0);\n\n  sb_keep_out_zones_write(d);\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_FlyZonesDatabase_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\\n\");\n\n  \/\/ initialise data structure for data port keep_in_zones\n  init_sp_union_art_DataContent(sb_keep_in_zones, &sb_keep_in_zones_seqNum);\n\n  \/\/ initialise data structure for data port keep_out_zones\n  init_sp_union_art_DataContent(sb_keep_out_zones, &sb_keep_out_zones_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_FlyZonesDatabase_thr_Impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/includes\/sb_FlyZonesDatabase_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_FLYZONESDATABASE_THR_IMPL_H\n#define SB_FLYZONESDATABASE_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_keep_in_zones_write(const union_art_DataContent * value);\n\nbool sb_keep_out_zones_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_FLYZONESDATABASE_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/src\/sb_WaypointPlanManagerService_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_WaypointPlanManagerService_thr_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_AutomationResponse_recv_queue;\n\n\/************************************************************************\n * sb_AutomationResponse_dequeue_poll:\n ************************************************************************\/\nbool sb_AutomationResponse_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_AutomationResponse_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_AutomationResponse_dequeue:\n ************************************************************************\/\nbool sb_AutomationResponse_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_AutomationResponse_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_AutomationResponse_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_AutomationResponse_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_AutomationResponse_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_AirVehicleState_recv_queue;\n\n\/************************************************************************\n * sb_AirVehicleState_dequeue_poll:\n ************************************************************************\/\nbool sb_AirVehicleState_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_AirVehicleState_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_AirVehicleState_dequeue:\n ************************************************************************\/\nbool sb_AirVehicleState_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_AirVehicleState_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_AirVehicleState_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_AirVehicleState_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_AirVehicleState_recv_queue);\n}\n\nbool sb_MissionCommand_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_MissionCommand_queue_1, (union_art_DataContent*) data);\n  sb_MissionCommand_1_notification_emit();\n\n  return true;\n}\n\n\/************************************************************************\n *\n * Static variables and queue management functions for event port:\n *     ReturnHome\n *\n ************************************************************************\/\nstatic sb_event_counter_t sb_ReturnHome_received_events = 0;\nstatic sb_event_counter_t sb_ReturnHome_last_counter = 0;\n\n\/************************************************************************\n * sb_ReturnHome_dequeue:\n * Invoked from local active thread.\n *\n * This is the function invoked by the active thread to decrement the\n * input event index.\n *\n ************************************************************************\/\nbool sb_ReturnHome_dequeue() {\n  if(sb_ReturnHome_received_events > 0) {\n    sb_ReturnHome_received_events--;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\/************************************************************************\n * sb_ReturnHome_is_empty;\n *\n * Helper method to determine if infrastructure port has not received\n * any new events since the last dispatch\n *\n ************************************************************************\/\nbool sb_ReturnHome_is_empty() {\n  return sb_ReturnHome_received_events == 0;\n}\n\nvoid sb_freeze_event_port_ReturnHome() {\n  sb_event_counter_t current_sb_ReturnHome_counter;\n\n  sb_ReturnHome_received_events = 0; \/\/ drop any events not handled during last dispatch\n\n  \/\/ get current shared counter value\n  current_sb_ReturnHome_counter = *sb_ReturnHome_counter;\n\n  \/\/ Acquire memory fence - ensure preceding read occurs before any subsequent read or write\n  sb_ReturnHome_counter_acquire();\n\n  \/\/ NOTE: Counters can wrap, so we must use != below instead of >\n  while(current_sb_ReturnHome_counter != sb_ReturnHome_last_counter){\n    sb_ReturnHome_last_counter++;\n    sb_ReturnHome_received_events++;\n  }\n\n  if(sb_ReturnHome_received_events > 0) {\n\n    \/\/ ReturnHome's queue size is 1\n    if(sb_ReturnHome_received_events > 1) {\n      \/\/printf(\"WaypointPlanManagerService_thr_Impl: dropping %i event(s) from incoming event port ReturnHome\\n\", (sb_ReturnHome_received_events - 1));\n\n      \/\/ drop events\n      sb_ReturnHome_received_events = 1;\n    }\n  }\n}\n\n\/\/ send MissionCommand: Out EventDataPort CMASI__MissionCommand_i\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_MissionCommand_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_MissionCommand_Send\", 0);\n\n  sb_MissionCommand_enqueue(d);\n}\n\n\/\/ is_empty AutomationResponse: In EventDataPort\nB uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AutomationResponse_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_AutomationResponse_is_empty();\n}\n\n\/\/ receive AutomationResponse: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AutomationResponse_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AutomationResponse_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_AutomationResponse_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty AirVehicleState: In EventDataPort\nB uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AirVehicleState_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_AirVehicleState_is_empty();\n}\n\n\/\/ receive AirVehicleState: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AirVehicleState_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_AirVehicleState_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_AirVehicleState_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty ReturnHome: In EventPort\nB uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_ReturnHome_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_ReturnHome_is_empty();\n}\n\n\/\/ receive ReturnHome: In EventPort\nUnit uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_ReturnHome_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_seL4Nix_ReturnHome_Receive\", 0);\n\n  if(sb_ReturnHome_dequeue()) {\n    \/\/ event port - ART requires an Empty payload be sent\n    DeclNewart_Empty(payload);\n\n    \/\/ wrap it in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &payload);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n} \n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\\n\");\n\n  \/\/ initialise data structure for incoming event data port AutomationResponse\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_AutomationResponse_recv_queue, sb_AutomationResponse_queue);\n\n  \/\/ initialise data structure for incoming event data port AirVehicleState\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_AirVehicleState_recv_queue, sb_AirVehicleState_queue);\n\n  \/\/ initialise data structure for outgoing event data port MissionCommand\n  sb_queue_union_art_DataContent_1_init(sb_MissionCommand_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_WaypointPlanManagerService_thr_Impl.c\", \"\", \"run\", 0);\n\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    sb_freeze_event_port_ReturnHome();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/includes\/sb_WaypointPlanManagerService_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_WAYPOINTPLANMANAGERSERVICE_THR_IMPL_H\n#define SB_WAYPOINTPLANMANAGERSERVICE_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_AutomationResponse_dequeue(union_art_DataContent *);\n\nbool sb_AirVehicleState_dequeue(union_art_DataContent *);\n\nbool sb_MissionCommand_enqueue(const union_art_DataContent *);\n\nbool sb_ReturnHome_dequeue(void);\n\n#endif \/\/ SB_WAYPOINTPLANMANAGERSERVICE_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl_ffi.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.h>\n\nuav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints entryPoints;\n\n\/\/ IS_D10119=IS[Z, art.Art.PortId]\nIS_D10119 event_in_port_ids;\nIS_D10119 data_in_port_ids;\nIS_D10119 event_out_port_ids;\nIS_D10119 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_get_trusted_ids(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_get_trusted_ids\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_trusted_ids__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_get_AutomationRequest_in(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_get_AutomationRequest_in\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_AutomationRequest_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_AutomationRequest_out_UXAS(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_send_AutomationRequest_out_UXAS\", 0);\n\n  init(SF_LAST);\n  api_put_AutomationRequest_out_UXAS__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_send_AutomationRequest_out_MON_REQ(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_send_AutomationRequest_out_MON_REQ\", 0);\n\n  init(SF_LAST);\n  api_put_AutomationRequest_out_MON_REQ__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_get_OperatingRegion_in(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_get_OperatingRegion_in\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_OperatingRegion_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_OperatingRegion_out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_send_OperatingRegion_out\", 0);\n\n  init(SF_LAST);\n  api_put_OperatingRegion_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_get_LineSearchTask_in(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_get_LineSearchTask_in\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_LineSearchTask_in__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_LineSearchTask_out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl_ffi.c\", \"\", \"ffiapi_send_LineSearchTask_out\", 0);\n\n  init(SF_LAST);\n  api_put_LineSearchTask_out__uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_pacer_notification_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  \/\/ non self-pacing so do nothing\n  output[0] = 1;\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl.S",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_CASE_AttestationGate_thr_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_trusted_ids_recv_queue;\n\n\/************************************************************************\n * sb_trusted_ids_dequeue_poll:\n ************************************************************************\/\nbool sb_trusted_ids_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_trusted_ids_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_trusted_ids_dequeue:\n ************************************************************************\/\nbool sb_trusted_ids_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_trusted_ids_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_trusted_ids_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_trusted_ids_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_trusted_ids_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_AutomationRequest_in_recv_queue;\n\n\/************************************************************************\n * sb_AutomationRequest_in_dequeue_poll:\n ************************************************************************\/\nbool sb_AutomationRequest_in_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_AutomationRequest_in_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_AutomationRequest_in_dequeue:\n ************************************************************************\/\nbool sb_AutomationRequest_in_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_AutomationRequest_in_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_AutomationRequest_in_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_AutomationRequest_in_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_AutomationRequest_in_recv_queue);\n}\n\nbool sb_AutomationRequest_out_UXAS_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AutomationRequest_out_UXAS_queue_1, (union_art_DataContent*) data);\n  sb_AutomationRequest_out_UXAS_1_notification_emit();\n\n  return true;\n}\n\nbool sb_AutomationRequest_out_MON_REQ_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AutomationRequest_out_MON_REQ_queue_1, (union_art_DataContent*) data);\n  sb_AutomationRequest_out_MON_REQ_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_OperatingRegion_in_recv_queue;\n\n\/************************************************************************\n * sb_OperatingRegion_in_dequeue_poll:\n ************************************************************************\/\nbool sb_OperatingRegion_in_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_OperatingRegion_in_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_OperatingRegion_in_dequeue:\n ************************************************************************\/\nbool sb_OperatingRegion_in_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_OperatingRegion_in_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_OperatingRegion_in_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_OperatingRegion_in_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_OperatingRegion_in_recv_queue);\n}\n\nbool sb_OperatingRegion_out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_OperatingRegion_out_queue_1, (union_art_DataContent*) data);\n  sb_OperatingRegion_out_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_LineSearchTask_in_recv_queue;\n\n\/************************************************************************\n * sb_LineSearchTask_in_dequeue_poll:\n ************************************************************************\/\nbool sb_LineSearchTask_in_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_LineSearchTask_in_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_LineSearchTask_in_dequeue:\n ************************************************************************\/\nbool sb_LineSearchTask_in_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_LineSearchTask_in_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_LineSearchTask_in_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_LineSearchTask_in_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_LineSearchTask_in_recv_queue);\n}\n\nbool sb_LineSearchTask_out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_LineSearchTask_out_queue_1, (union_art_DataContent*) data);\n  sb_LineSearchTask_out_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send AutomationRequest_out_UXAS: Out EventDataPort CMASI__AutomationRequest_i\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_out_UXAS_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_out_UXAS_Send\", 0);\n\n  sb_AutomationRequest_out_UXAS_enqueue(d);\n}\n\n\/\/ send AutomationRequest_out_MON_REQ: Out EventDataPort CMASI__AutomationRequest_i\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_out_MON_REQ_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_out_MON_REQ_Send\", 0);\n\n  sb_AutomationRequest_out_MON_REQ_enqueue(d);\n}\n\n\/\/ send OperatingRegion_out: Out EventDataPort CMASI__OperatingRegion_i\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_OperatingRegion_out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_OperatingRegion_out_Send\", 0);\n\n  sb_OperatingRegion_out_enqueue(d);\n}\n\n\/\/ send LineSearchTask_out: Out EventDataPort CMASI__LineSearchTask_i\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_LineSearchTask_out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_LineSearchTask_out_Send\", 0);\n\n  sb_LineSearchTask_out_enqueue(d);\n}\n\n\/\/ is_empty trusted_ids: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_trusted_ids_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_trusted_ids_is_empty();\n}\n\n\/\/ receive trusted_ids: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_trusted_ids_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_trusted_ids_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_trusted_ids_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty AutomationRequest_in: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_in_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_AutomationRequest_in_is_empty();\n}\n\n\/\/ receive AutomationRequest_in: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_in_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_AutomationRequest_in_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_AutomationRequest_in_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty OperatingRegion_in: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_OperatingRegion_in_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_OperatingRegion_in_is_empty();\n}\n\n\/\/ receive OperatingRegion_in: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_OperatingRegion_in_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_OperatingRegion_in_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_OperatingRegion_in_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty LineSearchTask_in: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_LineSearchTask_in_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_LineSearchTask_in_is_empty();\n}\n\n\/\/ receive LineSearchTask_in: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_LineSearchTask_in_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_seL4Nix_LineSearchTask_in_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_LineSearchTask_in_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\\n\");\n\n  \/\/ initialise data structure for incoming event data port trusted_ids\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_trusted_ids_recv_queue, sb_trusted_ids_queue);\n\n  \/\/ initialise data structure for incoming event data port AutomationRequest_in\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_AutomationRequest_in_recv_queue, sb_AutomationRequest_in_queue);\n\n  \/\/ initialise data structure for outgoing event data port AutomationRequest_out_UXAS\n  sb_queue_union_art_DataContent_1_init(sb_AutomationRequest_out_UXAS_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port AutomationRequest_out_MON_REQ\n  sb_queue_union_art_DataContent_1_init(sb_AutomationRequest_out_MON_REQ_queue_1);\n\n  \/\/ initialise data structure for incoming event data port OperatingRegion_in\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_OperatingRegion_in_recv_queue, sb_OperatingRegion_in_queue);\n\n  \/\/ initialise data structure for outgoing event data port OperatingRegion_out\n  sb_queue_union_art_DataContent_1_init(sb_OperatingRegion_out_queue_1);\n\n  \/\/ initialise data structure for incoming event data port LineSearchTask_in\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_LineSearchTask_in_recv_queue, sb_LineSearchTask_in_queue);\n\n  \/\/ initialise data structure for outgoing event data port LineSearchTask_out\n  sb_queue_union_art_DataContent_1_init(sb_LineSearchTask_out_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_thr_Impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/includes\/sb_CASE_AttestationGate_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_CASE_ATTESTATIONGATE_THR_IMPL_H\n#define SB_CASE_ATTESTATIONGATE_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_trusted_ids_dequeue(union_art_DataContent *);\n\nbool sb_AutomationRequest_in_dequeue(union_art_DataContent *);\n\nbool sb_AutomationRequest_out_UXAS_enqueue(const union_art_DataContent *);\n\nbool sb_AutomationRequest_out_MON_REQ_enqueue(const union_art_DataContent *);\n\nbool sb_OperatingRegion_in_dequeue(union_art_DataContent *);\n\nbool sb_OperatingRegion_out_enqueue(const union_art_DataContent *);\n\nbool sb_LineSearchTask_in_dequeue(union_art_DataContent *);\n\nbool sb_LineSearchTask_out_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_ATTESTATIONGATE_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl_ffi.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.h>\n\nuav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints entryPoints;\n\n\/\/ IS_D10119=IS[Z, art.Art.PortId]\nIS_D10119 event_in_port_ids;\nIS_D10119 data_in_port_ids;\nIS_D10119 event_out_port_ids;\nIS_D10119 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF str);\n} \n\nvoid ffiapi_get_filter_in(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_get_filter_in\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_filter_in__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_filter_out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl_ffi.c\", \"\", \"ffiapi_send_filter_out\", 0);\n\n  init(SF_LAST);\n  api_put_filter_out__uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_pacer_notification_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  \/\/ non self-pacing so do nothing\n  output[0] = 1;\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl.S",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/src\/sb_CASE_Filter_LST_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_CASE_Filter_LST_thr_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_filter_in_recv_queue;\n\n\/************************************************************************\n * sb_filter_in_dequeue_poll:\n ************************************************************************\/\nbool sb_filter_in_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_filter_in_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_filter_in_dequeue:\n ************************************************************************\/\nbool sb_filter_in_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_filter_in_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_filter_in_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_filter_in_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_filter_in_recv_queue);\n}\n\nbool sb_filter_out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_filter_out_queue_1, (union_art_DataContent*) data);\n  sb_filter_out_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send filter_out: Out EventDataPort CMASI__LineSearchTask_i\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_filter_out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Filter_LST_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_filter_out_Send\", 0);\n\n  sb_filter_out_enqueue(d);\n}\n\n\/\/ is_empty filter_in: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_filter_in_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_filter_in_is_empty();\n}\n\n\/\/ receive filter_in: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_filter_in_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Filter_LST_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_seL4Nix_filter_in_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_filter_in_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\\n\");\n\n  \/\/ initialise data structure for incoming event data port filter_in\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_filter_in_recv_queue, sb_filter_in_queue);\n\n  \/\/ initialise data structure for outgoing event data port filter_out\n  sb_queue_union_art_DataContent_1_init(sb_filter_out_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Filter_LST_thr_Impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/includes\/sb_CASE_Filter_LST_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_CASE_FILTER_LST_THR_IMPL_H\n#define SB_CASE_FILTER_LST_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_filter_in_dequeue(union_art_DataContent *);\n\nbool sb_filter_out_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_FILTER_LST_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/src\/sb_CASE_Monitor_Req_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_CASE_Monitor_Req_thr_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_observed_recv_queue;\n\n\/************************************************************************\n * sb_observed_dequeue_poll:\n ************************************************************************\/\nbool sb_observed_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_observed_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_observed_dequeue:\n ************************************************************************\/\nbool sb_observed_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_observed_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_observed_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_observed_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_observed_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_reference_1_recv_queue;\n\n\/************************************************************************\n * sb_reference_1_dequeue_poll:\n ************************************************************************\/\nbool sb_reference_1_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_reference_1_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_reference_1_dequeue:\n ************************************************************************\/\nbool sb_reference_1_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_reference_1_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_reference_1_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_reference_1_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_reference_1_recv_queue);\n}\n\n\/\/ is_empty observed: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_observed_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_observed_is_empty();\n}\n\n\/\/ receive observed: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_observed_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Req_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_observed_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_observed_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty reference_1: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_reference_1_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_reference_1_is_empty();\n}\n\n\/\/ receive reference_1: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_reference_1_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Req_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_seL4Nix_reference_1_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_reference_1_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Req_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\\n\");\n\n  \/\/ initialise data structure for incoming event data port observed\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_observed_recv_queue, sb_observed_queue);\n\n  \/\/ initialise data structure for incoming event data port reference_1\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_reference_1_recv_queue, sb_reference_1_queue);\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Req_thr_Impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/includes\/sb_CASE_Monitor_Req_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_CASE_MONITOR_REQ_THR_IMPL_H\n#define SB_CASE_MONITOR_REQ_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_observed_dequeue(union_art_DataContent *);\n\nbool sb_reference_1_dequeue(union_art_DataContent *);\n\n#endif \/\/ SB_CASE_MONITOR_REQ_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl_ffi.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.h>\n\nuav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints entryPoints;\n\n\/\/ IS_D10119=IS[Z, art.Art.PortId]\nIS_D10119 event_in_port_ids;\nIS_D10119 data_in_port_ids;\nIS_D10119 event_out_port_ids;\nIS_D10119 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_D10119) uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF str);\n} \n\nvoid ffiapi_get_keep_in_zones(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_get_keep_in_zones\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  api_get_keep_in_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &numBits, (U8 *)(output));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_get_keep_out_zones(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_get_keep_out_zones\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  api_get_keep_out_zones__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &numBits, (U8 *)(output));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_get_observed(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_get_observed\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_observed__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_output(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_send_output\", 0);\n\n  init(SF_LAST);\n  api_put_output__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_send_alert(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl_ffi.c\", \"\", \"ffiapi_send_alert\", 0);\n\n  init(SF_LAST);\n  api_put_alert__uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF_LAST );\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_pacer_notification_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  \/\/ non self-pacing so do nothing\n  output[0] = 1;\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl.S",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/src\/sb_CASE_Monitor_Geo_thr_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#include <sb_CASE_Monitor_Geo_thr_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_keep_out_zones_seqNum;\n\nseqNum_t sb_keep_in_zones_seqNum;\n\n\/*****************************************************************\n * sb_keep_in_zones_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_keep_in_zones_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_keep_in_zones);\n}\n\nbool sb_keep_in_zones_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_keep_in_zones, value, &new_seqNum) ) {\n    sb_keep_in_zones_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\/*****************************************************************\n * sb_keep_out_zones_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_keep_out_zones_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_keep_out_zones);\n}\n\nbool sb_keep_out_zones_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_keep_out_zones, value, &new_seqNum) ) {\n    sb_keep_out_zones_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_observed_recv_queue;\n\n\/************************************************************************\n * sb_observed_dequeue_poll:\n ************************************************************************\/\nbool sb_observed_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_observed_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_observed_dequeue:\n ************************************************************************\/\nbool sb_observed_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_observed_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_observed_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_observed_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_observed_recv_queue);\n}\n\nbool sb_output_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_output_queue_1, (union_art_DataContent*) data);\n  sb_output_1_notification_emit();\n\n  return true;\n}\n\n\/************************************************************************\n * sb_alert_enqueue\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to send to a remote event port.\n *\n ************************************************************************\/\nbool sb_alert_enqueue(void) {\n  \/\/ sb_alert_counter is a dataport (shared memory) that is written by the sender\n  \/\/ and read by the receiver(s). This counter is monotonicly increasing,\n  \/\/ but can wrap.\n  (*sb_alert_counter)++;\n\n  \/\/ Release memory fence - ensure subsequent write occurs after any preceeding read or write\n  sb_alert_counter_release();\n\n  sb_alert_emit();\n\n  return true;\n}\n\n\n\/\/ send output: Out EventDataPort CMASI__AutomationResponse_i\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_output_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_output_Send\", 0);\n\n  sb_output_enqueue(d);\n}\n\n\/\/ send alert: Out EventPort\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_alert_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_alert_Send\", 0);\n\n  \/\/ event port - can ignore the Slang Empty payload\n  art_Empty payload = (art_Empty) d;\n\n  \/\/ send event via CAmkES\n  sb_alert_enqueue();\n}\n\n\/\/ is_empty keep_in_zones: In DataPort\nB uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_in_zones_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_keep_in_zones_is_empty();\n}\n\n\/\/ receive keep_in_zones: In DataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_in_zones_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_in_zones_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_keep_in_zones_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty keep_out_zones: In DataPort\nB uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_out_zones_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_keep_out_zones_is_empty();\n}\n\n\/\/ receive keep_out_zones: In DataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_out_zones_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_keep_out_zones_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_keep_out_zones_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty observed: In EventDataPort\nB uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_observed_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_observed_is_empty();\n}\n\n\/\/ receive observed: In EventDataPort union_art_DataContent\nUnit uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_observed_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_seL4Nix_observed_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_observed_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\\n\");\n\n  \/\/ initialise data structure for incoming event data port observed\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_observed_recv_queue, sb_observed_queue);\n\n  \/\/ initialise data structure for outgoing event data port output\n  sb_queue_union_art_DataContent_1_init(sb_output_queue_1);\n\n  \/\/ initialise shared counter for event port alert\n  *sb_alert_counter = 0;\n\n  \/\/ initialise slang-embedded components\/ports\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor_Geo_thr_Impl.c\", \"\", \"run\", 0);\n\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    uav_june_step6__SeL4_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n#endif\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/includes\/sb_CASE_Monitor_Geo_thr_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\n#ifndef SB_CASE_MONITOR_GEO_THR_IMPL_H\n#define SB_CASE_MONITOR_GEO_THR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_keep_in_zones_read(union_art_DataContent * value);\n\nbool sb_keep_out_zones_read(union_art_DataContent * value);\n\nbool sb_observed_dequeue(union_art_DataContent *);\n\nbool sb_output_enqueue(const union_art_DataContent *);\n\nbool sb_alert_enqueue(void);\n\n#endif \/\/ SB_CASE_MONITOR_GEO_THR_IMPL_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/Pacer\/src\/Pacer.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Copyright 2019 Adventium Labs\n\n#include <camkes.h>\n#include <stdio.h>\n#include <sel4\/sel4.h>\n#include <sb_queue_int8_t_1.h>\n\nextern const char *get_instance_name(void);\n\nvoid send_period_to_vmRADIO(int8_t *data) {\n  sb_queue_int8_t_1_enqueue(period_to_vmRADIO_queue, data);\n  period_to_vmRADIO_notification_emit();\n}\n\nvoid send_period_to_vmUXAS(int8_t *data) {\n  sb_queue_int8_t_1_enqueue(period_to_vmUXAS_queue, data);\n  period_to_vmUXAS_notification_emit();\n}\n\nvoid pre_init(void) {\n  sb_queue_int8_t_1_init(period_to_vmRADIO_queue);\n  sb_queue_int8_t_1_init(period_to_vmUXAS_queue);\n}\n\nint run(void) {\n\n  int8_t tickCount = 0;\n\n  while (1) {\n    \/\/printf(\"%s: Period tick %d\\n\", get_instance_name(), tickCount);\n\n    tickCount++;\n\n    tick_emit();\n\n    send_period_to_vmRADIO(&tickCount);\n    send_period_to_vmUXAS(&tickCount);\n    period_emit();\n\n    tock_wait();\n  }\n\n  return 0;\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/sb_queue_union_art_DataContent_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE-1 elements.\n#define SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_union_art_DataContent_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type union_art_DataContent\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  union_art_DataContent elt[SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE];\n\n} sb_queue_union_art_DataContent_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue,\n  union_art_DataContent *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_union_art_DataContent_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_union_art_DataContent_1_t *queue;\n\n} sb_queue_union_art_DataContent_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_union_art_DataContent_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_union_art_DataContent_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  union_art_DataContent *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/src\/sb_queue_union_art_DataContent_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_union_art_DataContent_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue,\n  union_art_DataContent *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_queue_union_art_DataContent_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  union_art_DataContent *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_union_art_DataContent_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/src\/cross_vm_connections_vmRADIO.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2019, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <autoconf.h>\n#include <camkes.h>\n#include <vmlinux.h>\n#include <sel4vm\/guest_vm.h>\n\n#include <sel4vmmplatsupport\/drivers\/cross_vm_connection.h>\n#include <sel4vmmplatsupport\/drivers\/pci_helper.h>\n#include <pci\/helper.h>\n\n#ifdef CONFIG_PLAT_QEMU_ARM_VIRT\n#define CONNECTION_BASE_ADDRESS 0xDF000000\n#else\n#define CONNECTION_BASE_ADDRESS 0x3F000000\n#endif\n\n#define NUM_CONNECTIONS 5\nstatic struct camkes_crossvm_connection connections[NUM_CONNECTIONS];\n\nextern dataport_caps_handle_t sb_trusted_ids_queue_1_handle;\nvoid sb_trusted_ids_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_AutomationRequest_queue_1_handle;\nvoid sb_AutomationRequest_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_OperatingRegion_queue_1_handle;\nvoid sb_OperatingRegion_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_LineSearchTask_queue_1_handle;\nvoid sb_LineSearchTask_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_pacer_period_queue_handle;\nseL4_Word sb_pacer_period_notification_notification_badge(void);\n\nstatic int consume_callback(vm_t *vm, void *cookie) {\n    consume_connection_event(vm, (seL4_Word) cookie, true);\n    return 0;\n}\n\nvoid init_cross_vm_connections(vm_t *vm, void *cookie) {\n    connections[0] = (struct camkes_crossvm_connection) {\n      .handle = &sb_trusted_ids_queue_1_handle,\n      .emit_fn = sb_trusted_ids_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_trusted_ids_queue_1\"\n    };\n\n    connections[1] = (struct camkes_crossvm_connection) {\n      .handle = &sb_AutomationRequest_queue_1_handle,\n      .emit_fn = sb_AutomationRequest_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_AutomationRequest_queue_1\"\n    };\n\n    connections[2] = (struct camkes_crossvm_connection) {\n      .handle = &sb_OperatingRegion_queue_1_handle,\n      .emit_fn = sb_OperatingRegion_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_OperatingRegion_queue_1\"\n    };\n\n    connections[3] = (struct camkes_crossvm_connection) {\n      .handle = &sb_LineSearchTask_queue_1_handle,\n      .emit_fn = sb_LineSearchTask_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_LineSearchTask_queue_1\"\n    };\n\n    connections[4] = (struct camkes_crossvm_connection) {\n      .handle = &sb_pacer_period_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_pacer_period_notification_notification_badge(),\n      .connection_name = \"sb_pacer_period_queue\"\n    };\n\n    for (int i = 0; i < NUM_CONNECTIONS; i++) {\n        if (connections[i].consume_badge != -1) {\n            int err = register_async_event_handler(connections[i].consume_badge, consume_callback, (void *)connections[i].consume_badge);\n            ZF_LOGF_IF(err, \"Failed to register_async_event_handler for init_cross_vm_connections.\");\n        }\n    }\n\n    cross_vm_connections_init(vm, CONNECTION_BASE_ADDRESS, connections, ARRAY_SIZE(connections));\n}\n\nDEFINE_MODULE(cross_vm_connections, NULL, init_cross_vm_connections)",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/src\/cross_vm_connections_vmUXAS.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2019, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <autoconf.h>\n#include <camkes.h>\n#include <vmlinux.h>\n#include <sel4vm\/guest_vm.h>\n\n#include <sel4vmmplatsupport\/drivers\/cross_vm_connection.h>\n#include <sel4vmmplatsupport\/drivers\/pci_helper.h>\n#include <pci\/helper.h>\n\n#ifdef CONFIG_PLAT_QEMU_ARM_VIRT\n#define CONNECTION_BASE_ADDRESS 0xDF000000\n#else\n#define CONNECTION_BASE_ADDRESS 0x3F000000\n#endif\n\n#define NUM_CONNECTIONS 7\nstatic struct camkes_crossvm_connection connections[NUM_CONNECTIONS];\n\nextern dataport_caps_handle_t sb_AirVehicleState_queue_handle;\nseL4_Word sb_AirVehicleState_notification_notification_badge(void);\nextern dataport_caps_handle_t sb_AutomationResponse_MON_GEO_queue_1_handle;\nvoid sb_AutomationResponse_MON_GEO_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_AutomationResponse_MON_REQ_queue_1_handle;\nvoid sb_AutomationResponse_MON_REQ_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_AutomationRequest_queue_handle;\nseL4_Word sb_AutomationRequest_notification_notification_badge(void);\nextern dataport_caps_handle_t sb_OperatingRegion_queue_handle;\nseL4_Word sb_OperatingRegion_notification_notification_badge(void);\nextern dataport_caps_handle_t sb_LineSearchTask_queue_handle;\nseL4_Word sb_LineSearchTask_notification_notification_badge(void);\nextern dataport_caps_handle_t sb_pacer_period_queue_handle;\nseL4_Word sb_pacer_period_notification_notification_badge(void);\n\nstatic int consume_callback(vm_t *vm, void *cookie) {\n    consume_connection_event(vm, (seL4_Word) cookie, true);\n    return 0;\n}\n\nvoid init_cross_vm_connections(vm_t *vm, void *cookie) {\n    connections[0] = (struct camkes_crossvm_connection) {\n      .handle = &sb_AirVehicleState_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_AirVehicleState_notification_notification_badge(),\n      .connection_name = \"sb_AirVehicleState_queue\"\n    };\n\n    connections[1] = (struct camkes_crossvm_connection) {\n      .handle = &sb_AutomationResponse_MON_GEO_queue_1_handle,\n      .emit_fn = sb_AutomationResponse_MON_GEO_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_AutomationResponse_MON_GEO_queue_1\"\n    };\n\n    connections[2] = (struct camkes_crossvm_connection) {\n      .handle = &sb_AutomationResponse_MON_REQ_queue_1_handle,\n      .emit_fn = sb_AutomationResponse_MON_REQ_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_AutomationResponse_MON_REQ_queue_1\"\n    };\n\n    connections[3] = (struct camkes_crossvm_connection) {\n      .handle = &sb_AutomationRequest_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_AutomationRequest_notification_notification_badge(),\n      .connection_name = \"sb_AutomationRequest_queue\"\n    };\n\n    connections[4] = (struct camkes_crossvm_connection) {\n      .handle = &sb_OperatingRegion_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_OperatingRegion_notification_notification_badge(),\n      .connection_name = \"sb_OperatingRegion_queue\"\n    };\n\n    connections[5] = (struct camkes_crossvm_connection) {\n      .handle = &sb_LineSearchTask_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_LineSearchTask_notification_notification_badge(),\n      .connection_name = \"sb_LineSearchTask_queue\"\n    };\n\n    connections[6] = (struct camkes_crossvm_connection) {\n      .handle = &sb_pacer_period_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_pacer_period_notification_notification_badge(),\n      .connection_name = \"sb_pacer_period_queue\"\n    };\n\n    for (int i = 0; i < NUM_CONNECTIONS; i++) {\n        if (connections[i].consume_badge != -1) {\n            int err = register_async_event_handler(connections[i].consume_badge, consume_callback, (void *)connections[i].consume_badge);\n            ZF_LOGF_IF(err, \"Failed to register_async_event_handler for init_cross_vm_connections.\");\n        }\n    }\n\n    cross_vm_connections_init(vm, CONNECTION_BASE_ADDRESS, connections, ARRAY_SIZE(connections));\n}\n\nDEFINE_MODULE(cross_vm_connections, NULL, init_cross_vm_connections)",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\n# This file will not be overwritten so is safe to edit\n\nproject(arm-vm C)\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(arm-vm C)\n\n# including https:\/\/github.com\/seL4\/camkes-vm\/blob\/master\/arm_vm_helpers.cmake\ninclude(${CAMKES_ARM_VM_HELPERS_PATH})\n#MESSAGE(\"CAMKES_ARM_VM_HELPERS_PATH = ${CAMKES_ARM_VM_HELPERS_PATH}\")\n\nfind_package(camkes-vm-linux REQUIRED)\n\n# including https:\/\/github.com\/seL4\/camkes-vm-linux\/blob\/master\/vm-linux-helpers.cmake\ninclude(${CAMKES_VM_LINUX_HELPERS_PATH})\n#MESSAGE(\"CAMKES_VM_LINUX_HELPERS_PATH = ${CAMKES_VM_LINUX_HELPERS_PATH}\")\n\n# including https:\/\/github.com\/seL4\/camkes-vm-linux\/blob\/master\/linux-module-helpers.cmake\ninclude(${CAMKES_VM_LINUX_MODULE_HELPERS_PATH})\n#MESSAGE(\"CAMKES_VM_LINUX_MODULE_HELPERS_PATH = ${CAMKES_VM_LINUX_MODULE_HELPERS_PATH}\")\n\n# including https:\/\/github.com\/seL4\/camkes-vm-linux\/blob\/master\/linux-source-helpers.cmake\ninclude(${CAMKES_VM_LINUX_SOURCE_HELPERS_PATH})\n#MESSAGE(\"CAMKES_VM_LINUX_SOURCE_HELPERS_PATH = ${CAMKES_VM_LINUX_SOURCE_HELPERS_PATH}\")\n\n\n# This Project Depends on External Project(s)\n# see https:\/\/cmake.org\/cmake\/help\/latest\/module\/ExternalProject.html\ninclude(ExternalProject)\ninclude(external-project-helpers)\n\n\nfind_package(camkes-vm-images REQUIRED)\nfind_package(camkes-arm-vm REQUIRED)\n\n\n#MESSAGE(\"CAMKES_VM_LINUX_HELPERS_PATH = ${CAMKES_VM_LINUX_HELPERS_PATH}\")\n#MESSAGE(\"KernelARMPlatform = ${KernelARMPlatform}\")\n#MESSAGE(\"CAMKES_ARM_VM_DIR = ${CAMKES_ARM_VM_DIR}\")\n#MESSAGE(\"CAMKES_VM_IMAGES_DIR = ${CAMKES_VM_IMAGES_DIR}\")\n#MESSAGE(\"CAMKES_VM_LINUX_DIR = ${CAMKES_VM_LINUX_DIR}\")\n\n#MESSAGE(\"CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}\")\n#MESSAGE(\"CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}\")\n#MESSAGE(\"CMAKE_C_COMPILER = ${CMAKE_C_COMPILER}\")\n#MESSAGE(\"BASE_C_FLAGS = ${BASE_C_FLAGS}\")\n\n\n\n# Create our CPP Flags based on ARM VM config variables\nif(\"${KernelARMPlatform}\" STREQUAL \"exynos5422\")\n    set(cpp_flags \"-DKERNELARMPLATFORM_EXYNOS5422\")\n    set(linux_repo \"https:\/\/github.com\/hardkernel\/linux.git\")\n    set(linux_tag \"4.14.87-153\")\n    set(linux_arch \"arm\")\n    set(linux_cross_compile \"arm-linux-gnueabi-\")\nelseif(\"${KernelARMPlatform}\" STREQUAL \"qemu-arm-virt\")\n    set(cpp_flags \"-DKERNELARMPLATFORM_QEMU-ARM-VIRT\")\n    set(linux_repo \"https:\/\/git.kernel.org\/pub\/scm\/linux\/kernel\/git\/stable\/linux.git\")\n    set(linux_tag \"v4.9.189\")\n    set(linux_arch \"arm64\")\n    set(linux_cross_compile \"aarch64-linux-gnu-\")\n    include(simulation)\n    set(SIMULATION ON CACHE BOOL \"Generate simulation script to run qemu with the proper arguments\")\n    if(SIMULATION)\n        GenerateSimulateScript()\n    endif()\nendif()\n\n\n\nif(BUILD_CROSSVM)\n    MESSAGE(\"Not using preconfigured rootfs, will download a vanilla linux image instead\")\n\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs.cpio.gz\")\n    # Checkout and configure linux to build crossvm module\n    ExternalProject_Add(\n        checkout_linux\n        GIT_REPOSITORY\n        ${linux_repo}\n        GIT_TAG\n        ${linux_tag}\n        GIT_SHALLOW\n        1\n        GIT_PROGRESS\n        1\n        BUILD_COMMAND\n        \"\"\n        INSTALL_COMMAND\n        \"\"\n        CONFIGURE_COMMAND\n        \"\"\n        SOURCE_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n    )\n    # Linux config and symvers are to be copied to unpacked archive\n    set(linux_config \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/config\")\n    set(linux_symvers \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/Module.symvers\")\n    # Configure unpacked archive with config and symvers\n    ConfigureLinux(\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ${linux_config}\n        ${linux_symvers}\n        configure_vm_linux\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n    )\n\n    # Compile CrossVM Dataport Module\n    DefineLinuxModule(\n        ${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-modules\/camkes-connector-modules\/connection\n        output_module\n        output_module_target\n        KERNEL_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n        configure_vm_linux\n    )\n    AddFileToOverlayDir(\n        \"connection.ko\"\n        ${output_module}\n        \"lib\/modules\/4.14.87\/kernel\/drivers\/vmm\"\n        overlay\n        DEPENDS\n        output_module_target\n    )\n\n    # Complile CrossVM Dataport Apps\n    ExternalProject_Add(\n        dataport-apps\n        URL\n        file:\/\/\/${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-apps\/camkes-connector-apps\/pkgs\/dataport\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/dataport_apps\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n    )\n    AddExternalProjFilesToOverlay(\n        dataport-apps\n        ${CMAKE_CURRENT_BINARY_DIR}\/dataport_apps\n        overlay\n        \"usr\/bin\"\n        FILES\n        dataport_read\n        dataport_write\n    )\n\n    # Complile CrossVM Event Apps\n    ExternalProject_Add(\n        event-apps\n        URL\n        file:\/\/\/${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-apps\/camkes-connector-apps\/pkgs\/emits_event\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/emits_event_apps\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n    )\n    AddExternalProjFilesToOverlay(\n        event-apps\n        ${CMAKE_CURRENT_BINARY_DIR}\/emits_event_apps\n        overlay\n        \"usr\/bin\"\n        FILES\n        emits_event_emit\n    )\n\n    # Complile CrossVM Consume Event Apps\n    ExternalProject_Add(\n        consume-event-apps\n        URL\n        file:\/\/\/${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-apps\/camkes-connector-apps\/pkgs\/consumes_event\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/consume_event_apps\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n    )\n    AddExternalProjFilesToOverlay(\n        consume-event-apps\n        ${CMAKE_CURRENT_BINARY_DIR}\/consume_event_apps\n        overlay\n        \"usr\/bin\"\n        FILES\n        consumes_event_wait\n    )\n\n    # Add script to initialise dataport module\n    AddFileToOverlayDir(\n        \"S90crossvm_module_init\"\n        ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/cross_vm_module_init\n        \"etc\/init.d\"\n        overlay\n    )\nelse()\n    MESSAGE(\"Using pre-configured rootfs\")\n\n    # Use pre-configured rootfs file with crossvm modules and apps installed\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs_crossvm.cpio.gz\")\nendif()\n\n\n# Complile CrossVM Event Apps vmRADIO and vmUXAS\nforeach(item IN ITEMS vmRADIO vmUXAS)\n    ExternalProject_Add(\n        ${item}\n        SOURCE_DIR\n        ${CMAKE_CURRENT_SOURCE_DIR}\/apps\/${item}\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n        -DSlangTypeLibrary_DIR=${CMAKE_CURRENT_SOURCE_DIR}\/..\/..\/slang_libraries\/SlangTypeLibrary\n        -DSB_Type_Library_DIR=${CMAKE_CURRENT_SOURCE_DIR}\/..\/..\/types\n        -DCMAKE_C_FLAGS=${BASE_C_FLAGS}\n    )\n\n    AddExternalProjFilesToOverlay(\n        ${item}\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        overlay\n        \"usr\/bin\"\n        FILES\n        ${item}\n    )\nendforeach()\n\n# Overwrite inittab file for using the virtio console hvc0.\nAddFileToOverlayDir(\n    \"inittab\"\n    ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/inittab_hvc0\n    \"etc\"\n    overlay\n)\n\n# Construct new rootfs\nAddOverlayDirToRootfs(\n    overlay\n    ${rootfs_file}\n    \"buildroot\"\n    \"rootfs_install\"\n    output_overlayed_rootfs_location\n    rootfs_target\n    GZIP\n)\n\nAddToFileServer(\"linux-initrd\"\n                ${output_overlayed_rootfs_location}\n                DEPENDS rootfs_target)\n\n# Add linux kernel image to file server\nAddToFileServer(\"linux\"\n                \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux\")\n\nAddCamkesCPPFlag(\n    cpp_flags\n    CONFIG_VARS\n    VmEmmc2NoDMA\n    VmVUSB\n    VmVchan\n    Tk1DeviceFwd\n    Tk1Insecure\n    VmVirtioNetVirtqueue\n)\n\nDefineCAmkESVMFileServer()\n\nCAmkESAddImportPath(${CMAKE_CURRENT_SOURCE_DIR}\/${KernelARMPlatform}\/)\n\n# Define our VM Component with our cross vm dataports glue code\nDeclareCamkesARMVM(\n  VM_RadioDriver_Attestation_Impl_MCMP_PROC_SW_RADIO\n  EXTRA_SOURCES src\/cross_vm_connections_vmRADIO.c\n  EXTRA_LIBS SB_Type_Library\n             SlangTypeLibrary)\n\nDeclareCamkesARMVM(\n  VM_UxAS_Impl_MCMP_PROC_SW_UXAS\n  EXTRA_SOURCES src\/cross_vm_connections_vmUXAS.c\n  EXTRA_LIBS SB_Type_Library\n             SlangTypeLibrary)\n\nCAmkESAddCPPInclude(${CAMKES_ARM_VM_DIR}\/components\/VM)",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/exynos5422\/devices.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n#include <configurations\/vm.h>\n\n#define VM_RAM_OFFSET 0\n#define VM_INITRD_MAX_SIZE 0x1900000 \/\/ 25 MB\n\n#define VM0_RAM_BASE       0x40000000\n#define VM0_RAM_SIZE       0x8000000\n#define VM0_DTB_ADDR       0x47000000  \/\/ VM0_RAM_BASE + 0x7000000\n#define VM0_INITRD_ADDR    0x45700000  \/\/ VM0_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM0_RAM_MMIOS_BASE \"0x40000000:27\"\n\n#define VM1_RAM_BASE       0x50000000\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x57000000  \/\/ VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x55700000  \/\/ VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM1_RAM_MMIOS_BASE \"0x48000000:27\"\n\nassembly {\n  composition {}\n  configuration {\n    vmRADIO.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM0_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM0_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM0_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM0_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM0_INITRD_ADDR),\n    };\n\n    vmRADIO.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 root=\/dev\/ram0 nosmp rw debug loglevel=8 pci=nomsi initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd\",\n    };\n\n    vmRADIO.mmios = [\n      \"0x10000000:0x1000:12\", \/\/ CHIP ID\n      \"0x10486000:0x1000:12\"  \/\/ VCPU\n    ];\n\n    vmRADIO.untyped_mmios = [\n      VM0_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n\n    vmRADIO.irqs = [];\n\n    vmRADIO.dtb = dtb([{}]);\n\n    vmUXAS.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR),\n    };\n\n    vmUXAS.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 root=\/dev\/ram0 nosmp rw debug loglevel=8 pci=nomsi initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd\",\n    };\n\n    vmUXAS.mmios = [\n      \"0x10000000:0x1000:12\", \/\/ CHIP ID\n      \"0x10486000:0x1000:12\"  \/\/ VCPU\n    ];\n\n    vmUXAS.untyped_mmios = [\n      VM1_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n\n    vmUXAS.irqs = [];\n\n    vmUXAS.dtb = dtb([{}]);\n  }\n}",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/qemu-arm-virt\/devices.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n#include <configurations\/vm.h>\n#define VM_RAM_OFFSET      0x00000000\n#define VM_INITRD_MAX_SIZE 0x3200000 \/\/50 MB\n\n#define VM0_RAM_BASE       0x40000000\n#define VM0_RAM_SIZE       0x8000000\n#define VM0_DTB_ADDR       0x47000000 \/\/VM0_RAM_BASE + 0x7000000\n#define VM0_INITRD_ADDR    0x43e00000 \/\/VM0_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM0_MMIOS_ICI      \"0x8040000:0x1000:12\"\n#define VM0_MMIOS_LKMR     \"0x40000000:27\"\n\n\n#define VM1_RAM_BASE       0x48000000\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x4f000000 \/\/VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x4be00000 \/\/VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM1_MMIOS_ICI      \"0x8040000:0x1000:12\"\n#define VM1_MMIOS_LKMR     \"0x48000000:27\"\n\n\nassembly {\n  composition {}\n  configuration {\n    vmRADIO.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM0_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM0_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM0_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM0_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM0_INITRD_ADDR)\n    };\n\n    vmRADIO.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 nosmp rw debug loglevel=8 pci=nomsi,realloc=off,bios initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\": \"\",\n      \"initrd_name\" : \"linux-initrd\"\n    };\n\n    vmRADIO.dtb = dtb([{}]);\n\n    vmRADIO.irq = [];\n\n    vmRADIO.mmios = [\n      VM0_MMIOS_ICI, \/\/ Interrupt Controller Virtual CPU interface (Virtual Machine view)\n    ];\n\n    vmRADIO.untyped_mmios = [\n      VM0_MMIOS_LKMR, \/\/ Linux kernel memory regions\n    ];\n\n\n    vmUXAS.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR)\n    };\n\n    vmUXAS.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 nosmp rw debug loglevel=8 pci=nomsi,realloc=off,bios initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\": \"\",\n      \"initrd_name\" : \"linux-initrd\"\n    };\n\n    vmUXAS.dtb = dtb([{}]);\n\n    vmUXAS.irq = [];\n\n    vmUXAS.mmios = [\n      VM1_MMIOS_ICI, \/\/ Interrupt Controller Virtual CPU interface (Virtual Machine view)\n    ];\n\n    vmUXAS.untyped_mmios = [\n      VM1_MMIOS_LKMR, \/\/ Linux kernel memory regions\n    ];\n\n  }\n}",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/overlay_files\/init_scripts\/cross_vm_module_init",
        {
          "type" : "ITestResource",
          "content" : "#!\/bin\/sh\n\n# Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ninsmod \/lib\/modules\/4.14.87\/kernel\/drivers\/vmm\/connection.ko",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/overlay_files\/init_scripts\/inittab_hvc0",
        {
          "type" : "ITestResource",
          "content" : "# @TAG(CUSTOM)\n# \/etc\/inittab\n#\n# This file will not be overwritten so is safe to edit\n#\n# Copyright (C) 2001 Erik Andersen <andersen@codepoet.org>\n#\n# Note: BusyBox init doesn't support runlevels.  The runlevels field is\n# completely ignored by BusyBox init. If you want runlevels, use\n# sysvinit.\n#\n# Format for each entry: <id>:<runlevels>:<action>:<process>\n#\n# id        == tty to run on, or empty for \/dev\/console\n# runlevels == ignored\n# action    == one of sysinit, respawn, askfirst, wait, and once\n# process   == program to run\n\n# Startup the system\n::sysinit:\/bin\/mount -t proc proc \/proc\n::sysinit:\/bin\/mount -o remount,rw \/\n::sysinit:\/bin\/mkdir -p \/dev\/pts \/dev\/shm\n::sysinit:\/bin\/mount -a\n::sysinit:\/sbin\/swapon -a\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd \/dev\/fd\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/0 \/dev\/stdin\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/1 \/dev\/stdout\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/2 \/dev\/stderr\n::sysinit:\/bin\/hostname -F \/etc\/hostname\n# now run any rc scripts\n::sysinit:\/etc\/init.d\/rcS\n\n# Put a getty on the serial port\nhvc0:2345:respawn:\/sbin\/getty -L 9600 hvc0\n\n# Stuff to do for the 3-finger salute\n#::ctrlaltdel:\/sbin\/reboot\n\n# Stuff to do before rebooting\n::shutdown:\/etc\/init.d\/rcK\n::shutdown:\/sbin\/swapoff -a\n::shutdown:\/bin\/umount -a -r",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/apps\/vmRADIO\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\n# This file will not be overwritten so is safe to edit\n\nproject(vmRADIO C)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_subdirectory(${SlangTypeLibrary_DIR} SlangTypeLibrary)\n\nadd_subdirectory(${SB_Type_Library_DIR} SB_Type_Library)\n\nadd_executable(vmRADIO vmRADIO.c)\n\ntarget_link_libraries(vmRADIO\n                      SB_Type_Library\n                      SlangTypeLibrary\n                      -static-libgcc -static)",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/apps\/vmRADIO\/vmRADIO.c",
        {
          "type" : "ITestResource",
          "content" : "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/mman.h>\n#include <errno.h>\n\n#include <sb_types.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int8_t_1.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nint main(int argc, char *argv[]) {\n  printf(\"VM App vmRADIO started\\n\");\n  return 0;\n}",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/apps\/vmUXAS\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\n# This file will not be overwritten so is safe to edit\n\nproject(vmUXAS C)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_subdirectory(${SlangTypeLibrary_DIR} SlangTypeLibrary)\n\nadd_subdirectory(${SB_Type_Library_DIR} SB_Type_Library)\n\nadd_executable(vmUXAS vmUXAS.c)\n\ntarget_link_libraries(vmUXAS\n                      SB_Type_Library\n                      SlangTypeLibrary\n                      -static-libgcc -static)",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/components\/VM\/apps\/vmUXAS\/vmUXAS.c",
        {
          "type" : "ITestResource",
          "content" : "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/mman.h>\n#include <errno.h>\n\n#include <sb_types.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int8_t_1.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nint main(int argc, char *argv[]) {\n  printf(\"VM App vmUXAS started\\n\");\n  return 0;\n}",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/includes\/sb_queue_int8_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h>\n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain\n\/\/ SB_QUEUE_INT8_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT8_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int8_t_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int8_t\n  \/\/ (see sb_types.h) implemented as a ring buffer.\n  \/\/ No initialization necessary.\n  int8_t elt[SB_QUEUE_INT8_T_1_SIZE];\n\n} sb_queue_int8_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue,\n  int8_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int8_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int8_t_1_t *queue;\n\n} sb_queue_int8_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_queue_int8_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time.\n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int8_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int8_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int8_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/src\/sb_queue_int8_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int8_t_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue,\n  int8_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization.\n  \/\/ elt[queue->numSent % SB_QUEUE_INT8_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT8_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_queue_int8_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue,\n  sb_event_counter_t *numDropped,\n  int8_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int8_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT8_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT8_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT8_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT8_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT8_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped);\n    return false;\n  }\n}\n\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/kernel\/domain_schedule.c",
        {
          "type" : "ITestResource",
          "content" : "#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ this file will not be overwritten and is safe to edit\n\n\/************************************************************\n\n   This is a kernel data structure containing an example schedule.\n   The length is in seL4 ticks (2 ms).\n   This schedule should be generated from the AADL model\n   using execution time and data flow latency specifications.\n\n   Pacer runs at highest rate and should always be in domain 1\n\n   Properties from AADL Model\n   --------------------------\n\n     Timing_Properties::Clock_Period : 2 ms\n     Timing_Properties::Frame_Period : 1000 ms\n\n     UARTDriver\n     ----------\n\n       CASE_Scheduling::Domain : 3\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 500 ms\n\n     RadioDriver_Attestation\n     -----------------------\n\n       CASE_Scheduling::Domain : 2\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     FlyZonesDatabase\n     ----------------\n\n       CASE_Scheduling::Domain : 10\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     UxAS\n     ----\n\n       CASE_Scheduling::Domain : 9\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     WaypointPlanManagerService\n     --------------------------\n\n       CASE_Scheduling::Domain : 14\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_AttestationGate\n     --------------------\n\n       CASE_Scheduling::Domain : 5\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_Filter_LST\n     ---------------\n\n       CASE_Scheduling::Domain : 7\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_Monitor_Req\n     ----------------\n\n       CASE_Scheduling::Domain : 11\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_Monitor_Geo\n     ----------------\n\n       CASE_Scheduling::Domain : 13\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 2 ms\n       Timing_Properties::Period : 500 ms\n\n *********************************************************\/\n\nconst int dom0swapTime = 10; \n\nconst dschedule_t ksDomSchedule[] = {\n  { .domain = 0, .length = 100 },  \/\/ all other seL4 threads, init, 200ms\n  { .domain = 1, .length = 5 },  \/\/ pacer 10ms.  Should always be in domain 1\n  { .domain = 0, .length = 5 },  \/\/ deliver pacer pulses\n\n  { .domain = 2, .length = 50 },  \/\/ RadioDriver_Attestation  \n\n  { .domain = 3, .length = 5 },  \/\/ UARTDriver  \n  { .domain = 5, .length = 5 },  \/\/ CASE_AttestationGate  \n  { .domain = 7, .length = 5 },  \/\/ CASE_Filter_LST  \n\n  { .domain = 9, .length = 50 },  \/\/ UxAS  \n\n  { .domain = 10, .length = 5 },  \/\/ FlyZonesDatabase  \n  { .domain = 11, .length = 5 },  \/\/ CASE_Monitor_Req  \n  { .domain = 14, .length = 5 },  \/\/ WaypointPlanManagerService  \n  { .domain = 13, .length = 5 },  \/\/ CASE_Monitor_Geo \n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n# Add virtual PCI device to VMM for registering cross component connectors as\n# devices on the PCI bus.\nset(VmPCISupport ON CACHE BOOL \"\" FORCE)\n\n# Disable libusb from being compiled.\nset(LibUSB OFF CACHE BOOL \"\" FORCE)\n\n# Enables the option for the VM to open and load a seperate initrd file\nset(VmInitRdFile ON CACHE BOOL \"\" FORCE)\n\n# Enable virtio console vmm module\nset(VmVirtioConsole ON CACHE BOOL \"\" FORCE)\n\n# Make VTimers see absolute time rather than virtual time.\nset(KernelArmVtimerUpdateVOffset OFF CACHE BOOL \"\" FORCE)\n\n# Don't trap WFI or WFE instructions in a VM.\nset(KernelArmDisableWFIWFETraps ON CACHE BOOL \"\" FORCE)\n\nif(\"${PLATFORM}\" STREQUAL \"qemu-arm-virt\")\n\n    set(KernelArmCPU cortex-a53 CACHE STRING \"\" FORCE)\n    set(KernelArmExportPCNTUser ON CACHE BOOL \"\" FORCE)\n    set(KernelArmExportPTMRUser ON CACHE BOOL \"\" FORCE)\n\n    set(MIN_QEMU_VERSION \"4.0.0\")\n    execute_process(COMMAND qemu-system-aarch64 -version OUTPUT_VARIABLE QEMU_VERSION_STR)\n    string(\n        REGEX\n            MATCH\n            \"[0-9](\\\\.[0-9])+\"\n            QEMU_VERSION\n            ${QEMU_VERSION_STR}\n    )\n    if(\"${QEMU_VERSION}\" VERSION_LESS \"${MIN_QEMU_VERSION}\")\n        message(WARNING \"Warning: qemu version should be at least ${MIN_QEMU_VERSION}\")\n    endif()\n\nendif()\n# Add virtual PCI device to VMM for registering cross component connectors as\n# devices on the PCI bus.\nset(VmPCISupport ON CACHE BOOL \"\" FORCE)\n\n# Disable libusb from being compiled.\nset(LibUSB OFF CACHE BOOL \"\" FORCE)\n\n# Enables the option for the VM to open and load a seperate initrd file\nset(VmInitRdFile ON CACHE BOOL \"\" FORCE)\n\n# Enable virtio console vmm module\nset(VmVirtioConsole ON CACHE BOOL \"\" FORCE)\n\n# Make VTimers see absolute time rather than virtual time.\nset(KernelArmVtimerUpdateVOffset OFF CACHE BOOL \"\" FORCE)\n\n# Don't trap WFI or WFE instructions in a VM.\nset(KernelArmDisableWFIWFETraps ON CACHE BOOL \"\" FORCE)\n\nif(\"${PLATFORM}\" STREQUAL \"qemu-arm-virt\")\n\n    set(KernelArmCPU cortex-a53 CACHE STRING \"\" FORCE)\n    set(KernelArmExportPCNTUser ON CACHE BOOL \"\" FORCE)\n    set(KernelArmExportPTMRUser ON CACHE BOOL \"\" FORCE)\n\n    set(MIN_QEMU_VERSION \"4.0.0\")\n    execute_process(COMMAND qemu-system-aarch64 -version OUTPUT_VARIABLE QEMU_VERSION_STR)\n    string(\n        REGEX\n            MATCH\n            \"[0-9](\\\\.[0-9])+\"\n            QEMU_VERSION\n            ${QEMU_VERSION_STR}\n    )\n    if(\"${QEMU_VERSION}\" VERSION_LESS \"${MIN_QEMU_VERSION}\")\n        message(WARNING \"Warning: qemu version should be at least ${MIN_QEMU_VERSION}\")\n    endif()\n\nendif()\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 16 CACHE STRING \"\" FORCE)\n",
          "markers" : [
          ],
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# Do not edit this file as it will be overwritten if HAMR codegen is rerun\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_union_art_DataContent_1.c\n            src\/sb_queue_int8_t_1.c\n            src\/sp_union_art_DataContent.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ],
      [
        "camkes\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n(declare-datatypes ((Option 1))\n  ((par (T) ((Some (value T))\n             (None)))))\n\n(declare-datatypes ((Mode 0)) ((\n  (SeL4)\n  (SeL4_Only)\n  (SeL4_TB))))\n\n(declare-datatypes ((ComponentCategory 0)) ((\n  (Abstract)\n  (Bus)\n  (Data)\n  (Device)\n  (Memory)\n  (Process)\n  (Processor)\n  (Subprogram)\n  (SubprogramGroup)\n  (System)\n  (Thread)\n  (ThreadGroup)\n  (VirtualBus)\n  (VirtualProcessor))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out)\n  (InOut))))\n\n(declare-datatypes ((FeatureCategory 0)) ((\n  (AbstractFeature)\n  (BusAccess)\n  (DataAccess)\n  (DataPort)\n  (EventPort)\n  (EventDataPort)\n  (FeatureGroup)\n  (Parameter)\n  (SubprogramAccess)\n  (SubprogramAccessGroup))))\n\n\n(declare-const CodegenMode Mode)\n(assert (= CodegenMode SeL4))\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType Pacing))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                                AADL Model                              ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare-datatypes ((AadlComponent 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)\n  (UAV_Impl_Instance_MCMP_PROC_HW)\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO)\n  (UAV_Impl_Instance_MCMP_VM_Radio)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS)\n  (UAV_Impl_Instance_MCMP_VM_UxAS)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n)))\n(declare-const AadlComponent_count Int)\n(assert (= 12 AadlComponent_count))\n\n(declare-const AadlComponentCategory (Array AadlComponent (Option ComponentCategory)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Process) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_RADIO)))\n  (assert (= (Some VirtualProcessor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_VM_Radio)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Process) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS)))\n  (assert (= (Some VirtualProcessor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_VM_UxAS)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n  (assert (= (Some Thread) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)))\n  (assert (= (Some Processor) (select AadlComponentCategory UAV_Impl_Instance_MCMP_PROC_HW)))\n\n(declare-const ProcessorBindings (Array AadlComponent (Option AadlComponent)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_VM_Radio) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_RADIO)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_VM_UxAS) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_UXAS)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_HW) (select ProcessorBindings UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)))\n\n(declare-const AadlDispatchProtocol (Array AadlComponent (Option DispatchProtocol)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_VM_Radio)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_VM_UxAS)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)))\n  (assert (= (Some Periodic) (select AadlDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)))\n(declare-const AadlDispatchProtocol_size Int)\n(assert (= 9 AadlDispatchProtocol_size))\n\n(declare-datatypes ((AadlPort 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS)\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids)\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest)\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion)\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in)\n  (UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output)\n  (UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert))))\n(declare-const AadlPort_count Int)\n(assert (= 36 AadlPort_count))\n\n(declare-const AadlPortComponent (Array AadlPort (Option AadlComponent)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output)))\n  (assert (= (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) (select AadlPortComponent UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert)))\n(declare-const AadlPortComponent_size Int)\n(assert (= 36 AadlPortComponent_size))\n\n(declare-const AadlFeatureCategory (Array AadlPort FeatureCategory))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask)))\n  (assert (= DataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones)))\n  (assert (= DataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand)))\n  (assert (= EventPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1)))\n  (assert (= DataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones)))\n  (assert (= DataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed)))\n  (assert (= EventDataPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output)))\n  (assert (= EventPort (select AadlFeatureCategory UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert)))\n(declare-const AadlFeatureCategory_size Int)\n(assert (= 36 AadlFeatureCategory_size))\n\n(declare-const AadlPortDirection (Array AadlPort Direction))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones)))\n  (assert (= In (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output)))\n  (assert (= Out (select AadlPortDirection UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert)))\n(declare-const AadlPortDirection_size Int)\n(assert (= 36 AadlPortDirection_size))\n\n(define-fun AadlConnectionFlowTos ((p1 AadlPort) (p2 AadlPort)) Bool\n  (or\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome))\n    false))\n(declare-const AadlConnectionFlowsTos_count Int)\n(assert (= 18 AadlConnectionFlowsTos_count))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                              CAmkES Model                              ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare-datatypes ((AccessType 0)) ((\n  (R)\n  (W)\n  (RW))))\n\n(declare-datatypes ((seL4ConnectorType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4RPCDataport)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4SerialServer)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (MCMP_PROC_SW_FC_UART_UARTDriver)\n  (vmRADIO)\n  (fserv)\n  (serial)\n  (time_server)\n  (MCMP_PROC_SW_FlyZones_FlyZonesDatabase)\n  (vmUXAS)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)\n  (pacer))))\n(declare-const CAmkESComponent_count Int)\n(assert (= 13 CAmkESComponent_count))\n\n(define-fun isPeriodicDispatcher ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       false))\n\n(define-fun isPacer ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (= _component pacer)))\n\n(define-fun isFileServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a file server is expected\n       (= _component fserv)))\n\n(define-fun isTimeServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a time server is expected\n       (= _component time_server)))\n\n(define-fun isSerialServer ((_component CAmkESComponent)) Bool\n  (and ; TODO: list scenarios where a serial server is expected\n       (= _component serial)))\n\n(declare-datatypes ((CAmkESPort 0)) ((\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_queue)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_queue_1)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_queue_1)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_1_notification)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_1_notification)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_notification)\n  (MCMP_PROC_SW_FC_UART_UARTDriver_sb_pacer_notification)\n  (vmRADIO_sb_trusted_ids_queue_1)\n  (vmRADIO_sb_AutomationRequest_queue_1)\n  (vmRADIO_sb_OperatingRegion_queue_1)\n  (vmRADIO_sb_LineSearchTask_queue_1)\n  (vmRADIO_sb_pacer_period_queue)\n  (vmRADIO_notification_ready_connector)\n  (vmRADIO_sb_trusted_ids_1_notification)\n  (vmRADIO_sb_AutomationRequest_1_notification)\n  (vmRADIO_sb_OperatingRegion_1_notification)\n  (vmRADIO_sb_LineSearchTask_1_notification)\n  (vmRADIO_fs)\n  (vmRADIO_batch)\n  (vmRADIO_guest_putchar)\n  (vmRADIO_serial_getchar)\n  (vmRADIO_recv)\n  (vmRADIO_send)\n  (vmRADIO_dtb_self)\n  (vmRADIO_restart_event)\n  (vmRADIO_notification_ready)\n  (vmRADIO_sb_pacer_period_notification)\n  (vmRADIO_dtb)\n  (fserv_fs_ctrl)\n  (serial_getchar)\n  (serial_processed_batch)\n  (serial_timeout)\n  (time_server_the_timer)\n  (MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_in_zones)\n  (MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_out_zones)\n  (MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_pacer_notification)\n  (vmUXAS_sb_AirVehicleState_queue)\n  (vmUXAS_sb_AutomationResponse_MON_GEO_queue_1)\n  (vmUXAS_sb_AutomationResponse_MON_REQ_queue_1)\n  (vmUXAS_sb_AutomationRequest_queue)\n  (vmUXAS_sb_OperatingRegion_queue)\n  (vmUXAS_sb_LineSearchTask_queue)\n  (vmUXAS_sb_pacer_period_queue)\n  (vmUXAS_notification_ready_connector)\n  (vmUXAS_sb_AutomationResponse_MON_GEO_1_notification)\n  (vmUXAS_sb_AutomationResponse_MON_REQ_1_notification)\n  (vmUXAS_fs)\n  (vmUXAS_batch)\n  (vmUXAS_guest_putchar)\n  (vmUXAS_serial_getchar)\n  (vmUXAS_recv)\n  (vmUXAS_send)\n  (vmUXAS_dtb_self)\n  (vmUXAS_restart_event)\n  (vmUXAS_notification_ready)\n  (vmUXAS_sb_AirVehicleState_notification)\n  (vmUXAS_sb_AutomationRequest_notification)\n  (vmUXAS_sb_OperatingRegion_notification)\n  (vmUXAS_sb_LineSearchTask_notification)\n  (vmUXAS_sb_pacer_period_notification)\n  (vmUXAS_dtb)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_queue)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_queue)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_queue_1)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome_counter)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_1_notification)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_notification)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_notification)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome)\n  (MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_pacer_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_queue)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_queue)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_queue_1)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_queue_1)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_queue)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_queue_1)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_queue)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_queue_1)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_1_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_1_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_1_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_1_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_notification)\n  (MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_pacer_notification)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_queue)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_queue_1)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_1_notification)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_notification)\n  (MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_pacer_notification)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_queue)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_queue)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_notification)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_notification)\n  (MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_pacer_notification)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_in_zones)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_out_zones)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_queue)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_queue_1)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert_counter)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_1_notification)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_notification)\n  (MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_pacer_notification)\n  (pacer_period_to_vmRADIO_queue)\n  (pacer_period_to_vmUXAS_queue)\n  (pacer_period_to_vmRADIO_notification)\n  (pacer_period_to_vmUXAS_notification)\n  (pacer_period)\n  (pacer_tick)\n  (pacer_tock))))\n(declare-const CAmkESPort_count Int)\n(assert (= 113 CAmkESPort_count))\n\n(declare-const CAmkESAccessRestrictions (Array CAmkESPort AccessType))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions vmUXAS_sb_AirVehicleState_queue)))\n  (assert (= RW (select CAmkESAccessRestrictions vmRADIO_sb_trusted_ids_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_queue)))\n  (assert (= RW (select CAmkESAccessRestrictions vmRADIO_sb_AutomationRequest_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_queue)))\n  (assert (= RW (select CAmkESAccessRestrictions vmRADIO_sb_OperatingRegion_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_queue)))\n  (assert (= RW (select CAmkESAccessRestrictions vmRADIO_sb_LineSearchTask_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_in_zones)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_in_zones)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_out_zones)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_out_zones)))\n  (assert (= RW (select CAmkESAccessRestrictions vmUXAS_sb_AutomationResponse_MON_GEO_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_queue)))\n  (assert (= RW (select CAmkESAccessRestrictions vmUXAS_sb_AutomationResponse_MON_REQ_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions vmUXAS_sb_AutomationRequest_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions vmUXAS_sb_OperatingRegion_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions vmUXAS_sb_LineSearchTask_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert_counter)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome_counter)))\n  (assert (= W (select CAmkESAccessRestrictions pacer_period_to_vmRADIO_queue)))\n  (assert (= R (select CAmkESAccessRestrictions vmRADIO_sb_pacer_period_queue)))\n  (assert (= W (select CAmkESAccessRestrictions pacer_period_to_vmUXAS_queue)))\n  (assert (= R (select CAmkESAccessRestrictions vmUXAS_sb_pacer_period_queue)))\n(declare-const CAmkESAccessRestrictions_size Int)\n(assert (= 40 CAmkESAccessRestrictions_size))\n\n(declare-datatypes ((CAmkESConnection 0)) ((\n  (conn1)\n  (conn2)\n  (conn3)\n  (conn4)\n  (conn5)\n  (conn6)\n  (conn7)\n  (conn8)\n  (conn9)\n  (conn10)\n  (conn11)\n  (conn12)\n  (conn13)\n  (conn14)\n  (conn15)\n  (conn16)\n  (conn17)\n  (conn18)\n  (conn19)\n  (conn20)\n  (conn21)\n  (conn22)\n  (conn23)\n  (conn24)\n  (conn25)\n  (conn26)\n  (conn27)\n  (conn28)\n  (conn29)\n  (conn30)\n  (conn31)\n  (conn32)\n  (conn33)\n  (conn34)\n  (conn35)\n  (conn36)\n  (conn37)\n  (conn38)\n  (conn39)\n  (conn40)\n  (conn41)\n  (conn42)\n  (conn43)\n  (conn44)\n  (conn45)\n  (conn46)\n  (conn47)\n  (conn48)\n  (conn49)\n  (conn50)\n  (conn51)\n  (conn52)\n  (conn53)\n  (conn54)\n  (conn55)\n  (conn56)\n  (conn57))))\n(declare-const CAmkESConnection_count Int)\n(assert (= 57 CAmkESConnection_count))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or \n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or (= _conn conn46)\n           (= _conn conn47)\n           (= _conn conn48)\n           (= _conn conn49)\n           (= _conn conn50)\n           (= _conn conn51)\n           (= _conn conn52)\n           (= _conn conn53)\n           (= _conn conn54)\n           (= _conn conn55)\n           (= _conn conn56)\n           (= _conn conn57)\n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n           false)))\n(declare-const PeriodicDispatchingConnection_count Int)\n(assert (= 0 PeriodicDispatchingConnection_count))\n\n; non Aadl connection refinement connections required by a VM\n(define-fun isVMAuxConnection ((_conn CAmkESConnection)) Bool\n  (or (= _conn conn1)\n      (= _conn conn2)\n      (= _conn conn3)\n      (= _conn conn4)\n      (= _conn conn5)\n      (= _conn conn6)\n      (= _conn conn7)\n      (= _conn conn8)\n      (= _conn conn9)\n      (= _conn conn10)\n      (= _conn conn11)\n      false))\n\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4ConnectorType))\n  (assert (= seL4RPCDataport (select CAmkESConnectionType conn1)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn2)))\n  (assert (= seL4VMDTBPassthrough (select CAmkESConnectionType conn3)))\n  (assert (= seL4TimeServer (select CAmkESConnectionType conn4)))\n  (assert (= seL4SerialServer (select CAmkESConnectionType conn5)))\n  (assert (= seL4SerialServer (select CAmkESConnectionType conn6)))\n  (assert (= seL4RPCDataport (select CAmkESConnectionType conn7)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn8)))\n  (assert (= seL4VMDTBPassthrough (select CAmkESConnectionType conn9)))\n  (assert (= seL4SerialServer (select CAmkESConnectionType conn10)))\n  (assert (= seL4SerialServer (select CAmkESConnectionType conn11)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn12)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn13)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn14)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn15)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn16)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn17)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn18)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn19)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn20)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn21)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn22)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn23)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn24)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn25)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn26)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn27)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn28)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn29)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn30)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn31)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn32)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn33)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn34)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn35)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn36)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn37)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn38)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn39)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn40)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn41)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn42)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn43)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn44)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn45)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn46)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn47)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn48)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn49)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn50)))\n  (assert (= seL4GlobalAsynch (select CAmkESConnectionType conn51)))\n  (assert (= seL4SharedDataWithCaps (select CAmkESConnectionType conn52)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn53)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn54)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn55)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn56)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn57)))\n(declare-const CAmkESConnectionType_count Int)\n(assert (= 57 CAmkESConnectionType_count))\n\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_queue)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_queue_1)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_queue_1)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_1_notification)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_1_notification)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_notification)))\n  (assert (= MCMP_PROC_SW_FC_UART_UARTDriver (select CAmkESPortComponent MCMP_PROC_SW_FC_UART_UARTDriver_sb_pacer_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_trusted_ids_queue_1)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_AutomationRequest_queue_1)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_OperatingRegion_queue_1)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_LineSearchTask_queue_1)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_pacer_period_queue)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_notification_ready_connector)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_trusted_ids_1_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_AutomationRequest_1_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_OperatingRegion_1_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_LineSearchTask_1_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_fs)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_batch)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_guest_putchar)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_serial_getchar)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_recv)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_send)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_dtb_self)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_restart_event)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_notification_ready)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_sb_pacer_period_notification)))\n  (assert (= vmRADIO (select CAmkESPortComponent vmRADIO_dtb)))\n  (assert (= fserv (select CAmkESPortComponent fserv_fs_ctrl)))\n  (assert (= serial (select CAmkESPortComponent serial_getchar)))\n  (assert (= serial (select CAmkESPortComponent serial_processed_batch)))\n  (assert (= serial (select CAmkESPortComponent serial_timeout)))\n  (assert (= time_server (select CAmkESPortComponent time_server_the_timer)))\n  (assert (= MCMP_PROC_SW_FlyZones_FlyZonesDatabase (select CAmkESPortComponent MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_in_zones)))\n  (assert (= MCMP_PROC_SW_FlyZones_FlyZonesDatabase (select CAmkESPortComponent MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_out_zones)))\n  (assert (= MCMP_PROC_SW_FlyZones_FlyZonesDatabase (select CAmkESPortComponent MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_pacer_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AirVehicleState_queue)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationResponse_MON_GEO_queue_1)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationResponse_MON_REQ_queue_1)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationRequest_queue)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_OperatingRegion_queue)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_LineSearchTask_queue)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_pacer_period_queue)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_notification_ready_connector)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationResponse_MON_GEO_1_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationResponse_MON_REQ_1_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_fs)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_batch)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_guest_putchar)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_serial_getchar)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_recv)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_send)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_dtb_self)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_restart_event)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_notification_ready)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AirVehicleState_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_AutomationRequest_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_OperatingRegion_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_LineSearchTask_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_sb_pacer_period_notification)))\n  (assert (= vmUXAS (select CAmkESPortComponent vmUXAS_dtb)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_queue)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_queue)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_queue_1)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome_counter)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_1_notification)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_notification)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_notification)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome)))\n  (assert (= MCMP_PROC_SW_WPM_WaypointPlanManagerService (select CAmkESPortComponent MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_pacer_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_queue)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_queue)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_queue_1)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_queue_1)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_queue)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_queue_1)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_queue)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_queue_1)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_1_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_1_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_1_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_1_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_notification)))\n  (assert (= MCMP_PROC_SW_AM_Gate_CASE_AttestationGate (select CAmkESPortComponent MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_pacer_notification)))\n  (assert (= MCMP_PROC_SW_FLT_LST_CASE_Filter_LST (select CAmkESPortComponent MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_queue)))\n  (assert (= MCMP_PROC_SW_FLT_LST_CASE_Filter_LST (select CAmkESPortComponent MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_queue_1)))\n  (assert (= MCMP_PROC_SW_FLT_LST_CASE_Filter_LST (select CAmkESPortComponent MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_1_notification)))\n  (assert (= MCMP_PROC_SW_FLT_LST_CASE_Filter_LST (select CAmkESPortComponent MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_notification)))\n  (assert (= MCMP_PROC_SW_FLT_LST_CASE_Filter_LST (select CAmkESPortComponent MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_pacer_notification)))\n  (assert (= MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req (select CAmkESPortComponent MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_queue)))\n  (assert (= MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req (select CAmkESPortComponent MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_queue)))\n  (assert (= MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req (select CAmkESPortComponent MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_notification)))\n  (assert (= MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req (select CAmkESPortComponent MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_notification)))\n  (assert (= MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req (select CAmkESPortComponent MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_pacer_notification)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_in_zones)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_out_zones)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_queue)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_queue_1)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert_counter)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_1_notification)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_notification)))\n  (assert (= MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo (select CAmkESPortComponent MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_pacer_notification)))\n  (assert (= pacer (select CAmkESPortComponent pacer_period_to_vmRADIO_queue)))\n  (assert (= pacer (select CAmkESPortComponent pacer_period_to_vmUXAS_queue)))\n  (assert (= pacer (select CAmkESPortComponent pacer_period_to_vmRADIO_notification)))\n  (assert (= pacer (select CAmkESPortComponent pacer_period_to_vmUXAS_notification)))\n  (assert (= pacer (select CAmkESPortComponent pacer_period)))\n  (assert (= pacer (select CAmkESPortComponent pacer_tick)))\n  (assert (= pacer (select CAmkESPortComponent pacer_tock)))\n(declare-const CAmkESPortComponent_size Int)\n(assert (= 113 CAmkESPortComponent_size))\n\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    (and (= _conn conn1) (= _p1 vmRADIO_fs) (= _p2 fserv_fs_ctrl))\n    (and (= _conn conn2) (= _p1 vmRADIO_notification_ready_connector) (= _p2 vmRADIO_notification_ready))\n    (and (= _conn conn3) (= _p1 vmRADIO_dtb_self) (= _p2 vmRADIO_dtb))\n    (and (= _conn conn4) (= _p1 serial_timeout) (= _p2 time_server_the_timer))\n    (and (= _conn conn5) (= _p1 vmRADIO_batch) (= _p2 serial_processed_batch))\n    (and (= _conn conn6) (= _p1 vmRADIO_serial_getchar) (= _p2 serial_getchar))\n    (and (= _conn conn7) (= _p1 vmUXAS_fs) (= _p2 fserv_fs_ctrl))\n    (and (= _conn conn8) (= _p1 vmUXAS_notification_ready_connector) (= _p2 vmUXAS_notification_ready))\n    (and (= _conn conn9) (= _p1 vmUXAS_dtb_self) (= _p2 vmUXAS_dtb))\n    (and (= _conn conn10) (= _p1 vmUXAS_batch) (= _p2 serial_processed_batch))\n    (and (= _conn conn11) (= _p1 vmUXAS_serial_getchar) (= _p2 serial_getchar))\n    (and (= _conn conn12) (= _p1 MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_1_notification) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_notification))\n    (and (= _conn conn13) (= _p1 MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_queue_1) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_queue))\n    (and (= _conn conn14) (= _p1 MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_1_notification) (= _p2 vmUXAS_sb_AirVehicleState_notification))\n    (and (= _conn conn15) (= _p1 MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_queue_1) (= _p2 vmUXAS_sb_AirVehicleState_queue))\n    (and (= _conn conn16) (= _p1 vmRADIO_sb_trusted_ids_1_notification) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_notification))\n    (and (= _conn conn17) (= _p1 vmRADIO_sb_trusted_ids_queue_1) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_queue))\n    (and (= _conn conn18) (= _p1 vmRADIO_sb_AutomationRequest_1_notification) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_notification))\n    (and (= _conn conn19) (= _p1 vmRADIO_sb_AutomationRequest_queue_1) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_queue))\n    (and (= _conn conn20) (= _p1 vmRADIO_sb_OperatingRegion_1_notification) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_notification))\n    (and (= _conn conn21) (= _p1 vmRADIO_sb_OperatingRegion_queue_1) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_queue))\n    (and (= _conn conn22) (= _p1 vmRADIO_sb_LineSearchTask_1_notification) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_notification))\n    (and (= _conn conn23) (= _p1 vmRADIO_sb_LineSearchTask_queue_1) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_queue))\n    (and (= _conn conn24) (= _p1 MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_in_zones) (= _p2 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_in_zones))\n    (and (= _conn conn25) (= _p1 MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_out_zones) (= _p2 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_out_zones))\n    (and (= _conn conn26) (= _p1 vmUXAS_sb_AutomationResponse_MON_GEO_1_notification) (= _p2 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_notification))\n    (and (= _conn conn27) (= _p1 vmUXAS_sb_AutomationResponse_MON_GEO_queue_1) (= _p2 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_queue))\n    (and (= _conn conn28) (= _p1 vmUXAS_sb_AutomationResponse_MON_REQ_1_notification) (= _p2 MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_notification))\n    (and (= _conn conn29) (= _p1 vmUXAS_sb_AutomationResponse_MON_REQ_queue_1) (= _p2 MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_queue))\n    (and (= _conn conn30) (= _p1 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_1_notification) (= _p2 MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_notification))\n    (and (= _conn conn31) (= _p1 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_queue_1) (= _p2 MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_queue))\n    (and (= _conn conn32) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_1_notification) (= _p2 vmUXAS_sb_AutomationRequest_notification))\n    (and (= _conn conn33) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_queue_1) (= _p2 vmUXAS_sb_AutomationRequest_queue))\n    (and (= _conn conn34) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_1_notification) (= _p2 MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_notification))\n    (and (= _conn conn35) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_queue_1) (= _p2 MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_queue))\n    (and (= _conn conn36) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_1_notification) (= _p2 vmUXAS_sb_OperatingRegion_notification))\n    (and (= _conn conn37) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_queue_1) (= _p2 vmUXAS_sb_OperatingRegion_queue))\n    (and (= _conn conn38) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_1_notification) (= _p2 MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_notification))\n    (and (= _conn conn39) (= _p1 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_queue_1) (= _p2 MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_queue))\n    (and (= _conn conn40) (= _p1 MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_1_notification) (= _p2 vmUXAS_sb_LineSearchTask_notification))\n    (and (= _conn conn41) (= _p1 MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_queue_1) (= _p2 vmUXAS_sb_LineSearchTask_queue))\n    (and (= _conn conn42) (= _p1 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_1_notification) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_notification))\n    (and (= _conn conn43) (= _p1 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_queue_1) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_queue))\n    (and (= _conn conn44) (= _p1 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome))\n    (and (= _conn conn45) (= _p1 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert_counter) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome_counter))\n    (and (= _conn conn46) (= _p1 pacer_tick) (= _p2 pacer_tock))\n    (and (= _conn conn47) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_FC_UART_UARTDriver_sb_pacer_notification))\n    (and (= _conn conn48) (= _p1 pacer_period_to_vmRADIO_notification) (= _p2 vmRADIO_sb_pacer_period_notification))\n    (and (= _conn conn49) (= _p1 pacer_period_to_vmRADIO_queue) (= _p2 vmRADIO_sb_pacer_period_queue))\n    (and (= _conn conn50) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_pacer_notification))\n    (and (= _conn conn51) (= _p1 pacer_period_to_vmUXAS_notification) (= _p2 vmUXAS_sb_pacer_period_notification))\n    (and (= _conn conn52) (= _p1 pacer_period_to_vmUXAS_queue) (= _p2 vmUXAS_sb_pacer_period_queue))\n    (and (= _conn conn53) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_pacer_notification))\n    (and (= _conn conn54) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_pacer_notification))\n    (and (= _conn conn55) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_pacer_notification))\n    (and (= _conn conn56) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_pacer_notification))\n    (and (= _conn conn57) (= _p1 pacer_period) (= _p2 MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_pacer_notification))\n    false))\n(declare-const CAmkESConnectionFlowTos_count Int)\n(assert (= 57 CAmkESConnectionFlowTos_count))\n\n(define-fun ComponentRefinement ((ac (Option AadlComponent)) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver)) (= cc MCMP_PROC_SW_FC_UART_UARTDriver))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_RADIO)) (= cc vmRADIO))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase)) (= cc MCMP_PROC_SW_FlyZones_FlyZonesDatabase))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_UXAS)) (= cc vmUXAS))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService)) (= cc MCMP_PROC_SW_WPM_WaypointPlanManagerService))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate)) (= cc MCMP_PROC_SW_AM_Gate_CASE_AttestationGate))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST)) (= cc MCMP_PROC_SW_FLT_LST_CASE_Filter_LST))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req)) (= cc MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req))\n    (and (= ac (Some UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo)) (= cc MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo))\n    false))\n(declare-const ComponentRefinement_count Int)\n(assert (= 9 ComponentRefinement_count))\n\n(define-fun PortRefinement ((ap AadlPort) (cp CAmkESPort)) Bool\n  (or\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_WPM_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_AirVehicleState_UXAS_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand) (= cp MCMP_PROC_SW_FC_UART_UARTDriver_sb_MissionCommand_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids) (= cp vmRADIO_sb_trusted_ids_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest) (= cp vmRADIO_sb_AutomationRequest_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion) (= cp vmRADIO_sb_OperatingRegion_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask) (= cp vmRADIO_sb_LineSearchTask_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_trusted_ids) (= cp vmRADIO_sb_trusted_ids_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_AutomationRequest) (= cp vmRADIO_sb_AutomationRequest_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_OperatingRegion) (= cp vmRADIO_sb_OperatingRegion_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_LineSearchTask) (= cp vmRADIO_sb_LineSearchTask_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones) (= cp MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_in_zones))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones) (= cp MCMP_PROC_SW_FlyZones_FlyZonesDatabase_sb_keep_out_zones))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState) (= cp vmUXAS_sb_AirVehicleState_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO) (= cp vmUXAS_sb_AutomationResponse_MON_GEO_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ) (= cp vmUXAS_sb_AutomationResponse_MON_REQ_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest) (= cp vmUXAS_sb_AutomationRequest_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion) (= cp vmUXAS_sb_OperatingRegion_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask) (= cp vmUXAS_sb_LineSearchTask_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_GEO) (= cp vmUXAS_sb_AutomationResponse_MON_GEO_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationResponse_MON_REQ) (= cp vmUXAS_sb_AutomationResponse_MON_REQ_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AirVehicleState) (= cp vmUXAS_sb_AirVehicleState_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_AutomationRequest) (= cp vmUXAS_sb_AutomationRequest_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_OperatingRegion) (= cp vmUXAS_sb_OperatingRegion_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UXAS_LineSearchTask) (= cp vmUXAS_sb_LineSearchTask_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome_counter))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_MissionCommand_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AutomationResponse_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_AirVehicleState_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome) (= cp MCMP_PROC_SW_WPM_WaypointPlanManagerService_sb_ReturnHome))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_UXAS_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_out_MON_REQ_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_out_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_out_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_trusted_ids_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_AutomationRequest_in_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_OperatingRegion_in_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in) (= cp MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_sb_LineSearchTask_in_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in) (= cp MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out) (= cp MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out) (= cp MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_out_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in) (= cp MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_sb_filter_in_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed) (= cp MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1) (= cp MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed) (= cp MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_observed_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1) (= cp MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_sb_reference_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_in_zones))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_keep_out_zones))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert_counter))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_output_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_alert))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed) (= cp MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_sb_observed_notification))\n    false))\n(declare-const PortRefinement_count Int)\n(assert (= 68 PortRefinement_count))\n\n(define-fun isVMAuxPort ((cp CAmkESPort)) Bool\n  (exists ((cc CAmkESComponent))\n    (and (= cc (select CAmkESPortComponent cp))\n         (or (and (= cc vmRADIO)\n                  (or (= cp vmRADIO_notification_ready_connector) (= cp vmRADIO_fs) (= cp vmRADIO_batch) (= cp vmRADIO_guest_putchar) (= cp vmRADIO_serial_getchar) (= cp vmRADIO_recv) (= cp vmRADIO_send) (= cp vmRADIO_dtb_self) (= cp vmRADIO_restart_event) (= cp vmRADIO_notification_ready) (= cp vmRADIO_dtb) false))\n             (and (= cc vmUXAS)\n                  (or (= cp vmUXAS_notification_ready_connector) (= cp vmUXAS_fs) (= cp vmUXAS_batch) (= cp vmUXAS_guest_putchar) (= cp vmUXAS_serial_getchar) (= cp vmUXAS_recv) (= cp vmUXAS_send) (= cp vmUXAS_dtb_self) (= cp vmUXAS_restart_event) (= cp vmUXAS_notification_ready) (= cp vmUXAS_dtb) false))\n             false))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                             Proof Functions                            ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define-fun isVMComponent ((cc CAmkESComponent)) Bool\n  (exists ((ap AadlComponent))\n    (and (ComponentRefinement (Some ap) cc)                   ; cc refines ap\n         (= (Some Process) (select AadlComponentCategory ap)) ; ap is a process\n         (match (select ProcessorBindings ap) (\n           ((Some x) (= (Some VirtualProcessor) (select AadlComponentCategory x))) ; ap is bound to virtual processor\n           (None false))))))\n\n(define-fun AadlFlowDirectionality () Bool\n  (forall ((p1 AadlPort) (p2 AadlPort))\n    (=> (AadlConnectionFlowTos p1 p2)\n        (and (= Out (select AadlPortDirection p1)) (= In (select AadlPortDirection p2))))))\n\n(define-fun AadlFlowNoSelfConnection () Bool\n  (forall ((p1 AadlPort) (p2 AadlPort))\n    (=> (AadlConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AadlConnectedPortTypeMatch () Bool\n  (forall ((src AadlPort) (dst AadlPort))\n    (=> (AadlConnectionFlowTos src dst)\n        (or (and (= AbstractFeature (select AadlFeatureCategory src)) (= AbstractFeature (select AadlFeatureCategory dst)))\n            (and (= BusAccess (select AadlFeatureCategory src)) (= BusAccess (select AadlFeatureCategory dst)))\n            (and (= DataAccess (select AadlFeatureCategory src)) (= DataAccess (select AadlFeatureCategory dst)))\n            (and (= DataPort (select AadlFeatureCategory src)) (= DataPort (select AadlFeatureCategory dst)))\n            (and (= EventPort (select AadlFeatureCategory src)) (= EventPort (select AadlFeatureCategory dst)))\n            (and (= EventDataPort (select AadlFeatureCategory src)) (= EventDataPort (select AadlFeatureCategory dst)))\n            (and (= FeatureGroup (select AadlFeatureCategory src)) (= FeatureGroup (select AadlFeatureCategory dst)))\n            (and (= Parameter (select AadlFeatureCategory src)) (= Parameter (select AadlFeatureCategory dst)))\n            (and (= SubprogramAccess (select AadlFeatureCategory src)) (= SubprogramAccess (select AadlFeatureCategory dst)))\n            (and (= SubprogramAccessGroup (select AadlFeatureCategory src)) (= SubprogramAccessGroup (select AadlFeatureCategory dst)))\n             false))))\n(declare-const AadlConnectedPortTypeMatch_count Int)\n(assert (= 10 AadlConnectedPortTypeMatch_count))\n\n(define-fun AadlDispatchProtocolSpecified () Bool\n  (forall ((_comp AadlComponent))\n    (match (select AadlComponentCategory _comp) (\n      ((Some _category_) (\n        ; threads and virtual processors must have an assigned dispatch protocol, all others are 'don't care'\n        match _category_ (\n          (Thread (not (= (as None (Option DispatchProtocol)) (select AadlDispatchProtocol _comp))))\n          (VirtualProcessor (not (= (as None (Option DispatchProtocol)) (select AadlDispatchProtocol _comp))))\n          (_z_ true)\n        )))\n      (None false) ; sanity check: all AADL components must have an assigned component category\n      ))))\n\n(define-fun AadlAllPortsAssigned () Bool\n  (forall ((_p AadlPort))\n    (not (= (as None (Option AadlComponent)) (select AadlPortComponent _p)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    (= AadlPort_count AadlPortComponent_size) ; all Aadl ports belong to an Aadl component\n    AadlAllPortsAssigned\n    AadlDispatchProtocolSpecified\n    AadlFlowDirectionality\n    AadlFlowNoSelfConnection\n    AadlConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun CAmkESDataPortAccess () Bool\n  (forall ((_conn CAmkESConnection) (_src CAmkESPort) (_dst CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _src _dst)\n        (and\n             (=> (= seL4SharedData (select CAmkESConnectionType _conn))\n                 (and (= W (select CAmkESAccessRestrictions _src))\n                      (= R (select CAmkESAccessRestrictions _dst))))\n             (=> (= seL4SharedDataWithCaps (select CAmkESConnectionType _conn))\n                 (and (ite (isVMComponent (select CAmkESPortComponent _src))\n                           (= RW (select CAmkESAccessRestrictions _src))\n                           (= W (select CAmkESAccessRestrictions _src)))\n                      (= R (select CAmkESAccessRestrictions _dst))))))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AadlComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement (Some aadlComponent1) camkesComponent)\n        (not (exists ((aadlComponent2 AadlComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement (Some aadlComponent2) camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AadlPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AadlPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    (= CAmkESPort_count CAmkESPortComponent_size) ; all CAmkES ports belong to a CAmkES component\n    CAmkESDataPortAccess\n    CAmkESFlowNoSelfConnection))\n\n; helper method: if either port belongs to a VM component then any data connection between the two of them\n; must be seL4SharedDataWithCaps, seL4SharedData otherwise\n(define-fun getExpectedDataConnectionType ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) seL4ConnectorType\n  (ite (or (isVMComponent (select CAmkESPortComponent camkesSource))\n           (isVMComponent (select CAmkESPortComponent camkesDest))\n           false)\n       seL4SharedDataWithCaps\n       seL4SharedData))\n\n; helper method: if the destination port belongs to a VM component than any event connection between the two ports\n; must be seL4GlobalAsynch, seL4Notification otherwise\n(define-fun getExpectedEventConnectionType ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) seL4ConnectorType\n  (ite (isVMComponent (select CAmkESPortComponent camkesDest))\n       seL4GlobalAsynch\n       seL4Notification))\n\n(define-fun SB_DataPortRefinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) (getExpectedDataConnectionType camkesSource camkesDest)) ; actual connector type must match expected\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_EventPortRefinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) (getExpectedEventConnectionType camkesSource camkesDest)) ; actual connector type must match expected\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_Refinement ((aadlSource AadlPort) (aadlDest AadlPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (or\n         (and\n           (= DataPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)) ; payload\n         (and\n           (= EventPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; event counter\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         (and\n           (= EventDataPort (select AadlFeatureCategory aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; payload\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         false)))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AadlPort) (aadlDest AadlPort))\n    (=> (AadlConnectionFlowTos aadlSource aadlDest)\n        (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n             (SB_Refinement aadlSource aadlDest)))))\n\n\n(define-fun isAadl_SB_ConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (exists ((aadlSource AadlPort) (aadlDest AadlPort))\n         (and\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest camkesDest)\n           (ComponentRefinement (select AadlPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AadlPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n           (AadlConnectionFlowTos aadlSource aadlDest)))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun isVirtualMachineInducedConnection ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (or\n    (and (isVMAuxConnection conn)\n         (or (isVMAuxPort camkesSource)\n             (isVMAuxPort camkesDest)\n             false))\n    (and (isSerialServer (select CAmkESPortComponent camkesSource)) ; connection b\/w serial and time server\n         (isTimeServer (select CAmkESPortComponent camkesDest)))\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAadl_SB_ConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        (isVirtualMachineInducedConnection conn camkesSource camkesDest)\n        false))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;                                                                        ;;\n;;                              Proof                                     ;;\n;;                                                                        ;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "markers" : [
          ],
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false,
          "isDatatype" : false
        }
      ]
    ]
  }
}