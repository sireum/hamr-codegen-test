{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Environment\/Heat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Environment\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Heat {\n  \"Dummy_Head_Enum\"\n}\n\nobject Heat_Payload {\n  def empty(): Heat_Payload = {\n    return Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get)\n  }\n}\n\n@datatype class Heat_Payload(value: Isolette_Environment.Heat.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Environment\/Interface_Interaction.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Environment\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Interface_Interaction {\n  \"Dummy_Interface_Interaction_Enum\"\n}\n\nobject Interface_Interaction_Payload {\n  def empty(): Interface_Interaction_Payload = {\n    return Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get)\n  }\n}\n\n@datatype class Interface_Interaction_Payload(value: Isolette_Environment.Interface_Interaction.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/PhysicalTemp_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject PhysicalTemp_impl {\n  def empty(): Isolette_Data_Model.PhysicalTemp_impl = {\n    return Isolette_Data_Model.PhysicalTemp_impl(Base_Types.Float_32_empty())\n  }\n}\n\n@datatype class PhysicalTemp_impl(\n  value : F32) {\n}\n\nobject PhysicalTemp_impl_Payload {\n  def empty(): PhysicalTemp_impl_Payload = {\n    return PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty())\n  }\n}\n\n@datatype class PhysicalTemp_impl_Payload(value: Isolette_Data_Model.PhysicalTemp_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/ValueStatus.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object ValueStatus {\n  \"Valid\"\n  \"Invalid\"\n}\n\nobject ValueStatus_Payload {\n  def empty(): ValueStatus_Payload = {\n    return ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get)\n  }\n}\n\n@datatype class ValueStatus_Payload(value: Isolette_Data_Model.ValueStatus.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/TempWstatus_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject TempWstatus_impl {\n  def empty(): Isolette_Data_Model.TempWstatus_impl = {\n    return Isolette_Data_Model.TempWstatus_impl(Base_Types.Float_32_empty(), Isolette_Data_Model.ValueStatus.byOrdinal(0).get)\n  }\n}\n\n@datatype class TempWstatus_impl(\n  value : F32,\n  status : Isolette_Data_Model.ValueStatus.Type) {\n}\n\nobject TempWstatus_impl_Payload {\n  def empty(): TempWstatus_impl_Payload = {\n    return TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n}\n\n@datatype class TempWstatus_impl_Payload(value: Isolette_Data_Model.TempWstatus_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/On_Off.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object On_Off {\n  \"Onn\"\n  \"Off\"\n}\n\nobject On_Off_Payload {\n  def empty(): On_Off_Payload = {\n    return On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n}\n\n@datatype class On_Off_Payload(value: Isolette_Data_Model.On_Off.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/Status.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Status {\n  \"Init_Status\"\n  \"On_Status\"\n  \"Failed_Status\"\n}\n\nobject Status_Payload {\n  def empty(): Status_Payload = {\n    return Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get)\n  }\n}\n\n@datatype class Status_Payload(value: Isolette_Data_Model.Status.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/Temp_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Temp_impl {\n  def empty(): Isolette_Data_Model.Temp_impl = {\n    return Isolette_Data_Model.Temp_impl(Base_Types.Float_32_empty())\n  }\n}\n\n@datatype class Temp_impl(\n  value : F32) {\n}\n\nobject Temp_impl_Payload {\n  def empty(): Temp_impl_Payload = {\n    return Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty())\n  }\n}\n\n@datatype class Temp_impl_Payload(value: Isolette_Data_Model.Temp_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/Regulator_Mode.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Regulator_Mode {\n  \"Init_Regulator_Mode\"\n  \"Normal_Regulator_Mode\"\n  \"Failed_Regulator_Mode\"\n}\n\nobject Regulator_Mode_Payload {\n  def empty(): Regulator_Mode_Payload = {\n    return Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n  }\n}\n\n@datatype class Regulator_Mode_Payload(value: Isolette_Data_Model.Regulator_Mode.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/Failure_Flag_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Failure_Flag_impl {\n  def empty(): Isolette_Data_Model.Failure_Flag_impl = {\n    return Isolette_Data_Model.Failure_Flag_impl(Base_Types.Boolean_empty())\n  }\n}\n\n@datatype class Failure_Flag_impl(\n  value : B) {\n}\n\nobject Failure_Flag_impl_Payload {\n  def empty(): Failure_Flag_impl_Payload = {\n    return Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n}\n\n@datatype class Failure_Flag_impl_Payload(value: Isolette_Data_Model.Failure_Flag_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Isolette_Data_Model\/Monitor_Mode.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette_Data_Model\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Monitor_Mode {\n  \"Init_Monitor_Mode\"\n  \"Normal_Monitor_Mode\"\n  \"Failed_Monitor_Mode\"\n}\n\nobject Monitor_Mode_Payload {\n  def empty(): Monitor_Mode_Payload = {\n    return Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n  }\n}\n\n@datatype class Monitor_Mode_Payload(value: Isolette_Data_Model.Monitor_Mode.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: S32) extends art.DataContent\n  @datatype class Float_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit : slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_current_tempWstatus\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_tempWstatus\", mode = DataIn)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_tempWstatus\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_mode\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_temp\", mode = DataOut)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 5, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_temp\", mode = DataOut)\n    val displayed_temp = Port[Isolette_Data_Model.Temp_impl] (id = 6, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_displayed_temp\", mode = DataOut)\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 7, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 8, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_interface_failure\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      regulator_mode = regulator_mode,\n      upper_desired_temp = upper_desired_temp,\n      lower_desired_temp = lower_desired_temp,\n      displayed_temp = displayed_temp,\n      regulator_status = regulator_status,\n      interface_failure = interface_failure\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst : slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 9, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_current_tempWstatus\", mode = DataIn)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 10, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_lower_desired_temp\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 11, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_upper_desired_temp\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 12, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_regulator_mode\", mode = DataIn)\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 13, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_heat_control\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge(\n      id = 1,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_temp = lower_desired_temp,\n      upper_desired_temp = upper_desired_temp,\n      regulator_mode = regulator_mode,\n      heat_control = heat_control\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt : slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 14, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 15, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 16, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_internal_failure\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 17, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_regulator_mode\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge(\n      id = 2,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      regulator_mode = regulator_mode\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat : slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 18, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_current_tempWstatus\", mode = DataIn)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 19, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_lower_alarm_temp\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 20, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_upper_alarm_temp\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 21, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_monitor_mode\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 22, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_alarm_control\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge(\n      id = 3,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_alarm_temp = lower_alarm_temp,\n      upper_alarm_temp = upper_alarm_temp,\n      monitor_mode = monitor_mode,\n      alarm_control = alarm_control\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit : slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge = {\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 23, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_tempWstatus\", mode = DataIn)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 24, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_tempWstatus\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 25, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_current_tempWstatus\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 26, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_mode\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 27, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_temp\", mode = DataOut)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 28, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_temp\", mode = DataOut)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 29, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 30, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_interface_failure\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge(\n      id = 4,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      current_tempWstatus = current_tempWstatus,\n      monitor_mode = monitor_mode,\n      upper_alarm_temp = upper_alarm_temp,\n      lower_alarm_temp = lower_alarm_temp,\n      monitor_status = monitor_status,\n      interface_failure = interface_failure\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt : slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 31, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 32, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 33, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_internal_failure\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 34, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_monitor_mode\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge(\n      id = 5,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      monitor_mode = monitor_mode\n    )\n  }\n  val isolette_single_sensor_Instance_operator_interface_oip_oit : slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge = {\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 35, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_regulator_status\", mode = DataIn)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 36, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_monitor_status\", mode = DataIn)\n    val display_temperature = Port[Isolette_Data_Model.Temp_impl] (id = 37, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_display_temperature\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 38, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_alarm_control\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 39, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus\", mode = DataOut)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 40, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus\", mode = DataOut)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 41, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus\", mode = DataOut)\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 42, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus\", mode = DataOut)\n\n    slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge(\n      id = 6,\n      name = \"isolette_single_sensor_Instance_operator_interface_oip_oit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      regulator_status = regulator_status,\n      monitor_status = monitor_status,\n      display_temperature = display_temperature,\n      alarm_control = alarm_control,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus\n    )\n  }\n  val isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat : slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge = {\n    val air = Port[Isolette_Data_Model.PhysicalTemp_impl] (id = 43, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_air\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 44, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus\", mode = DataOut)\n\n    slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge(\n      id = 7,\n      name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      air = air,\n      current_tempWstatus = current_tempWstatus\n    )\n  }\n  val isolette_single_sensor_Instance_heat_source_cpi_heat_controller : slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge = {\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 45, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_control\", mode = DataIn)\n    val heat_out = Port[Isolette_Environment.Heat.Type] (id = 46, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_out\", mode = DataOut)\n\n    slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge(\n      id = 8,\n      name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      heat_control = heat_control,\n      heat_out = heat_out\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit, isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst, isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt, isolette_single_sensor_Instance_operator_interface_oip_oit, isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat, isolette_single_sensor_Instance_heat_source_cpi_heat_controller),\n\n      connections = ISZ (Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.upper_desired_temp, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.upper_desired_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.lower_desired_temp, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.lower_desired_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.interface_failure, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.interface_failure),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.regulator_mode, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.regulator_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.regulator_mode, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.regulator_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.upper_alarm_temp, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.upper_alarm_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.lower_alarm_temp, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.lower_alarm_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.interface_failure, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.interface_failure),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.monitor_mode, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.monitor_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.monitor_mode, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.monitor_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.displayed_temp, to = isolette_single_sensor_Instance_operator_interface_oip_oit.display_temperature),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.regulator_status, to = isolette_single_sensor_Instance_operator_interface_oip_oit.regulator_status),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.heat_control, to = isolette_single_sensor_Instance_heat_source_cpi_heat_controller.heat_control),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.alarm_control, to = isolette_single_sensor_Instance_operator_interface_oip_oit.alarm_control),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.monitor_status, to = isolette_single_sensor_Instance_operator_interface_oip_oit.monitor_status),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.lower_desired_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.lower_desired_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_desired_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.upper_desired_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_alarm_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.upper_alarm_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_alarm_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.lower_alarm_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.current_tempWstatus))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage slang_embedded\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/inspector\/slang_embedded\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi extends BridgeTestSuite[Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_desired_tempWstatus payload for data port lower_desired_tempWstatus\n   * @param upper_desired_tempWstatus payload for data port upper_desired_tempWstatus\n   * @param regulator_mode payload for data port regulator_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_desired_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          upper_desired_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          regulator_mode : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_desired_tempWstatus(lower_desired_tempWstatus)\n    put_upper_desired_tempWstatus(upper_desired_tempWstatus)\n    put_regulator_mode(regulator_mode)\n  }\n\n\n  \/** helper function to check Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param upper_desired_temp method that will be called with the value of the outgoing data\n   *        port 'upper_desired_temp'.\n   * @param lower_desired_temp method that will be called with the value of the outgoing data\n   *        port 'lower_desired_temp'.\n   * @param displayed_temp method that will be called with the value of the outgoing data\n   *        port 'displayed_temp'.\n   * @param regulator_status method that will be called with the value of the outgoing data\n   *        port 'regulator_status'.\n   * @param interface_failure method that will be called with the value of the outgoing data\n   *        port 'interface_failure'.\n   *\/\n  def check_concrete_output(upper_desired_temp: Isolette_Data_Model.Temp_impl => B = upper_desired_tempParam => {T},\n                            lower_desired_temp: Isolette_Data_Model.Temp_impl => B = lower_desired_tempParam => {T},\n                            displayed_temp: Isolette_Data_Model.Temp_impl => B = displayed_tempParam => {T},\n                            regulator_status: Isolette_Data_Model.Status.Type => B = regulator_statusParam => {T},\n                            interface_failure: Isolette_Data_Model.Failure_Flag_impl => B = interface_failureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val upper_desired_tempValue: Isolette_Data_Model.Temp_impl = get_upper_desired_temp().get\n    if(!upper_desired_temp(upper_desired_tempValue)) {\n      testFailures = testFailures :+ st\"'upper_desired_temp' did not match expected: value of the outgoing data port is ${upper_desired_tempValue}\"\n    }\n    val lower_desired_tempValue: Isolette_Data_Model.Temp_impl = get_lower_desired_temp().get\n    if(!lower_desired_temp(lower_desired_tempValue)) {\n      testFailures = testFailures :+ st\"'lower_desired_temp' did not match expected: value of the outgoing data port is ${lower_desired_tempValue}\"\n    }\n    val displayed_tempValue: Isolette_Data_Model.Temp_impl = get_displayed_temp().get\n    if(!displayed_temp(displayed_tempValue)) {\n      testFailures = testFailures :+ st\"'displayed_temp' did not match expected: value of the outgoing data port is ${displayed_tempValue}\"\n    }\n    val regulator_statusValue: Isolette_Data_Model.Status.Type = get_regulator_status().get\n    if(!regulator_status(regulator_statusValue)) {\n      testFailures = testFailures :+ st\"'regulator_status' did not match expected: value of the outgoing data port is ${regulator_statusValue}\"\n    }\n    val interface_failureValue: Isolette_Data_Model.Failure_Flag_impl = get_interface_failure().get\n    if(!interface_failure(interface_failureValue)) {\n      testFailures = testFailures :+ st\"'interface_failure' did not match expected: value of the outgoing data port is ${interface_failureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_regulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_desired_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_upper_desired_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_desired_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_desired_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_desired_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_lower_desired_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_desired_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_desired_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_displayed_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_displayed_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port displayed_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_displayed_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.displayed_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_regulator_status(): Option[Isolette_Data_Model.Status.Type] = {\n    val value: Option[Isolette_Data_Model.Status.Type] = get_regulator_status_payload() match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port regulator_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_regulator_status_payload(): Option[Isolette_Data_Model.Status_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.regulator_status_Id).asInstanceOf[Option[Isolette_Data_Model.Status_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_interface_failure(): Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value: Option[Isolette_Data_Model.Failure_Flag_impl] = get_interface_failure_payload() match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_interface_failure_payload(): Option[Isolette_Data_Model.Failure_Flag_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.interface_failure_Id).asInstanceOf[Option[Isolette_Data_Model.Failure_Flag_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Test extends Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Regulate.{Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type],\n  upper_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  lower_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  displayed_temp: Port[Isolette_Data_Model.Temp_impl],\n  regulator_status: Port[Isolette_Data_Model.Status.Type],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_desired_tempWstatus,\n              upper_desired_tempWstatus,\n              regulator_mode,\n              upper_desired_temp,\n              lower_desired_temp,\n              displayed_temp,\n              regulator_status,\n              interface_failure),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_desired_tempWstatus,\n                  upper_desired_tempWstatus,\n                  regulator_mode),\n\n    dataOuts = ISZ(upper_desired_temp,\n                   lower_desired_temp,\n                   displayed_temp,\n                   regulator_status,\n                   interface_failure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Regulator_Interface_impl_Initialization_Api = {\n    val api = Manage_Regulator_Interface_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id\n    )\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Regulator_Interface_impl_Operational_Api = {\n    val api = Manage_Regulator_Interface_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id\n    )\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge {\n\n  var c_initialization_api: Option[Manage_Regulator_Interface_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Regulator_Interface_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_desired_tempWstatus_Id : Art.PortId,\n    upper_desired_tempWstatus_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n    upper_desired_temp_Id : Art.PortId,\n    lower_desired_temp_Id : Art.PortId,\n    displayed_temp_Id : Art.PortId,\n    regulator_status_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Regulator_Interface_impl_Initialization_Api,\n    operational_api: Manage_Regulator_Interface_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_desired_tempWstatus_Id,\n                                             upper_desired_tempWstatus_Id,\n                                             regulator_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(upper_desired_temp_Id,\n                                              lower_desired_temp_Id,\n                                              displayed_temp_Id,\n                                              regulator_status_Id,\n                                              interface_failure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Regulator_Interface_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_desired_tempWstatus_Id : Art.PortId\n  def upper_desired_tempWstatus_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n  def upper_desired_temp_Id : Art.PortId\n  def lower_desired_temp_Id : Art.PortId\n  def displayed_temp_Id : Art.PortId\n  def regulator_status_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n\n  def setupper_desired_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(upper_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setlower_desired_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(lower_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setdisplayed_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(displayed_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setregulator_status(value : Isolette_Data_Model.Status.Type) : Unit = {\n    Art.putValue(regulator_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  def setinterface_failure(value : Isolette_Data_Model.Failure_Flag_impl) : Unit = {\n    Art.putValue(interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Regulator_Interface_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val displayed_temp_Id : Art.PortId,\n  val regulator_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Regulator_Interface_impl_Api\n\n@datatype class Manage_Regulator_Interface_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val displayed_temp_Id : Art.PortId,\n  val regulator_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Regulator_Interface_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_desired_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(lower_desired_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getupper_desired_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(upper_desired_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getregulator_mode() : Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Regulator_Mode.Type] = Art.getValue(regulator_mode_Id) match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Regulator_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit {\n\n  def initialise(api: Manage_Regulator_Interface_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setupper_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setlower_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setdisplayed_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setregulator_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n    api.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n\n  def timeTriggered(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getlower_desired_tempWstatus()\n    api.logInfo(s\"Received on lower_desired_tempWstatus: ${apiUsage_lower_desired_tempWstatus}\")\n    val apiUsage_upper_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getupper_desired_tempWstatus()\n    api.logInfo(s\"Received on upper_desired_tempWstatus: ${apiUsage_upper_desired_tempWstatus}\")\n    val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = api.getregulator_mode()\n    api.logInfo(s\"Received on regulator_mode: ${apiUsage_regulator_mode}\")\n  }\n\n  def activate(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[slang_embedded.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi extends BridgeTestSuite[Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_desired_temp payload for data port lower_desired_temp\n   * @param upper_desired_temp payload for data port upper_desired_temp\n   * @param regulator_mode payload for data port regulator_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_desired_temp : Isolette_Data_Model.Temp_impl,\n                          upper_desired_temp : Isolette_Data_Model.Temp_impl,\n                          regulator_mode : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_desired_temp(lower_desired_temp)\n    put_upper_desired_temp(upper_desired_temp)\n    put_regulator_mode(regulator_mode)\n  }\n\n\n  \/** helper function to check Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param heat_control method that will be called with the value of the outgoing data\n   *        port 'heat_control'.\n   *\/\n  def check_concrete_output(heat_control: Isolette_Data_Model.On_Off.Type => B = heat_controlParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val heat_controlValue: Isolette_Data_Model.On_Off.Type = get_heat_control().get\n    if(!heat_control(heat_controlValue)) {\n      testFailures = testFailures :+ st\"'heat_control' did not match expected: value of the outgoing data port is ${heat_controlValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_desired_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_desired_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_regulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_heat_control(): Option[Isolette_Data_Model.On_Off.Type] = {\n    val value: Option[Isolette_Data_Model.On_Off.Type] = get_heat_control_payload() match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port heat_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_heat_control_payload(): Option[Isolette_Data_Model.On_Off_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.heat_control_Id).asInstanceOf[Option[Isolette_Data_Model.On_Off_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Test extends Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Regulate.{Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  upper_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type],\n  heat_control: Port[Isolette_Data_Model.On_Off.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_desired_temp,\n              upper_desired_temp,\n              regulator_mode,\n              heat_control),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_desired_temp,\n                  upper_desired_temp,\n                  regulator_mode),\n\n    dataOuts = ISZ(heat_control),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Heat_Source_impl_Initialization_Api = {\n    val api = Manage_Heat_Source_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id\n    )\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Heat_Source_impl_Operational_Api = {\n    val api = Manage_Heat_Source_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id\n    )\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge {\n\n  var c_initialization_api: Option[Manage_Heat_Source_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Heat_Source_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_desired_temp_Id : Art.PortId,\n    upper_desired_temp_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n    heat_control_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Heat_Source_impl_Initialization_Api,\n    operational_api: Manage_Heat_Source_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_desired_temp_Id,\n                                             upper_desired_temp_Id,\n                                             regulator_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(heat_control_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Heat_Source_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_desired_temp_Id : Art.PortId\n  def upper_desired_temp_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n  def heat_control_Id : Art.PortId\n\n  def setheat_control(value : Isolette_Data_Model.On_Off.Type) : Unit = {\n    Art.putValue(heat_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Heat_Source_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val heat_control_Id : Art.PortId) extends Manage_Heat_Source_impl_Api\n\n@datatype class Manage_Heat_Source_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val heat_control_Id : Art.PortId) extends Manage_Heat_Source_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_desired_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(lower_desired_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getupper_desired_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(upper_desired_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getregulator_mode() : Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Regulator_Mode.Type] = Art.getValue(regulator_mode_Id) match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Regulator_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst {\n\n  def initialise(api: Manage_Heat_Source_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setheat_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Heat_Source_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_desired_temp: Option[Isolette_Data_Model.Temp_impl] = api.getlower_desired_temp()\n    api.logInfo(s\"Received on lower_desired_temp: ${apiUsage_lower_desired_temp}\")\n    val apiUsage_upper_desired_temp: Option[Isolette_Data_Model.Temp_impl] = api.getupper_desired_temp()\n    api.logInfo(s\"Received on upper_desired_temp: ${apiUsage_upper_desired_temp}\")\n    val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = api.getregulator_mode()\n    api.logInfo(s\"Received on regulator_mode: ${apiUsage_regulator_mode}\")\n  }\n\n  def activate(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi extends BridgeTestSuite[Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param interface_failure payload for data port interface_failure\n   * @param internal_failure payload for data port internal_failure\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          interface_failure : Isolette_Data_Model.Failure_Flag_impl,\n                          internal_failure : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_interface_failure(interface_failure)\n    put_internal_failure(internal_failure)\n  }\n\n\n  \/** helper function to check Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param regulator_mode method that will be called with the value of the outgoing data\n   *        port 'regulator_mode'.\n   *\/\n  def check_concrete_output(regulator_mode: Isolette_Data_Model.Regulator_Mode.Type => B = regulator_modeParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val regulator_modeValue: Isolette_Data_Model.Regulator_Mode.Type = get_regulator_mode().get\n    if(!regulator_mode(regulator_modeValue)) {\n      testFailures = testFailures :+ st\"'regulator_mode' did not match expected: value of the outgoing data port is ${regulator_modeValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_interface_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_internal_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.internal_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_regulator_mode(): Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value: Option[Isolette_Data_Model.Regulator_Mode.Type] = get_regulator_mode_payload() match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_regulator_mode_payload(): Option[Isolette_Data_Model.Regulator_Mode_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.regulator_mode_Id).asInstanceOf[Option[Isolette_Data_Model.Regulator_Mode_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Test extends Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Regulate.{Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  internal_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              interface_failure,\n              internal_failure,\n              regulator_mode),\n\n    dataIns = ISZ(current_tempWstatus,\n                  interface_failure,\n                  internal_failure),\n\n    dataOuts = ISZ(regulator_mode),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Regulator_Mode_impl_Initialization_Api = {\n    val api = Manage_Regulator_Mode_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id\n    )\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Regulator_Mode_impl_Operational_Api = {\n    val api = Manage_Regulator_Mode_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id\n    )\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge {\n\n  var c_initialization_api: Option[Manage_Regulator_Mode_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Regulator_Mode_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n    internal_failure_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Regulator_Mode_impl_Initialization_Api,\n    operational_api: Manage_Regulator_Mode_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             interface_failure_Id,\n                                             internal_failure_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(regulator_mode_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Regulator_Mode_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n  def internal_failure_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n\n  def setregulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type) : Unit = {\n    Art.putValue(regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Regulator_Mode_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId) extends Manage_Regulator_Mode_impl_Api\n\n@datatype class Manage_Regulator_Mode_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId) extends Manage_Regulator_Mode_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getinterface_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(interface_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  def getinternal_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(internal_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port internal_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt {\n\n  def initialise(api: Manage_Regulator_Mode_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setregulator_mode(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinterface_failure()\n    api.logInfo(s\"Received on interface_failure: ${apiUsage_interface_failure}\")\n    val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinternal_failure()\n    api.logInfo(s\"Received on internal_failure: ${apiUsage_internal_failure}\")\n  }\n\n  def activate(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi extends BridgeTestSuite[Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_alarm_temp payload for data port lower_alarm_temp\n   * @param upper_alarm_temp payload for data port upper_alarm_temp\n   * @param monitor_mode payload for data port monitor_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_alarm_temp : Isolette_Data_Model.Temp_impl,\n                          upper_alarm_temp : Isolette_Data_Model.Temp_impl,\n                          monitor_mode : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_alarm_temp(lower_alarm_temp)\n    put_upper_alarm_temp(upper_alarm_temp)\n    put_monitor_mode(monitor_mode)\n  }\n\n\n  \/** helper function to check Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param alarm_control method that will be called with the value of the outgoing data\n   *        port 'alarm_control'.\n   *\/\n  def check_concrete_output(alarm_control: Isolette_Data_Model.On_Off.Type => B = alarm_controlParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val alarm_controlValue: Isolette_Data_Model.On_Off.Type = get_alarm_control().get\n    if(!alarm_control(alarm_controlValue)) {\n      testFailures = testFailures :+ st\"'alarm_control' did not match expected: value of the outgoing data port is ${alarm_controlValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_alarm_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_alarm_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_alarm_control(): Option[Isolette_Data_Model.On_Off.Type] = {\n    val value: Option[Isolette_Data_Model.On_Off.Type] = get_alarm_control_payload() match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port alarm_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_alarm_control_payload(): Option[Isolette_Data_Model.On_Off_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.alarm_control_Id).asInstanceOf[Option[Isolette_Data_Model.On_Off_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Test extends Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Monitor.{Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  upper_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type],\n  alarm_control: Port[Isolette_Data_Model.On_Off.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_alarm_temp,\n              upper_alarm_temp,\n              monitor_mode,\n              alarm_control),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_alarm_temp,\n                  upper_alarm_temp,\n                  monitor_mode),\n\n    dataOuts = ISZ(alarm_control),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Alarm_impl_Initialization_Api = {\n    val api = Manage_Alarm_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id\n    )\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Alarm_impl_Operational_Api = {\n    val api = Manage_Alarm_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id\n    )\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge {\n\n  var c_initialization_api: Option[Manage_Alarm_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Alarm_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_alarm_temp_Id : Art.PortId,\n    upper_alarm_temp_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n    alarm_control_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Alarm_impl_Initialization_Api,\n    operational_api: Manage_Alarm_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_alarm_temp_Id,\n                                             upper_alarm_temp_Id,\n                                             monitor_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(alarm_control_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Alarm_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Alarm_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_alarm_temp_Id : Art.PortId\n  def upper_alarm_temp_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n  def alarm_control_Id : Art.PortId\n\n  def setalarm_control(value : Isolette_Data_Model.On_Off.Type) : Unit = {\n    Art.putValue(alarm_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Alarm_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId) extends Manage_Alarm_impl_Api\n\n@datatype class Manage_Alarm_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId) extends Manage_Alarm_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_alarm_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(lower_alarm_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getupper_alarm_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(upper_alarm_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getmonitor_mode() : Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Monitor_Mode.Type] = Art.getValue(monitor_mode_Id) match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Monitor_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat {\n\n  def initialise(api: Manage_Alarm_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setalarm_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Alarm_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = api.getlower_alarm_temp()\n    api.logInfo(s\"Received on lower_alarm_temp: ${apiUsage_lower_alarm_temp}\")\n    val apiUsage_upper_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = api.getupper_alarm_temp()\n    api.logInfo(s\"Received on upper_alarm_temp: ${apiUsage_upper_alarm_temp}\")\n    val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = api.getmonitor_mode()\n    api.logInfo(s\"Received on monitor_mode: ${apiUsage_monitor_mode}\")\n  }\n\n  def activate(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi extends BridgeTestSuite[Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param upper_alarm_tempWstatus payload for data port upper_alarm_tempWstatus\n   * @param lower_alarm_tempWstatus payload for data port lower_alarm_tempWstatus\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param monitor_mode payload for data port monitor_mode\n   *\/\n  def put_concrete_inputs(upper_alarm_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_alarm_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          monitor_mode : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    put_upper_alarm_tempWstatus(upper_alarm_tempWstatus)\n    put_lower_alarm_tempWstatus(lower_alarm_tempWstatus)\n    put_current_tempWstatus(current_tempWstatus)\n    put_monitor_mode(monitor_mode)\n  }\n\n\n  \/** helper function to check Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param upper_alarm_temp method that will be called with the value of the outgoing data\n   *        port 'upper_alarm_temp'.\n   * @param lower_alarm_temp method that will be called with the value of the outgoing data\n   *        port 'lower_alarm_temp'.\n   * @param monitor_status method that will be called with the value of the outgoing data\n   *        port 'monitor_status'.\n   * @param interface_failure method that will be called with the value of the outgoing data\n   *        port 'interface_failure'.\n   *\/\n  def check_concrete_output(upper_alarm_temp: Isolette_Data_Model.Temp_impl => B = upper_alarm_tempParam => {T},\n                            lower_alarm_temp: Isolette_Data_Model.Temp_impl => B = lower_alarm_tempParam => {T},\n                            monitor_status: Isolette_Data_Model.Status.Type => B = monitor_statusParam => {T},\n                            interface_failure: Isolette_Data_Model.Failure_Flag_impl => B = interface_failureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val upper_alarm_tempValue: Isolette_Data_Model.Temp_impl = get_upper_alarm_temp().get\n    if(!upper_alarm_temp(upper_alarm_tempValue)) {\n      testFailures = testFailures :+ st\"'upper_alarm_temp' did not match expected: value of the outgoing data port is ${upper_alarm_tempValue}\"\n    }\n    val lower_alarm_tempValue: Isolette_Data_Model.Temp_impl = get_lower_alarm_temp().get\n    if(!lower_alarm_temp(lower_alarm_tempValue)) {\n      testFailures = testFailures :+ st\"'lower_alarm_temp' did not match expected: value of the outgoing data port is ${lower_alarm_tempValue}\"\n    }\n    val monitor_statusValue: Isolette_Data_Model.Status.Type = get_monitor_status().get\n    if(!monitor_status(monitor_statusValue)) {\n      testFailures = testFailures :+ st\"'monitor_status' did not match expected: value of the outgoing data port is ${monitor_statusValue}\"\n    }\n    val interface_failureValue: Isolette_Data_Model.Failure_Flag_impl = get_interface_failure().get\n    if(!interface_failure(interface_failureValue)) {\n      testFailures = testFailures :+ st\"'interface_failure' did not match expected: value of the outgoing data port is ${interface_failureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_upper_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_alarm_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_upper_alarm_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_alarm_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_alarm_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_alarm_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_lower_alarm_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_alarm_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_alarm_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_monitor_status(): Option[Isolette_Data_Model.Status.Type] = {\n    val value: Option[Isolette_Data_Model.Status.Type] = get_monitor_status_payload() match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port monitor_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_monitor_status_payload(): Option[Isolette_Data_Model.Status_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.monitor_status_Id).asInstanceOf[Option[Isolette_Data_Model.Status_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_interface_failure(): Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value: Option[Isolette_Data_Model.Failure_Flag_impl] = get_interface_failure_payload() match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_interface_failure_payload(): Option[Isolette_Data_Model.Failure_Flag_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.interface_failure_Id).asInstanceOf[Option[Isolette_Data_Model.Failure_Flag_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Test extends Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Monitor.{Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  upper_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type],\n  upper_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  lower_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  monitor_status: Port[Isolette_Data_Model.Status.Type],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(upper_alarm_tempWstatus,\n              lower_alarm_tempWstatus,\n              current_tempWstatus,\n              monitor_mode,\n              upper_alarm_temp,\n              lower_alarm_temp,\n              monitor_status,\n              interface_failure),\n\n    dataIns = ISZ(upper_alarm_tempWstatus,\n                  lower_alarm_tempWstatus,\n                  current_tempWstatus,\n                  monitor_mode),\n\n    dataOuts = ISZ(upper_alarm_temp,\n                   lower_alarm_temp,\n                   monitor_status,\n                   interface_failure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Monitor_Interface_impl_Initialization_Api = {\n    val api = Manage_Monitor_Interface_impl_Initialization_Api(\n      id,\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id\n    )\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Monitor_Interface_impl_Operational_Api = {\n    val api = Manage_Monitor_Interface_impl_Operational_Api(\n      id,\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id\n    )\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.EntryPoints(\n      id,\n\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge {\n\n  var c_initialization_api: Option[Manage_Monitor_Interface_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Monitor_Interface_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_BridgeId : Art.BridgeId,\n\n    upper_alarm_tempWstatus_Id : Art.PortId,\n    lower_alarm_tempWstatus_Id : Art.PortId,\n    current_tempWstatus_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n    upper_alarm_temp_Id : Art.PortId,\n    lower_alarm_temp_Id : Art.PortId,\n    monitor_status_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Monitor_Interface_impl_Initialization_Api,\n    operational_api: Manage_Monitor_Interface_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(upper_alarm_tempWstatus_Id,\n                                             lower_alarm_tempWstatus_Id,\n                                             current_tempWstatus_Id,\n                                             monitor_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(upper_alarm_temp_Id,\n                                              lower_alarm_temp_Id,\n                                              monitor_status_Id,\n                                              interface_failure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Monitor_Interface_impl_Api {\n  def id: Art.BridgeId\n  def upper_alarm_tempWstatus_Id : Art.PortId\n  def lower_alarm_tempWstatus_Id : Art.PortId\n  def current_tempWstatus_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n  def upper_alarm_temp_Id : Art.PortId\n  def lower_alarm_temp_Id : Art.PortId\n  def monitor_status_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n\n  def setupper_alarm_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(upper_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setlower_alarm_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(lower_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setmonitor_status(value : Isolette_Data_Model.Status.Type) : Unit = {\n    Art.putValue(monitor_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  def setinterface_failure(value : Isolette_Data_Model.Failure_Flag_impl) : Unit = {\n    Art.putValue(interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Monitor_Interface_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val upper_alarm_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Monitor_Interface_impl_Api\n\n@datatype class Manage_Monitor_Interface_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val upper_alarm_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Monitor_Interface_impl_Api {\n\n  def getupper_alarm_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(upper_alarm_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_alarm_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(lower_alarm_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getmonitor_mode() : Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Monitor_Mode.Type] = Art.getValue(monitor_mode_Id) match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Monitor_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit {\n\n  def initialise(api: Manage_Monitor_Interface_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setupper_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setlower_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setmonitor_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n    api.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n\n  def timeTriggered(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_upper_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getupper_alarm_tempWstatus()\n    api.logInfo(s\"Received on upper_alarm_tempWstatus: ${apiUsage_upper_alarm_tempWstatus}\")\n    val apiUsage_lower_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getlower_alarm_tempWstatus()\n    api.logInfo(s\"Received on lower_alarm_tempWstatus: ${apiUsage_lower_alarm_tempWstatus}\")\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = api.getmonitor_mode()\n    api.logInfo(s\"Received on monitor_mode: ${apiUsage_monitor_mode}\")\n  }\n\n  def activate(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi extends BridgeTestSuite[Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param interface_failure payload for data port interface_failure\n   * @param internal_failure payload for data port internal_failure\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          interface_failure : Isolette_Data_Model.Failure_Flag_impl,\n                          internal_failure : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_interface_failure(interface_failure)\n    put_internal_failure(internal_failure)\n  }\n\n\n  \/** helper function to check Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param monitor_mode method that will be called with the value of the outgoing data\n   *        port 'monitor_mode'.\n   *\/\n  def check_concrete_output(monitor_mode: Isolette_Data_Model.Monitor_Mode.Type => B = monitor_modeParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val monitor_modeValue: Isolette_Data_Model.Monitor_Mode.Type = get_monitor_mode().get\n    if(!monitor_mode(monitor_modeValue)) {\n      testFailures = testFailures :+ st\"'monitor_mode' did not match expected: value of the outgoing data port is ${monitor_modeValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_interface_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_internal_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.internal_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_monitor_mode(): Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value: Option[Isolette_Data_Model.Monitor_Mode.Type] = get_monitor_mode_payload() match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_monitor_mode_payload(): Option[Isolette_Data_Model.Monitor_Mode_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.monitor_mode_Id).asInstanceOf[Option[Isolette_Data_Model.Monitor_Mode_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Test extends Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Monitor.{Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  internal_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              interface_failure,\n              internal_failure,\n              monitor_mode),\n\n    dataIns = ISZ(current_tempWstatus,\n                  interface_failure,\n                  internal_failure),\n\n    dataOuts = ISZ(monitor_mode),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Monitor_Mode_impl_Initialization_Api = {\n    val api = Manage_Monitor_Mode_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id\n    )\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Monitor_Mode_impl_Operational_Api = {\n    val api = Manage_Monitor_Mode_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id\n    )\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge {\n\n  var c_initialization_api: Option[Manage_Monitor_Mode_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Monitor_Mode_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n    internal_failure_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Monitor_Mode_impl_Initialization_Api,\n    operational_api: Manage_Monitor_Mode_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             interface_failure_Id,\n                                             internal_failure_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(monitor_mode_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Manage_Monitor_Mode_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n  def internal_failure_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n\n  def setmonitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type) : Unit = {\n    Art.putValue(monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Monitor_Mode_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId) extends Manage_Monitor_Mode_impl_Api\n\n@datatype class Manage_Monitor_Mode_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId) extends Manage_Monitor_Mode_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getinterface_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(interface_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  def getinternal_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(internal_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port internal_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt {\n\n  def initialise(api: Manage_Monitor_Mode_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setmonitor_mode(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinterface_failure()\n    api.logInfo(s\"Received on interface_failure: ${apiUsage_interface_failure}\")\n    val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinternal_failure()\n    api.logInfo(s\"Received on internal_failure: ${apiUsage_internal_failure}\")\n  }\n\n  def activate(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Isolette\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class operator_interface_thread_impl_operator_interface_oip_oit_TestApi extends BridgeTestSuite[operator_interface_thread_impl_operator_interface_oip_oit_Bridge](Arch.isolette_single_sensor_Instance_operator_interface_oip_oit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param regulator_status payload for data port regulator_status\n   * @param monitor_status payload for data port monitor_status\n   * @param display_temperature payload for data port display_temperature\n   * @param alarm_control payload for data port alarm_control\n   *\/\n  def put_concrete_inputs(regulator_status : Isolette_Data_Model.Status.Type,\n                          monitor_status : Isolette_Data_Model.Status.Type,\n                          display_temperature : Isolette_Data_Model.Temp_impl,\n                          alarm_control : Isolette_Data_Model.On_Off.Type): Unit = {\n    put_regulator_status(regulator_status)\n    put_monitor_status(monitor_status)\n    put_display_temperature(display_temperature)\n    put_alarm_control(alarm_control)\n  }\n\n\n  \/** helper function to check operator_interface_thread_impl_operator_interface_oip_oit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param lower_desired_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'lower_desired_tempWstatus'.\n   * @param upper_desired_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'upper_desired_tempWstatus'.\n   * @param lower_alarm_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'lower_alarm_tempWstatus'.\n   * @param upper_alarm_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'upper_alarm_tempWstatus'.\n   *\/\n  def check_concrete_output(lower_desired_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = lower_desired_tempWstatusParam => {T},\n                            upper_desired_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = upper_desired_tempWstatusParam => {T},\n                            lower_alarm_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = lower_alarm_tempWstatusParam => {T},\n                            upper_alarm_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = upper_alarm_tempWstatusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val lower_desired_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_lower_desired_tempWstatus().get\n    if(!lower_desired_tempWstatus(lower_desired_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'lower_desired_tempWstatus' did not match expected: value of the outgoing data port is ${lower_desired_tempWstatusValue}\"\n    }\n    val upper_desired_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_upper_desired_tempWstatus().get\n    if(!upper_desired_tempWstatus(upper_desired_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'upper_desired_tempWstatus' did not match expected: value of the outgoing data port is ${upper_desired_tempWstatusValue}\"\n    }\n    val lower_alarm_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_lower_alarm_tempWstatus().get\n    if(!lower_alarm_tempWstatus(lower_alarm_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'lower_alarm_tempWstatus' did not match expected: value of the outgoing data port is ${lower_alarm_tempWstatusValue}\"\n    }\n    val upper_alarm_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_upper_alarm_tempWstatus().get\n    if(!upper_alarm_tempWstatus(upper_alarm_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'upper_alarm_tempWstatus' did not match expected: value of the outgoing data port is ${upper_alarm_tempWstatusValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_regulator_status(value : Isolette_Data_Model.Status.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_status(value : Isolette_Data_Model.Status.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_display_temperature(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.display_temperature_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_alarm_control(value : Isolette_Data_Model.On_Off.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.alarm_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_desired_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_lower_desired_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_desired_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_desired_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_desired_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_upper_desired_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_desired_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_desired_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_alarm_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_lower_alarm_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_alarm_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_alarm_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_alarm_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_upper_alarm_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_alarm_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_alarm_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Isolette\n\nimport org.sireum._\nimport slang_embedded.Isolette._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass operator_interface_thread_impl_operator_interface_oip_oit_Test extends operator_interface_thread_impl_operator_interface_oip_oit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Isolette.{operator_interface_thread_impl_operator_interface_oip_oit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class operator_interface_thread_impl_operator_interface_oip_oit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  regulator_status: Port[Isolette_Data_Model.Status.Type],\n  monitor_status: Port[Isolette_Data_Model.Status.Type],\n  display_temperature: Port[Isolette_Data_Model.Temp_impl],\n  alarm_control: Port[Isolette_Data_Model.On_Off.Type],\n  lower_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(regulator_status,\n              monitor_status,\n              display_temperature,\n              alarm_control,\n              lower_desired_tempWstatus,\n              upper_desired_tempWstatus,\n              lower_alarm_tempWstatus,\n              upper_alarm_tempWstatus),\n\n    dataIns = ISZ(regulator_status,\n                  monitor_status,\n                  display_temperature,\n                  alarm_control),\n\n    dataOuts = ISZ(lower_desired_tempWstatus,\n                   upper_desired_tempWstatus,\n                   lower_alarm_tempWstatus,\n                   upper_alarm_tempWstatus),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : operator_interface_thread_impl_Initialization_Api = {\n    val api = operator_interface_thread_impl_Initialization_Api(\n      id,\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id\n    )\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : operator_interface_thread_impl_Operational_Api = {\n    val api = operator_interface_thread_impl_Operational_Api(\n      id,\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id\n    )\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.EntryPoints(\n      id,\n\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject operator_interface_thread_impl_operator_interface_oip_oit_Bridge {\n\n  var c_initialization_api: Option[operator_interface_thread_impl_Initialization_Api] = None()\n  var c_operational_api: Option[operator_interface_thread_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    operator_interface_thread_impl_operator_interface_oip_oit_BridgeId : Art.BridgeId,\n\n    regulator_status_Id : Art.PortId,\n    monitor_status_Id : Art.PortId,\n    display_temperature_Id : Art.PortId,\n    alarm_control_Id : Art.PortId,\n    lower_desired_tempWstatus_Id : Art.PortId,\n    upper_desired_tempWstatus_Id : Art.PortId,\n    lower_alarm_tempWstatus_Id : Art.PortId,\n    upper_alarm_tempWstatus_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: operator_interface_thread_impl_Initialization_Api,\n    operational_api: operator_interface_thread_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(regulator_status_Id,\n                                             monitor_status_Id,\n                                             display_temperature_Id,\n                                             alarm_control_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(lower_desired_tempWstatus_Id,\n                                              upper_desired_tempWstatus_Id,\n                                              lower_alarm_tempWstatus_Id,\n                                              upper_alarm_tempWstatus_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Isolette\/operator_interface_thread_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait operator_interface_thread_impl_Api {\n  def id: Art.BridgeId\n  def regulator_status_Id : Art.PortId\n  def monitor_status_Id : Art.PortId\n  def display_temperature_Id : Art.PortId\n  def alarm_control_Id : Art.PortId\n  def lower_desired_tempWstatus_Id : Art.PortId\n  def upper_desired_tempWstatus_Id : Art.PortId\n  def lower_alarm_tempWstatus_Id : Art.PortId\n  def upper_alarm_tempWstatus_Id : Art.PortId\n\n  def setlower_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(lower_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setupper_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(upper_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setlower_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(lower_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setupper_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(upper_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class operator_interface_thread_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val regulator_status_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val display_temperature_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val upper_alarm_tempWstatus_Id : Art.PortId) extends operator_interface_thread_impl_Api\n\n@datatype class operator_interface_thread_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val regulator_status_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val display_temperature_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val upper_alarm_tempWstatus_Id : Art.PortId) extends operator_interface_thread_impl_Api {\n\n  def getregulator_status() : Option[Isolette_Data_Model.Status.Type] = {\n    val value : Option[Isolette_Data_Model.Status.Type] = Art.getValue(regulator_status_Id) match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Status.Type]()\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  def getmonitor_status() : Option[Isolette_Data_Model.Status.Type] = {\n    val value : Option[Isolette_Data_Model.Status.Type] = Art.getValue(monitor_status_Id) match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Status.Type]()\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  def getdisplay_temperature() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(display_temperature_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port display_temperature.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getalarm_control() : Option[Isolette_Data_Model.On_Off.Type] = {\n    val value : Option[Isolette_Data_Model.On_Off.Type] = Art.getValue(alarm_control_Id) match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port alarm_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n        None[Isolette_Data_Model.On_Off.Type]()\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject operator_interface_thread_impl_operator_interface_oip_oit {\n\n  def initialise(api: operator_interface_thread_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setlower_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setupper_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setlower_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setupper_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n\n  def timeTriggered(api: operator_interface_thread_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_regulator_status: Option[Isolette_Data_Model.Status.Type] = api.getregulator_status()\n    api.logInfo(s\"Received on regulator_status: ${apiUsage_regulator_status}\")\n    val apiUsage_monitor_status: Option[Isolette_Data_Model.Status.Type] = api.getmonitor_status()\n    api.logInfo(s\"Received on monitor_status: ${apiUsage_monitor_status}\")\n    val apiUsage_display_temperature: Option[Isolette_Data_Model.Temp_impl] = api.getdisplay_temperature()\n    api.logInfo(s\"Received on display_temperature: ${apiUsage_display_temperature}\")\n    val apiUsage_alarm_control: Option[Isolette_Data_Model.On_Off.Type] = api.getalarm_control()\n    api.logInfo(s\"Received on alarm_control: ${apiUsage_alarm_control}\")\n  }\n\n  def activate(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def finalise(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def recover(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi extends BridgeTestSuite[Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge](Arch.isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat) {\n\n  \/** helper function to set the values of all input ports.\n   * @param air payload for data port air\n   *\/\n  def put_concrete_inputs(air : Isolette_Data_Model.PhysicalTemp_impl): Unit = {\n    put_air(air)\n  }\n\n\n  \/** helper function to check Temperature_Sensor_impl_temperature_sensor_cpi_thermostat's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param current_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'current_tempWstatus'.\n   *\/\n  def check_concrete_output(current_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = current_tempWstatusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val current_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_current_tempWstatus().get\n    if(!current_tempWstatus(current_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'current_tempWstatus' did not match expected: value of the outgoing data port is ${current_tempWstatusValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_air(value : Isolette_Data_Model.PhysicalTemp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.air_Id, Isolette_Data_Model.PhysicalTemp_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_current_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_current_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_current_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.current_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport slang_embedded.Devices._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Test extends Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Devices.{Temperature_Sensor_impl_temperature_sensor_cpi_thermostat => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  air: Port[Isolette_Data_Model.PhysicalTemp_impl],\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(air,\n              current_tempWstatus),\n\n    dataIns = ISZ(air),\n\n    dataOuts = ISZ(current_tempWstatus),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Temperature_Sensor_impl_Initialization_Api = {\n    val api = Temperature_Sensor_impl_Initialization_Api(\n      id,\n      air.id,\n      current_tempWstatus.id\n    )\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Temperature_Sensor_impl_Operational_Api = {\n    val api = Temperature_Sensor_impl_Operational_Api(\n      id,\n      air.id,\n      current_tempWstatus.id\n    )\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.EntryPoints(\n      id,\n\n      air.id,\n      current_tempWstatus.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge {\n\n  var c_initialization_api: Option[Temperature_Sensor_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Temperature_Sensor_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_BridgeId : Art.BridgeId,\n\n    air_Id : Art.PortId,\n    current_tempWstatus_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Temperature_Sensor_impl_Initialization_Api,\n    operational_api: Temperature_Sensor_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(air_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Devices\/Temperature_Sensor_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Temperature_Sensor_impl_Api {\n  def id: Art.BridgeId\n  def air_Id : Art.PortId\n  def current_tempWstatus_Id : Art.PortId\n\n  def setcurrent_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Temperature_Sensor_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val air_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId) extends Temperature_Sensor_impl_Api\n\n@datatype class Temperature_Sensor_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val air_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId) extends Temperature_Sensor_impl_Api {\n\n  def getair() : Option[Isolette_Data_Model.PhysicalTemp_impl] = {\n    val value : Option[Isolette_Data_Model.PhysicalTemp_impl] = Art.getValue(air_Id) match {\n      case Some(Isolette_Data_Model.PhysicalTemp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port air.  Expecting 'Isolette_Data_Model.PhysicalTemp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.PhysicalTemp_impl]()\n      case _ => None[Isolette_Data_Model.PhysicalTemp_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Temperature_Sensor_impl_temperature_sensor_cpi_thermostat {\n\n  def initialise(api: Temperature_Sensor_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setcurrent_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n\n  def timeTriggered(api: Temperature_Sensor_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_air: Option[Isolette_Data_Model.PhysicalTemp_impl] = api.getair()\n    api.logInfo(s\"Received on air: ${apiUsage_air}\")\n  }\n\n  def activate(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def recover(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Heat_Source_impl_heat_source_cpi_heat_controller_TestApi extends BridgeTestSuite[Heat_Source_impl_heat_source_cpi_heat_controller_Bridge](Arch.isolette_single_sensor_Instance_heat_source_cpi_heat_controller) {\n\n  \/** helper function to set the values of all input ports.\n   * @param heat_control payload for data port heat_control\n   *\/\n  def put_concrete_inputs(heat_control : Isolette_Data_Model.On_Off.Type): Unit = {\n    put_heat_control(heat_control)\n  }\n\n\n  \/** helper function to check Heat_Source_impl_heat_source_cpi_heat_controller's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param heat_out method that will be called with the value of the outgoing data\n   *        port 'heat_out'.\n   *\/\n  def check_concrete_output(heat_out: Isolette_Environment.Heat.Type => B = heat_outParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val heat_outValue: Isolette_Environment.Heat.Type = get_heat_out().get\n    if(!heat_out(heat_outValue)) {\n      testFailures = testFailures :+ st\"'heat_out' did not match expected: value of the outgoing data port is ${heat_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_heat_control(value : Isolette_Data_Model.On_Off.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.heat_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_heat_out(): Option[Isolette_Environment.Heat.Type] = {\n    val value: Option[Isolette_Environment.Heat.Type] = get_heat_out_payload() match {\n      case Some(Isolette_Environment.Heat_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port heat_out.  Expecting 'Isolette_Environment.Heat_Payload' but received ${v}\")\n      case _ => None[Isolette_Environment.Heat.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_heat_out_payload(): Option[Isolette_Environment.Heat_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.heat_out_Id).asInstanceOf[Option[Isolette_Environment.Heat_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport slang_embedded.Devices._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Heat_Source_impl_heat_source_cpi_heat_controller_Test extends Heat_Source_impl_heat_source_cpi_heat_controller_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.Devices.{Heat_Source_impl_heat_source_cpi_heat_controller => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Heat_Source_impl_heat_source_cpi_heat_controller_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  heat_control: Port[Isolette_Data_Model.On_Off.Type],\n  heat_out: Port[Isolette_Environment.Heat.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(heat_control,\n              heat_out),\n\n    dataIns = ISZ(heat_control),\n\n    dataOuts = ISZ(heat_out),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Heat_Source_impl_Initialization_Api = {\n    val api = Heat_Source_impl_Initialization_Api(\n      id,\n      heat_control.id,\n      heat_out.id\n    )\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Heat_Source_impl_Operational_Api = {\n    val api = Heat_Source_impl_Operational_Api(\n      id,\n      heat_control.id,\n      heat_out.id\n    )\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.EntryPoints(\n      id,\n\n      heat_control.id,\n      heat_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Heat_Source_impl_heat_source_cpi_heat_controller_Bridge {\n\n  var c_initialization_api: Option[Heat_Source_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Heat_Source_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Heat_Source_impl_heat_source_cpi_heat_controller_BridgeId : Art.BridgeId,\n\n    heat_control_Id : Art.PortId,\n    heat_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Heat_Source_impl_Initialization_Api,\n    operational_api: Heat_Source_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(heat_control_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(heat_out_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/Devices\/Heat_Source_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait Heat_Source_impl_Api {\n  def id: Art.BridgeId\n  def heat_control_Id : Art.PortId\n  def heat_out_Id : Art.PortId\n\n  def setheat_out(value : Isolette_Environment.Heat.Type) : Unit = {\n    Art.putValue(heat_out_Id, Isolette_Environment.Heat_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Heat_Source_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val heat_control_Id : Art.PortId,\n  val heat_out_Id : Art.PortId) extends Heat_Source_impl_Api\n\n@datatype class Heat_Source_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val heat_control_Id : Art.PortId,\n  val heat_out_Id : Art.PortId) extends Heat_Source_impl_Api {\n\n  def getheat_control() : Option[Isolette_Data_Model.On_Off.Type] = {\n    val value : Option[Isolette_Data_Model.On_Off.Type] = Art.getValue(heat_control_Id) match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port heat_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n        None[Isolette_Data_Model.On_Off.Type]()\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Heat_Source_impl_heat_source_cpi_heat_controller {\n\n  def initialise(api: Heat_Source_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setheat_out(Isolette_Environment.Heat.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Heat_Source_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_heat_control: Option[Isolette_Data_Model.On_Off.Type] = api.getheat_control()\n    api.logInfo(s\"Received on heat_control: ${apiUsage_heat_control}\")\n  }\n\n  def activate(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def recover(api: Heat_Source_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/mrit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix\n\nobject mrit extends App {\n\n  val mritBridge : slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_current_tempWstatus\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_tempWstatus\", mode = DataIn)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_tempWstatus\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_mode\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_temp\", mode = DataOut)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 5, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_temp\", mode = DataOut)\n    val displayed_temp = Port[Isolette_Data_Model.Temp_impl] (id = 6, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_displayed_temp\", mode = DataOut)\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 7, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 8, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_interface_failure\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      regulator_mode = regulator_mode,\n      upper_desired_temp = upper_desired_temp,\n      lower_desired_temp = lower_desired_temp,\n      displayed_temp = displayed_temp,\n      regulator_status = regulator_status,\n      interface_failure = interface_failure\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = mritBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = mritBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ lower_desired_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val lower_desired_tempWstatus_id: Art.PortId = mritBridge.lower_desired_tempWstatus.id\n  var lower_desired_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ upper_desired_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val upper_desired_tempWstatus_id: Art.PortId = mritBridge.upper_desired_tempWstatus.id\n  var upper_desired_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ regulator_mode: In DataPort Isolette_Data_Model.Regulator_Mode\n  val regulator_mode_id: Art.PortId = mritBridge.regulator_mode.id\n  var regulator_mode_port: Option[DataContent] = noData\n\n  \/\/ upper_desired_temp: Out DataPort Isolette_Data_Model.Temp_impl\n  val upper_desired_temp_id: Art.PortId = mritBridge.upper_desired_temp.id\n  var upper_desired_temp_port: Option[DataContent] = noData\n\n  \/\/ lower_desired_temp: Out DataPort Isolette_Data_Model.Temp_impl\n  val lower_desired_temp_id: Art.PortId = mritBridge.lower_desired_temp.id\n  var lower_desired_temp_port: Option[DataContent] = noData\n\n  \/\/ displayed_temp: Out DataPort Isolette_Data_Model.Temp_impl\n  val displayed_temp_id: Art.PortId = mritBridge.displayed_temp.id\n  var displayed_temp_port: Option[DataContent] = noData\n\n  \/\/ regulator_status: Out DataPort Isolette_Data_Model.Status\n  val regulator_status_id: Art.PortId = mritBridge.regulator_status.id\n  var regulator_status_port: Option[DataContent] = noData\n\n  \/\/ interface_failure: Out DataPort Isolette_Data_Model.Failure_Flag_impl\n  val interface_failure_id: Art.PortId = mritBridge.interface_failure.id\n  var interface_failure_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == lower_desired_tempWstatus_id) {\n      return lower_desired_tempWstatus_port\n    } else if(portId == upper_desired_tempWstatus_id) {\n      return upper_desired_tempWstatus_port\n    } else if(portId == regulator_mode_id) {\n      return regulator_mode_port\n    } else {\n      halt(s\"Unexpected: mrit.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    current_tempWstatus_port = Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.current_tempWstatus_Receive()\n\n    lower_desired_tempWstatus_port = Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.lower_desired_tempWstatus_Receive()\n\n    upper_desired_tempWstatus_port = Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.upper_desired_tempWstatus_Receive()\n\n    regulator_mode_port = Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.regulator_mode_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == upper_desired_temp_id) {\n      upper_desired_temp_port = Some(data)\n    } else if(portId == lower_desired_temp_id) {\n      lower_desired_temp_port = Some(data)\n    } else if(portId == displayed_temp_id) {\n      displayed_temp_port = Some(data)\n    } else if(portId == regulator_status_id) {\n      regulator_status_port = Some(data)\n    } else if(portId == interface_failure_id) {\n      interface_failure_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mrit.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(upper_desired_temp_port.nonEmpty) {\n      Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.upper_desired_temp_Send(upper_desired_temp_port.get)\n      upper_desired_temp_port = noData\n    }\n\n    if(lower_desired_temp_port.nonEmpty) {\n      Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.lower_desired_temp_Send(lower_desired_temp_port.get)\n      lower_desired_temp_port = noData\n    }\n\n    if(displayed_temp_port.nonEmpty) {\n      Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.displayed_temp_Send(displayed_temp_port.get)\n      displayed_temp_port = noData\n    }\n\n    if(regulator_status_port.nonEmpty) {\n      Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.regulator_status_Send(regulator_status_port.get)\n      regulator_status_port = noData\n    }\n\n    if(interface_failure_port.nonEmpty) {\n      Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.interface_failure_Send(interface_failure_port.get)\n      interface_failure_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (mritBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_lower_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.getlower_desired_tempWstatus()\n      val apiUsage_upper_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.getupper_desired_tempWstatus()\n      val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.getregulator_mode()\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.setupper_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.setupper_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.setlower_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.setlower_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.setdisplayed_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.setdisplayed_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.setregulator_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.setregulator_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api.get.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n      slang_embedded.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api.get.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix {\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's lower_desired_tempWstatus port is empty, F otherwise \n  def lower_desired_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's lower_desired_tempWstatus port \n  def lower_desired_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's upper_desired_tempWstatus port is empty, F otherwise \n  def upper_desired_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's upper_desired_tempWstatus port \n  def upper_desired_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's regulator_mode port is empty, F otherwise \n  def regulator_mode_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's regulator_mode port \n  def regulator_mode_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's upper_desired_temp port\n  def upper_desired_temp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's lower_desired_temp port\n  def lower_desired_temp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's displayed_temp port\n  def displayed_temp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's regulator_status port\n  def regulator_status_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's interface_failure port\n  def interface_failure_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\nobject Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_Ext {\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def lower_desired_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def lower_desired_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def upper_desired_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def upper_desired_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def regulator_mode_IsEmpty(): B = halt(\"stub\")\n\n  def regulator_mode_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def upper_desired_temp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def lower_desired_temp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def displayed_temp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def regulator_status_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def interface_failure_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.h>\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_mrit_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_mrit_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_mrit_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_mrit_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_REGULATOR_INTERFACE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_REGULATOR_INTERFACE_MRIT_ADAPTER_H\n#define MANAGE_REGULATOR_INTERFACE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_REGULATOR_INTERFACE_MRIT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/mhst.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix\n\nobject mhst extends App {\n\n  val mhstBridge : slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_current_tempWstatus\", mode = DataIn)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_lower_desired_temp\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_upper_desired_temp\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_regulator_mode\", mode = DataIn)\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_heat_control\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_temp = lower_desired_temp,\n      upper_desired_temp = upper_desired_temp,\n      regulator_mode = regulator_mode,\n      heat_control = heat_control\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = mhstBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = mhstBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ lower_desired_temp: In DataPort Isolette_Data_Model.Temp_impl\n  val lower_desired_temp_id: Art.PortId = mhstBridge.lower_desired_temp.id\n  var lower_desired_temp_port: Option[DataContent] = noData\n\n  \/\/ upper_desired_temp: In DataPort Isolette_Data_Model.Temp_impl\n  val upper_desired_temp_id: Art.PortId = mhstBridge.upper_desired_temp.id\n  var upper_desired_temp_port: Option[DataContent] = noData\n\n  \/\/ regulator_mode: In DataPort Isolette_Data_Model.Regulator_Mode\n  val regulator_mode_id: Art.PortId = mhstBridge.regulator_mode.id\n  var regulator_mode_port: Option[DataContent] = noData\n\n  \/\/ heat_control: Out DataPort Isolette_Data_Model.On_Off\n  val heat_control_id: Art.PortId = mhstBridge.heat_control.id\n  var heat_control_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == lower_desired_temp_id) {\n      return lower_desired_temp_port\n    } else if(portId == upper_desired_temp_id) {\n      return upper_desired_temp_port\n    } else if(portId == regulator_mode_id) {\n      return regulator_mode_port\n    } else {\n      halt(s\"Unexpected: mhst.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    current_tempWstatus_port = Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.current_tempWstatus_Receive()\n\n    lower_desired_temp_port = Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.lower_desired_temp_Receive()\n\n    upper_desired_temp_port = Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.upper_desired_temp_Receive()\n\n    regulator_mode_port = Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.regulator_mode_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == heat_control_id) {\n      heat_control_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mhst.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(heat_control_port.nonEmpty) {\n      Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.heat_control_Send(heat_control_port.get)\n      heat_control_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (mhstBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_lower_desired_temp: Option[Isolette_Data_Model.Temp_impl] = slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.getlower_desired_temp()\n      val apiUsage_upper_desired_temp: Option[Isolette_Data_Model.Temp_impl] = slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.getupper_desired_temp()\n      val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.getregulator_mode()\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api.get.setheat_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n      slang_embedded.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api.get.setheat_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix {\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's lower_desired_temp port is empty, F otherwise \n  def lower_desired_temp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's lower_desired_temp port \n  def lower_desired_temp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's upper_desired_temp port is empty, F otherwise \n  def upper_desired_temp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's upper_desired_temp port \n  def upper_desired_temp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's regulator_mode port is empty, F otherwise \n  def regulator_mode_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's regulator_mode port \n  def regulator_mode_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's heat_control port\n  def heat_control_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\nobject Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_Ext {\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def lower_desired_temp_IsEmpty(): B = halt(\"stub\")\n\n  def lower_desired_temp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def upper_desired_temp_IsEmpty(): B = halt(\"stub\")\n\n  def upper_desired_temp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def regulator_mode_IsEmpty(): B = halt(\"stub\")\n\n  def regulator_mode_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def heat_control_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.h>\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_mhst_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_mhst_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_mhst_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_mhst_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_HEAT_SOURCE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_HEAT_SOURCE_MHST_ADAPTER_H\n#define MANAGE_HEAT_SOURCE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_HEAT_SOURCE_MHST_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/mrmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix\n\nobject mrmt extends App {\n\n  val mrmtBridge : slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_internal_failure\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_regulator_mode\", mode = DataOut)\n\n    slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      regulator_mode = regulator_mode\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = mrmtBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = mrmtBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ interface_failure: In DataPort Isolette_Data_Model.Failure_Flag_impl\n  val interface_failure_id: Art.PortId = mrmtBridge.interface_failure.id\n  var interface_failure_port: Option[DataContent] = noData\n\n  \/\/ internal_failure: In DataPort Isolette_Data_Model.Failure_Flag_impl\n  val internal_failure_id: Art.PortId = mrmtBridge.internal_failure.id\n  var internal_failure_port: Option[DataContent] = noData\n\n  \/\/ regulator_mode: Out DataPort Isolette_Data_Model.Regulator_Mode\n  val regulator_mode_id: Art.PortId = mrmtBridge.regulator_mode.id\n  var regulator_mode_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == interface_failure_id) {\n      return interface_failure_port\n    } else if(portId == internal_failure_id) {\n      return internal_failure_port\n    } else {\n      halt(s\"Unexpected: mrmt.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    current_tempWstatus_port = Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix.current_tempWstatus_Receive()\n\n    interface_failure_port = Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix.interface_failure_Receive()\n\n    internal_failure_port = Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix.internal_failure_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == regulator_mode_id) {\n      regulator_mode_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mrmt.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(regulator_mode_port.nonEmpty) {\n      Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix.regulator_mode_Send(regulator_mode_port.get)\n      regulator_mode_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (mrmtBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.getinterface_failure()\n      val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.getinternal_failure()\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api.get.setregulator_mode(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n      slang_embedded.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api.get.setregulator_mode(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix {\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's interface_failure port is empty, F otherwise \n  def interface_failure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's interface_failure port \n  def interface_failure_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's internal_failure port is empty, F otherwise \n  def internal_failure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's internal_failure port \n  def internal_failure_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's regulator_mode port\n  def regulator_mode_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Regulate\n\nimport org.sireum._\nimport art._\n\nobject Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_Ext {\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def interface_failure_IsEmpty(): B = halt(\"stub\")\n\n  def interface_failure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def internal_failure_IsEmpty(): B = halt(\"stub\")\n\n  def internal_failure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def regulator_mode_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.h>\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_mrmt_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_mrmt_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_mrmt_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_mrmt_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_REGULATOR_MODE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_REGULATOR_MODE_MRMT_ADAPTER_H\n#define MANAGE_REGULATOR_MODE_IMPL_THERMOSTAT_REGULATE_TEMPERATURE_MANAGE_REGULATOR_MODE_MRMT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/mat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix\n\nobject mat extends App {\n\n  val matBridge : slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_current_tempWstatus\", mode = DataIn)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_lower_alarm_temp\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_upper_alarm_temp\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_monitor_mode\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_alarm_control\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_alarm_temp = lower_alarm_temp,\n      upper_alarm_temp = upper_alarm_temp,\n      monitor_mode = monitor_mode,\n      alarm_control = alarm_control\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = matBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = matBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ lower_alarm_temp: In DataPort Isolette_Data_Model.Temp_impl\n  val lower_alarm_temp_id: Art.PortId = matBridge.lower_alarm_temp.id\n  var lower_alarm_temp_port: Option[DataContent] = noData\n\n  \/\/ upper_alarm_temp: In DataPort Isolette_Data_Model.Temp_impl\n  val upper_alarm_temp_id: Art.PortId = matBridge.upper_alarm_temp.id\n  var upper_alarm_temp_port: Option[DataContent] = noData\n\n  \/\/ monitor_mode: In DataPort Isolette_Data_Model.Monitor_Mode\n  val monitor_mode_id: Art.PortId = matBridge.monitor_mode.id\n  var monitor_mode_port: Option[DataContent] = noData\n\n  \/\/ alarm_control: Out DataPort Isolette_Data_Model.On_Off\n  val alarm_control_id: Art.PortId = matBridge.alarm_control.id\n  var alarm_control_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == lower_alarm_temp_id) {\n      return lower_alarm_temp_port\n    } else if(portId == upper_alarm_temp_id) {\n      return upper_alarm_temp_port\n    } else if(portId == monitor_mode_id) {\n      return monitor_mode_port\n    } else {\n      halt(s\"Unexpected: mat.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    current_tempWstatus_port = Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.current_tempWstatus_Receive()\n\n    lower_alarm_temp_port = Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.lower_alarm_temp_Receive()\n\n    upper_alarm_temp_port = Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.upper_alarm_temp_Receive()\n\n    monitor_mode_port = Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.monitor_mode_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == alarm_control_id) {\n      alarm_control_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mat.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(alarm_control_port.nonEmpty) {\n      Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.alarm_control_Send(alarm_control_port.get)\n      alarm_control_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (matBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_lower_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.getlower_alarm_temp()\n      val apiUsage_upper_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.getupper_alarm_temp()\n      val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.getmonitor_mode()\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api.get.setalarm_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n      slang_embedded.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api.get.setalarm_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix {\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's lower_alarm_temp port is empty, F otherwise \n  def lower_alarm_temp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's lower_alarm_temp port \n  def lower_alarm_temp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's upper_alarm_temp port is empty, F otherwise \n  def upper_alarm_temp_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's upper_alarm_temp port \n  def upper_alarm_temp_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's monitor_mode port is empty, F otherwise \n  def monitor_mode_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's monitor_mode port \n  def monitor_mode_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's alarm_control port\n  def alarm_control_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\nobject Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_Ext {\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def lower_alarm_temp_IsEmpty(): B = halt(\"stub\")\n\n  def lower_alarm_temp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def upper_alarm_temp_IsEmpty(): B = halt(\"stub\")\n\n  def upper_alarm_temp_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def monitor_mode_IsEmpty(): B = halt(\"stub\")\n\n  def monitor_mode_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def alarm_control_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.h>\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_mat_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_mat_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_mat_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_mat_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_ALARM_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_ALARM_MAT_ADAPTER_H\n#define MANAGE_ALARM_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_ALARM_MAT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/mmit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix\n\nobject mmit extends App {\n\n  val mmitBridge : slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge = {\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_tempWstatus\", mode = DataIn)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_tempWstatus\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_current_tempWstatus\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_mode\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_temp\", mode = DataOut)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 5, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_temp\", mode = DataOut)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 6, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 7, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_interface_failure\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      current_tempWstatus = current_tempWstatus,\n      monitor_mode = monitor_mode,\n      upper_alarm_temp = upper_alarm_temp,\n      lower_alarm_temp = lower_alarm_temp,\n      monitor_status = monitor_status,\n      interface_failure = interface_failure\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = mmitBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ upper_alarm_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val upper_alarm_tempWstatus_id: Art.PortId = mmitBridge.upper_alarm_tempWstatus.id\n  var upper_alarm_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ lower_alarm_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val lower_alarm_tempWstatus_id: Art.PortId = mmitBridge.lower_alarm_tempWstatus.id\n  var lower_alarm_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = mmitBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ monitor_mode: In DataPort Isolette_Data_Model.Monitor_Mode\n  val monitor_mode_id: Art.PortId = mmitBridge.monitor_mode.id\n  var monitor_mode_port: Option[DataContent] = noData\n\n  \/\/ upper_alarm_temp: Out DataPort Isolette_Data_Model.Temp_impl\n  val upper_alarm_temp_id: Art.PortId = mmitBridge.upper_alarm_temp.id\n  var upper_alarm_temp_port: Option[DataContent] = noData\n\n  \/\/ lower_alarm_temp: Out DataPort Isolette_Data_Model.Temp_impl\n  val lower_alarm_temp_id: Art.PortId = mmitBridge.lower_alarm_temp.id\n  var lower_alarm_temp_port: Option[DataContent] = noData\n\n  \/\/ monitor_status: Out DataPort Isolette_Data_Model.Status\n  val monitor_status_id: Art.PortId = mmitBridge.monitor_status.id\n  var monitor_status_port: Option[DataContent] = noData\n\n  \/\/ interface_failure: Out DataPort Isolette_Data_Model.Failure_Flag_impl\n  val interface_failure_id: Art.PortId = mmitBridge.interface_failure.id\n  var interface_failure_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == upper_alarm_tempWstatus_id) {\n      return upper_alarm_tempWstatus_port\n    } else if(portId == lower_alarm_tempWstatus_id) {\n      return lower_alarm_tempWstatus_port\n    } else if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == monitor_mode_id) {\n      return monitor_mode_port\n    } else {\n      halt(s\"Unexpected: mmit.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    upper_alarm_tempWstatus_port = Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.upper_alarm_tempWstatus_Receive()\n\n    lower_alarm_tempWstatus_port = Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.lower_alarm_tempWstatus_Receive()\n\n    current_tempWstatus_port = Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.current_tempWstatus_Receive()\n\n    monitor_mode_port = Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.monitor_mode_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == upper_alarm_temp_id) {\n      upper_alarm_temp_port = Some(data)\n    } else if(portId == lower_alarm_temp_id) {\n      lower_alarm_temp_port = Some(data)\n    } else if(portId == monitor_status_id) {\n      monitor_status_port = Some(data)\n    } else if(portId == interface_failure_id) {\n      interface_failure_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mmit.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(upper_alarm_temp_port.nonEmpty) {\n      Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.upper_alarm_temp_Send(upper_alarm_temp_port.get)\n      upper_alarm_temp_port = noData\n    }\n\n    if(lower_alarm_temp_port.nonEmpty) {\n      Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.lower_alarm_temp_Send(lower_alarm_temp_port.get)\n      lower_alarm_temp_port = noData\n    }\n\n    if(monitor_status_port.nonEmpty) {\n      Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.monitor_status_Send(monitor_status_port.get)\n      monitor_status_port = noData\n    }\n\n    if(interface_failure_port.nonEmpty) {\n      Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.interface_failure_Send(interface_failure_port.get)\n      interface_failure_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (mmitBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_upper_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.getupper_alarm_tempWstatus()\n      val apiUsage_lower_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.getlower_alarm_tempWstatus()\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.getmonitor_mode()\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.setupper_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.setupper_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.setlower_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.setlower_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.setmonitor_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.setmonitor_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api.get.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n      slang_embedded.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api.get.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix {\n  \/\/ returns T if seL4's upper_alarm_tempWstatus port is empty, F otherwise \n  def upper_alarm_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's upper_alarm_tempWstatus port \n  def upper_alarm_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's lower_alarm_tempWstatus port is empty, F otherwise \n  def lower_alarm_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's lower_alarm_tempWstatus port \n  def lower_alarm_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's monitor_mode port is empty, F otherwise \n  def monitor_mode_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's monitor_mode port \n  def monitor_mode_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's upper_alarm_temp port\n  def upper_alarm_temp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's lower_alarm_temp port\n  def lower_alarm_temp_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's monitor_status port\n  def monitor_status_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's interface_failure port\n  def interface_failure_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\nobject Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_Ext {\n  def upper_alarm_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def upper_alarm_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def lower_alarm_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def lower_alarm_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def monitor_mode_IsEmpty(): B = halt(\"stub\")\n\n  def monitor_mode_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def upper_alarm_temp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def lower_alarm_temp_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def monitor_status_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def interface_failure_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.h>\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_mmit_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_mmit_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_mmit_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_mmit_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_MONITOR_INTERFACE_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_MONITOR_INTERFACE_MMIT_ADAPTER_H\n#define MANAGE_MONITOR_INTERFACE_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_MONITOR_INTERFACE_MMIT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/mmmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix\n\nobject mmmt extends App {\n\n  val mmmtBridge : slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_internal_failure\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_monitor_mode\", mode = DataOut)\n\n    slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      monitor_mode = monitor_mode\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = mmmtBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ current_tempWstatus: In DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = mmmtBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ interface_failure: In DataPort Isolette_Data_Model.Failure_Flag_impl\n  val interface_failure_id: Art.PortId = mmmtBridge.interface_failure.id\n  var interface_failure_port: Option[DataContent] = noData\n\n  \/\/ internal_failure: In DataPort Isolette_Data_Model.Failure_Flag_impl\n  val internal_failure_id: Art.PortId = mmmtBridge.internal_failure.id\n  var internal_failure_port: Option[DataContent] = noData\n\n  \/\/ monitor_mode: Out DataPort Isolette_Data_Model.Monitor_Mode\n  val monitor_mode_id: Art.PortId = mmmtBridge.monitor_mode.id\n  var monitor_mode_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == current_tempWstatus_id) {\n      return current_tempWstatus_port\n    } else if(portId == interface_failure_id) {\n      return interface_failure_port\n    } else if(portId == internal_failure_id) {\n      return internal_failure_port\n    } else {\n      halt(s\"Unexpected: mmmt.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    current_tempWstatus_port = Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix.current_tempWstatus_Receive()\n\n    interface_failure_port = Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix.interface_failure_Receive()\n\n    internal_failure_port = Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix.internal_failure_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == monitor_mode_id) {\n      monitor_mode_port = Some(data)\n    } else {\n      halt(s\"Unexpected: mmmt.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(monitor_mode_port.nonEmpty) {\n      Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix.monitor_mode_Send(monitor_mode_port.get)\n      monitor_mode_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (mmmtBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.getcurrent_tempWstatus()\n      val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.getinterface_failure()\n      val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.getinternal_failure()\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api.get.setmonitor_mode(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n      slang_embedded.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api.get.setmonitor_mode(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\n@ext object Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix {\n  \/\/ returns T if seL4's current_tempWstatus port is empty, F otherwise \n  def current_tempWstatus_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's current_tempWstatus port \n  def current_tempWstatus_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's interface_failure port is empty, F otherwise \n  def interface_failure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's interface_failure port \n  def interface_failure_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's internal_failure port is empty, F otherwise \n  def internal_failure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's internal_failure port \n  def internal_failure_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's monitor_mode port\n  def monitor_mode_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Monitor\n\nimport org.sireum._\nimport art._\n\nobject Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_Ext {\n  def current_tempWstatus_IsEmpty(): B = halt(\"stub\")\n\n  def current_tempWstatus_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def interface_failure_IsEmpty(): B = halt(\"stub\")\n\n  def interface_failure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def internal_failure_IsEmpty(): B = halt(\"stub\")\n\n  def internal_failure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def monitor_mode_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.h>\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_mmmt_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_mmmt_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_mmmt_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_entryPoints\", 0);\n\n  return slang_embedded_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_mmmt_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef MANAGE_MONITOR_MODE_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_MONITOR_MODE_MMMT_ADAPTER_H\n#define MANAGE_MONITOR_MODE_IMPL_THERMOSTAT_MONITOR_TEMPERATURE_MANAGE_MONITOR_MODE_MMMT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/operator_interface_thread_impl_operator_interface_oip_oit\/oit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.operator_interface_thread_impl_operator_interface_oip_oit\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix\n\nobject oit extends App {\n\n  val oitBridge : slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge = {\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 0, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_regulator_status\", mode = DataIn)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 1, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_monitor_status\", mode = DataIn)\n    val display_temperature = Port[Isolette_Data_Model.Temp_impl] (id = 2, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_display_temperature\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 3, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_alarm_control\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 4, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus\", mode = DataOut)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 5, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus\", mode = DataOut)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 6, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus\", mode = DataOut)\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 7, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus\", mode = DataOut)\n\n    slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_operator_interface_oip_oit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      regulator_status = regulator_status,\n      monitor_status = monitor_status,\n      display_temperature = display_temperature,\n      alarm_control = alarm_control,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = oitBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ regulator_status: In DataPort Isolette_Data_Model.Status\n  val regulator_status_id: Art.PortId = oitBridge.regulator_status.id\n  var regulator_status_port: Option[DataContent] = noData\n\n  \/\/ monitor_status: In DataPort Isolette_Data_Model.Status\n  val monitor_status_id: Art.PortId = oitBridge.monitor_status.id\n  var monitor_status_port: Option[DataContent] = noData\n\n  \/\/ display_temperature: In DataPort Isolette_Data_Model.Temp_impl\n  val display_temperature_id: Art.PortId = oitBridge.display_temperature.id\n  var display_temperature_port: Option[DataContent] = noData\n\n  \/\/ alarm_control: In DataPort Isolette_Data_Model.On_Off\n  val alarm_control_id: Art.PortId = oitBridge.alarm_control.id\n  var alarm_control_port: Option[DataContent] = noData\n\n  \/\/ lower_desired_tempWstatus: Out DataPort Isolette_Data_Model.TempWstatus_impl\n  val lower_desired_tempWstatus_id: Art.PortId = oitBridge.lower_desired_tempWstatus.id\n  var lower_desired_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ upper_desired_tempWstatus: Out DataPort Isolette_Data_Model.TempWstatus_impl\n  val upper_desired_tempWstatus_id: Art.PortId = oitBridge.upper_desired_tempWstatus.id\n  var upper_desired_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ lower_alarm_tempWstatus: Out DataPort Isolette_Data_Model.TempWstatus_impl\n  val lower_alarm_tempWstatus_id: Art.PortId = oitBridge.lower_alarm_tempWstatus.id\n  var lower_alarm_tempWstatus_port: Option[DataContent] = noData\n\n  \/\/ upper_alarm_tempWstatus: Out DataPort Isolette_Data_Model.TempWstatus_impl\n  val upper_alarm_tempWstatus_id: Art.PortId = oitBridge.upper_alarm_tempWstatus.id\n  var upper_alarm_tempWstatus_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == regulator_status_id) {\n      return regulator_status_port\n    } else if(portId == monitor_status_id) {\n      return monitor_status_port\n    } else if(portId == display_temperature_id) {\n      return display_temperature_port\n    } else if(portId == alarm_control_id) {\n      return alarm_control_port\n    } else {\n      halt(s\"Unexpected: oit.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    regulator_status_port = operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.regulator_status_Receive()\n\n    monitor_status_port = operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.monitor_status_Receive()\n\n    display_temperature_port = operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.display_temperature_Receive()\n\n    alarm_control_port = operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.alarm_control_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == lower_desired_tempWstatus_id) {\n      lower_desired_tempWstatus_port = Some(data)\n    } else if(portId == upper_desired_tempWstatus_id) {\n      upper_desired_tempWstatus_port = Some(data)\n    } else if(portId == lower_alarm_tempWstatus_id) {\n      lower_alarm_tempWstatus_port = Some(data)\n    } else if(portId == upper_alarm_tempWstatus_id) {\n      upper_alarm_tempWstatus_port = Some(data)\n    } else {\n      halt(s\"Unexpected: oit.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(lower_desired_tempWstatus_port.nonEmpty) {\n      operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.lower_desired_tempWstatus_Send(lower_desired_tempWstatus_port.get)\n      lower_desired_tempWstatus_port = noData\n    }\n\n    if(upper_desired_tempWstatus_port.nonEmpty) {\n      operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.upper_desired_tempWstatus_Send(upper_desired_tempWstatus_port.get)\n      upper_desired_tempWstatus_port = noData\n    }\n\n    if(lower_alarm_tempWstatus_port.nonEmpty) {\n      operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.lower_alarm_tempWstatus_Send(lower_alarm_tempWstatus_port.get)\n      lower_alarm_tempWstatus_port = noData\n    }\n\n    if(upper_alarm_tempWstatus_port.nonEmpty) {\n      operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.upper_alarm_tempWstatus_Send(upper_alarm_tempWstatus_port.get)\n      upper_alarm_tempWstatus_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (oitBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_regulator_status: Option[Isolette_Data_Model.Status.Type] = slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.getregulator_status()\n      val apiUsage_monitor_status: Option[Isolette_Data_Model.Status.Type] = slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.getmonitor_status()\n      val apiUsage_display_temperature: Option[Isolette_Data_Model.Temp_impl] = slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.getdisplay_temperature()\n      val apiUsage_alarm_control: Option[Isolette_Data_Model.On_Off.Type] = slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.getalarm_control()\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.setlower_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.setlower_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.setupper_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.setupper_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.setlower_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.setlower_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api.get.setupper_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api.get.setupper_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Isolette\n\nimport org.sireum._\nimport art._\n\n@ext object operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix {\n  \/\/ returns T if seL4's regulator_status port is empty, F otherwise \n  def regulator_status_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's regulator_status port \n  def regulator_status_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's monitor_status port is empty, F otherwise \n  def monitor_status_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's monitor_status port \n  def monitor_status_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's display_temperature port is empty, F otherwise \n  def display_temperature_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's display_temperature port \n  def display_temperature_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's alarm_control port is empty, F otherwise \n  def alarm_control_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's alarm_control port \n  def alarm_control_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's lower_desired_tempWstatus port\n  def lower_desired_tempWstatus_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's upper_desired_tempWstatus port\n  def upper_desired_tempWstatus_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's lower_alarm_tempWstatus port\n  def lower_alarm_tempWstatus_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's upper_alarm_tempWstatus port\n  def upper_alarm_tempWstatus_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Isolette\n\nimport org.sireum._\nimport art._\n\nobject operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_Ext {\n  def regulator_status_IsEmpty(): B = halt(\"stub\")\n\n  def regulator_status_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def monitor_status_IsEmpty(): B = halt(\"stub\")\n\n  def monitor_status_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def display_temperature_IsEmpty(): B = halt(\"stub\")\n\n  def display_temperature_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def alarm_control_IsEmpty(): B = halt(\"stub\")\n\n  def alarm_control_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def lower_desired_tempWstatus_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def upper_desired_tempWstatus_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def lower_alarm_tempWstatus_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def upper_alarm_tempWstatus_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <operator_interface_thread_impl_operator_interface_oip_oit_adapter.h>\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"operator_interface_thread_impl_operator_interface_oip_oit_adapter.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_operator_interface_thread_impl_operator_interface_oip_oit_oit_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"operator_interface_thread_impl_operator_interface_oip_oit_adapter.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_operator_interface_thread_impl_operator_interface_oip_oit_oit_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"operator_interface_thread_impl_operator_interface_oip_oit_adapter.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_operator_interface_thread_impl_operator_interface_oip_oit_oit_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"operator_interface_thread_impl_operator_interface_oip_oit_adapter.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_entryPoints\", 0);\n\n  return slang_embedded_operator_interface_thread_impl_operator_interface_oip_oit_oit_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef OPERATOR_INTERFACE_THREAD_IMPL_OPERATOR_INTERFACE_OIP_OIT_ADAPTER_H\n#define OPERATOR_INTERFACE_THREAD_IMPL_OPERATOR_INTERFACE_OIP_OIT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_operator_interface_thread_impl_operator_interface_oip_oit.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(operator_interface_thread_impl_operator_interface_oip_oit\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/thermostat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix\n\nobject thermostat extends App {\n\n  val thermostatBridge : slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge = {\n    val air = Port[Isolette_Data_Model.PhysicalTemp_impl] (id = 0, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_air\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 1, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus\", mode = DataOut)\n\n    slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      air = air,\n      current_tempWstatus = current_tempWstatus\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = thermostatBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ air: In DataPort Isolette_Data_Model.PhysicalTemp_impl\n  val air_id: Art.PortId = thermostatBridge.air.id\n  var air_port: Option[DataContent] = noData\n\n  \/\/ current_tempWstatus: Out DataPort Isolette_Data_Model.TempWstatus_impl\n  val current_tempWstatus_id: Art.PortId = thermostatBridge.current_tempWstatus.id\n  var current_tempWstatus_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == air_id) {\n      return air_port\n    } else {\n      halt(s\"Unexpected: thermostat.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    air_port = Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix.air_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == current_tempWstatus_id) {\n      current_tempWstatus_port = Some(data)\n    } else {\n      halt(s\"Unexpected: thermostat.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(current_tempWstatus_port.nonEmpty) {\n      Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix.current_tempWstatus_Send(current_tempWstatus_port.get)\n      current_tempWstatus_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (thermostatBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_air: Option[Isolette_Data_Model.PhysicalTemp_impl] = slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api.get.getair()\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api.get.setcurrent_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n      slang_embedded.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api.get.setcurrent_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\n\n@ext object Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix {\n  \/\/ returns T if seL4's air port is empty, F otherwise \n  def air_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's air port \n  def air_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's current_tempWstatus port\n  def current_tempWstatus_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport art._\n\nobject Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_Ext {\n  def air_IsEmpty(): B = halt(\"stub\")\n\n  def air_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def current_tempWstatus_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.h>\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_thermostat_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_thermostat_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_thermostat_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_entryPoints\", 0);\n\n  return slang_embedded_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_thermostat_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef TEMPERATURE_SENSOR_IMPL_TEMPERATURE_SENSOR_CPI_THERMOSTAT_ADAPTER_H\n#define TEMPERATURE_SENSOR_IMPL_TEMPERATURE_SENSOR_CPI_THERMOSTAT_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Heat_Source_impl_heat_source_cpi_heat_controller\/heat_controller.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Heat_Source_impl_heat_source_cpi_heat_controller\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix\n\nobject heat_controller extends App {\n\n  val heat_controllerBridge : slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge = {\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 0, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_control\", mode = DataIn)\n    val heat_out = Port[Isolette_Environment.Heat.Type] (id = 1, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_out\", mode = DataOut)\n\n    slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      heat_control = heat_control,\n      heat_out = heat_out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = heat_controllerBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ heat_control: In DataPort Isolette_Data_Model.On_Off\n  val heat_control_id: Art.PortId = heat_controllerBridge.heat_control.id\n  var heat_control_port: Option[DataContent] = noData\n\n  \/\/ heat_out: Out DataPort Isolette_Environment.Heat\n  val heat_out_id: Art.PortId = heat_controllerBridge.heat_out.id\n  var heat_out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == heat_control_id) {\n      return heat_control_port\n    } else {\n      halt(s\"Unexpected: heat_controller.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    heat_control_port = Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix.heat_control_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == heat_out_id) {\n      heat_out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: heat_controller.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(heat_out_port.nonEmpty) {\n      Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix.heat_out_Send(heat_out_port.get)\n      heat_out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (heat_controllerBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n      printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n      printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n      printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n      printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n      printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n      printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n      printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n      printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n      printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n      printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n      printDataContent(art.Empty())\n\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_heat_control: Option[Isolette_Data_Model.On_Off.Type] = slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api.get.getheat_control()\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api.get.setheat_out(Isolette_Environment.Heat.byOrdinal(0).get)\n      slang_embedded.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api.get.setheat_out(Isolette_Environment.Heat.byOrdinal(0).get)\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.Devices\n\nimport org.sireum._\nimport art._\n\n@ext object Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix {\n  \/\/ returns T if seL4's heat_control port is empty, F otherwise \n  def heat_control_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's heat_control port \n  def heat_control_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's heat_out port\n  def heat_out_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.Devices\n\nimport org.sireum._\nimport art._\n\nobject Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_Ext {\n  def heat_control_IsEmpty(): B = halt(\"stub\")\n\n  def heat_control_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def heat_out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <Heat_Source_impl_heat_source_cpi_heat_controller_adapter.h>\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_Heat_Source_impl_heat_source_cpi_heat_controller_heat_controller_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_Heat_Source_impl_heat_source_cpi_heat_controller_heat_controller_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_Heat_Source_impl_heat_source_cpi_heat_controller_heat_controller_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_entryPoints\", 0);\n\n  return slang_embedded_Heat_Source_impl_heat_source_cpi_heat_controller_heat_controller_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef HEAT_SOURCE_IMPL_HEAT_SOURCE_CPI_HEAT_CONTROLLER_ADAPTER_H\n#define HEAT_SOURCE_IMPL_HEAT_SOURCE_CPI_HEAT_CONTROLLER_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_Heat_Source_impl_heat_source_cpi_heat_controller.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(Heat_Source_impl_heat_source_cpi_heat_controller\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <ext.h>\n\n\/\/ add c extension code here\n\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n#include <all.h>\n\n#endif",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Isolette_Environment.Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get))\n    printDataContent(Isolette_Environment.Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get))\n    printDataContent(Base_Types.Float_32_Payload(Base_Types.Float_32_empty()))\n    printDataContent(Isolette_Data_Model.PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty()))\n    printDataContent(Isolette_Data_Model.ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get))\n    printDataContent(Isolette_Data_Model.TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty()))\n    printDataContent(Isolette_Data_Model.On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get))\n    printDataContent(Isolette_Data_Model.Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get))\n    printDataContent(Isolette_Data_Model.Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty()))\n    printDataContent(Isolette_Data_Model.Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get))\n    printDataContent(Base_Types.Boolean_Payload(Base_Types.Boolean_empty()))\n    printDataContent(Isolette_Data_Model.Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty()))\n    printDataContent(Isolette_Data_Model.Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/bin\/transpile-sel4.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Regulate${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\" \\\n  --apps \"slang_embedded.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.mrit\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 9 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=9;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=9\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.mrit\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Regulate${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\" \\\n  --apps \"slang_embedded.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.mhst\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=5\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.mhst\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Regulate${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\" \\\n  --apps \"slang_embedded.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.mrmt\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 4 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=4;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=4\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.mrmt\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Monitor${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\" \\\n  --apps \"slang_embedded.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.mat\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=5\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.mat\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Monitor${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\" \\\n  --apps \"slang_embedded.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.mmit\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 8 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=8;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=8\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.mmit\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Monitor${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\" \\\n  --apps \"slang_embedded.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.mmmt\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 4 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=4;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=4\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.mmmt\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/operator_interface_thread_impl_operator_interface_oip_oit\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Isolette${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/operator_interface_thread_impl_operator_interface_oip_oit\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"operator_interface_thread_impl_operator_interface_oip_oit\" \\\n  --apps \"slang_embedded.operator_interface_thread_impl_operator_interface_oip_oit.oit\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 8 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=8;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=8\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_operator_interface_thread_impl_operator_interface_oip_oit.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.operator_interface_thread_impl_operator_interface_oip_oit.oit\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Devices${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\" \\\n  --apps \"slang_embedded.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.thermostat\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.thermostat\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/Heat_Source_impl_heat_source_cpi_heat_controller\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Devices${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/Heat_Source_impl_heat_source_cpi_heat_controller\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"Heat_Source_impl_heat_source_cpi_heat_controller\" \\\n  --apps \"slang_embedded.Heat_Source_impl_heat_source_cpi_heat_controller.heat_controller\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_Heat_Source_impl_heat_source_cpi_heat_controller.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.Heat_Source_impl_heat_source_cpi_heat_controller.heat_controller\" \\\n  --stack-size \"217088\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller_adapter.c\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"SlangTypeLibrary\" \\\n  --apps \"slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --fingerprint 3 \\\n  --bits 64 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --lib-only \\\n  --verbose",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    ArtDebug_Ext.start()\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 9\n  val maxPorts: PortId = 47\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill is included with Sireum Kekinian: https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang-embedded ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w slang_embedded.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `slang_embedded` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.sireum.version.scala\n  val scalaVer = \"2.13.3\"\n\n  \/\/ versions.properties key: org.sireum.version.scalatest\n  val scalaTestVersion = \"3.2.3\"\n\n  \/\/ versions.properties key: org.sireum.version.scalac-plugin\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20201221.73c7e64\n  val sireumScalacVersion = \"4.20201221.73c7e64\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20201221.b159c6f\n  val kekinianVersion = \"4.20201221.b159c6f\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"slang_embedded.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"slang_embedded.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/slang_embedded\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val isolette_single_sensor_Instance = slangEmbeddedProject(\"isolette_single_sensor_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.sireum.version.scala\nval scalaVer = \"2.13.3\"\n\n\/\/ versions.properties key: org.sireum.version.scalatest\nval scalaTestVersion = \"3.2.3\"\n\n\/\/ versions.properties key: org.sireum.version.scalac-plugin\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20201221.73c7e64\nval sireumScalacVersion = \"4.20201221.73c7e64\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20201221.b159c6f\nval kekinianVersion = \"4.20201221.b159c6f\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.Demo\"),\n\n  mainClass in assembly := Some(\"slang_embedded.Demo\"),\n  assemblyJarName in assembly := \"isolette_single_sensor_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_lower_desired_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_upper_desired_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_regulator_mode;\n  dataport sp_union_art_DataContent_t sb_upper_desired_temp;\n  dataport sp_union_art_DataContent_t sb_lower_desired_temp;\n  dataport sp_union_art_DataContent_t sb_displayed_temp;\n  dataport sp_union_art_DataContent_t sb_regulator_status;\n  dataport sp_union_art_DataContent_t sb_interface_failure;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_lower_desired_temp;\n  dataport sp_union_art_DataContent_t sb_upper_desired_temp;\n  dataport sp_union_art_DataContent_t sb_regulator_mode;\n  dataport sp_union_art_DataContent_t sb_heat_control;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_interface_failure;\n  dataport sp_union_art_DataContent_t sb_regulator_mode;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_lower_alarm_temp;\n  dataport sp_union_art_DataContent_t sb_upper_alarm_temp;\n  dataport sp_union_art_DataContent_t sb_monitor_mode;\n  dataport sp_union_art_DataContent_t sb_alarm_control;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_upper_alarm_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_lower_alarm_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_monitor_mode;\n  dataport sp_union_art_DataContent_t sb_upper_alarm_temp;\n  dataport sp_union_art_DataContent_t sb_lower_alarm_temp;\n  dataport sp_union_art_DataContent_t sb_monitor_status;\n  dataport sp_union_art_DataContent_t sb_interface_failure;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.camkes",
        {
          "type" : "TestResource",
          "content" : "component Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_interface_failure;\n  dataport sp_union_art_DataContent_t sb_monitor_mode;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit.camkes",
        {
          "type" : "TestResource",
          "content" : "component operator_interface_thread_impl_operator_interface_oip_oit {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_regulator_status;\n  dataport sp_union_art_DataContent_t sb_monitor_status;\n  dataport sp_union_art_DataContent_t sb_display_temperature;\n  dataport sp_union_art_DataContent_t sb_alarm_control;\n  dataport sp_union_art_DataContent_t sb_lower_desired_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_upper_desired_tempWstatus;\n  dataport sp_union_art_DataContent_t sb_upper_alarm_tempWstatus;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.camkes",
        {
          "type" : "TestResource",
          "content" : "component Temperature_Sensor_impl_temperature_sensor_cpi_thermostat {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_current_tempWstatus;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller.camkes",
        {
          "type" : "TestResource",
          "content" : "component Heat_Source_impl_heat_source_cpi_heat_controller {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_heat_control;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/isolette_single_sensor_Instance.camkes",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.camkes\";\nimport \"components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.camkes\";\nimport \"components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.camkes\";\nimport \"components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.camkes\";\nimport \"components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.camkes\";\nimport \"components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.camkes\";\nimport \"components\/operator_interface_thread_impl_operator_interface_oip_oit\/operator_interface_thread_impl_operator_interface_oip_oit.camkes\";\nimport \"components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.camkes\";\nimport \"components\/Heat_Source_impl_heat_source_cpi_heat_controller\/Heat_Source_impl_heat_source_cpi_heat_controller.camkes\";\n\nassembly {\n  composition {\n    component Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit thermostat_regulate_temperature_manage_regulator_interface_mrit;\n    component Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst thermostat_regulate_temperature_manage_heat_source_mhst;\n    component Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt thermostat_regulate_temperature_manage_regulator_mode_mrmt;\n    component Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat thermostat_monitor_temperature_manage_alarm_mat;\n    component Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit thermostat_monitor_temperature_manage_monitor_interface_mmit;\n    component Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt thermostat_monitor_temperature_manage_monitor_mode_mmmt;\n    component operator_interface_thread_impl_operator_interface_oip_oit operator_interface_oip_oit;\n    component Temperature_Sensor_impl_temperature_sensor_cpi_thermostat temperature_sensor_cpi_thermostat;\n    component Heat_Source_impl_heat_source_cpi_heat_controller heat_source_cpi_heat_controller;\n\n    connection seL4SharedData conn1(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_displayed_temp, to operator_interface_oip_oit.sb_display_temperature);\n    connection seL4SharedData conn2(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_regulator_status, to operator_interface_oip_oit.sb_regulator_status);\n    connection seL4SharedData conn3(from thermostat_regulate_temperature_manage_heat_source_mhst.sb_heat_control, to heat_source_cpi_heat_controller.sb_heat_control);\n    connection seL4SharedData conn4(from thermostat_monitor_temperature_manage_alarm_mat.sb_alarm_control, to operator_interface_oip_oit.sb_alarm_control);\n    connection seL4SharedData conn5(from thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_monitor_status, to operator_interface_oip_oit.sb_monitor_status);\n    connection seL4SharedData conn6(from operator_interface_oip_oit.sb_lower_desired_tempWstatus, to thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_lower_desired_tempWstatus);\n    connection seL4SharedData conn7(from operator_interface_oip_oit.sb_upper_desired_tempWstatus, to thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_upper_desired_tempWstatus);\n    connection seL4SharedData conn8(from operator_interface_oip_oit.sb_upper_alarm_tempWstatus, to thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_upper_alarm_tempWstatus, to thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_lower_alarm_tempWstatus);\n    connection seL4SharedData conn9(from temperature_sensor_cpi_thermostat.sb_current_tempWstatus, to thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_current_tempWstatus, to thermostat_monitor_temperature_manage_alarm_mat.sb_current_tempWstatus, to thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_current_tempWstatus, to thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_current_tempWstatus, to thermostat_regulate_temperature_manage_heat_source_mhst.sb_current_tempWstatus, to thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_current_tempWstatus);\n    connection seL4SharedData conn10(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_upper_desired_temp, to thermostat_regulate_temperature_manage_heat_source_mhst.sb_upper_desired_temp);\n    connection seL4SharedData conn11(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_lower_desired_temp, to thermostat_regulate_temperature_manage_heat_source_mhst.sb_lower_desired_temp);\n    connection seL4SharedData conn12(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_interface_failure, to thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_interface_failure);\n    connection seL4SharedData conn13(from thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_regulator_mode, to thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_regulator_mode, to thermostat_regulate_temperature_manage_heat_source_mhst.sb_regulator_mode);\n    connection seL4SharedData conn14(from thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_upper_alarm_temp, to thermostat_monitor_temperature_manage_alarm_mat.sb_upper_alarm_temp);\n    connection seL4SharedData conn15(from thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_lower_alarm_temp, to thermostat_monitor_temperature_manage_alarm_mat.sb_lower_alarm_temp);\n    connection seL4SharedData conn16(from thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_interface_failure, to thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_interface_failure);\n    connection seL4SharedData conn17(from thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_monitor_mode, to thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_monitor_mode, to thermostat_monitor_temperature_manage_alarm_mat.sb_monitor_mode);\n    connection seL4Notification conn18(from thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_self_pacer_tick, to thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_self_pacer_tock);\n    connection seL4Notification conn19(from thermostat_regulate_temperature_manage_heat_source_mhst.sb_self_pacer_tick, to thermostat_regulate_temperature_manage_heat_source_mhst.sb_self_pacer_tock);\n    connection seL4Notification conn20(from thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_self_pacer_tick, to thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_self_pacer_tock);\n    connection seL4Notification conn21(from thermostat_monitor_temperature_manage_alarm_mat.sb_self_pacer_tick, to thermostat_monitor_temperature_manage_alarm_mat.sb_self_pacer_tock);\n    connection seL4Notification conn22(from thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_self_pacer_tick, to thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_self_pacer_tock);\n    connection seL4Notification conn23(from thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_self_pacer_tick, to thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_self_pacer_tock);\n    connection seL4Notification conn24(from operator_interface_oip_oit.sb_self_pacer_tick, to operator_interface_oip_oit.sb_self_pacer_tock);\n    connection seL4Notification conn25(from temperature_sensor_cpi_thermostat.sb_self_pacer_tick, to temperature_sensor_cpi_thermostat.sb_self_pacer_tock);\n    connection seL4Notification conn26(from heat_source_cpi_heat_controller.sb_self_pacer_tick, to heat_source_cpi_heat_controller.sb_self_pacer_tock);\n  }\n\n  configuration {\n    thermostat_regulate_temperature_manage_regulator_interface_mrit._stack_size = 217088;\n    thermostat_regulate_temperature_manage_regulator_interface_mrit._domain = 5;\n    thermostat_regulate_temperature_manage_heat_source_mhst._stack_size = 217088;\n    thermostat_regulate_temperature_manage_heat_source_mhst._domain = 6;\n    thermostat_regulate_temperature_manage_regulator_mode_mrmt._stack_size = 217088;\n    thermostat_regulate_temperature_manage_regulator_mode_mrmt._domain = 4;\n    thermostat_monitor_temperature_manage_alarm_mat._stack_size = 217088;\n    thermostat_monitor_temperature_manage_alarm_mat._domain = 9;\n    thermostat_monitor_temperature_manage_monitor_interface_mmit._stack_size = 217088;\n    thermostat_monitor_temperature_manage_monitor_interface_mmit._domain = 8;\n    thermostat_monitor_temperature_manage_monitor_mode_mmmt._stack_size = 217088;\n    thermostat_monitor_temperature_manage_monitor_mode_mmmt._domain = 7;\n    operator_interface_oip_oit._stack_size = 217088;\n    operator_interface_oip_oit._domain = 2;\n    temperature_sensor_cpi_thermostat._stack_size = 217088;\n    temperature_sensor_cpi_thermostat._domain = 3;\n    heat_source_cpi_heat_controller._stack_size = 217088;\n    heat_source_cpi_heat_controller._domain = 10;\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_displayed_temp_access = \"W\";\n    operator_interface_oip_oit.sb_display_temperature_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_regulator_status_access = \"W\";\n    operator_interface_oip_oit.sb_regulator_status_access = \"R\";\n    thermostat_regulate_temperature_manage_heat_source_mhst.sb_heat_control_access = \"W\";\n    heat_source_cpi_heat_controller.sb_heat_control_access = \"R\";\n    thermostat_monitor_temperature_manage_alarm_mat.sb_alarm_control_access = \"W\";\n    operator_interface_oip_oit.sb_alarm_control_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_monitor_status_access = \"W\";\n    operator_interface_oip_oit.sb_monitor_status_access = \"R\";\n    operator_interface_oip_oit.sb_lower_desired_tempWstatus_access = \"W\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_lower_desired_tempWstatus_access = \"R\";\n    operator_interface_oip_oit.sb_upper_desired_tempWstatus_access = \"W\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_upper_desired_tempWstatus_access = \"R\";\n    operator_interface_oip_oit.sb_upper_alarm_tempWstatus_access = \"W\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_upper_alarm_tempWstatus_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_lower_alarm_tempWstatus_access = \"R\";\n    temperature_sensor_cpi_thermostat.sb_current_tempWstatus_access = \"W\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_current_tempWstatus_access = \"R\";\n    thermostat_monitor_temperature_manage_alarm_mat.sb_current_tempWstatus_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_current_tempWstatus_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_current_tempWstatus_access = \"R\";\n    thermostat_regulate_temperature_manage_heat_source_mhst.sb_current_tempWstatus_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_current_tempWstatus_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_upper_desired_temp_access = \"W\";\n    thermostat_regulate_temperature_manage_heat_source_mhst.sb_upper_desired_temp_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_lower_desired_temp_access = \"W\";\n    thermostat_regulate_temperature_manage_heat_source_mhst.sb_lower_desired_temp_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_interface_failure_access = \"W\";\n    thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_interface_failure_access = \"R\";\n    thermostat_regulate_temperature_manage_regulator_mode_mrmt.sb_regulator_mode_access = \"W\";\n    thermostat_regulate_temperature_manage_regulator_interface_mrit.sb_regulator_mode_access = \"R\";\n    thermostat_regulate_temperature_manage_heat_source_mhst.sb_regulator_mode_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_upper_alarm_temp_access = \"W\";\n    thermostat_monitor_temperature_manage_alarm_mat.sb_upper_alarm_temp_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_lower_alarm_temp_access = \"W\";\n    thermostat_monitor_temperature_manage_alarm_mat.sb_lower_alarm_temp_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_interface_failure_access = \"W\";\n    thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_interface_failure_access = \"R\";\n    thermostat_monitor_temperature_manage_monitor_mode_mmmt.sb_monitor_mode_access = \"W\";\n    thermostat_monitor_temperature_manage_monitor_interface_mmit.sb_monitor_mode_access = \"R\";\n    thermostat_monitor_temperature_manage_alarm_mat.sb_monitor_mode_access = \"R\";\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/types\/includes\/seqNum.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef _SEQNUM_H_\n#define _SEQNUM_H_\n\n\/\/ Typedef for seqNum to make it easy to change the type. Keep these consistent!\ntypedef uintmax_t seqNum_t;\n#define SEQNUM_MAX UINTMAX_MAX\n#define PRIseqNum PRIuMAX\n\n\/\/ DIRTY_SEQ_NUM is used to mark a sampling port message as dirty while it is\n\/\/ being writen. DIRTY_SEQ_NUM is not a valid sequence number. Valid sequence\n\/\/ numbers are from 0 to DIRTY_SEQ_NUM-1 is never a valid sequence number.\nstatic const seqNum_t DIRTY_SEQ_NUM = SEQNUM_MAX;\n\n#endif",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/types\/includes\/sp_union_art_DataContent.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SP_UNION_ART_DATACONTENT_H\n#define SP_UNION_ART_DATACONTENT_H\n\n#include <sb_types.h>\n#include <seqNum.h>\n\n\/\/ Sampling port message with bool data\ntypedef struct sp_union_art_DataContent {\n\n  \/\/ The sampling port message data.\n  \/\/\n  union_art_DataContent data;\n\n  \/\/ Sequence number incremented by the writer every time the sampling port is\n  \/\/ written. Read by the receiver to detect dropped messages and incoherent\n  \/\/ message reads.  An incoherent message is one that is formed of parts of\n  \/\/ more than one message.  An incoherent message can occur when writing\n  \/\/ happens during read. If the component runs long enough, this counter\n  \/\/ will wrap back to zero.  This causes no problems unless the receiver is\n  \/\/ delayed for the wrap time. In that case the receiver may not detect\n  \/\/ dropped or incoherent message. But if the receiver is delayed for that\n  \/\/ long the system is probably in a very bad state. Also see DIRTY_SEQ_NUM\n  \/\/ above.\n  \/\/\n  \/\/ TODO: Currently using ggc builtin _Atomic. Would like to use c11 std, but\n  \/\/ have not figured out how to do this int the seL4 cmake build environment.\n  _Atomic seqNum_t seqNum;  \n\n} sp_union_art_DataContent_t;\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum);\n\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum);\n\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum);\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/types\/src\/sp_union_art_DataContent.c",
        {
          "type" : "TestResource",
          "content" : "#include <sp_union_art_DataContent.h>\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum) {\n  *seqNum = 0; \/\/ First message sequence number will be 1.\n  port->seqNum = DIRTY_SEQ_NUM;\n}\n\n\/\/ Write message to a sampling port (data type: int)\n\/\/\n\/\/ Returns true when successful. Otherwise returns false. Currently there is no\n\/\/ way to fail and true is always returned. But this may change in the\n\/\/ future. seqNum is incremented when a message is successfully sent. seqNum\n\/\/ should not be modified otherwise.\n\/\/\n\/\/ TODO: Encapsulate this better. seqNum state should be maintained internally. Possible solutions:\n\/\/\n\/\/    - Allow write to have read access to dataport. Then seqNum is simply in the data port.\n\/\/\n\/\/    - Create a wrapper struct.\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_RELEASE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum) {\n  \/\/ Mark the message dirty BEFORE we start writing.\n  port->seqNum = DIRTY_SEQ_NUM;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Write the data\n  port->data = *data;\n  \/\/ Increment the sequence number. We are the only writer of seqNum, so\n  \/\/ increment does not have to be atomic.\n  *seqNum = (*seqNum + 1) % DIRTY_SEQ_NUM;\n  port->seqNum = *seqNum;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE continuing\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Can't fail for now.\n  return true;\n}\n\n\/\/ Read a message from a sampling port (data type: int)\n\/\/\n\/\/ Return true upon successful read. Data is updated with the read\n\/\/ message. The sequence number of the message is also returned. The message,\n\/\/ might be tha same previously read. The sequences number can be used to\n\/\/ detect rereading the same message or dropped messages.\n\/\/\n\/\/ Return false if we fail to read a message. For now the only way to fail is\n\/\/ when we detect the possibility of a write during read. In this case data\n\/\/ may be incoherent and should not be used. Sequence number is set to\n\/\/ DIRTY_SEQ_NUM;\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_ACQUIRE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum) {\n  seqNum_t newSeqNum = port->seqNum;\n  \/\/ Acquire memory fence - Read seqNum BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  *data = port->data;\n  \/\/ Acquire memory fence - Read data BEFORE reading seqNum again \n  \/\/atomic_thread_fence(memory_order_acquire);\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  \/\/ The following logic will NOT catch case where the writer wrapped\n  \/\/ sequence numbers since our last read. For this to happen, this reader\n  \/\/ would have to be delayed for the entire time to wrap. \n  if (newSeqNum != DIRTY_SEQ_NUM && newSeqNum == port->seqNum) {\n    \/\/ Message data is good.  Write did not occur during read. \n    *seqNum = newSeqNum;\n    return true;\n  } else {\n    \/\/ Writer may have updated data while we were reading. Do not use possibly incoherent data.\n    *seqNum = DIRTY_SEQ_NUM;\n    return false;\n  }\n}\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port) {\n  return port->seqNum == DIRTY_SEQ_NUM;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (isolette_single_sensor_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/operator_interface_thread_impl_operator_interface_oip_oit)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/Heat_Source_impl_heat_source_cpi_heat_controller)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\n  SOURCES components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/src\/sb_Manage_Regulator_Interface_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\n)\n\nDeclareCAmkESComponent(Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\n  SOURCES components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/src\/sb_Manage_Heat_Source_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\n)\n\nDeclareCAmkESComponent(Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\n  SOURCES components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/src\/sb_Manage_Regulator_Mode_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/includes\/ types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\n)\n\nDeclareCAmkESComponent(Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\n  SOURCES components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/src\/sb_Manage_Alarm_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\n)\n\nDeclareCAmkESComponent(Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\n  SOURCES components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/src\/sb_Manage_Monitor_Interface_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\n)\n\nDeclareCAmkESComponent(Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\n  SOURCES components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/src\/sb_Manage_Monitor_Mode_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/includes\/ types\/includes types\/includes types\/includes types\/includes\n  LIBS Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\n)\n\nDeclareCAmkESComponent(operator_interface_thread_impl_operator_interface_oip_oit\n  SOURCES components\/operator_interface_thread_impl_operator_interface_oip_oit\/src\/sb_operator_interface_thread_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/operator_interface_thread_impl_operator_interface_oip_oit\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS operator_interface_thread_impl_operator_interface_oip_oit\n)\n\nDeclareCAmkESComponent(Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\n  SOURCES components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/src\/sb_Temperature_Sensor_impl.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/includes\/ types\/includes types\/includes\n  LIBS Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\n)\n\nDeclareCAmkESComponent(Heat_Source_impl_heat_source_cpi_heat_controller\n  SOURCES components\/Heat_Source_impl_heat_source_cpi_heat_controller\/src\/sb_Heat_Source_impl.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/Heat_Source_impl_heat_source_cpi_heat_controller\/includes\/ types\/includes types\/includes\n  LIBS Heat_Source_impl_heat_source_cpi_heat_controller\n)\n\nDeclareCAmkESRootserver(isolette_single_sensor_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:s\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"  -c, --camkes-dir      Location of CAmkES project\"\n  echo \"  -n, --non-interactive Non-interactive mode.  Will not prompt before deleting apps and build directories\"\n  echo \"  -o, --camkes-options  CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"  -s, --simulate        Simulate via QEMU\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\nif [ \"${SIMULATE}\" = true ]; then\n  .\/simulate\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/src\/sb_Manage_Regulator_Interface_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Regulator_Interface_impl.h>\n#include <Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_interface_failure_seqNum;\n\nseqNum_t sb_regulator_status_seqNum;\n\nseqNum_t sb_displayed_temp_seqNum;\n\nseqNum_t sb_lower_desired_temp_seqNum;\n\nseqNum_t sb_upper_desired_temp_seqNum;\n\nseqNum_t sb_regulator_mode_seqNum;\n\nseqNum_t sb_upper_desired_tempWstatus_seqNum;\n\nseqNum_t sb_lower_desired_tempWstatus_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_lower_desired_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_lower_desired_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_lower_desired_tempWstatus);\n}\n\nbool sb_lower_desired_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_lower_desired_tempWstatus, value, &new_seqNum) ) {\n    sb_lower_desired_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_upper_desired_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_upper_desired_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_upper_desired_tempWstatus);\n}\n\nbool sb_upper_desired_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_upper_desired_tempWstatus, value, &new_seqNum) ) {\n    sb_upper_desired_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_regulator_mode_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_regulator_mode_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_regulator_mode);\n}\n\nbool sb_regulator_mode_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_regulator_mode, value, &new_seqNum) ) {\n    sb_regulator_mode_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_upper_desired_temp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_upper_desired_temp, value, &sb_upper_desired_temp_seqNum);\n}\n\nbool sb_lower_desired_temp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_lower_desired_temp, value, &sb_lower_desired_temp_seqNum);\n}\n\nbool sb_displayed_temp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_displayed_temp, value, &sb_displayed_temp_seqNum);\n}\n\nbool sb_regulator_status_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_regulator_status, value, &sb_regulator_status_seqNum);\n}\n\nbool sb_interface_failure_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_interface_failure, value, &sb_interface_failure_seqNum);\n}\n\n\/\/ send upper_desired_temp: Out DataPort Isolette_Data_Model__Temp_impl\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_upper_desired_temp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_upper_desired_temp_Send\", 0);\n\n  sb_upper_desired_temp_write(d);\n}\n\n\/\/ send lower_desired_temp: Out DataPort Isolette_Data_Model__Temp_impl\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_lower_desired_temp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_lower_desired_temp_Send\", 0);\n\n  sb_lower_desired_temp_write(d);\n}\n\n\/\/ send displayed_temp: Out DataPort Isolette_Data_Model__Temp_impl\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_displayed_temp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_displayed_temp_Send\", 0);\n\n  sb_displayed_temp_write(d);\n}\n\n\/\/ send regulator_status: Out DataPort Isolette_Data_Model__Status\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_regulator_status_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_regulator_status_Send\", 0);\n\n  sb_regulator_status_write(d);\n}\n\n\/\/ send interface_failure: Out DataPort Isolette_Data_Model__Failure_Flag_impl\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_interface_failure_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_interface_failure_Send\", 0);\n\n  sb_interface_failure_write(d);\n}\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty lower_desired_tempWstatus: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_lower_desired_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_lower_desired_tempWstatus_is_empty();\n}\n\n\/\/ receive lower_desired_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_lower_desired_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_lower_desired_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_lower_desired_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty upper_desired_tempWstatus: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_upper_desired_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_upper_desired_tempWstatus_is_empty();\n}\n\n\/\/ receive upper_desired_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_upper_desired_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_upper_desired_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_upper_desired_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty regulator_mode: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_regulator_mode_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_regulator_mode_is_empty();\n}\n\n\/\/ receive regulator_mode: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_regulator_mode_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_seL4Nix_regulator_mode_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_regulator_mode_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\\n\");\n\n  \/\/ initialise data structure for data port upper_desired_temp\n  init_sp_union_art_DataContent(sb_upper_desired_temp, &sb_upper_desired_temp_seqNum);\n\n  \/\/ initialise data structure for data port lower_desired_temp\n  init_sp_union_art_DataContent(sb_lower_desired_temp, &sb_lower_desired_temp_seqNum);\n\n  \/\/ initialise data structure for data port displayed_temp\n  init_sp_union_art_DataContent(sb_displayed_temp, &sb_displayed_temp_seqNum);\n\n  \/\/ initialise data structure for data port regulator_status\n  init_sp_union_art_DataContent(sb_regulator_status, &sb_regulator_status_seqNum);\n\n  \/\/ initialise data structure for data port interface_failure\n  init_sp_union_art_DataContent(sb_interface_failure, &sb_interface_failure_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Regulator_Interface_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Regulate_Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit\/includes\/sb_Manage_Regulator_Interface_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_REGULATOR_INTERFACE_IMPL_H\n#define SB_MANAGE_REGULATOR_INTERFACE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_lower_desired_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_upper_desired_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_regulator_mode_read(union_art_DataContent * value);\n\nbool sb_upper_desired_temp_write(const union_art_DataContent * value);\n\nbool sb_lower_desired_temp_write(const union_art_DataContent * value);\n\nbool sb_displayed_temp_write(const union_art_DataContent * value);\n\nbool sb_regulator_status_write(const union_art_DataContent * value);\n\nbool sb_interface_failure_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_REGULATOR_INTERFACE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/src\/sb_Manage_Heat_Source_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Heat_Source_impl.h>\n#include <Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_heat_control_seqNum;\n\nseqNum_t sb_regulator_mode_seqNum;\n\nseqNum_t sb_upper_desired_temp_seqNum;\n\nseqNum_t sb_lower_desired_temp_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_lower_desired_temp_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_lower_desired_temp_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_lower_desired_temp);\n}\n\nbool sb_lower_desired_temp_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_lower_desired_temp, value, &new_seqNum) ) {\n    sb_lower_desired_temp_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_upper_desired_temp_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_upper_desired_temp_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_upper_desired_temp);\n}\n\nbool sb_upper_desired_temp_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_upper_desired_temp, value, &new_seqNum) ) {\n    sb_upper_desired_temp_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_regulator_mode_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_regulator_mode_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_regulator_mode);\n}\n\nbool sb_regulator_mode_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_regulator_mode, value, &new_seqNum) ) {\n    sb_regulator_mode_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_heat_control_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_heat_control, value, &sb_heat_control_seqNum);\n}\n\n\/\/ send heat_control: Out DataPort Isolette_Data_Model__On_Off\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_heat_control_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Heat_Source_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_heat_control_Send\", 0);\n\n  sb_heat_control_write(d);\n}\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Heat_Source_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty lower_desired_temp: In DataPort\nB slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_lower_desired_temp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_lower_desired_temp_is_empty();\n}\n\n\/\/ receive lower_desired_temp: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_lower_desired_temp_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Heat_Source_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_lower_desired_temp_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_lower_desired_temp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty upper_desired_temp: In DataPort\nB slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_upper_desired_temp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_upper_desired_temp_is_empty();\n}\n\n\/\/ receive upper_desired_temp: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_upper_desired_temp_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Heat_Source_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_upper_desired_temp_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_upper_desired_temp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty regulator_mode: In DataPort\nB slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_regulator_mode_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_regulator_mode_is_empty();\n}\n\n\/\/ receive regulator_mode: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_regulator_mode_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Heat_Source_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_seL4Nix_regulator_mode_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_regulator_mode_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Heat_Source_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\\n\");\n\n  \/\/ initialise data structure for data port heat_control\n  init_sp_union_art_DataContent(sb_heat_control, &sb_heat_control_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Heat_Source_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Regulate_Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst\/includes\/sb_Manage_Heat_Source_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_HEAT_SOURCE_IMPL_H\n#define SB_MANAGE_HEAT_SOURCE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_lower_desired_temp_read(union_art_DataContent * value);\n\nbool sb_upper_desired_temp_read(union_art_DataContent * value);\n\nbool sb_regulator_mode_read(union_art_DataContent * value);\n\nbool sb_heat_control_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_HEAT_SOURCE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/src\/sb_Manage_Regulator_Mode_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Regulator_Mode_impl.h>\n#include <Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_regulator_mode_seqNum;\n\nseqNum_t sb_interface_failure_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_interface_failure_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_interface_failure_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_interface_failure);\n}\n\nbool sb_interface_failure_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_interface_failure, value, &new_seqNum) ) {\n    sb_interface_failure_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_regulator_mode_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_regulator_mode, value, &sb_regulator_mode_seqNum);\n}\n\n\/\/ send regulator_mode: Out DataPort Isolette_Data_Model__Regulator_Mode\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_regulator_mode_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_regulator_mode_Send\", 0);\n\n  sb_regulator_mode_write(d);\n}\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty interface_failure: In DataPort\nB slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_interface_failure_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_interface_failure_is_empty();\n}\n\n\/\/ receive interface_failure: In DataPort union_art_DataContent\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_interface_failure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_interface_failure_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_interface_failure_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_internal_failure_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_internal_failure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_seL4Nix_internal_failure_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\\n\");\n\n  \/\/ initialise data structure for data port regulator_mode\n  init_sp_union_art_DataContent(sb_regulator_mode, &sb_regulator_mode_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Regulator_Mode_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Regulate_Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt\/includes\/sb_Manage_Regulator_Mode_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_REGULATOR_MODE_IMPL_H\n#define SB_MANAGE_REGULATOR_MODE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_interface_failure_read(union_art_DataContent * value);\n\nbool sb_regulator_mode_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_REGULATOR_MODE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/src\/sb_Manage_Alarm_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Alarm_impl.h>\n#include <Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_alarm_control_seqNum;\n\nseqNum_t sb_monitor_mode_seqNum;\n\nseqNum_t sb_upper_alarm_temp_seqNum;\n\nseqNum_t sb_lower_alarm_temp_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_lower_alarm_temp_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_lower_alarm_temp_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_lower_alarm_temp);\n}\n\nbool sb_lower_alarm_temp_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_lower_alarm_temp, value, &new_seqNum) ) {\n    sb_lower_alarm_temp_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_upper_alarm_temp_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_upper_alarm_temp_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_upper_alarm_temp);\n}\n\nbool sb_upper_alarm_temp_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_upper_alarm_temp, value, &new_seqNum) ) {\n    sb_upper_alarm_temp_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_monitor_mode_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_monitor_mode_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_monitor_mode);\n}\n\nbool sb_monitor_mode_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_monitor_mode, value, &new_seqNum) ) {\n    sb_monitor_mode_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_alarm_control_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_alarm_control, value, &sb_alarm_control_seqNum);\n}\n\n\/\/ send alarm_control: Out DataPort Isolette_Data_Model__On_Off\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_alarm_control_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Alarm_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_alarm_control_Send\", 0);\n\n  sb_alarm_control_write(d);\n}\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Alarm_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty lower_alarm_temp: In DataPort\nB slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_lower_alarm_temp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_lower_alarm_temp_is_empty();\n}\n\n\/\/ receive lower_alarm_temp: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_lower_alarm_temp_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Alarm_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_lower_alarm_temp_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_lower_alarm_temp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty upper_alarm_temp: In DataPort\nB slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_upper_alarm_temp_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_upper_alarm_temp_is_empty();\n}\n\n\/\/ receive upper_alarm_temp: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_upper_alarm_temp_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Alarm_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_upper_alarm_temp_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_upper_alarm_temp_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty monitor_mode: In DataPort\nB slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_monitor_mode_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_monitor_mode_is_empty();\n}\n\n\/\/ receive monitor_mode: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_monitor_mode_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Alarm_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_seL4Nix_monitor_mode_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_monitor_mode_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Alarm_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\\n\");\n\n  \/\/ initialise data structure for data port alarm_control\n  init_sp_union_art_DataContent(sb_alarm_control, &sb_alarm_control_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Alarm_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Monitor_Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat\/includes\/sb_Manage_Alarm_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_ALARM_IMPL_H\n#define SB_MANAGE_ALARM_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_lower_alarm_temp_read(union_art_DataContent * value);\n\nbool sb_upper_alarm_temp_read(union_art_DataContent * value);\n\nbool sb_monitor_mode_read(union_art_DataContent * value);\n\nbool sb_alarm_control_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_ALARM_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/src\/sb_Manage_Monitor_Interface_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Monitor_Interface_impl.h>\n#include <Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_interface_failure_seqNum;\n\nseqNum_t sb_monitor_status_seqNum;\n\nseqNum_t sb_lower_alarm_temp_seqNum;\n\nseqNum_t sb_upper_alarm_temp_seqNum;\n\nseqNum_t sb_monitor_mode_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\nseqNum_t sb_lower_alarm_tempWstatus_seqNum;\n\nseqNum_t sb_upper_alarm_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_upper_alarm_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_upper_alarm_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_upper_alarm_tempWstatus);\n}\n\nbool sb_upper_alarm_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_upper_alarm_tempWstatus, value, &new_seqNum) ) {\n    sb_upper_alarm_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_lower_alarm_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_lower_alarm_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_lower_alarm_tempWstatus);\n}\n\nbool sb_lower_alarm_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_lower_alarm_tempWstatus, value, &new_seqNum) ) {\n    sb_lower_alarm_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_monitor_mode_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_monitor_mode_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_monitor_mode);\n}\n\nbool sb_monitor_mode_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_monitor_mode, value, &new_seqNum) ) {\n    sb_monitor_mode_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_upper_alarm_temp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_upper_alarm_temp, value, &sb_upper_alarm_temp_seqNum);\n}\n\nbool sb_lower_alarm_temp_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_lower_alarm_temp, value, &sb_lower_alarm_temp_seqNum);\n}\n\nbool sb_monitor_status_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_monitor_status, value, &sb_monitor_status_seqNum);\n}\n\nbool sb_interface_failure_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_interface_failure, value, &sb_interface_failure_seqNum);\n}\n\n\/\/ send upper_alarm_temp: Out DataPort Isolette_Data_Model__Temp_impl\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_upper_alarm_temp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_upper_alarm_temp_Send\", 0);\n\n  sb_upper_alarm_temp_write(d);\n}\n\n\/\/ send lower_alarm_temp: Out DataPort Isolette_Data_Model__Temp_impl\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_lower_alarm_temp_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_lower_alarm_temp_Send\", 0);\n\n  sb_lower_alarm_temp_write(d);\n}\n\n\/\/ send monitor_status: Out DataPort Isolette_Data_Model__Status\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_monitor_status_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_monitor_status_Send\", 0);\n\n  sb_monitor_status_write(d);\n}\n\n\/\/ send interface_failure: Out DataPort Isolette_Data_Model__Failure_Flag_impl\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_interface_failure_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_interface_failure_Send\", 0);\n\n  sb_interface_failure_write(d);\n}\n\n\/\/ is_empty upper_alarm_tempWstatus: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_upper_alarm_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_upper_alarm_tempWstatus_is_empty();\n}\n\n\/\/ receive upper_alarm_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_upper_alarm_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_upper_alarm_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_upper_alarm_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty lower_alarm_tempWstatus: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_lower_alarm_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_lower_alarm_tempWstatus_is_empty();\n}\n\n\/\/ receive lower_alarm_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_lower_alarm_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_lower_alarm_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_lower_alarm_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty monitor_mode: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_monitor_mode_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_monitor_mode_is_empty();\n}\n\n\/\/ receive monitor_mode: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_monitor_mode_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_seL4Nix_monitor_mode_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_monitor_mode_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\\n\");\n\n  \/\/ initialise data structure for data port upper_alarm_temp\n  init_sp_union_art_DataContent(sb_upper_alarm_temp, &sb_upper_alarm_temp_seqNum);\n\n  \/\/ initialise data structure for data port lower_alarm_temp\n  init_sp_union_art_DataContent(sb_lower_alarm_temp, &sb_lower_alarm_temp_seqNum);\n\n  \/\/ initialise data structure for data port monitor_status\n  init_sp_union_art_DataContent(sb_monitor_status, &sb_monitor_status_seqNum);\n\n  \/\/ initialise data structure for data port interface_failure\n  init_sp_union_art_DataContent(sb_interface_failure, &sb_interface_failure_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Monitor_Interface_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Monitor_Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit\/includes\/sb_Manage_Monitor_Interface_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_MONITOR_INTERFACE_IMPL_H\n#define SB_MANAGE_MONITOR_INTERFACE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_upper_alarm_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_lower_alarm_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_monitor_mode_read(union_art_DataContent * value);\n\nbool sb_upper_alarm_temp_write(const union_art_DataContent * value);\n\nbool sb_lower_alarm_temp_write(const union_art_DataContent * value);\n\nbool sb_monitor_status_write(const union_art_DataContent * value);\n\nbool sb_interface_failure_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_MONITOR_INTERFACE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/src\/sb_Manage_Monitor_Mode_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Manage_Monitor_Mode_impl.h>\n#include <Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_monitor_mode_seqNum;\n\nseqNum_t sb_interface_failure_seqNum;\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\n\/*****************************************************************\n * sb_current_tempWstatus_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_current_tempWstatus_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_current_tempWstatus);\n}\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_current_tempWstatus, value, &new_seqNum) ) {\n    sb_current_tempWstatus_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_interface_failure_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_interface_failure_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_interface_failure);\n}\n\nbool sb_interface_failure_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_interface_failure, value, &new_seqNum) ) {\n    sb_interface_failure_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_monitor_mode_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_monitor_mode, value, &sb_monitor_mode_seqNum);\n}\n\n\/\/ send monitor_mode: Out DataPort Isolette_Data_Model__Monitor_Mode\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_monitor_mode_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_monitor_mode_Send\", 0);\n\n  sb_monitor_mode_write(d);\n}\n\n\/\/ is_empty current_tempWstatus: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_current_tempWstatus_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_current_tempWstatus_is_empty();\n}\n\n\/\/ receive current_tempWstatus: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_current_tempWstatus_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_current_tempWstatus_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_current_tempWstatus_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty interface_failure: In DataPort\nB slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_interface_failure_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_interface_failure_is_empty();\n}\n\n\/\/ receive interface_failure: In DataPort union_art_DataContent\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_interface_failure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_interface_failure_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_interface_failure_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_internal_failure_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_internal_failure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_seL4Nix_internal_failure_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\\n\");\n\n  \/\/ initialise data structure for data port monitor_mode\n  init_sp_union_art_DataContent(sb_monitor_mode, &sb_monitor_mode_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Manage_Monitor_Mode_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Monitor_Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt\/includes\/sb_Manage_Monitor_Mode_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_MANAGE_MONITOR_MODE_IMPL_H\n#define SB_MANAGE_MONITOR_MODE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_read(union_art_DataContent * value);\n\nbool sb_interface_failure_read(union_art_DataContent * value);\n\nbool sb_monitor_mode_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_MANAGE_MONITOR_MODE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/operator_interface_thread_impl_operator_interface_oip_oit\/src\/sb_operator_interface_thread_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_operator_interface_thread_impl.h>\n#include <operator_interface_thread_impl_operator_interface_oip_oit_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_upper_alarm_tempWstatus_seqNum;\n\nseqNum_t sb_upper_desired_tempWstatus_seqNum;\n\nseqNum_t sb_lower_desired_tempWstatus_seqNum;\n\nseqNum_t sb_alarm_control_seqNum;\n\nseqNum_t sb_display_temperature_seqNum;\n\nseqNum_t sb_monitor_status_seqNum;\n\nseqNum_t sb_regulator_status_seqNum;\n\n\/*****************************************************************\n * sb_regulator_status_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_regulator_status_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_regulator_status);\n}\n\nbool sb_regulator_status_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_regulator_status, value, &new_seqNum) ) {\n    sb_regulator_status_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_monitor_status_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_monitor_status_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_monitor_status);\n}\n\nbool sb_monitor_status_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_monitor_status, value, &new_seqNum) ) {\n    sb_monitor_status_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_display_temperature_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_display_temperature_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_display_temperature);\n}\n\nbool sb_display_temperature_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_display_temperature, value, &new_seqNum) ) {\n    sb_display_temperature_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_alarm_control_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_alarm_control_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_alarm_control);\n}\n\nbool sb_alarm_control_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_alarm_control, value, &new_seqNum) ) {\n    sb_alarm_control_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_lower_desired_tempWstatus_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_lower_desired_tempWstatus, value, &sb_lower_desired_tempWstatus_seqNum);\n}\n\nbool sb_upper_desired_tempWstatus_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_upper_desired_tempWstatus, value, &sb_upper_desired_tempWstatus_seqNum);\n}\n\nbool sb_upper_alarm_tempWstatus_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_upper_alarm_tempWstatus, value, &sb_upper_alarm_tempWstatus_seqNum);\n}\n\n\/\/ send lower_desired_tempWstatus: Out DataPort Isolette_Data_Model__TempWstatus_impl\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_lower_desired_tempWstatus_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_lower_desired_tempWstatus_Send\", 0);\n\n  sb_lower_desired_tempWstatus_write(d);\n}\n\n\/\/ send upper_desired_tempWstatus: Out DataPort Isolette_Data_Model__TempWstatus_impl\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_upper_desired_tempWstatus_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_upper_desired_tempWstatus_Send\", 0);\n\n  sb_upper_desired_tempWstatus_write(d);\n}\n\n\/\/ send upper_alarm_tempWstatus: Out DataPort Isolette_Data_Model__TempWstatus_impl\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_upper_alarm_tempWstatus_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_upper_alarm_tempWstatus_Send\", 0);\n\n  sb_upper_alarm_tempWstatus_write(d);\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_lower_alarm_tempWstatus_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_lower_alarm_tempWstatus_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ is_empty regulator_status: In DataPort\nB slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_regulator_status_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_regulator_status_is_empty();\n}\n\n\/\/ receive regulator_status: In DataPort union_art_DataContent\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_regulator_status_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_regulator_status_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_regulator_status_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty monitor_status: In DataPort\nB slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_monitor_status_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_monitor_status_is_empty();\n}\n\n\/\/ receive monitor_status: In DataPort union_art_DataContent\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_monitor_status_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_monitor_status_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_monitor_status_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty display_temperature: In DataPort\nB slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_display_temperature_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_display_temperature_is_empty();\n}\n\n\/\/ receive display_temperature: In DataPort union_art_DataContent\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_display_temperature_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_display_temperature_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_display_temperature_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty alarm_control: In DataPort\nB slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_alarm_control_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_alarm_control_is_empty();\n}\n\n\/\/ receive alarm_control: In DataPort union_art_DataContent\nUnit slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_alarm_control_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_operator_interface_thread_impl.c\", \"\", \"slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_seL4Nix_alarm_control_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_alarm_control_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_operator_interface_thread_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of operator_interface_thread_impl_operator_interface_oip_oit\\n\");\n\n  \/\/ initialise data structure for data port lower_desired_tempWstatus\n  init_sp_union_art_DataContent(sb_lower_desired_tempWstatus, &sb_lower_desired_tempWstatus_seqNum);\n\n  \/\/ initialise data structure for data port upper_desired_tempWstatus\n  init_sp_union_art_DataContent(sb_upper_desired_tempWstatus, &sb_upper_desired_tempWstatus_seqNum);\n\n  \/\/ initialise data structure for data port upper_alarm_tempWstatus\n  init_sp_union_art_DataContent(sb_upper_alarm_tempWstatus, &sb_upper_alarm_tempWstatus_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of operator_interface_thread_impl_operator_interface_oip_oit\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_operator_interface_thread_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Isolette_operator_interface_thread_impl_operator_interface_oip_oit_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/operator_interface_thread_impl_operator_interface_oip_oit\/includes\/sb_operator_interface_thread_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_OPERATOR_INTERFACE_THREAD_IMPL_H\n#define SB_OPERATOR_INTERFACE_THREAD_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_regulator_status_read(union_art_DataContent * value);\n\nbool sb_monitor_status_read(union_art_DataContent * value);\n\nbool sb_display_temperature_read(union_art_DataContent * value);\n\nbool sb_alarm_control_read(union_art_DataContent * value);\n\nbool sb_lower_desired_tempWstatus_write(const union_art_DataContent * value);\n\nbool sb_upper_desired_tempWstatus_write(const union_art_DataContent * value);\n\nbool sb_upper_alarm_tempWstatus_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_OPERATOR_INTERFACE_THREAD_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/src\/sb_Temperature_Sensor_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Temperature_Sensor_impl.h>\n#include <Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_current_tempWstatus_seqNum;\n\nbool sb_current_tempWstatus_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_current_tempWstatus, value, &sb_current_tempWstatus_seqNum);\n}\n\n\/\/ send current_tempWstatus: Out DataPort Isolette_Data_Model__TempWstatus_impl\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_current_tempWstatus_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Temperature_Sensor_impl.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_current_tempWstatus_Send\", 0);\n\n  sb_current_tempWstatus_write(d);\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_air_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_air_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Temperature_Sensor_impl.c\", \"\", \"slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_seL4Nix_air_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Temperature_Sensor_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\\n\");\n\n  \/\/ initialise data structure for data port current_tempWstatus\n  init_sp_union_art_DataContent(sb_current_tempWstatus, &sb_current_tempWstatus_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Temperature_Sensor_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Devices_Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat\/includes\/sb_Temperature_Sensor_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_TEMPERATURE_SENSOR_IMPL_H\n#define SB_TEMPERATURE_SENSOR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_current_tempWstatus_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_TEMPERATURE_SENSOR_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Heat_Source_impl_heat_source_cpi_heat_controller\/src\/sb_Heat_Source_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_Heat_Source_impl.h>\n#include <Heat_Source_impl_heat_source_cpi_heat_controller_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_heat_control_seqNum;\n\n\/*****************************************************************\n * sb_heat_control_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_heat_control_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_heat_control);\n}\n\nbool sb_heat_control_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_heat_control, value, &new_seqNum) ) {\n    sb_heat_control_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_heat_out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_Heat_Source_impl.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_heat_out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ is_empty heat_control: In DataPort\nB slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_heat_control_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_heat_control_is_empty();\n}\n\n\/\/ receive heat_control: In DataPort union_art_DataContent\nUnit slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_heat_control_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_Heat_Source_impl.c\", \"\", \"slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_seL4Nix_heat_control_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_heat_control_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_Heat_Source_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of Heat_Source_impl_heat_source_cpi_heat_controller\\n\");\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of Heat_Source_impl_heat_source_cpi_heat_controller\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_Heat_Source_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_Devices_Heat_Source_impl_heat_source_cpi_heat_controller_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/components\/Heat_Source_impl_heat_source_cpi_heat_controller\/includes\/sb_Heat_Source_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_HEAT_SOURCE_IMPL_H\n#define SB_HEAT_SOURCE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_heat_control_read(union_art_DataContent * value);\n\n#endif \/\/ SB_HEAT_SOURCE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/kernel\/domain_schedule.c",
        {
          "type" : "TestResource",
          "content" : "#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ this file will not be overwritten and is safe to edit\n\n\/************************************************************\n\n   This is a kernel data structure containing an example schedule.\n   The length is in seL4 ticks (2 ms).\n   This schedule should be generated from the AADL model\n   using execution time and data flow latency specifications.\n\n   Pacer runs at highest rate and should always be in domain 1\n\n   Properties from AADL Model\n   --------------------------\n\n     Timing_Properties::Clock_Period : 2 ms\n     Timing_Properties::Frame_Period : 1000 ms\n\n     mrit\n     ----\n\n       CASE_Scheduling::Domain : 5\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     mhst\n     ----\n\n       CASE_Scheduling::Domain : 6\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     mrmt\n     ----\n\n       CASE_Scheduling::Domain : 4\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     mat\n     ---\n\n       CASE_Scheduling::Domain : 9\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     mmit\n     ----\n\n       CASE_Scheduling::Domain : 8\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     mmmt\n     ----\n\n       CASE_Scheduling::Domain : 7\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     oit\n     ---\n\n       CASE_Scheduling::Domain : 2\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     thermostat\n     ----------\n\n       CASE_Scheduling::Domain : 3\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n     heat_controller\n     ---------------\n\n       CASE_Scheduling::Domain : 10\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 6 ms\n       Timing_Properties::Period : 1000 ms\n\n *********************************************************\/\n\nconst dschedule_t ksDomSchedule[] = {\n  { .domain = 0, .length = 100 },  \/\/ all other seL4 threads, init, 200ms\n  { .domain = 5, .length = 3 },  \/\/ mrit  6ms\n  { .domain = 6, .length = 3 },  \/\/ mhst  6ms\n  { .domain = 4, .length = 3 },  \/\/ mrmt  6ms\n  { .domain = 9, .length = 3 },  \/\/ mat  6ms\n  { .domain = 8, .length = 3 },  \/\/ mmit  6ms\n  { .domain = 7, .length = 3 },  \/\/ mmmt  6ms\n  { .domain = 2, .length = 3 },  \/\/ oit  6ms\n  { .domain = 3, .length = 3 },  \/\/ thermostat  6ms\n  { .domain = 10, .length = 3 },  \/\/ heat_controller  6ms\n  { .domain = 0, .length = 368 },  \/\/ pad rest of frame period\n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/settings.cmake",
        {
          "type" : "TestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 11 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sp_union_art_DataContent.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ]
    ]
  }
}