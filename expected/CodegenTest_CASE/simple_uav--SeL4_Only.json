{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "simple_uav--SeL4_Only\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/RadioDriver_Impl_MCMP_PROC_SW_RADIO.camkes",
        {
          "type" : "ITestResource",
          "content" : "component RadioDriver_Impl_MCMP_PROC_SW_RADIO {\n  include <sb_types.h>;\n  include <sb_queue_SW__Command_Impl_1.h>;\n  control;\n  emits ReceiveEvent sb_recv_map_out_1_notification;\n  dataport sb_queue_SW__Command_Impl_1_t sb_recv_map_out_queue_1;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN.camkes",
        {
          "type" : "ITestResource",
          "content" : "component FlightPlanner_Impl_MCMP_PROC_SW_FPLN {\n  include <sb_types.h>;\n  include <sb_queue_sb_SW__Mission_container_1.h>;\n  include <sb_queue_bool_1.h>;\n  include <sb_queue_SW__Command_Impl_1.h>;\n  control;\n  emits ReceiveEvent sb_flight_plan_1_notification;\n  consumes ReceiveEvent sb_mission_rcv_notification;\n  consumes ReceiveEvent sb_recv_map_notification;\n  dataport sb_queue_sb_SW__Mission_container_1_t sb_flight_plan_queue_1;\n  dataport sb_queue_bool_1_t sb_mission_rcv_queue;\n  dataport sb_queue_SW__Command_Impl_1_t sb_recv_map_queue;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/WaypointManager_Impl_MCMP_PROC_SW_WPM.camkes",
        {
          "type" : "ITestResource",
          "content" : "component WaypointManager_Impl_MCMP_PROC_SW_WPM {\n  include <sb_types.h>;\n  include <sb_queue_sb_SW__Mission_container_1.h>;\n  include <sb_queue_bool_1.h>;\n  include <sb_queue_sb_SW__MissionWindow_container_1.h>;\n  include <sb_queue_int64_t_1.h>;\n  control;\n  emits ReceiveEvent sb_mission_rcv_1_notification;\n  emits ReceiveEvent sb_mission_window_1_notification;\n  consumes ReceiveEvent sb_flight_plan_notification;\n  consumes ReceiveEvent sb_tracking_id_notification;\n  dataport sb_queue_sb_SW__Mission_container_1_t sb_flight_plan_queue;\n  dataport sb_queue_bool_1_t sb_mission_rcv_queue_1;\n  dataport sb_queue_sb_SW__MissionWindow_container_1_t sb_mission_window_queue_1;\n  dataport sb_queue_int64_t_1_t sb_tracking_id_queue;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/UARTDriver_Impl_MCMP_PROC_SW_UART.camkes",
        {
          "type" : "ITestResource",
          "content" : "component UARTDriver_Impl_MCMP_PROC_SW_UART {\n  include <sb_types.h>;\n  include <sb_queue_sb_SW__MissionWindow_container_1.h>;\n  include <sb_queue_int64_t_1.h>;\n  control;\n  emits ReceiveEvent sb_tracking_id_1_notification;\n  consumes ReceiveEvent sb_mission_window_notification;\n  dataport sb_queue_sb_SW__MissionWindow_container_1_t sb_mission_window_queue;\n  dataport sb_queue_int64_t_1_t sb_tracking_id_queue_1;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/UAV_Impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/RadioDriver_Impl_MCMP_PROC_SW_RADIO.camkes\";\nimport \"components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN.camkes\";\nimport \"components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/WaypointManager_Impl_MCMP_PROC_SW_WPM.camkes\";\nimport \"components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/UARTDriver_Impl_MCMP_PROC_SW_UART.camkes\";\n\nassembly {\n  composition {\n    component RadioDriver_Impl_MCMP_PROC_SW_RADIO MCMP_PROC_SW_RADIO;\n    component FlightPlanner_Impl_MCMP_PROC_SW_FPLN MCMP_PROC_SW_FPLN;\n    component WaypointManager_Impl_MCMP_PROC_SW_WPM MCMP_PROC_SW_WPM;\n    component UARTDriver_Impl_MCMP_PROC_SW_UART MCMP_PROC_SW_UART;\n\n    connection seL4Notification conn1(from MCMP_PROC_SW_RADIO.sb_recv_map_out_1_notification, to MCMP_PROC_SW_FPLN.sb_recv_map_notification);\n    connection seL4SharedData conn2(from MCMP_PROC_SW_RADIO.sb_recv_map_out_queue_1, to MCMP_PROC_SW_FPLN.sb_recv_map_queue);\n    connection seL4Notification conn3(from MCMP_PROC_SW_FPLN.sb_flight_plan_1_notification, to MCMP_PROC_SW_WPM.sb_flight_plan_notification);\n    connection seL4SharedData conn4(from MCMP_PROC_SW_FPLN.sb_flight_plan_queue_1, to MCMP_PROC_SW_WPM.sb_flight_plan_queue);\n    connection seL4Notification conn5(from MCMP_PROC_SW_WPM.sb_mission_rcv_1_notification, to MCMP_PROC_SW_FPLN.sb_mission_rcv_notification);\n    connection seL4SharedData conn6(from MCMP_PROC_SW_WPM.sb_mission_rcv_queue_1, to MCMP_PROC_SW_FPLN.sb_mission_rcv_queue);\n    connection seL4Notification conn7(from MCMP_PROC_SW_WPM.sb_mission_window_1_notification, to MCMP_PROC_SW_UART.sb_mission_window_notification);\n    connection seL4SharedData conn8(from MCMP_PROC_SW_WPM.sb_mission_window_queue_1, to MCMP_PROC_SW_UART.sb_mission_window_queue);\n    connection seL4Notification conn9(from MCMP_PROC_SW_UART.sb_tracking_id_1_notification, to MCMP_PROC_SW_WPM.sb_tracking_id_notification);\n    connection seL4SharedData conn10(from MCMP_PROC_SW_UART.sb_tracking_id_queue_1, to MCMP_PROC_SW_WPM.sb_tracking_id_queue);\n  }\n\n  configuration {\n    MCMP_PROC_SW_RADIO.sb_recv_map_out_queue_1_access = \"W\";\n    MCMP_PROC_SW_FPLN.sb_recv_map_queue_access = \"R\";\n    MCMP_PROC_SW_FPLN.sb_flight_plan_queue_1_access = \"W\";\n    MCMP_PROC_SW_WPM.sb_flight_plan_queue_access = \"R\";\n    MCMP_PROC_SW_WPM.sb_mission_rcv_queue_1_access = \"W\";\n    MCMP_PROC_SW_FPLN.sb_mission_rcv_queue_access = \"R\";\n    MCMP_PROC_SW_WPM.sb_mission_window_queue_1_access = \"W\";\n    MCMP_PROC_SW_UART.sb_mission_window_queue_access = \"R\";\n    MCMP_PROC_SW_UART.sb_tracking_id_queue_1_access = \"W\";\n    MCMP_PROC_SW_WPM.sb_tracking_id_queue_access = \"R\";\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/radiodriver.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_RadioDriver_Impl.h>\n#include <assert.h>\n\nvoid init(const int64_t * in_arg) {\n\n  printf(\"RDIO: initialise entry point called\\n\");\n\n  SW__Command_Impl command = {\n    .Map = {{ .lat = 0, .longitude = 1, .alt = 2 },\n            { .lat = 1, .longitude = 2, .alt = 3 },\n            { .lat = 2, .longitude = 3, .alt = 4 },\n            { .lat = 3, .longitude = 4, .alt = 5 }},\n      .Pattern = Perimeter,\n      .HMAC = true\n  };\n\n  printf(\"RDIO:> Sending command.\\n\");\n\n  \/\/ send command to FPLN  \n  assert(sb_recv_map_out_enqueue(&command)==true);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/flightplanner.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_FlightPlanner_Impl.h>\n#include <assert.h>\n\nstatic bool missioncommand_sent = false;\n\nvoid init(const int64_t *arg){\n}\n\nvoid printCommand(const SW__Command_Impl * command) {\n  \tprintf(\"  Map     = [\\n\");\n    for(int i = 0; i < 4; i++){\n      SW__Coordinate_Impl c = command->Map[i];\n      printf(\"             %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n    }  \t\n    printf(\"            ]\\n\");\n\t\tprintf(\"  Pattern = %i\\n\", command->Pattern);\n\t\tprintf(\"  HMAC    = %i\\n\", command->HMAC);\n}\n\nvoid recv_map(const SW__Command_Impl * command) {\n\n  \tprintf(\"FPLN:< Command.\\n\");\n  \tprintCommand(command);\n\n  \tif(!missioncommand_sent) {\n\n  \t    \/\/ simulate the creation of a new mission\n  \t\tsb_SW__Mission_container mission = { .f = {{ .lat = 0, .longitude = 1, .alt = 2},\n   \t\t                                           { .lat = 1, .longitude = 2, .alt = 3},\n  \t\t                                           { .lat = 2, .longitude = 3, .alt = 4},\n  \t\t                                           { .lat = 3, .longitude = 4, .alt = 5},\n  \t\t                                           { .lat = 4, .longitude = 5, .alt = 6},\n  \t\t                                           { .lat = 5, .longitude = 6, .alt = 7},\n  \t\t                                           { .lat = 6, .longitude = 7, .alt = 8},\n  \t\t                                           { .lat = 7, .longitude = 8, .alt = 9},\n  \t\t                                           { .lat = 8, .longitude = 9, .alt = 10},\n  \t\t                                           { .lat = 9, .longitude = 10, .alt = 11}}};\n\n  \t\tprintf(\"FPLN:> new mission notification.\\n\");\n\n  \t\t\/\/ send the flight plan to WMP\n  \t\tassert(sb_flight_plan_enqueue(&mission) == true);\n\n    \tmissioncommand_sent = true;\n  \t}\n}\n\nvoid mission_rcv(const bool * value) {\n\tprintf(\"FPLN:< Received mission receipt confirmation: %i.\\n\", *value);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/waypointmanager.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_WaypointManager_Impl.h>\n#include <assert.h>\n#include <string.h>\n\n\nsb_SW__Mission_container _mission;\n\nvoid init(const int64_t * __unused__) {\n}\n\nvoid printMission(const sb_SW__Mission_container * mission){\n  printf(\"  Mission:\\n\");\n  for(int i = 0; i < 10; i++){\n    SW__Coordinate_Impl c = mission->f[i];\n    printf(\"    %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n  }\n}\n\nvoid sendWin(int i) {\n\n  \/\/ simulate creation of new mission windows\n  sb_SW__MissionWindow_container missionWindow = { \n    .f = { _mission.f[i % 10], \n           _mission.f[(i + 1) % 10],\n           _mission.f[(i + 2) % 10],\n           _mission.f[(i + 3) % 10]} \n  };\n\n  \/\/ send mission window to UART  \n  assert(sb_mission_window_enqueue(&missionWindow) == true);\n\n  printf(\"WM:> Sent mission window\\n\");\n}\n\nvoid flight_plan(const sb_SW__Mission_container * mission){\n  printf(\"WM:< Received flight plan\\n\");\n\n  memcpy(&_mission, mission, sizeof(struct sb_SW__Mission_container));\n\n  printMission(&_mission);\n\n  sendWin(0);\n\n  \/\/ send receipt confirmation back to FPLN\n  bool dummy = true;\n  assert(sb_mission_rcv_enqueue(&dummy) == true);\n}\n\nvoid tracking_id(const int64_t * nid) {\n  printf(\"WM:< Received %lu as the next id.\\n\", *nid);\n\n  sendWin(*nid);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/uartdriver.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_UARTDriver_Impl.h>\n#include <assert.h>\n\nstatic int64_t i = 0;\n\nvoid init(const int64_t * in_arg) {\n}\n\nvoid printMissionWindow(const sb_SW__MissionWindow_container * missionWindow){\n  printf(\"  MissionWindow:\\n\");\n  for(int i = 0; i < 4; i++){\n    SW__Coordinate_Impl c = missionWindow->f[i];\n    printf(\"    %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n  }\n}\n\nvoid mission_window(const sb_SW__MissionWindow_container * missionWindow){\n  printf(\"UART:< Received mission window\\n\");\n  printMissionWindow(missionWindow);\n\n  for(unsigned int j = 0; j < 100000000; j++){}\n\n  i++;\n\n  printf(\"UART:> Sending %lu as the next id.\\n\", i);\n\n  \/\/ send tracking id to WPM\n  assert(sb_tracking_id_enqueue(&i) == true);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (UAV_Impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(RadioDriver_Impl_MCMP_PROC_SW_RADIO\n  SOURCES components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/\/src\/radiodriver.c components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/sb_RadioDriver_Impl.c types\/src\/sb_queue_SW__Command_Impl_1.c\n  INCLUDES components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(FlightPlanner_Impl_MCMP_PROC_SW_FPLN\n  SOURCES components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/\/src\/flightplanner.c components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/sb_FlightPlanner_Impl.c types\/src\/sb_queue_sb_SW__Mission_container_1.c types\/src\/sb_queue_bool_1.c types\/src\/sb_queue_SW__Command_Impl_1.c\n  INCLUDES components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(WaypointManager_Impl_MCMP_PROC_SW_WPM\n  SOURCES components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/\/src\/waypointmanager.c components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/sb_WaypointManager_Impl.c types\/src\/sb_queue_sb_SW__Mission_container_1.c types\/src\/sb_queue_bool_1.c types\/src\/sb_queue_sb_SW__MissionWindow_container_1.c types\/src\/sb_queue_int64_t_1.c\n  INCLUDES components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(UARTDriver_Impl_MCMP_PROC_SW_UART\n  SOURCES components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/\/src\/uartdriver.c components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/sb_UARTDriver_Impl.c types\/src\/sb_queue_sb_SW__MissionWindow_container_1.c types\/src\/sb_queue_int64_t_1.c\n  INCLUDES components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/includes\/ types\/includes\n)\n\nDeclareCAmkESRootserver(UAV_Impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present, CAmkES build directory will not be deleted\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/sb_RadioDriver_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_RadioDriver_Impl.h>\n#include <sb_queue_SW__Command_Impl_1.h>\n#include <string.h>\n#include <camkes.h>\n\nbool sb_recv_map_out_enqueue(const SW__Command_Impl *data) {\n  sb_queue_SW__Command_Impl_1_enqueue(sb_recv_map_out_queue_1, (SW__Command_Impl*) data);\n  sb_recv_map_out_1_notification_emit();\n\n  return true;\n}\n\n\/************************************************************************\n *  sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid pre_init(void) {\n  \/\/ initialise data structure for outgoing event data port recv_map_out\n  sb_queue_SW__Command_Impl_1_init(sb_recv_map_out_queue_1);\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/includes\/sb_RadioDriver_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_RADIODRIVER_IMPL_H\n#define SB_RADIODRIVER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_recv_map_out_enqueue(const SW__Command_Impl *);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_RADIODRIVER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/sb_FlightPlanner_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_FlightPlanner_Impl.h>\n#include <sb_queue_sb_SW__Mission_container_1.h>\n#include <sb_queue_bool_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_SW__Command_Impl_1.h>\n#include <sb_event_counter.h>\n#include <string.h>\n#include <camkes.h>\n\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container *data) {\n  sb_queue_sb_SW__Mission_container_1_enqueue(sb_flight_plan_queue_1, (sb_SW__Mission_container*) data);\n  sb_flight_plan_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_bool_1_Recv_t sb_mission_rcv_recv_queue;\n\n\/************************************************************************\n * sb_mission_rcv_dequeue_poll:\n ************************************************************************\/\nbool sb_mission_rcv_dequeue_poll(sb_event_counter_t *numDropped, bool *data) {\n  return sb_queue_bool_1_dequeue(&sb_mission_rcv_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_mission_rcv_dequeue:\n ************************************************************************\/\nbool sb_mission_rcv_dequeue(bool *data) {\n  sb_event_counter_t numDropped;\n  return sb_mission_rcv_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_mission_rcv_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_mission_rcv_is_empty(){\n  return sb_queue_bool_1_is_empty(&sb_mission_rcv_recv_queue);\n}\n\n\/************************************************************************\n * sb_mission_rcv_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_mission_rcv\n *\n ************************************************************************\/\nstatic void sb_mission_rcv_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_FlightPlanner_Impl_mission_rcv:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_mission_rcv(const bool * in_arg) {\n  mission_rcv((bool *) in_arg);\n}\n\n\nsb_queue_SW__Command_Impl_1_Recv_t sb_recv_map_recv_queue;\n\n\/************************************************************************\n * sb_recv_map_dequeue_poll:\n ************************************************************************\/\nbool sb_recv_map_dequeue_poll(sb_event_counter_t *numDropped, SW__Command_Impl *data) {\n  return sb_queue_SW__Command_Impl_1_dequeue(&sb_recv_map_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_recv_map_dequeue:\n ************************************************************************\/\nbool sb_recv_map_dequeue(SW__Command_Impl *data) {\n  sb_event_counter_t numDropped;\n  return sb_recv_map_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_recv_map_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_recv_map_is_empty(){\n  return sb_queue_SW__Command_Impl_1_is_empty(&sb_recv_map_recv_queue);\n}\n\n\/************************************************************************\n * sb_recv_map_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_recv_map\n *\n ************************************************************************\/\nstatic void sb_recv_map_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_FlightPlanner_Impl_recv_map:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_recv_map(const SW__Command_Impl * in_arg) {\n  recv_map((SW__Command_Impl *) in_arg);\n}\n\n\n\/************************************************************************\n *  sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid pre_init(void) {\n  \/\/ initialise data structure for outgoing event data port flight_plan\n  sb_queue_sb_SW__Mission_container_1_init(sb_flight_plan_queue_1);\n\n  \/\/ initialise data structure for incoming event data port mission_rcv\n  sb_queue_bool_1_Recv_init(&sb_mission_rcv_recv_queue, sb_mission_rcv_queue);\n\n  \/\/ initialise data structure for incoming event data port recv_map\n  sb_queue_SW__Command_Impl_1_Recv_init(&sb_recv_map_recv_queue, sb_recv_map_queue);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port mission_rcv\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n\n  \/\/ register callback for EventDataPort port recv_map\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    {\n      bool sb_mission_rcv;\n      while (sb_mission_rcv_dequeue((bool *) &sb_mission_rcv)) {\n        sb_entrypoint_FlightPlanner_Impl_mission_rcv(&sb_mission_rcv);\n      }\n    }\n    {\n      SW__Command_Impl sb_recv_map;\n      while (sb_recv_map_dequeue((SW__Command_Impl *) &sb_recv_map)) {\n        sb_entrypoint_FlightPlanner_Impl_recv_map(&sb_recv_map);\n      }\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/includes\/sb_FlightPlanner_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_FLIGHTPLANNER_IMPL_H\n#define SB_FLIGHTPLANNER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container *);\n\nbool sb_mission_rcv_dequeue(bool *);\n\nvoid mission_rcv(const bool *);\n\nbool sb_recv_map_dequeue(SW__Command_Impl *);\n\nvoid recv_map(const SW__Command_Impl *);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_FLIGHTPLANNER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/sb_WaypointManager_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_WaypointManager_Impl.h>\n#include <sb_queue_sb_SW__Mission_container_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_bool_1.h>\n#include <sb_queue_sb_SW__MissionWindow_container_1.h>\n#include <sb_queue_int64_t_1.h>\n#include <sb_event_counter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_sb_SW__Mission_container_1_Recv_t sb_flight_plan_recv_queue;\n\n\/************************************************************************\n * sb_flight_plan_dequeue_poll:\n ************************************************************************\/\nbool sb_flight_plan_dequeue_poll(sb_event_counter_t *numDropped, sb_SW__Mission_container *data) {\n  return sb_queue_sb_SW__Mission_container_1_dequeue(&sb_flight_plan_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_flight_plan_dequeue:\n ************************************************************************\/\nbool sb_flight_plan_dequeue(sb_SW__Mission_container *data) {\n  sb_event_counter_t numDropped;\n  return sb_flight_plan_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_flight_plan_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_flight_plan_is_empty(){\n  return sb_queue_sb_SW__Mission_container_1_is_empty(&sb_flight_plan_recv_queue);\n}\n\n\/************************************************************************\n * sb_flight_plan_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_flight_plan\n *\n ************************************************************************\/\nstatic void sb_flight_plan_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_WaypointManager_Impl_flight_plan:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_flight_plan(const sb_SW__Mission_container * in_arg) {\n  flight_plan((sb_SW__Mission_container *) in_arg);\n}\n\n\nbool sb_mission_rcv_enqueue(const bool *data) {\n  sb_queue_bool_1_enqueue(sb_mission_rcv_queue_1, (bool*) data);\n  sb_mission_rcv_1_notification_emit();\n\n  return true;\n}\n\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container *data) {\n  sb_queue_sb_SW__MissionWindow_container_1_enqueue(sb_mission_window_queue_1, (sb_SW__MissionWindow_container*) data);\n  sb_mission_window_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_int64_t_1_Recv_t sb_tracking_id_recv_queue;\n\n\/************************************************************************\n * sb_tracking_id_dequeue_poll:\n ************************************************************************\/\nbool sb_tracking_id_dequeue_poll(sb_event_counter_t *numDropped, int64_t *data) {\n  return sb_queue_int64_t_1_dequeue(&sb_tracking_id_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_tracking_id_dequeue:\n ************************************************************************\/\nbool sb_tracking_id_dequeue(int64_t *data) {\n  sb_event_counter_t numDropped;\n  return sb_tracking_id_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_tracking_id_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_tracking_id_is_empty(){\n  return sb_queue_int64_t_1_is_empty(&sb_tracking_id_recv_queue);\n}\n\n\/************************************************************************\n * sb_tracking_id_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_tracking_id\n *\n ************************************************************************\/\nstatic void sb_tracking_id_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_WaypointManager_Impl_tracking_id:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_tracking_id(const int64_t * in_arg) {\n  tracking_id((int64_t *) in_arg);\n}\n\n\n\/************************************************************************\n *  sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid pre_init(void) {\n  \/\/ initialise data structure for incoming event data port flight_plan\n  sb_queue_sb_SW__Mission_container_1_Recv_init(&sb_flight_plan_recv_queue, sb_flight_plan_queue);\n\n  \/\/ initialise data structure for outgoing event data port mission_rcv\n  sb_queue_bool_1_init(sb_mission_rcv_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port mission_window\n  sb_queue_sb_SW__MissionWindow_container_1_init(sb_mission_window_queue_1);\n\n  \/\/ initialise data structure for incoming event data port tracking_id\n  sb_queue_int64_t_1_Recv_init(&sb_tracking_id_recv_queue, sb_tracking_id_queue);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port flight_plan\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n\n  \/\/ register callback for EventDataPort port tracking_id\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    {\n      sb_SW__Mission_container sb_flight_plan;\n      while (sb_flight_plan_dequeue((sb_SW__Mission_container *) &sb_flight_plan)) {\n        sb_entrypoint_WaypointManager_Impl_flight_plan(&sb_flight_plan);\n      }\n    }\n    {\n      int64_t sb_tracking_id;\n      while (sb_tracking_id_dequeue((int64_t *) &sb_tracking_id)) {\n        sb_entrypoint_WaypointManager_Impl_tracking_id(&sb_tracking_id);\n      }\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/includes\/sb_WaypointManager_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_WAYPOINTMANAGER_IMPL_H\n#define SB_WAYPOINTMANAGER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_flight_plan_dequeue(sb_SW__Mission_container *);\n\nvoid flight_plan(const sb_SW__Mission_container *);\n\nbool sb_mission_rcv_enqueue(const bool *);\n\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container *);\n\nbool sb_tracking_id_dequeue(int64_t *);\n\nvoid tracking_id(const int64_t *);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_WAYPOINTMANAGER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/sb_UARTDriver_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_UARTDriver_Impl.h>\n#include <sb_queue_sb_SW__MissionWindow_container_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int64_t_1.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_sb_SW__MissionWindow_container_1_Recv_t sb_mission_window_recv_queue;\n\n\/************************************************************************\n * sb_mission_window_dequeue_poll:\n ************************************************************************\/\nbool sb_mission_window_dequeue_poll(sb_event_counter_t *numDropped, sb_SW__MissionWindow_container *data) {\n  return sb_queue_sb_SW__MissionWindow_container_1_dequeue(&sb_mission_window_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_mission_window_dequeue:\n ************************************************************************\/\nbool sb_mission_window_dequeue(sb_SW__MissionWindow_container *data) {\n  sb_event_counter_t numDropped;\n  return sb_mission_window_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_mission_window_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_mission_window_is_empty(){\n  return sb_queue_sb_SW__MissionWindow_container_1_is_empty(&sb_mission_window_recv_queue);\n}\n\n\/************************************************************************\n * sb_mission_window_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * sb_mission_window\n *\n ************************************************************************\/\nstatic void sb_mission_window_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_UARTDriver_Impl_mission_window:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_UARTDriver_Impl_mission_window(const sb_SW__MissionWindow_container * in_arg) {\n  mission_window((sb_SW__MissionWindow_container *) in_arg);\n}\n\n\nbool sb_tracking_id_enqueue(const int64_t *data) {\n  sb_queue_int64_t_1_enqueue(sb_tracking_id_queue_1, (int64_t*) data);\n  sb_tracking_id_1_notification_emit();\n\n  return true;\n}\n\n\/************************************************************************\n *  sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid pre_init(void) {\n  \/\/ initialise data structure for incoming event data port mission_window\n  sb_queue_sb_SW__MissionWindow_container_1_Recv_init(&sb_mission_window_recv_queue, sb_mission_window_queue);\n\n  \/\/ initialise data structure for outgoing event data port tracking_id\n  sb_queue_int64_t_1_init(sb_tracking_id_queue_1);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port mission_window\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    {\n      sb_SW__MissionWindow_container sb_mission_window;\n      while (sb_mission_window_dequeue((sb_SW__MissionWindow_container *) &sb_mission_window)) {\n        sb_entrypoint_UARTDriver_Impl_mission_window(&sb_mission_window);\n      }\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/includes\/sb_UARTDriver_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_UARTDRIVER_IMPL_H\n#define SB_UARTDRIVER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_mission_window_dequeue(sb_SW__MissionWindow_container *);\n\nvoid mission_window(const sb_SW__MissionWindow_container *);\n\nbool sb_tracking_id_enqueue(const int64_t *);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_UARTDRIVER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_queue_SW__Command_Impl_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_SW__COMMAND_IMPL_1_SIZE-1 elements.\n#define SB_QUEUE_SW__COMMAND_IMPL_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_SW__Command_Impl_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type SW__Command_Impl \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  SW__Command_Impl elt[SB_QUEUE_SW__COMMAND_IMPL_1_SIZE];\n\n} sb_queue_SW__Command_Impl_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_SW__Command_Impl_1_init(sb_queue_SW__Command_Impl_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_SW__Command_Impl_1_enqueue(\n  sb_queue_SW__Command_Impl_1_t *queue, \n  SW__Command_Impl *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_SW__Command_Impl_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_SW__Command_Impl_1_t *queue;\n\n} sb_queue_SW__Command_Impl_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_SW__Command_Impl_1_Recv_init(\n  sb_queue_SW__Command_Impl_1_Recv_t *recvQueue, \n  sb_queue_SW__Command_Impl_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_SW__Command_Impl_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_SW__Command_Impl_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_SW__Command_Impl_1_dequeue(\n  sb_queue_SW__Command_Impl_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  SW__Command_Impl *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_SW__Command_Impl_1_is_empty(sb_queue_SW__Command_Impl_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/src\/sb_queue_SW__Command_Impl_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_SW__Command_Impl_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_SW__Command_Impl_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_SW__Command_Impl_1_init(sb_queue_SW__Command_Impl_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_SW__Command_Impl_1_enqueue(\n  sb_queue_SW__Command_Impl_1_t *queue, \n  SW__Command_Impl *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_SW__COMMAND_IMPL_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_SW__COMMAND_IMPL_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_SW__Command_Impl_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_SW__Command_Impl_1_Recv_init(\n  sb_queue_SW__Command_Impl_1_Recv_t *recvQueue, \n  sb_queue_SW__Command_Impl_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_SW__Command_Impl_1_dequeue(\n  sb_queue_SW__Command_Impl_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  SW__Command_Impl *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_SW__Command_Impl_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_SW__COMMAND_IMPL_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_SW__COMMAND_IMPL_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_SW__COMMAND_IMPL_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_SW__COMMAND_IMPL_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_SW__COMMAND_IMPL_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_SW__Command_Impl_1_is_empty(sb_queue_SW__Command_Impl_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_queue_sb_SW__Mission_container_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE-1 elements.\n#define SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_sb_SW__Mission_container_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type sb_SW__Mission_container \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  sb_SW__Mission_container elt[SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE];\n\n} sb_queue_sb_SW__Mission_container_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_sb_SW__Mission_container_1_init(sb_queue_sb_SW__Mission_container_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_sb_SW__Mission_container_1_enqueue(\n  sb_queue_sb_SW__Mission_container_1_t *queue, \n  sb_SW__Mission_container *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_sb_SW__Mission_container_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_sb_SW__Mission_container_1_t *queue;\n\n} sb_queue_sb_SW__Mission_container_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_sb_SW__Mission_container_1_Recv_init(\n  sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue, \n  sb_queue_sb_SW__Mission_container_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_sb_SW__Mission_container_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_sb_SW__Mission_container_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_sb_SW__Mission_container_1_dequeue(\n  sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  sb_SW__Mission_container *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_sb_SW__Mission_container_1_is_empty(sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/src\/sb_queue_sb_SW__Mission_container_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_sb_SW__Mission_container_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_sb_SW__Mission_container_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_sb_SW__Mission_container_1_init(sb_queue_sb_SW__Mission_container_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_sb_SW__Mission_container_1_enqueue(\n  sb_queue_sb_SW__Mission_container_1_t *queue, \n  sb_SW__Mission_container *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_sb_SW__Mission_container_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_sb_SW__Mission_container_1_Recv_init(\n  sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue, \n  sb_queue_sb_SW__Mission_container_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_sb_SW__Mission_container_1_dequeue(\n  sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  sb_SW__Mission_container *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_sb_SW__Mission_container_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_SB_SW__MISSION_CONTAINER_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_sb_SW__Mission_container_1_is_empty(sb_queue_sb_SW__Mission_container_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_queue_bool_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_BOOL_1_SIZE-1 elements.\n#define SB_QUEUE_BOOL_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_bool_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type bool \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  bool elt[SB_QUEUE_BOOL_1_SIZE];\n\n} sb_queue_bool_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_bool_1_init(sb_queue_bool_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_bool_1_enqueue(\n  sb_queue_bool_1_t *queue, \n  bool *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_bool_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_bool_1_t *queue;\n\n} sb_queue_bool_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_bool_1_Recv_init(\n  sb_queue_bool_1_Recv_t *recvQueue, \n  sb_queue_bool_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_bool_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_bool_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_bool_1_dequeue(\n  sb_queue_bool_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  bool *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_bool_1_is_empty(sb_queue_bool_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/src\/sb_queue_bool_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_bool_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_bool_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_bool_1_init(sb_queue_bool_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_bool_1_enqueue(\n  sb_queue_bool_1_t *queue, \n  bool *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_BOOL_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_BOOL_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_bool_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_bool_1_Recv_init(\n  sb_queue_bool_1_Recv_t *recvQueue, \n  sb_queue_bool_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_bool_1_dequeue(\n  sb_queue_bool_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  bool *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_bool_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_BOOL_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_BOOL_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_BOOL_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_BOOL_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_BOOL_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_bool_1_is_empty(sb_queue_bool_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_queue_sb_SW__MissionWindow_container_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE-1 elements.\n#define SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_sb_SW__MissionWindow_container_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type sb_SW__MissionWindow_container \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  sb_SW__MissionWindow_container elt[SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE];\n\n} sb_queue_sb_SW__MissionWindow_container_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_sb_SW__MissionWindow_container_1_init(sb_queue_sb_SW__MissionWindow_container_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_sb_SW__MissionWindow_container_1_enqueue(\n  sb_queue_sb_SW__MissionWindow_container_1_t *queue, \n  sb_SW__MissionWindow_container *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_sb_SW__MissionWindow_container_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_sb_SW__MissionWindow_container_1_t *queue;\n\n} sb_queue_sb_SW__MissionWindow_container_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_sb_SW__MissionWindow_container_1_Recv_init(\n  sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue, \n  sb_queue_sb_SW__MissionWindow_container_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_sb_SW__MissionWindow_container_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_sb_SW__MissionWindow_container_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_sb_SW__MissionWindow_container_1_dequeue(\n  sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  sb_SW__MissionWindow_container *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_sb_SW__MissionWindow_container_1_is_empty(sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/src\/sb_queue_sb_SW__MissionWindow_container_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_sb_SW__MissionWindow_container_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_sb_SW__MissionWindow_container_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_sb_SW__MissionWindow_container_1_init(sb_queue_sb_SW__MissionWindow_container_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_sb_SW__MissionWindow_container_1_enqueue(\n  sb_queue_sb_SW__MissionWindow_container_1_t *queue, \n  sb_SW__MissionWindow_container *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_sb_SW__MissionWindow_container_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_sb_SW__MissionWindow_container_1_Recv_init(\n  sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue, \n  sb_queue_sb_SW__MissionWindow_container_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_sb_SW__MissionWindow_container_1_dequeue(\n  sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  sb_SW__MissionWindow_container *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_sb_SW__MissionWindow_container_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_SB_SW__MISSIONWINDOW_CONTAINER_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_sb_SW__MissionWindow_container_1_is_empty(sb_queue_sb_SW__MissionWindow_container_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_queue_int64_t_1.h",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_INT64_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT64_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int64_t_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int64_t \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  int64_t elt[SB_QUEUE_INT64_T_1_SIZE];\n\n} sb_queue_int64_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int64_t_1_init(sb_queue_int64_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int64_t_1_enqueue(\n  sb_queue_int64_t_1_t *queue, \n  int64_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int64_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int64_t_1_t *queue;\n\n} sb_queue_int64_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int64_t_1_Recv_init(\n  sb_queue_int64_t_1_Recv_t *recvQueue, \n  sb_queue_int64_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int64_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int64_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int64_t_1_dequeue(\n  sb_queue_int64_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int64_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int64_t_1_is_empty(sb_queue_int64_t_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/src\/sb_queue_int64_t_1.c",
        {
          "type" : "ITestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int64_t_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int64_t_1_init(sb_queue_int64_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int64_t_1_enqueue(\n  sb_queue_int64_t_1_t *queue, \n  int64_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_INT64_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT64_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int64_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int64_t_1_Recv_init(\n  sb_queue_int64_t_1_Recv_t *recvQueue, \n  sb_queue_int64_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int64_t_1_dequeue(\n  sb_queue_int64_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int64_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int64_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT64_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT64_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT64_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT64_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT64_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_int64_t_1_is_empty(sb_queue_int64_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef\n  struct MC__MISSING_TYPE_Impl {\n    int32_t MISSING;\n  } MC__MISSING_TYPE_Impl;\n\ntypedef\n  enum {ZigZag, StraightLine, Perimeter} SW__FlightPattern;\n\ntypedef\n  struct SW__Coordinate_Impl {\n    int32_t lat;\n    int32_t longitude;\n    int32_t alt;\n  } SW__Coordinate_Impl;\n\ntypedef SW__Coordinate_Impl SW__Map [4];\n\ntypedef\n  struct sb_SW__Map_container {\n    SW__Map f;\n  } sb_SW__Map_container;\n\ntypedef\n  struct SW__Command_Impl {\n    SW__Map Map;\n    SW__FlightPattern Pattern;\n    bool HMAC;\n  } SW__Command_Impl;\n\ntypedef SW__Coordinate_Impl SW__Mission [10];\n\ntypedef\n  struct sb_SW__Mission_container {\n    SW__Mission f;\n  } sb_SW__Mission_container;\n\ntypedef SW__Coordinate_Impl SW__MissionWindow [4];\n\ntypedef\n  struct sb_SW__MissionWindow_container {\n    SW__MissionWindow f;\n  } sb_SW__MissionWindow_container;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/includes\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_SW__Command_Impl_1.c\n            src\/sb_queue_sb_SW__Mission_container_1.c\n            src\/sb_queue_bool_1.c\n            src\/sb_queue_sb_SW__MissionWindow_container_1.c\n            src\/sb_queue_int64_t_1.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_Only\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n(declare-datatypes ((Mode 0)) ((\n  (SeL4)\n  (SeL4_Only)\n  (SeL4_TB))))\n\n(declare-datatypes ((ComponentType 0)) ((\n  (AadlComponent)\n  (AadlVMComponent)\n  (PacerComponent)\n  (PeriodicDispatcher))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic)\n  (UNSPECIFIED_DISPATCH_PROTOCOL))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out))))\n\n(declare-datatypes ((PortType 0)) ((\n  (AadlDataPort)\n  (AadlEventPort)\n  (AadlEventDataPort))))\n\n\n(declare-const CodegenMode Mode)\n(assert (= CodegenMode SeL4_Only))\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType PeriodicDispatching))\n\n(declare-datatypes ((AADLComponent 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO); Instance of SW::RadioDriver.Impl declared at \/Simple_UAV\/SW.aadl (144, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN); Instance of SW::FlightPlanner.Impl declared at \/Simple_UAV\/SW.aadl (145, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM); Instance of SW::WaypointManager.Impl declared at \/Simple_UAV\/SW.aadl (146, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART); Instance of SW::UARTDriver.Impl declared at \/Simple_UAV\/SW.aadl (147, 4)\n)))\n(declare-const AADLComponent_count Int)\n(assert (= 4 AADLComponent_count))\n\n(declare-const AADLDispatchProtocol (Array AADLComponent DispatchProtocol))\n  (assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_RADIO)))\n  (assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_FPLN)))\n  (assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_WPM)))\n  (assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_UART)))\n(declare-const AADLDispatchProtocol_size Int)\n(assert (= 4 AADLDispatchProtocol_size))\n\n(define-fun altAADLDispatchProtocol ((_comp AADLComponent)) DispatchProtocol\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_RADIO) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_FPLN) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_WPM) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_UART) Sporadic\n  UNSPECIFIED_DISPATCH_PROTOCOL)))))\n(declare-const AADLDispatchProtocol_count Int)\n(assert (= 4 AADLDispatchProtocol_count))\n\n(declare-datatypes ((AADLPort 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id))))\n(declare-const AADLPort_count Int)\n(assert (= 10 AADLPort_count))\n\n(declare-const AADLPortComponent (Array AADLPort AADLComponent))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_RADIO (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_UART (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n  (assert (= UAV_Impl_Instance_MCMP_PROC_SW_UART (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n(declare-const AADLPortComponent_size Int)\n(assert (= 10 AADLPortComponent_size))\n\n(declare-const AADLPortType (Array AADLPort PortType))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n  (assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n(declare-const AADLPortType_size Int)\n(assert (= 10 AADLPortType_size))\n\n(declare-const AADLPortDirection (Array AADLPort Direction))\n  (assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n  (assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n  (assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n  (assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n  (assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n  (assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n  (assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n  (assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n  (assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n  (assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n(declare-const AADLPortDirection_size Int)\n(assert (= 10 AADLPortDirection_size))\n\n(define-fun AADLConnectionFlowTos ((p1 AADLPort) (p2 AADLPort)) Bool\n  (or\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window))\n    (and (= p1 UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id) (= p2 UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id))\n    false))\n(declare-const AADLConnectionFlowsTos_count Int)\n(assert (= 5 AADLConnectionFlowsTos_count))\n\n\n(declare-datatypes ((AccessType 0)) ((\n  (R)\n  (W)\n  (RW))))\n\n(declare-datatypes ((seL4PortType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (MCMP_PROC_SW_RADIO)\n  (MCMP_PROC_SW_FPLN)\n  (MCMP_PROC_SW_WPM)\n  (MCMP_PROC_SW_UART))))\n(declare-const CAmkESComponent_count Int)\n(assert (= 4 CAmkESComponent_count))\n\n(define-fun isPeriodicDispatcher ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n           false)))\n\n(define-fun isPacer ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isTimeServer ((_component CAmkESComponent)) Bool\n  (and ; TODO - list scenarios where a time server is expected\n       (or \n           false)))\n\n(define-fun isMonitor ((_component CAmkESComponent)) Bool\n  (or \n      false))\n(declare-const Monitor_count Int)\n(assert (= 0 Monitor_count))\n\n(declare-datatypes ((CAmkESPort 0)) ((\n  (MCMP_PROC_SW_RADIO_sb_recv_map_out_queue_1)\n  (MCMP_PROC_SW_RADIO_sb_recv_map_out_1_notification)\n  (MCMP_PROC_SW_FPLN_sb_flight_plan_queue_1)\n  (MCMP_PROC_SW_FPLN_sb_mission_rcv_queue)\n  (MCMP_PROC_SW_FPLN_sb_recv_map_queue)\n  (MCMP_PROC_SW_FPLN_sb_flight_plan_1_notification)\n  (MCMP_PROC_SW_FPLN_sb_mission_rcv_notification)\n  (MCMP_PROC_SW_FPLN_sb_recv_map_notification)\n  (MCMP_PROC_SW_WPM_sb_flight_plan_queue)\n  (MCMP_PROC_SW_WPM_sb_mission_rcv_queue_1)\n  (MCMP_PROC_SW_WPM_sb_mission_window_queue_1)\n  (MCMP_PROC_SW_WPM_sb_tracking_id_queue)\n  (MCMP_PROC_SW_WPM_sb_mission_rcv_1_notification)\n  (MCMP_PROC_SW_WPM_sb_mission_window_1_notification)\n  (MCMP_PROC_SW_WPM_sb_flight_plan_notification)\n  (MCMP_PROC_SW_WPM_sb_tracking_id_notification)\n  (MCMP_PROC_SW_UART_sb_mission_window_queue)\n  (MCMP_PROC_SW_UART_sb_tracking_id_queue_1)\n  (MCMP_PROC_SW_UART_sb_tracking_id_1_notification)\n  (MCMP_PROC_SW_UART_sb_mission_window_notification))))\n(declare-const CAmkESPort_count Int)\n(assert (= 20 CAmkESPort_count))\n\n(declare-const CAmkESAccessRestrictions (Array CAmkESPort AccessType))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_RADIO_sb_recv_map_out_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_FPLN_sb_recv_map_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_FPLN_sb_flight_plan_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_sb_flight_plan_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_sb_mission_rcv_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_FPLN_sb_mission_rcv_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_sb_mission_window_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_UART_sb_mission_window_queue)))\n  (assert (= W (select CAmkESAccessRestrictions MCMP_PROC_SW_UART_sb_tracking_id_queue_1)))\n  (assert (= R (select CAmkESAccessRestrictions MCMP_PROC_SW_WPM_sb_tracking_id_queue)))\n(declare-const CAmkESAccessRestrictions_size Int)\n(assert (= 10 CAmkESAccessRestrictions_size))\n\n(declare-datatypes ((CAmkESConnection 0)) ((\n  (conn1)\n  (conn2)\n  (conn3)\n  (conn4)\n  (conn5)\n  (conn6)\n  (conn7)\n  (conn8)\n  (conn9)\n  (conn10))))\n(declare-const CAmkESConnection_count Int)\n(assert (= 10 CAmkESConnection_count))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or \n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n           false)))\n(declare-const PeriodicDispatchingConnection_count Int)\n(assert (= 0 PeriodicDispatchingConnection_count))\n\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4PortType))\n  (assert (= seL4Notification (select CAmkESConnectionType conn1)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn2)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn3)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn4)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn5)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn6)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn7)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn8)))\n  (assert (= seL4Notification (select CAmkESConnectionType conn9)))\n  (assert (= seL4SharedData (select CAmkESConnectionType conn10)))\n(declare-const CAmkESConnectionType_count Int)\n(assert (= 10 CAmkESConnectionType_count))\n\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n  (assert (= MCMP_PROC_SW_RADIO (select CAmkESPortComponent MCMP_PROC_SW_RADIO_sb_recv_map_out_queue_1)))\n  (assert (= MCMP_PROC_SW_RADIO (select CAmkESPortComponent MCMP_PROC_SW_RADIO_sb_recv_map_out_1_notification)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_flight_plan_queue_1)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_mission_rcv_queue)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_recv_map_queue)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_flight_plan_1_notification)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_mission_rcv_notification)))\n  (assert (= MCMP_PROC_SW_FPLN (select CAmkESPortComponent MCMP_PROC_SW_FPLN_sb_recv_map_notification)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_flight_plan_queue)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_mission_rcv_queue_1)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_mission_window_queue_1)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_tracking_id_queue)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_mission_rcv_1_notification)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_mission_window_1_notification)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_flight_plan_notification)))\n  (assert (= MCMP_PROC_SW_WPM (select CAmkESPortComponent MCMP_PROC_SW_WPM_sb_tracking_id_notification)))\n  (assert (= MCMP_PROC_SW_UART (select CAmkESPortComponent MCMP_PROC_SW_UART_sb_mission_window_queue)))\n  (assert (= MCMP_PROC_SW_UART (select CAmkESPortComponent MCMP_PROC_SW_UART_sb_tracking_id_queue_1)))\n  (assert (= MCMP_PROC_SW_UART (select CAmkESPortComponent MCMP_PROC_SW_UART_sb_tracking_id_1_notification)))\n  (assert (= MCMP_PROC_SW_UART (select CAmkESPortComponent MCMP_PROC_SW_UART_sb_mission_window_notification)))\n(declare-const CAmkESPortComponent_size Int)\n(assert (= 20 CAmkESPortComponent_size))\n\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    (and (= _conn conn1) (= _p1 MCMP_PROC_SW_RADIO_sb_recv_map_out_1_notification) (= _p2 MCMP_PROC_SW_FPLN_sb_recv_map_notification))\n    (and (= _conn conn2) (= _p1 MCMP_PROC_SW_RADIO_sb_recv_map_out_queue_1) (= _p2 MCMP_PROC_SW_FPLN_sb_recv_map_queue))\n    (and (= _conn conn3) (= _p1 MCMP_PROC_SW_FPLN_sb_flight_plan_1_notification) (= _p2 MCMP_PROC_SW_WPM_sb_flight_plan_notification))\n    (and (= _conn conn4) (= _p1 MCMP_PROC_SW_FPLN_sb_flight_plan_queue_1) (= _p2 MCMP_PROC_SW_WPM_sb_flight_plan_queue))\n    (and (= _conn conn5) (= _p1 MCMP_PROC_SW_WPM_sb_mission_rcv_1_notification) (= _p2 MCMP_PROC_SW_FPLN_sb_mission_rcv_notification))\n    (and (= _conn conn6) (= _p1 MCMP_PROC_SW_WPM_sb_mission_rcv_queue_1) (= _p2 MCMP_PROC_SW_FPLN_sb_mission_rcv_queue))\n    (and (= _conn conn7) (= _p1 MCMP_PROC_SW_WPM_sb_mission_window_1_notification) (= _p2 MCMP_PROC_SW_UART_sb_mission_window_notification))\n    (and (= _conn conn8) (= _p1 MCMP_PROC_SW_WPM_sb_mission_window_queue_1) (= _p2 MCMP_PROC_SW_UART_sb_mission_window_queue))\n    (and (= _conn conn9) (= _p1 MCMP_PROC_SW_UART_sb_tracking_id_1_notification) (= _p2 MCMP_PROC_SW_WPM_sb_tracking_id_notification))\n    (and (= _conn conn10) (= _p1 MCMP_PROC_SW_UART_sb_tracking_id_queue_1) (= _p2 MCMP_PROC_SW_WPM_sb_tracking_id_queue))\n    false))\n(declare-const CAmkESConnectionFlowTos_count Int)\n(assert (= 10 CAmkESConnectionFlowTos_count))\n\n(define-fun ComponentRefinement ((ac AADLComponent) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (= cc MCMP_PROC_SW_RADIO))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_FPLN) (= cc MCMP_PROC_SW_FPLN))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_WPM) (= cc MCMP_PROC_SW_WPM))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_UART) (= cc MCMP_PROC_SW_UART))\n    false))\n(declare-const ComponentRefinement_count Int)\n(assert (= 4 ComponentRefinement_count))\n\n(define-fun PortRefinement ((ap AADLPort) (cp CAmkESPort)) Bool\n  (or\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out) (= cp MCMP_PROC_SW_RADIO_sb_recv_map_out_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out) (= cp MCMP_PROC_SW_RADIO_sb_recv_map_out_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan) (= cp MCMP_PROC_SW_FPLN_sb_flight_plan_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv) (= cp MCMP_PROC_SW_FPLN_sb_mission_rcv_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map) (= cp MCMP_PROC_SW_FPLN_sb_recv_map_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan) (= cp MCMP_PROC_SW_FPLN_sb_flight_plan_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv) (= cp MCMP_PROC_SW_FPLN_sb_mission_rcv_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map) (= cp MCMP_PROC_SW_FPLN_sb_recv_map_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan) (= cp MCMP_PROC_SW_WPM_sb_flight_plan_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv) (= cp MCMP_PROC_SW_WPM_sb_mission_rcv_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window) (= cp MCMP_PROC_SW_WPM_sb_mission_window_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id) (= cp MCMP_PROC_SW_WPM_sb_tracking_id_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv) (= cp MCMP_PROC_SW_WPM_sb_mission_rcv_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window) (= cp MCMP_PROC_SW_WPM_sb_mission_window_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan) (= cp MCMP_PROC_SW_WPM_sb_flight_plan_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id) (= cp MCMP_PROC_SW_WPM_sb_tracking_id_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window) (= cp MCMP_PROC_SW_UART_sb_mission_window_queue))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id) (= cp MCMP_PROC_SW_UART_sb_tracking_id_queue_1))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id) (= cp MCMP_PROC_SW_UART_sb_tracking_id_1_notification))\n    (and (= ap UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window) (= cp MCMP_PROC_SW_UART_sb_mission_window_notification))\n    false))\n(declare-const PortRefinement_count Int)\n(assert (= 20 PortRefinement_count))\n\n\n(define-fun AADLFlowDirectionality () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (and (= Out (select AADLPortDirection p1)) (= In (select AADLPortDirection p2))))))\n\n(define-fun AADLFlowNoSelfConnection () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AADLConnectedPortTypeMatch () Bool\n  (forall ((src AADLPort) (dst AADLPort))\n    (=> (AADLConnectionFlowTos src dst)\n        (or (and (= AadlDataPort (select AADLPortType src)) (= AadlDataPort (select AADLPortType dst)))\n            (and (= AadlEventPort (select AADLPortType src)) (= AadlEventPort (select AADLPortType dst)))\n            (and (= AadlEventDataPort (select AADLPortType src)) (= AadlEventDataPort (select AADLPortType dst)))\n             false))))\n(declare-const AADLConnectedPortTypeMatch_count Int)\n(assert (= 3 AADLConnectedPortTypeMatch_count))\n\n(define-fun AADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (select AADLDispatchProtocol _comp)))))\n\n(define-fun altAADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (altAADLDispatchProtocol _comp)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    (= AADLPort_count AADLPortComponent_size) ; all AADL ports belong to an AADL component\n    altAADLDispatchProtocolSpecified\n    AADLDispatchProtocolSpecified\n    AADLFlowDirectionality\n    AADLFlowNoSelfConnection\n    AADLConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun CAmkESDataPortAccess () Bool\n  (forall ((_conn CAmkESConnection) (_src CAmkESPort) (_dst CAmkESPort))\n    (=> (and (CAmkESConnectionFlowTos _conn _src _dst) (= seL4SharedData (select CAmkESConnectionType _conn)))\n      (and (= W (select CAmkESAccessRestrictions _src))\n           (= R (select CAmkESAccessRestrictions _dst))))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AADLComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement aadlComponent1 camkesComponent)\n        (not (exists ((aadlComponent2 AADLComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement aadlComponent2 camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AADLPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AADLPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    (= CAmkESPort_count CAmkESPortComponent_size) ; all CAmkES ports belong to a CAmkES component\n    CAmkESDataPortAccess\n    CAmkESFlowNoSelfConnection))\n\n(define-fun SB_DataPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) seL4SharedData )\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_EventPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) seL4Notification )\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_Refinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (or\n         (and\n           (= AadlDataPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)) ; payload\n         (and\n           (= AadlEventPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; event counter\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         (and\n           (= AadlEventDataPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; payload\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         false)))\n\n(define-fun TB_Refinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (and (= CodegenMode SeL4_TB)\n       false))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AADLPort) (aadlDest AADLPort))\n    (=> (AADLConnectionFlowTos aadlSource aadlDest)\n      (or (SB_Refinement aadlSource aadlDest)\n          (TB_Refinement aadlSource aadlDest)\n          false))))\n\n\n(define-fun isAADLConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (exists ((aadlSource AADLPort) (aadlDest AADLPort))\n    (and\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n      (AADLConnectionFlowTos aadlSource aadlDest))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAADLConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        false))))\n\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}