{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = { return F }\n\n  def Integer_example(): Integer = { return z\"0\" }\n\n  def Integer_8_example(): Integer_8 = { return s8\"0\" }\n  def Integer_16_example(): Integer_16 = { return s16\"0\" }\n  def Integer_32_example(): Integer_32 = { return s32\"0\" }\n  def Integer_64_example(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_example(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_example(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_example(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_example(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_example(): Float = { return r\"0\" }\n  def Float_32_example(): Float_32 = { return f32\"0\" }\n  def Float_64_example(): Float_64 = { return f64\"0\" }\n\n  def Character_example(): Character = { return ' ' }\n  def String_example(): String = { return \"\" }\n\n  def Bits_example(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val top_impl_Instance_src_process_src_thread : slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge = {\n    val emit = Port[art.Empty] (id = 0, name = \"top_impl_Instance_src_process_src_thread_emit\", mode = EventOut)\n\n    slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_src_process_src_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      emit = emit\n    )\n  }\n  val top_impl_Instance_dst_process_dst_thread : slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge = {\n    val consume = Port[art.Empty] (id = 1, name = \"top_impl_Instance_dst_process_dst_thread_consume\", mode = EventIn)\n\n    slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge(\n      id = 1,\n      name = \"top_impl_Instance_dst_process_dst_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      consume = consume\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n    TranspilerUtil.touch()\n\n    ArchitectureDescription(\n      components = ISZ (top_impl_Instance_src_process_src_thread, top_impl_Instance_dst_process_dst_thread),\n\n      connections = ISZ (Connection(from = top_impl_Instance_src_process_src_thread.emit, to = top_impl_Instance_dst_process_dst_thread.consume))\n    )\n  }\n}\n\nobject TranspilerUtil {\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch process\/thread timing properties\n      println(Schedulers.top_impl_Instance_proc_timingProperties)\n      println(Schedulers.top_impl_Instance_src_process_src_thread_timingProperties)\n      println(Schedulers.top_impl_Instance_dst_process_dst_thread_timingProperties)\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(art.Empty())\n\n      {\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logError(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logInfo(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logDebug(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logError(\"\")\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.put_emit()\n        slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.put_emit()\n      }\n      {\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logError(\"\")\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logInfo(\"\")\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logDebug(\"\")\n        slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_consume: Option[art.Empty] = slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.get_consume()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticScheduler(None())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n        art.Art.run(Arch.ad, scheduler)\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Schedulers.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage slang_embedded\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec, Slot}\nimport art.scheduling.static.StaticScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val top_impl_Instance_proc_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = Some(2),\n    framePeriod = Some(1000),\n    maxDomain = Some(3),\n    slotTime = None())\n\n  val top_impl_Instance_src_process_src_thread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(2))\n\n  val top_impl_Instance_dst_process_dst_thread_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 10)),\n    domain = Some(3))\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[art.Bridge] = Arch.ad.components\n\n  val framePeriod: Z = 1000\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ staticSchedule represents the component dispatch order\n  val staticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Slot(Arch.top_impl_Instance_src_process_src_thread.id, maxExecutionTime),\n    Slot(Arch.top_impl_Instance_dst_process_dst_thread.id, maxExecutionTime)\n  )))\n\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[art.Bridge]]): RoundRobin = {\n    if(roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  def getStaticScheduler(schedule: Option[DScheduleSpec]): StaticScheduler = {\n    if(staticSchedule.schedule.slots.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return StaticScheduler(Arch.ad.components, s)\n      case _ => return StaticScheduler(Arch.ad.components, ScheduleProviderI.getStaticSchedule())\n    }\n  }\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[art.Bridge] = $\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/ScheduleProvider.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded\n\nimport org.sireum._\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[art.Bridge] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.staticSchedule\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/inspector\/slang_embedded\/InspectorDemo.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/sergen.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class emitter_t_impl_src_process_src_thread_TestApi extends BridgeTestSuite[emitter_t_impl_src_process_src_thread_Bridge](Arch.top_impl_Instance_src_process_src_thread) {\n\n  \/** helper function to check emitter_t_impl_src_process_src_thread's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param emit method that will be called with the number of events to be sent\n   *        on the outgoing event port 'emit'.\n   *\/\n  def check_concrete_output(emit: Z => B = emitParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val emitValue: Z = if(get_emit().nonEmpty) z\"1\" else z\"0\"\n    if(!emit(emitValue)) {\n      testFailures = testFailures :+ st\"'emit' did not match expected: ${emitValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out EventPort\n  def get_emit(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_emit_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port emit.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_emit_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.emit_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded.test_event_port_periodic_domains._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass emitter_t_impl_src_process_src_thread_Test extends emitter_t_impl_src_process_src_thread_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.test_event_port_periodic_domains.{emitter_t_impl_src_process_src_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class emitter_t_impl_src_process_src_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  emit: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(emit),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(emit)\n  )\n\n  val initialization_api : emitter_t_impl_Initialization_Api = {\n    val api = emitter_t_impl_Initialization_Api(\n      id,\n      emit.id\n    )\n    emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : emitter_t_impl_Operational_Api = {\n    val api = emitter_t_impl_Operational_Api(\n      id,\n      emit.id\n    )\n    emitter_t_impl_src_process_src_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    emitter_t_impl_src_process_src_thread_Bridge.EntryPoints(\n      id,\n\n      emit.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject emitter_t_impl_src_process_src_thread_Bridge {\n\n  var c_initialization_api: Option[emitter_t_impl_Initialization_Api] = None()\n  var c_operational_api: Option[emitter_t_impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    emitter_t_impl_src_process_src_thread_BridgeId : Art.BridgeId,\n\n    emit_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: emitter_t_impl_Initialization_Api,\n    operational_api: emitter_t_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(emit_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: emitter_t_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: emitter_t_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait emitter_t_impl_Api {\n  def id: Art.BridgeId\n  def emit_Id : Art.PortId\n\n  def put_emit() : Unit = {\n    Art.putValue(emit_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class emitter_t_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val emit_Id : Art.PortId) extends emitter_t_impl_Api\n\n@datatype class emitter_t_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val emit_Id : Art.PortId) extends emitter_t_impl_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject emitter_t_impl_src_process_src_thread {\n\n  def initialise(api: emitter_t_impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def activate(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def finalise(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def recover(api: emitter_t_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/BridgeTestSuite.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[slang_embedded.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_TestApi.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class consumer_t_impl_dst_process_dst_thread_TestApi extends BridgeTestSuite[consumer_t_impl_dst_process_dst_thread_Bridge](Arch.top_impl_Instance_dst_process_dst_thread) {\n\n  \/** helper function to set the values of all input ports.\n   * @param consume the number of events to place in the consume event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(consume : Z): Unit = {\n    for(i <- 0 until consume) {\n      put_consume()\n    }\n  }\n\n\n  \/\/ setter for in EventPort\n  def put_consume(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.consume_Id, Empty())\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_Test.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded.test_event_port_periodic_domains._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass consumer_t_impl_dst_process_dst_thread_Test extends consumer_t_impl_dst_process_dst_thread_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_Bridge.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.test_event_port_periodic_domains.{consumer_t_impl_dst_process_dst_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class consumer_t_impl_dst_process_dst_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  consume: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(consume),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(consume),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : consumer_t_impl_Initialization_Api = {\n    val api = consumer_t_impl_Initialization_Api(\n      id,\n      consume.id\n    )\n    consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : consumer_t_impl_Operational_Api = {\n    val api = consumer_t_impl_Operational_Api(\n      id,\n      consume.id\n    )\n    consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    consumer_t_impl_dst_process_dst_thread_Bridge.EntryPoints(\n      id,\n\n      consume.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject consumer_t_impl_dst_process_dst_thread_Bridge {\n\n  var c_initialization_api: Option[consumer_t_impl_Initialization_Api] = None()\n  var c_operational_api: Option[consumer_t_impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    consumer_t_impl_dst_process_dst_thread_BridgeId : Art.BridgeId,\n\n    consume_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: consumer_t_impl_Initialization_Api,\n    operational_api: consumer_t_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(consume_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: consumer_t_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: consumer_t_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_Api.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait consumer_t_impl_Api {\n  def id: Art.BridgeId\n  def consume_Id : Art.PortId\n\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class consumer_t_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val consume_Id : Art.PortId) extends consumer_t_impl_Api\n\n@datatype class consumer_t_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val consume_Id : Art.PortId) extends consumer_t_impl_Api {\n\n  def get_consume() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(consume_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port consume.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject consumer_t_impl_dst_process_dst_thread {\n\n  def initialise(api: consumer_t_impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def activate(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def finalise(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def recover(api: consumer_t_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/TranspilerToucher.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/emitter_t_impl_src_process_src_thread\/src_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.emitter_t_impl_src_process_src_thread\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_seL4Nix\n\nobject src_thread extends App {\n\n  val src_threadBridge : slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge = {\n    val emit = Port[art.Empty] (id = 0, name = \"top_impl_Instance_src_process_src_thread_emit\", mode = EventOut)\n\n    slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_src_process_src_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      emit = emit\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = src_threadBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ emit: Out EventPort art.Empty\n  val emit_id: Art.PortId = src_threadBridge.emit.id\n  var emit_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    halt(s\"Unexpected: src_thread.getValue called with: ${portId}\")\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == emit_id) {\n      emit_port = Some(data)\n    } else {\n      halt(s\"Unexpected: src_thread.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(emit_port.nonEmpty) {\n      emitter_t_impl_src_process_src_thread_seL4Nix.emit_Send(emit_port.get)\n      emit_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(art.Empty())\n\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logError(\"\")\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.put_emit()\n      slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.put_emit()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(src_threadBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(src_threadBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(src_threadBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\n@ext object emitter_t_impl_src_process_src_thread_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's emit port\n  def emit_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains\/emitter_t_impl_src_process_src_thread_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\nobject emitter_t_impl_src_process_src_thread_seL4Nix_Ext {\n  def emit_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.c",
        {
          "type" : "ITestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_api.h>\n#include <emitter_t_impl_src_process_src_thread.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"top_impl_Instance_src_process_src_thread\";\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_\", 0);\n\n  printf(\"%s: slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n  api_put_emit__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF_LAST);\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_\", 0);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_\", 0);\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_API_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_emit__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(STACK_FRAME_ONLY);\n\nvoid api_logInfo__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_api.h>\n#include <emitter_t_impl_src_process_src_thread.h>\n\nstatic bool apis_initialized = false;\nstatic struct slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api initialization_api;\nstatic struct slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_DDF1B8 = Option[slang_embedded.test_event_port_periodic_domains.emitter_t_impl_Initialization_Api]\n  Option_DDF1B8_get_(SF (slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api) &initialization_api, slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_E05852 = Option[slang_embedded.test_event_port_periodic_domains.emitter_t_impl_Operational_Api]\n  Option_E05852_get_(SF (slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Operational_Api) &operational_api, slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_emit__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_put_emit__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api_put_emit_(\n    SF\n    &initialization_api);\n}\n\nvoid api_logInfo__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logInfo__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logDebug__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logError__slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_adapter.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints\", 0);\n\n  return slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_ADAPTER_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/bin\/settings_emitter_t_impl_src_process_src_thread.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(emitter_t_impl_src_process_src_thread\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/consumer_t_impl_dst_process_dst_thread\/dst_thread.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.consumer_t_impl_dst_process_dst_thread\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_seL4Nix\n\nobject dst_thread extends App {\n\n  val dst_threadBridge : slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge = {\n    val consume = Port[art.Empty] (id = 0, name = \"top_impl_Instance_dst_process_dst_thread_consume\", mode = EventIn)\n\n    slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_dst_process_dst_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      consume = consume\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = dst_threadBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ consume: In EventPort art.Empty\n  val consume_id: Art.PortId = dst_threadBridge.consume.id\n  var consume_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == consume_id) {\n      return consume_port\n    } else {\n      halt(s\"Unexpected: dst_thread.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    consume_port = consumer_t_impl_dst_process_dst_thread_seL4Nix.consume_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    halt(s\"Unexpected: dst_thread.putValue called with: ${portId}\")\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def initialiseArchitecture(): Unit = {\n    \/\/ nothing to do - CAmkES is responsible for initialization\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(art.Empty())\n\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_consume: Option[art.Empty] = slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.get_consume()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(dst_threadBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(dst_threadBridge.name)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(dst_threadBridge.name)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_seL4Nix.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\n@ext object consumer_t_impl_dst_process_dst_thread_seL4Nix {\n  \/\/ returns T if seL4's consume port is empty, F otherwise \n  def consume_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's consume port \n  def consume_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_seL4Nix_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package slang_embedded.test_event_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\nobject consumer_t_impl_dst_process_dst_thread_seL4Nix_Ext {\n  def consume_IsEmpty(): B = halt(\"stub\")\n\n  def consume_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.c",
        {
          "type" : "ITestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_api.h>\n#include <consumer_t_impl_dst_process_dst_thread.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nstatic char* component_id = \"top_impl_Instance_dst_process_dst_thread\";\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_\", 0);\n\n  printf(\"%s: slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_ called\\n\", component_id);\n\n  \/\/ example usage of api setters\n\n\n  \/* example usage of api loggers. Commented out as the constructed String may be too long\n  api_logInfo__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logError\"));\n  *\/\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_\", 0);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  if(api_get_consume__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF_LAST )){\n    printf(\"%s: Received event on consume\\n\", component_id);\n\n    \/* alternative using logInfo.  Commented out as the constructed String may be too large\n    String consume_str = string(\"Received event on event port consume\");\n    api_logInfo__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF consume_str);\n    *\/\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_API_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_consume__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(STACK_FRAME_ONLY);\n\nvoid api_logInfo__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.c",
        {
          "type" : "ITestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_api.h>\n#include <consumer_t_impl_dst_process_dst_thread.h>\n\nstatic bool apis_initialized = false;\nstatic struct slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api initialization_api;\nstatic struct slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Operational_Api operational_api;\n\nstatic void initialize_apis(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"initialize_apis\", 0);\n\n  \/\/ Option_592190 = Option[slang_embedded.test_event_port_periodic_domains.consumer_t_impl_Initialization_Api]\n  Option_592190_get_(SF (slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api) &initialization_api, slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_initialization_api(SF_LAST));\n  \/\/ Option_463829 = Option[slang_embedded.test_event_port_periodic_domains.consumer_t_impl_Operational_Api]\n  Option_463829_get_(SF (slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Operational_Api) &operational_api, slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_operational_api(SF_LAST));\n  apis_initialized = true;\n}\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_consume__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(STACK_FRAME_ONLY){\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_get_consume__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  \/\/ Option_C622DB = Option[art.Empty]\n  \/\/ Some_4782C6 = Some[art.Empty]\n  DeclNewOption_C622DB(t_0);\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Operational_Api_get_consume_(\n    SF\n    (Option_C622DB) &t_0,\n    &operational_api);\n\n  if(t_0.type == TSome_4782C6){\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logInfo__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api_logInfo_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logDebug__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api_logDebug_(\n    SF\n    &initialization_api,\n    str);\n}\n\nvoid api_logError__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logError__slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  if(!apis_initialized) { initialize_apis(SF_LAST); }\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api_logError_(\n    SF\n    &initialization_api,\n    str);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered(\n  STACK_FRAME\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered\", 0);\n\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_adapter.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints\", 0);\n\n  return slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_ADAPTER_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/bin\/settings_consumer_t_impl_dst_process_dst_thread.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(consumer_t_impl_dst_process_dst_thread\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "ITestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n#endif",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "ITestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/bin\/transpile-sel4.cmd",
        {
          "type" : "ITestResource",
          "content" : "::#! 2> \/dev\/null                                   #\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\nif [ -z ${SIREUM_HOME} ]; then                      #\n  echo \"Please set SIREUM_HOME env var\"             #\n  exit -1                                           #\nfi                                                  #\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\n:BOF\nsetlocal\nif not defined SIREUM_HOME (\n  echo Please set SIREUM_HOME env var\n  exit \/B -1\n)\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\nexit \/B %errorlevel%\n::!#\n\/\/ #Sireum\n\nimport org.sireum._\n\n\/\/ This file was auto-generated.  Do not edit\n\nval SCRIPT_HOME: Os.Path = Os.slashDir\nval PATH_SEP: String = Os.pathSep\n\nval emitter_t_impl_src_process_src_thread: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/emitter_t_impl_src_process_src_thread\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/emitter_t_impl_src_process_src_thread\",\n  \"--name\", \"emitter_t_impl_src_process_src_thread\",\n  \"--apps\", \"slang_embedded.emitter_t_impl_src_process_src_thread.src_thread\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"32\",\n  \"--string-size\", \"256\",\n  \"--sequence-size\", \"1\",\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=1\",\n  \"--constants\", s\"art.Art.maxComponents=1;art.Art.maxPorts=1\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_emitter_t_impl_src_process_src_thread.cmake\",\n  \"--forward\", \"art.ArtNative=slang_embedded.emitter_t_impl_src_process_src_thread.src_thread\",\n  \"--stack-size\", \"16777216\",\n  \"--stable-type-id\",\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.c\",\n  \"--exclude-build\", \"slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread,slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread\",\n  \"--lib-only\")\n\nval consumer_t_impl_dst_process_dst_thread: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/test_event_port_periodic_domains${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/consumer_t_impl_dst_process_dst_thread\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/consumer_t_impl_dst_process_dst_thread\",\n  \"--name\", \"consumer_t_impl_dst_process_dst_thread\",\n  \"--apps\", \"slang_embedded.consumer_t_impl_dst_process_dst_thread.dst_thread\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"32\",\n  \"--string-size\", \"256\",\n  \"--sequence-size\", \"1\",\n  \"--sequence\", s\"MS[Z,Option[art.Bridge]]=1;IS[Z,art.UPort]=1\",\n  \"--constants\", s\"art.Art.maxComponents=1;art.Art.maxPorts=1\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_consumer_t_impl_dst_process_dst_thread.cmake\",\n  \"--forward\", \"art.ArtNative=slang_embedded.consumer_t_impl_dst_process_dst_thread.dst_thread\",\n  \"--stack-size\", \"16777216\",\n  \"--stable-type-id\",\n  \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.c\",\n  \"--exclude-build\", \"slang_embedded.test_event_port_periodic_domains.emitter_t_impl_src_process_src_thread,slang_embedded.test_event_port_periodic_domains.consumer_t_impl_dst_process_dst_thread\",\n  \"--lib-only\")\n\nval SlangTypeLibrary: ISZ[String] = ISZ(\n  \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\",\n  \"--output-dir\", s\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\",\n  \"--name\", \"SlangTypeLibrary\",\n  \"--apps\", \"slang_embedded.SlangTypeLibrary.SlangTypeLibrary\",\n  \"--fingerprint\", \"3\",\n  \"--bits\", \"32\",\n  \"--string-size\", \"256\",\n  \"--sequence-size\", \"1\",\n  \"--cmake-includes\", s\"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\",\n  \"--forward\", \"art.ArtNative=slang_embedded.SlangTypeLibrary.SlangTypeLibrary\",\n  \"--stack-size\", \"16777216\",\n  \"--stable-type-id\",\n  \"--lib-only\")\n\nval projects: ISZ[ISZ[String]] = ISZ(\n  emitter_t_impl_src_process_src_thread,\n  consumer_t_impl_dst_process_dst_thread,\n  SlangTypeLibrary\n)\n\nprintln(\"Initializing runtime library ...\")\nSireum.initRuntimeLibrary()\n\nfor(p <- projects) {\n  Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\n}\n\n\/\/ops.ISZOps(projects).parMap(p =>\n\/\/  Sireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ p)\n\/\/)\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  \/\/ ** Manually added method by JH to support debugging interface\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport org.sireum.S64._\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < s64\"0\") {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridges(bridgeId).get\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 2\n  val maxPorts: PortId = 2\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, Option[Bridge]] = MS.create[BridgeId, Option[Bridge]](maxComponents, None[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val Some(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n\n  \/\/ JH: Refactored - manually added method to support\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeInPortValue(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET_PORT,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET_PORT,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when sendOutput transferred message from out port var of producer\n                       var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: ISZ[Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = ISZ()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val inPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val outPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId \/\/ dequeue from infrastructure port\n          inPortVariables(portId) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n          outPortVariables -= srcPortId\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId;\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id).filter(inInfrastructurePorts.get(_).nonEmpty): _*)\n        val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(urgentFifo)\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    Console.out.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/\/ Manually added method to support debugging framework\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\n@record class StaticScheduler(bridges: ISZ[art.Bridge],\n                              staticSchedule: DScheduleSpec) extends Scheduler {\n\n  override def initialize(): Unit = {\n    Schedule.dScheduleSpec = staticSchedule\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      art.Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    Explorer.runSystem()\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      art.Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, Bridge}\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(bridgeId: art.Art.BridgeId, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0,0,DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def setSchedule(spec: DScheduleSpec, bridgeMap: ISZ[Art.BridgeId]) : Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = bridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Z = {\n    \/\/val domainId = slot.domain\n    \/\/val bridgeId = domainToBridgeIdMap(domainId).get\n    val bridgeId = slot.bridgeId\n    return bridgeId\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Z = {\n    val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n    return getBridgeIdFromSlot(slot)\n  }\n\n  def getBridgeId(scheduleState : Explorer.ScheduleState): Z = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  \/\/def getDomain(slotNum: Z): Z = {\n  \/\/  val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n  \/\/  return slot.domain\n  \/\/}\n\n  \/\/def getDomain(scheduleState : Explorer.ScheduleState): Z = {\n  \/\/   return getDomain(scheduleState.slotNum)\n  \/\/}\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    halt(\"TODO\")\n    \/*\n    for (e <- StaticScheduling.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n     *\/\n  }\n\n  def threadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState) : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ --------- helper methods for contracts -------------\n\n  def mySome[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (pred(e)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  def myAll[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (!pred(e)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    checkMaxDomain(dScheduleSpec)\n    checkNoMissingDomain(dScheduleSpec)\n    checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/\/myAll[Slot](dScheduleSpec.schedule.slots, s => s.domain <= dScheduleSpec.maxDomain)\n    \/\/  for (s <- dScheduleSpec.schedule.slots) {\n    \/\/    if (s.domain > dScheduleSpec.maxDomain) {\n    \/\/      return false\n    \/\/    }\n    \/\/  }\n    \/\/  return true\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    for (d <- 0 to dScheduleSpec.maxDomain) {\n      if (!mySome[Slot](dScheduleSpec.schedule.slots, s => s.domain == d)) {\n        return false\n      }\n    }\n    return true\n\n     *\/\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n\n     *\/\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec) : (Z,Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks,remainingHPTicks)\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent }\n\nobject StateObserver {\n\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeInPortValue(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def generatePortContentsInputsCurrent() : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsOutputsCurrent() : String = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState,Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        val result =\n          st\"\"\"****************************\n              |   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n              |****************************\n              | Output Ports\n              | ===============\n              |  ${formatPortInfo(outPortInfo)}\"\"\".render\n        return result\n      }\n      case None() => {\n        return \"(initial state - no previous state to show)\"\n      }\n    }\n  }\n\n  def formatPortInfo(portVals: ISZ[(String,Option[DataContent])]): String = {\n    var result: String = \"\" \/\/ ToDo: Ask Robby if I can do this with a repeating template\n    for (e <- portVals) {\n      result = st\"\"\"$result\n                   |${e._1} = ${e._2}\"\"\".render  \/\/ how do I put in new line?\n    }\n    return result\n  }\n\n  def generatePortContents(bridgeId: Z) : String = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\n          |\n          | Output Ports\n          | ================\n          |  ${formatPortInfo(outPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsByNickName(threadNickName: String) : String = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return generatePortContents(bridgeId)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec) : B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return  slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  \/\/ no overloading in Slang\n  \/\/def isHyperPeriodBoundary(): B = {\n  \/\/  return isHyperPeriodBoundary(scheduleState)\n  \/\/}\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState : ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    ScheduleState(0,0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    \/\/val domainId: Z = slot.domain\n    \/\/val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId).get\n    val bridgeId: Art.BridgeId = slot.bridgeId\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if(ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState,dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum,nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState,dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1           \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) {  \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1  \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum,nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP() : Unit = {\n    scheduleState = nextState(scheduleState,dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      halt(\"TODO\")\n      \/\/Cli.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots :Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP : Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n    halt(\"TODO\")\n    \/\/Cli.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods:Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      \/\/ println(\"===== Hyperperiod \", scheduleState.hyperperiodNum, \" ============\")\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    halt(\"TODO\")\n    \/\/Cli.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    \/\/while (scheduleState.hyperperiodNum < hpNum) {\n    \/\/  stepSystemOneSlotIMP(F)\n    \/\/}\n    \/\/Cli.message(\"*********** Run to ... Completed *************\")\n    \/\/Cli.showState(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum:Z, slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    halt(\"TODO\")\n    \/*\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to domain $domainId\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n\n     *\/\n  }\n\n  \/*\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = art.StaticScheduling.bridgeIdToDomainMap(bridgeId)\n    Cli.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n  }\n   *\/\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    \/\/Cli.message (s\"...Running system according to static schedule\")\n    cprintln(F, \"...Running system according to static schedule\")\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\n\n@record class RoundRobin(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  def shouldDispatch(bridge: art.Bridge): B = {\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if(Art.time() - lastDispatch(bridge.id) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridge.id)  \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if(Art.time() - lastSporadic(bridge.id) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridge.id)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while(!RoundRobinExtensions.shouldStop()) {\n      for (bridge <- bridges) {\n        if(shouldDispatch(bridge)) {\n          lastDispatch(bridge.id) = Art.time()\n          bridge.entryPoints.compute()\n\n          if(bridge.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridge.id) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n  def shouldStop(): B = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = { }\n\n  override def computePhase(): Unit = { }\n\n  override def finalizePhase(): Unit = { }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "ITestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: ISZ[Bridge],\n                                        connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n\n    def testInitialise(): Unit = { println(\"Default testInitialise\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "ITestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\n\nobject ArtSlangMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Art.PortId,\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for(e <- eventIns) {\n          if(inInfrastructurePorts.contains(e.id)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  def lt(a : art.UPort,b : art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if(sorted.isEmpty) { return ISZ(p) }\n      else {\n        if(lt(sorted(0), p)) { return sorted(0) +: insert(p, ops.ISZOps(sorted).tail) }\n        else { return p +: sorted }\n      }\n    }\n    if(ports.isEmpty) { return ports}\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds: ISZ[Art.PortId] =\n          for(p <- Art.bridges(bridgeId).get.ports.eventIns if inInfrastructurePorts.get(p.id).nonEmpty) yield p.id\n\n        if(portIds.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(for(p <- portIds) yield Art.port(p))\n        EventTriggered(for(p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId, data))\n          inPortVariables = inPortVariables + (portId ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = ArtSlangMessage.UNSET_PORT, sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if(inPortVariables.contains(portId)) {\n      return Some(inPortVariables.get(portId).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/bin\/project.cmd",
        {
          "type" : "ITestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/github.com\/sireum\/kekinian#installing\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . slang_embedded.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . slang_embedded.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main slang_embedded.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   If you prevented HAMR from running Proyek IVE then first generate the IVE project:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/slang_embedded\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\/\/\r\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\r\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\r\n\/\/         named 'target' and retry\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"top_impl_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/versions.properties",
        {
          "type" : "ITestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=7f8abdc\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20210915.fd34029\n\norg.sireum.kekinian%%library%=4.20210930.abd2495\n\norg.scala-lang%scala-library%=2.13.6\norg.scalatest%%scalatest%%=3.2.10\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "ITestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang-embedded ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w slang_embedded.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `slang_embedded` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.6\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.10\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210915.fd34029\n  val sireumScalacVersion = \"4.20210915.fd34029\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210930.abd2495\n  val kekinianVersion = \"4.20210930.abd2495\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"slang_embedded.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"slang_embedded.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/slang_embedded\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val top_impl_Instance = slangEmbeddedProject(\"top_impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.6\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.10\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210915.fd34029\nval sireumScalacVersion = \"4.20210915.fd34029\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210930.abd2495\nval kekinianVersion = \"4.20210930.abd2495\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.Demo\"),\n\n  mainClass in assembly := Some(\"slang_embedded.Demo\"),\n  assemblyJarName in assembly := \"top_impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "ITestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "ITestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.camkes",
        {
          "type" : "ITestResource",
          "content" : "component emitter_t_impl_src_process_src_thread {\n  include <sb_types.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_emit;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_event_counter_t sb_emit_counter;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.camkes",
        {
          "type" : "ITestResource",
          "content" : "component consumer_t_impl_dst_process_dst_thread {\n  include <sb_types.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_consume;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_event_counter_t sb_consume_counter;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/top_impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.camkes\";\nimport \"components\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.camkes\";\n\nassembly {\n  composition {\n    component emitter_t_impl_src_process_src_thread src_process_src_thread;\n    component consumer_t_impl_dst_process_dst_thread dst_process_dst_thread;\n\n    connection seL4Notification conn1(from src_process_src_thread.sb_emit, to dst_process_dst_thread.sb_consume);\n    connection seL4SharedData conn2(from src_process_src_thread.sb_emit_counter, to dst_process_dst_thread.sb_consume_counter);\n    connection seL4Notification conn3(from src_process_src_thread.sb_self_pacer_tick, to src_process_src_thread.sb_self_pacer_tock);\n    connection seL4Notification conn4(from dst_process_dst_thread.sb_self_pacer_tick, to dst_process_dst_thread.sb_self_pacer_tock);\n  }\n\n  configuration {\n    src_process_src_thread._domain = 2;\n    dst_process_dst_thread._domain = 3;\n    src_process_src_thread.sb_emit_counter_access = \"W\";\n    dst_process_dst_thread.sb_consume_counter_access = \"R\";\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "ITestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (top_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/emitter_t_impl_src_process_src_thread)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/consumer_t_impl_dst_process_dst_thread)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(emitter_t_impl_src_process_src_thread\n  SOURCES components\/emitter_t_impl_src_process_src_thread\/src\/sb_emitter_t_impl.c\n  INCLUDES components\/emitter_t_impl_src_process_src_thread\/includes\/ types\/includes\n  LIBS emitter_t_impl_src_process_src_thread\n)\n\nDeclareCAmkESComponent(consumer_t_impl_dst_process_dst_thread\n  SOURCES components\/consumer_t_impl_dst_process_dst_thread\/src\/sb_consumer_t_impl.c\n  INCLUDES components\/consumer_t_impl_dst_process_dst_thread\/includes\/ types\/includes\n  LIBS consumer_t_impl_dst_process_dst_thread\n)\n\nDeclareCAmkESRootserver(top_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present, CAmkES build directory will not be deleted\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/emitter_t_impl_src_process_src_thread\/src\/sb_emitter_t_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_emitter_t_impl.h>\n#include <sb_event_counter.h>\n#include <emitter_t_impl_src_process_src_thread_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_emit_enqueue\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to send to a remote event port.\n *\n ************************************************************************\/\nbool sb_emit_enqueue(void) {\n  \/\/ sb_emit_counter is a dataport (shared memory) that is written by the sender\n  \/\/ and read by the receiver(s). This counter is monotonicly increasing,\n  \/\/ but can wrap.\n  (*sb_emit_counter)++;\n\n  \/\/ Release memory fence - ensure subsequent write occurs after any preceeding read or write\n  sb_emit_counter_release();\n\n  sb_emit_emit();\n\n  return true;\n}\n\n\n\/\/ send emit: Out EventPort\nUnit slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_seL4Nix_emit_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_emitter_t_impl.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_seL4Nix_emit_Send\", 0);\n\n  \/\/ event port - can ignore the Slang Empty payload\n  art_Empty payload = (art_Empty) d;\n\n  \/\/ send event via CAmkES\n  sb_emit_enqueue();\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_emitter_t_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of emitter_t_impl_src_process_src_thread\\n\");\n\n  \/\/ initialise shared counter for event port emit\n  *sb_emit_counter = 0;\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of emitter_t_impl_src_process_src_thread\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_emitter_t_impl.c\", \"\", \"run\", 0);\n\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_test_event_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/emitter_t_impl_src_process_src_thread\/includes\/sb_emitter_t_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_EMITTER_T_IMPL_H\n#define SB_EMITTER_T_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_emit_enqueue(void);\n\n#endif \/\/ SB_EMITTER_T_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/src\/sb_consumer_t_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_consumer_t_impl.h>\n#include <sb_event_counter.h>\n#include <consumer_t_impl_dst_process_dst_thread_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n *\n * Static variables and queue management functions for event port:\n *     consume\n *\n ************************************************************************\/\nstatic sb_event_counter_t sb_consume_received_events = 0;\nstatic sb_event_counter_t sb_consume_last_counter = 0;\n\n\/************************************************************************\n * sb_consume_dequeue:\n * Invoked from local active thread.\n *\n * This is the function invoked by the active thread to decrement the\n * input event index.\n *\n ************************************************************************\/\nbool sb_consume_dequeue() {\n  if(sb_consume_received_events > 0) {\n    sb_consume_received_events--;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\/************************************************************************\n * sb_consume_is_empty;\n *\n * Helper method to determine if infrastructure port has not received\n * any new events since the last dispatch\n *\n ************************************************************************\/\nbool sb_consume_is_empty() {\n  return sb_consume_received_events == 0;\n}\n\nvoid sb_freeze_event_port_consume() {\n  sb_event_counter_t current_sb_consume_counter;\n\n  sb_consume_received_events = 0; \/\/ drop any events not handled during last dispatch\n\n  \/\/ get current shared counter value\n  current_sb_consume_counter = *sb_consume_counter;\n\n  \/\/ Acquire memory fence - ensure preceding read occurs before any subsequent read or write\n  sb_consume_counter_acquire();\n\n  \/\/ NOTE: Counters can wrap, so we must use != below instead of >\n  while(current_sb_consume_counter != sb_consume_last_counter){\n    sb_consume_last_counter++;\n    sb_consume_received_events++;\n  }\n\n  if(sb_consume_received_events > 0) {\n\n    \/\/ consume's queue size is 1\n    if(sb_consume_received_events > 1) {\n      \/\/printf(\"consumer_t_impl: dropping %i event(s) from incoming event port consume\\n\", (sb_consume_received_events - 1));\n\n      \/\/ drop events\n      sb_consume_received_events = 1;\n    }\n  }\n}\n\n\/\/ is_empty consume: In EventPort\nB slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_consume_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_consume_is_empty();\n}\n\n\/\/ receive consume: In EventPort\nUnit slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_consume_Receive(STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_consumer_t_impl.c\", \"\", \"slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_consume_Receive\", 0);\n\n  if(sb_consume_dequeue()) {\n    \/\/ event port - ART requires an Empty payload be sent\n    DeclNewart_Empty(payload);\n\n    \/\/ wrap it in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &payload);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n} \n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_consumer_t_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of consumer_t_impl_dst_process_dst_thread\\n\");\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of consumer_t_impl_dst_process_dst_thread\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_consumer_t_impl.c\", \"\", \"run\", 0);\n\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    sb_freeze_event_port_consume();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_test_event_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/includes\/sb_consumer_t_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CONSUMER_T_IMPL_H\n#define SB_CONSUMER_T_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_consume_dequeue(void);\n\n#endif \/\/ SB_CONSUMER_T_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/types\/includes\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/kernel\/domain_schedule.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ Copyright 2020 Adventium Labs\n\n\/\/ This is a kernel data structure\n\n#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ An arbitrary hand generated schedule. The length is in seL4 ticks\n\/\/ (2 ms default). This schedule should be generated from the AADL model\n\/\/ using execution time and data flow latency specifications.\n\/\/\n\/\/ Pacer runs at highest rate\n\/\/\n\/\/ This schedule is single-rate, 1Hz, run each thread at 200ms ticks for simplicity.\n\/\/ Fill space in with domain 0.\n\/\/\n\/\/         +\n\/\/ 3 dest  |        -              -              -              -      \n\/\/ 2 src   |     -              -              -              -         \n\/\/ 1 pacer |  -              -              -              -            \n\/\/ 0 dom0  |-- -- -- -------- -- -- -------- -- -- -------- -- -- ------\n\/\/         |______________|______________________________________________\\time\n\/\/           seconds      1              2              3              4 \/\n\/\/\n\/\/ Major frame is 1 seconds, since destination has 1 second period\n\/\/\nconst dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n    { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n    { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n    { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n    { .domain = 2, .length =   5 }, \/\/ source       10ms\n    { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n    { .domain = 3, .length =   5 }, \/\/ destination  10ms\n    { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 4 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            INTERFACE\n            )\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           INTERFACE\n                           includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port_periodic_domains--SeL4\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n(declare-datatypes ((Mode 0)) ((\n  (SeL4)\n  (SeL4_Only)\n  (SeL4_TB))))\n\n(declare-datatypes ((ComponentType 0)) ((\n  (AadlComponent)\n  (AadlVMComponent)\n  (PacerComponent)\n  (PeriodicDispatcher))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic)\n  (UNSPECIFIED_DISPATCH_PROTOCOL))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out))))\n\n(declare-datatypes ((PortType 0)) ((\n  (AadlDataPort)\n  (AadlEventPort)\n  (AadlEventDataPort))))\n\n\n(declare-const CodegenMode Mode)\n(assert (= CodegenMode SeL4))\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType SelfPacing))\n\n; 2 AADLComponent\n(declare-datatypes ((AADLComponent 0)) ((\n  (top_impl_Instance_src_process_src_thread); Instance of test_event_port_periodic_domains::emitter_t.impl declared at \/test_event_port_periodic_domains\/test_event_port_periodic_domains.aadl (36, 4)\n  (top_impl_Instance_dst_process_dst_thread); Instance of test_event_port_periodic_domains::consumer_t.impl declared at \/test_event_port_periodic_domains\/test_event_port_periodic_domains.aadl (67, 4)\n)))\n\n; 2 AADLDispatchProtocol\n(declare-const AADLDispatchProtocol (Array AADLComponent DispatchProtocol))\n(assert (= Periodic (select AADLDispatchProtocol top_impl_Instance_src_process_src_thread)))\n(assert (= Periodic (select AADLDispatchProtocol top_impl_Instance_dst_process_dst_thread)))\n\n; 2 altAADLDispatchProtocol\n(define-fun altAADLDispatchProtocol ((_comp AADLComponent)) DispatchProtocol\n  (ite (= _comp top_impl_Instance_src_process_src_thread) Periodic\n  (ite (= _comp top_impl_Instance_dst_process_dst_thread) Periodic\n  UNSPECIFIED_DISPATCH_PROTOCOL)))\n\n; 2 AADLPort\n(declare-datatypes ((AADLPort 0)) ((\n  (top_impl_Instance_src_process_src_thread_emit)\n  (top_impl_Instance_dst_process_dst_thread_consume))))\n\n; 2 AADLPortComponent\n(declare-const AADLPortComponent (Array AADLPort AADLComponent))\n(assert (= top_impl_Instance_src_process_src_thread (select AADLPortComponent top_impl_Instance_src_process_src_thread_emit)))\n(assert (= top_impl_Instance_dst_process_dst_thread (select AADLPortComponent top_impl_Instance_dst_process_dst_thread_consume)))\n\n; 2 AADLPortType\n(declare-const AADLPortType (Array AADLPort PortType))\n(assert (= AadlEventPort (select AADLPortType top_impl_Instance_src_process_src_thread_emit)))\n(assert (= AadlEventPort (select AADLPortType top_impl_Instance_dst_process_dst_thread_consume)))\n\n; 2 AADLPortDirection\n(declare-const AADLPortDirection (Array AADLPort Direction))\n(assert (= Out (select AADLPortDirection top_impl_Instance_src_process_src_thread_emit)))\n(assert (= In (select AADLPortDirection top_impl_Instance_dst_process_dst_thread_consume)))\n\n; 1 AADLConnectionFlowTos\n(define-fun AADLConnectionFlowTos ((p1 AADLPort) (p2 AADLPort)) Bool\n  (or\n    (and (= p1 top_impl_Instance_src_process_src_thread_emit) (= p2 top_impl_Instance_dst_process_dst_thread_consume))\n    false)\n)\n\n\n(declare-datatypes ((AccessType 0)) ((\n  (R)\n  (W)\n  (RW))))\n\n(declare-datatypes ((seL4PortType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n; 2 CAmkESComponent\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (src_process_src_thread)\n  (dst_process_dst_thread)\n)))\n\n(define-fun isPeriodicDispatcher ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n           false)))\n\n(define-fun isPacer ((_component CAmkESComponent)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isTimeServer ((_component CAmkESComponent)) Bool\n  (and ; TODO - list scenarios where a time server is expected\n       (or \n           false)))\n\n(define-fun isMonitor ((_component CAmkESComponent)) Bool\n  (or \n      false))\n\n\n; 8 CAmkESPort\n(declare-datatypes ((CAmkESPort 0)) ((\n  (src_process_src_thread_sb_emit_counter)\n  (src_process_src_thread_sb_emit)\n  (src_process_src_thread_sb_self_pacer_tick)\n  (src_process_src_thread_sb_self_pacer_tock)\n  (dst_process_dst_thread_sb_consume_counter)\n  (dst_process_dst_thread_sb_self_pacer_tick)\n  (dst_process_dst_thread_sb_consume)\n  (dst_process_dst_thread_sb_self_pacer_tock)\n)))\n\n(declare-const CAmkESAccessRestrictions (Array CAmkESPort AccessType))\n(assert (= W (select CAmkESAccessRestrictions src_process_src_thread_sb_emit_counter)))\n(assert (= R (select CAmkESAccessRestrictions dst_process_dst_thread_sb_consume_counter)))\n\n; 4 CAmkESConnection\n(declare-datatypes ((CAmkESConnection 0)) ((\n  (conn1)\n  (conn2)\n  (conn3)\n  (conn4)\n)))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or (= _conn conn3)\n           (= _conn conn4)\n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n           false)))\n\n; 4 CAmkESConnectionType\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4PortType))\n(assert (= seL4Notification (select CAmkESConnectionType conn1)))\n(assert (= seL4SharedData (select CAmkESConnectionType conn2)))\n(assert (= seL4Notification (select CAmkESConnectionType conn3)))\n(assert (= seL4Notification (select CAmkESConnectionType conn4)))\n\n; 8 CAmkESPortComponent\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n(assert (= src_process_src_thread (select CAmkESPortComponent src_process_src_thread_sb_emit)))\n(assert (= src_process_src_thread (select CAmkESPortComponent src_process_src_thread_sb_emit_counter)))\n(assert (= src_process_src_thread (select CAmkESPortComponent src_process_src_thread_sb_self_pacer_tick)))\n(assert (= src_process_src_thread (select CAmkESPortComponent src_process_src_thread_sb_self_pacer_tock)))\n(assert (= dst_process_dst_thread (select CAmkESPortComponent dst_process_dst_thread_sb_consume)))\n(assert (= dst_process_dst_thread (select CAmkESPortComponent dst_process_dst_thread_sb_consume_counter)))\n(assert (= dst_process_dst_thread (select CAmkESPortComponent dst_process_dst_thread_sb_self_pacer_tick)))\n(assert (= dst_process_dst_thread (select CAmkESPortComponent dst_process_dst_thread_sb_self_pacer_tock)))\n\n; 4 CAmkESConnectionFlowTos\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    (and (= _conn conn1) (= _p1 src_process_src_thread_sb_emit) (= _p2 dst_process_dst_thread_sb_consume))\n    (and (= _conn conn2) (= _p1 src_process_src_thread_sb_emit_counter) (= _p2 dst_process_dst_thread_sb_consume_counter))\n    (and (= _conn conn3) (= _p1 src_process_src_thread_sb_self_pacer_tick) (= _p2 src_process_src_thread_sb_self_pacer_tock))\n    (and (= _conn conn4) (= _p1 dst_process_dst_thread_sb_self_pacer_tick) (= _p2 dst_process_dst_thread_sb_self_pacer_tock))\n    false))\n\n\n; 2 ComponentRefinement\n(define-fun ComponentRefinement ((ac AADLComponent) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac top_impl_Instance_src_process_src_thread) (= cc src_process_src_thread))\n    (and (= ac top_impl_Instance_dst_process_dst_thread) (= cc dst_process_dst_thread))\n    false))\n\n; 4 PortRefinement\n(define-fun PortRefinement ((ap AADLPort) (cp CAmkESPort)) Bool\n  (or\n    (and (= ap top_impl_Instance_src_process_src_thread_emit) (= cp src_process_src_thread_sb_emit_counter))\n    (and (= ap top_impl_Instance_src_process_src_thread_emit) (= cp src_process_src_thread_sb_emit))\n    (and (= ap top_impl_Instance_dst_process_dst_thread_consume) (= cp dst_process_dst_thread_sb_consume_counter))\n    (and (= ap top_impl_Instance_dst_process_dst_thread_consume) (= cp dst_process_dst_thread_sb_consume))\n    false))\n\n\n(define-fun AADLFlowDirectionality () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (and (= Out (select AADLPortDirection p1)) (= In (select AADLPortDirection p2))))))\n\n(define-fun AADLFlowNoSelfConnection () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AADLConnectedPortTypeMatch () Bool\n  (forall ((src AADLPort) (dst AADLPort))\n    (=> (AADLConnectionFlowTos src dst)\n        (or\n          (and (= AadlDataPort (select AADLPortType src)) (= AadlDataPort (select AADLPortType dst)))(and (= AadlEventPort (select AADLPortType src)) (= AadlEventPort (select AADLPortType dst)))(and (= AadlEventDataPort (select AADLPortType src)) (= AadlEventDataPort (select AADLPortType dst)))\n          false))))\n\n(define-fun AADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (select AADLDispatchProtocol _comp)))))\n\n(define-fun altAADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (altAADLDispatchProtocol _comp)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    altAADLDispatchProtocolSpecified\n    AADLDispatchProtocolSpecified\n    AADLFlowDirectionality\n    AADLFlowNoSelfConnection\n    AADLConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun CAmkESDataPortAccess () Bool\n  (forall ((_conn CAmkESConnection) (_src CAmkESPort) (_dst CAmkESPort))\n    (=> (and (CAmkESConnectionFlowTos _conn _src _dst) (= seL4SharedData (select CAmkESConnectionType _conn)))\n      (and (= W (select CAmkESAccessRestrictions _src))\n           (= R (select CAmkESAccessRestrictions _dst))))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AADLComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement aadlComponent1 camkesComponent)\n        (not (exists ((aadlComponent2 AADLComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement aadlComponent2 camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AADLPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AADLPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    CAmkESDataPortAccess\n    CAmkESFlowNoSelfConnection))\n\n(define-fun SB_DataPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) seL4SharedData )\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_EventPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) seL4Notification )\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun SB_Refinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (and (or (= CodegenMode SeL4) (= CodegenMode SeL4_Only) false)\n       (or\n         (and\n           (= AadlDataPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)) ; payload\n         (and\n           (= AadlEventPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; event counter\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         (and\n           (= AadlEventDataPort (select AADLPortType aadlSource))\n           (SB_DataPortRefinement aadlSource aadlDest)   ; payload\n           (SB_EventPortRefinement aadlSource aadlDest)) ; event\n         false)))\n\n(define-fun TB_Refinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (and (= CodegenMode SeL4_TB)\n       false))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AADLPort) (aadlDest AADLPort))\n    (=> (AADLConnectionFlowTos aadlSource aadlDest)\n      (or (SB_Refinement aadlSource aadlDest)\n          (TB_Refinement aadlSource aadlDest)\n          false))))\n\n\n(define-fun isAADLConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (exists ((aadlSource AADLPort) (aadlDest AADLPort))\n    (and\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n      (AADLConnectionFlowTos aadlSource aadlDest))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAADLConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        false))))\n\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}