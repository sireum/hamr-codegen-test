{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "simple_uav--SeL4_TB\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n\n(declare-datatypes ((ComponentType 0)) ((\n  (AadlComponent)\n  (AadlVMComponent)\n  (PacerComponent)\n  (PeriodicDispatcher))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic)\n  (UNSPECIFIED_DISPATCH_PROTOCOL))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out))))\n\n(declare-datatypes ((PortType 0)) ((\n  (AadlDataPort)\n  (AadlEventPort)\n  (AadlEventDataPort))))\n\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType PeriodicDispatching))\n\n; 4 AADLComponent\n(declare-datatypes ((AADLComponent 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO); Instance of SW::RadioDriver.Impl declared at \/Simple_UAV\/SW.aadl (144, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN); Instance of SW::FlightPlanner.Impl declared at \/Simple_UAV\/SW.aadl (145, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM); Instance of SW::WaypointManager.Impl declared at \/Simple_UAV\/SW.aadl (146, 4)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART); Instance of SW::UARTDriver.Impl declared at \/Simple_UAV\/SW.aadl (147, 4)\n)))\n\n; 4 AADLDispatchProtocol\n(declare-const AADLDispatchProtocol (Array AADLComponent DispatchProtocol))\n(assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_RADIO)))\n(assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_FPLN)))\n(assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_WPM)))\n(assert (= Sporadic (select AADLDispatchProtocol UAV_Impl_Instance_MCMP_PROC_SW_UART)))\n\n; 4 altAADLDispatchProtocol\n(define-fun altAADLDispatchProtocol ((_comp AADLComponent)) DispatchProtocol\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_RADIO) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_FPLN) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_WPM) Sporadic\n  (ite (= _comp UAV_Impl_Instance_MCMP_PROC_SW_UART) Sporadic\n  UNSPECIFIED_DISPATCH_PROTOCOL)))))\n\n; 10 AADLPort\n(declare-datatypes ((AADLPort 0)) ((\n  (UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)\n  (UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)\n  (UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)\n  (UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id))))\n\n; 10 AADLPortComponent\n(declare-const AADLPortComponent (Array AADLPort AADLComponent))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_RADIO (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_FPLN (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_WPM (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_UART (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n(assert (= UAV_Impl_Instance_MCMP_PROC_SW_UART (select AADLPortComponent UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n\n; 10 AADLPortType\n(declare-const AADLPortType (Array AADLPort PortType))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n(assert (= AadlEventDataPort (select AADLPortType UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n\n; 10 AADLPortDirection\n(declare-const AADLPortDirection (Array AADLPort Direction))\n(assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_RADIO_recv_map_out)))\n(assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_flight_plan)))\n(assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_mission_rcv)))\n(assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_FPLN_recv_map)))\n(assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_flight_plan)))\n(assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_rcv)))\n(assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_mission_window)))\n(assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_WPM_tracking_id)))\n(assert (= In (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UART_mission_window)))\n(assert (= Out (select AADLPortDirection UAV_Impl_Instance_MCMP_PROC_SW_UART_tracking_id)))\n\n; 0 AADLConnectionFlowTos\n(define-fun AADLConnectionFlowTos ((p1 AADLPort) (p2 AADLPort)) Bool\n  (or\n    false)\n)\n\n\n(declare-datatypes ((seL4PortType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n; 4 CAmkESComponent\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (MCMP_PROC_SW_RADIO)\n  (MCMP_PROC_SW_FPLN)\n  (MCMP_PROC_SW_WPM)\n  (MCMP_PROC_SW_UART)\n)))\n\n; 0 CAmkESPort\n(declare-datatypes ((CAmkESPort 0)) ((\n)))\n\n; 0 CAmkESConnection\n(declare-datatypes ((CAmkESConnection 0)) ((\n)))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or \n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n            false)))\n\n; 0 CAmkESConnectionType\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4PortType))\n\n; 0 CAmkESPortComponent\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n\n; 0 CAmkESConnectionFlowTos\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    false))\n\n\n; 4 ComponentRefinement\n(define-fun ComponentRefinement ((ac AADLComponent) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_RADIO) (= cc MCMP_PROC_SW_RADIO))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_FPLN) (= cc MCMP_PROC_SW_FPLN))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_WPM) (= cc MCMP_PROC_SW_WPM))\n    (and (= ac UAV_Impl_Instance_MCMP_PROC_SW_UART) (= cc MCMP_PROC_SW_UART))\n    false))\n\n; 0 PortRefinement\n(define-fun PortRefinement ((ap AADLPort) (cp CAmkESPort)) Bool\n  (or\n    false))\n\n\n(define-fun AADLFlowDirectionality () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (and (= Out (select AADLPortDirection p1)) (= In (select AADLPortDirection p2))))))\n\n(define-fun AADLFlowNoSelfConnection () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AADLConnectedPortTypeMatch () Bool\n  (forall ((src AADLPort) (dst AADLPort))\n    (=> (AADLConnectionFlowTos src dst)\n        (or\n          (and (= AadlDataPort (select AADLPortType src)) (= AadlDataPort (select AADLPortType dst)))(and (= AadlEventPort (select AADLPortType src)) (= AadlEventPort (select AADLPortType dst)))(and (= AadlEventDataPort (select AADLPortType src)) (= AadlEventDataPort (select AADLPortType dst)))\n          false))))\n\n(define-fun AADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (select AADLDispatchProtocol _comp)))))\n\n(define-fun altAADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (altAADLDispatchProtocol _comp)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    altAADLDispatchProtocolSpecified\n    AADLDispatchProtocolSpecified\n    AADLFlowDirectionality\n    AADLFlowNoSelfConnection\n    AADLConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AADLComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement aadlComponent1 camkesComponent)\n        (not (exists ((aadlComponent2 AADLComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement aadlComponent2 camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AADLPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AADLPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    CAmkESFlowNoSelfConnection))\n\n(define-fun DataPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) seL4SharedData )\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun EventPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) seL4Notification )\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AADLPort) (aadlDest AADLPort))\n    (=> (AADLConnectionFlowTos aadlSource aadlDest)\n        (or\n          (and\n               (= AadlDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)) ; payload\n          (and\n               (= AadlEventPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; event counter\n               (EventPortRefinement aadlSource aadlDest)) ; event\n          (and\n               (= AadlEventDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; payload\n               (EventPortRefinement aadlSource aadlDest)) ; event\n           false))))\n\n(define-fun isAADLConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (exists ((aadlSource AADLPort) (aadlDest AADLPort))\n    (and\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n      (AADLConnectionFlowTos aadlSource aadlDest))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAADLConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        false))))\n\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/RadioDriver_Impl_MCMP_PROC_SW_RADIO.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\ncomponent RadioDriver_Impl_MCMP_PROC_SW_RADIO {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_SW__Command_Impl_1 sb_recv_map_out0;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\ncomponent FlightPlanner_Impl_MCMP_PROC_SW_FPLN {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_SW__Mission_1 sb_flight_plan0;\n  uses sb_Monitor_bool_1 sb_mission_rcv;\n  uses sb_Monitor_SW__Command_Impl_1 sb_recv_map;\n  consumes QueuedData sb_mission_rcv_notification;\n  consumes QueuedData sb_recv_map_notification;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/WaypointManager_Impl_MCMP_PROC_SW_WPM.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\ncomponent WaypointManager_Impl_MCMP_PROC_SW_WPM {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_SW__Mission_1 sb_flight_plan;\n  uses sb_Monitor_bool_1 sb_mission_rcv0;\n  uses sb_Monitor_SW__MissionWindow_1 sb_mission_window0;\n  uses sb_Monitor_int64_t_1 sb_tracking_id;\n  consumes QueuedData sb_flight_plan_notification;\n  consumes QueuedData sb_tracking_id_notification;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/UARTDriver_Impl_MCMP_PROC_SW_UART.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_1.idl4\";\nimport \"..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\ncomponent UARTDriver_Impl_MCMP_PROC_SW_UART {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_SW__MissionWindow_1 sb_mission_window;\n  uses sb_Monitor_int64_t_1 sb_tracking_id0;\n  consumes QueuedData sb_mission_window_notification;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/sb_FPLN_recv_map_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4\";\ncomponent sb_FPLN_recv_map_Monitor {\n\n  provides sb_Monitor_SW__Command_Impl_1 mon;\n  emits QueuedData monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/sb_WPM_flight_plan_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__Mission_1.idl4\";\ncomponent sb_WPM_flight_plan_Monitor {\n\n  provides sb_Monitor_SW__Mission_1 mon;\n  emits QueuedData monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/sb_FPLN_mission_rcv_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_bool_1.idl4\";\ncomponent sb_FPLN_mission_rcv_Monitor {\n\n  provides sb_Monitor_bool_1 mon;\n  emits QueuedData monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/sb_UART_mission_window_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_SW__MissionWindow_1.idl4\";\ncomponent sb_UART_mission_window_Monitor {\n\n  provides sb_Monitor_SW__MissionWindow_1 mon;\n  emits QueuedData monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/sb_WPM_tracking_id_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_int64_t_1.idl4\";\ncomponent sb_WPM_tracking_id_Monitor {\n\n  provides sb_Monitor_int64_t_1 mon;\n  emits QueuedData monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/UAV_Impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/RadioDriver_Impl_MCMP_PROC_SW_RADIO.camkes\";\nimport \"components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN.camkes\";\nimport \"components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/WaypointManager_Impl_MCMP_PROC_SW_WPM.camkes\";\nimport \"components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/UARTDriver_Impl_MCMP_PROC_SW_UART.camkes\";\nimport \"components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/sb_FPLN_recv_map_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/sb_WPM_flight_plan_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/sb_FPLN_mission_rcv_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_UART_mission_window_Monitor\/sb_UART_mission_window_Monitor.camkes\";\nimport \"components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/sb_WPM_tracking_id_Monitor.camkes\";\n\nassembly {\n  composition {\n    component RadioDriver_Impl_MCMP_PROC_SW_RADIO MCMP_PROC_SW_RADIO;\n    component FlightPlanner_Impl_MCMP_PROC_SW_FPLN MCMP_PROC_SW_FPLN;\n    component WaypointManager_Impl_MCMP_PROC_SW_WPM MCMP_PROC_SW_WPM;\n    component UARTDriver_Impl_MCMP_PROC_SW_UART MCMP_PROC_SW_UART;\n    component sb_FPLN_recv_map_Monitor sb_fpln_recv_map_monitor;\n    component sb_WPM_flight_plan_Monitor sb_wpm_flight_plan_monitor;\n    component sb_FPLN_mission_rcv_Monitor sb_fpln_mission_rcv_monitor;\n    component sb_UART_mission_window_Monitor sb_uart_mission_window_monitor;\n    component sb_WPM_tracking_id_Monitor sb_wpm_tracking_id_monitor;\n\n    connection seL4RPCCall conn1(from MCMP_PROC_SW_RADIO.sb_recv_map_out0, to sb_fpln_recv_map_monitor.mon);\n    connection seL4RPCCall conn2(from MCMP_PROC_SW_FPLN.sb_recv_map, to sb_fpln_recv_map_monitor.mon);\n    connection seL4Notification conn3(from sb_fpln_recv_map_monitor.monsig, to MCMP_PROC_SW_FPLN.sb_recv_map_notification);\n    connection seL4RPCCall conn4(from MCMP_PROC_SW_FPLN.sb_flight_plan0, to sb_wpm_flight_plan_monitor.mon);\n    connection seL4RPCCall conn5(from MCMP_PROC_SW_WPM.sb_flight_plan, to sb_wpm_flight_plan_monitor.mon);\n    connection seL4Notification conn6(from sb_wpm_flight_plan_monitor.monsig, to MCMP_PROC_SW_WPM.sb_flight_plan_notification);\n    connection seL4RPCCall conn7(from MCMP_PROC_SW_WPM.sb_mission_rcv0, to sb_fpln_mission_rcv_monitor.mon);\n    connection seL4RPCCall conn8(from MCMP_PROC_SW_FPLN.sb_mission_rcv, to sb_fpln_mission_rcv_monitor.mon);\n    connection seL4Notification conn9(from sb_fpln_mission_rcv_monitor.monsig, to MCMP_PROC_SW_FPLN.sb_mission_rcv_notification);\n    connection seL4RPCCall conn10(from MCMP_PROC_SW_WPM.sb_mission_window0, to sb_uart_mission_window_monitor.mon);\n    connection seL4RPCCall conn11(from MCMP_PROC_SW_UART.sb_mission_window, to sb_uart_mission_window_monitor.mon);\n    connection seL4Notification conn12(from sb_uart_mission_window_monitor.monsig, to MCMP_PROC_SW_UART.sb_mission_window_notification);\n    connection seL4RPCCall conn13(from MCMP_PROC_SW_UART.sb_tracking_id0, to sb_wpm_tracking_id_monitor.mon);\n    connection seL4RPCCall conn14(from MCMP_PROC_SW_WPM.sb_tracking_id, to sb_wpm_tracking_id_monitor.mon);\n    connection seL4Notification conn15(from sb_wpm_tracking_id_monitor.monsig, to MCMP_PROC_SW_WPM.sb_tracking_id_notification);\n  }\n\n  configuration {\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/radiodriver.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_RadioDriver_Impl.h>\n#include <assert.h>\n\nvoid init(const int64_t * in_arg) {\n\n  printf(\"RDIO: initialise entry point called\\n\");\n\n  SW__Command_Impl command = {\n    .Map = {{ .lat = 0, .longitude = 1, .alt = 2 },\n            { .lat = 1, .longitude = 2, .alt = 3 },\n            { .lat = 2, .longitude = 3, .alt = 4 },\n            { .lat = 3, .longitude = 4, .alt = 5 }},\n      .Pattern = Perimeter,\n      .HMAC = true\n  };\n\n  printf(\"RDIO:> Sending command.\\n\");\n\n  \/\/ send command to FPLN  \n  assert(sb_recv_map_out_enqueue(&command)==true);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/flightplanner.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_FlightPlanner_Impl.h>\n#include <assert.h>\n\nstatic bool missioncommand_sent = false;\n\nvoid init(const int64_t *arg){\n}\n\nvoid printCommand(const SW__Command_Impl * command) {\n  \tprintf(\"  Map     = [\\n\");\n    for(int i = 0; i < 4; i++){\n      SW__Coordinate_Impl c = command->Map[i];\n      printf(\"             %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n    }  \t\n    printf(\"            ]\\n\");\n\t\tprintf(\"  Pattern = %i\\n\", command->Pattern);\n\t\tprintf(\"  HMAC    = %i\\n\", command->HMAC);\n}\n\nvoid recv_map(const SW__Command_Impl * command) {\n\n  \tprintf(\"FPLN:< Command.\\n\");\n  \tprintCommand(command);\n\n  \tif(!missioncommand_sent) {\n\n  \t    \/\/ simulate the creation of a new mission\n  \t\tsb_SW__Mission_container mission = { .f = {{ .lat = 0, .longitude = 1, .alt = 2},\n   \t\t                                           { .lat = 1, .longitude = 2, .alt = 3},\n  \t\t                                           { .lat = 2, .longitude = 3, .alt = 4},\n  \t\t                                           { .lat = 3, .longitude = 4, .alt = 5},\n  \t\t                                           { .lat = 4, .longitude = 5, .alt = 6},\n  \t\t                                           { .lat = 5, .longitude = 6, .alt = 7},\n  \t\t                                           { .lat = 6, .longitude = 7, .alt = 8},\n  \t\t                                           { .lat = 7, .longitude = 8, .alt = 9},\n  \t\t                                           { .lat = 8, .longitude = 9, .alt = 10},\n  \t\t                                           { .lat = 9, .longitude = 10, .alt = 11}}};\n\n  \t\tprintf(\"FPLN:> new mission notification.\\n\");\n\n  \t\t\/\/ send the flight plan to WMP\n  \t\tassert(sb_flight_plan_enqueue(&mission) == true);\n\n    \tmissioncommand_sent = true;\n  \t}\n}\n\nvoid mission_rcv(const bool * value) {\n\tprintf(\"FPLN:< Received mission receipt confirmation: %i.\\n\", *value);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/waypointmanager.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_WaypointManager_Impl.h>\n#include <assert.h>\n#include <string.h>\n\n\nsb_SW__Mission_container _mission;\n\nvoid init(const int64_t * __unused__) {\n}\n\nvoid printMission(const sb_SW__Mission_container * mission){\n  printf(\"  Mission:\\n\");\n  for(int i = 0; i < 10; i++){\n    SW__Coordinate_Impl c = mission->f[i];\n    printf(\"    %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n  }\n}\n\nvoid sendWin(int i) {\n\n  \/\/ simulate creation of new mission windows\n  sb_SW__MissionWindow_container missionWindow = { \n    .f = { _mission.f[i % 10], \n           _mission.f[(i + 1) % 10],\n           _mission.f[(i + 2) % 10],\n           _mission.f[(i + 3) % 10]} \n  };\n\n  \/\/ send mission window to UART  \n  assert(sb_mission_window_enqueue(&missionWindow) == true);\n\n  printf(\"WM:> Sent mission window\\n\");\n}\n\nvoid flight_plan(const sb_SW__Mission_container * mission){\n  printf(\"WM:< Received flight plan\\n\");\n\n  memcpy(&_mission, mission, sizeof(struct sb_SW__Mission_container));\n\n  printMission(&_mission);\n\n  sendWin(0);\n\n  \/\/ send receipt confirmation back to FPLN\n  bool dummy = true;\n  assert(sb_mission_rcv_enqueue(&dummy) == true);\n}\n\nvoid tracking_id(const int64_t * nid) {\n  printf(\"WM:< Received %lu as the next id.\\n\", *nid);\n\n  sendWin(*nid);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/uartdriver.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <sb_types.h>\n#include <sb_UARTDriver_Impl.h>\n#include <assert.h>\n\nstatic int64_t i = 0;\n\nvoid init(const int64_t * in_arg) {\n}\n\nvoid printMissionWindow(const sb_SW__MissionWindow_container * missionWindow){\n  printf(\"  MissionWindow:\\n\");\n  for(int i = 0; i < 4; i++){\n    SW__Coordinate_Impl c = missionWindow->f[i];\n    printf(\"    %i: {%i, %i, %i}\\n\", i, c.lat, c.longitude, c.alt);\n  }\n}\n\nvoid mission_window(const sb_SW__MissionWindow_container * missionWindow){\n  printf(\"UART:< Received mission window\\n\");\n  printMissionWindow(missionWindow);\n\n  for(unsigned int j = 0; j < 100000000; j++){}\n\n  i++;\n\n  printf(\"UART:> Sending %lu as the next id.\\n\", i);\n\n  \/\/ send tracking id to WPM\n  assert(sb_tracking_id_enqueue(&i) == true);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/interfaces\/sb_Monitor_SW__Command_Impl_1.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_SW__Command_Impl_1 {\n  include <sb_types.h>;\n  bool is_empty();\n  bool enqueue(refin SW__Command_Impl m);\n  bool dequeue(out SW__Command_Impl m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/src\/sb_FPLN_recv_map_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_types.h>\n#include <sb_FPLN_recv_map_Monitor.h>\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nSW__Command_Impl contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(SW__Command_Impl * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const SW__Command_Impl * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/includes\/sb_FPLN_recv_map_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_FPLN_RECV_MAP_MONITOR_H\n#define SB_FPLN_RECV_MAP_MONITOR_H\n\n\n#endif \/\/ SB_FPLN_RECV_MAP_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/interfaces\/sb_Monitor_SW__Mission_1.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_SW__Mission_1 {\n  include <sb_types.h>;\n  bool is_empty();\n  bool enqueue(refin sb_SW__Mission_container m);\n  bool dequeue(out sb_SW__Mission_container m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/src\/sb_WPM_flight_plan_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_types.h>\n#include <sb_WPM_flight_plan_Monitor.h>\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nsb_SW__Mission_container contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(sb_SW__Mission_container * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const sb_SW__Mission_container * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/includes\/sb_WPM_flight_plan_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_WPM_FLIGHT_PLAN_MONITOR_H\n#define SB_WPM_FLIGHT_PLAN_MONITOR_H\n\n\n#endif \/\/ SB_WPM_FLIGHT_PLAN_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/interfaces\/sb_Monitor_bool_1.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_bool_1 {\n  include <sb_types.h>;\n  bool is_empty();\n  bool enqueue(refin bool m);\n  bool dequeue(out bool m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/src\/sb_FPLN_mission_rcv_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_types.h>\n#include <sb_FPLN_mission_rcv_Monitor.h>\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nbool contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(bool * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const bool * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/includes\/sb_FPLN_mission_rcv_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_FPLN_MISSION_RCV_MONITOR_H\n#define SB_FPLN_MISSION_RCV_MONITOR_H\n\n\n#endif \/\/ SB_FPLN_MISSION_RCV_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/interfaces\/sb_Monitor_SW__MissionWindow_1.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_SW__MissionWindow_1 {\n  include <sb_types.h>;\n  bool is_empty();\n  bool enqueue(refin sb_SW__MissionWindow_container m);\n  bool dequeue(out sb_SW__MissionWindow_container m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/src\/sb_UART_mission_window_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_types.h>\n#include <sb_UART_mission_window_Monitor.h>\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nsb_SW__MissionWindow_container contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(sb_SW__MissionWindow_container * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const sb_SW__MissionWindow_container * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_UART_mission_window_Monitor\/includes\/sb_UART_mission_window_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_UART_MISSION_WINDOW_MONITOR_H\n#define SB_UART_MISSION_WINDOW_MONITOR_H\n\n\n#endif \/\/ SB_UART_MISSION_WINDOW_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/interfaces\/sb_Monitor_int64_t_1.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_int64_t_1 {\n  include <sb_types.h>;\n  bool is_empty();\n  bool enqueue(refin int64_t m);\n  bool dequeue(out int64_t m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/src\/sb_WPM_tracking_id_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_VERIFY\n#include <stdio.h>\n#endif \/\/ SB_VERIFY\n\n#include <sb_types.h>\n#include <sb_WPM_tracking_id_Monitor.h>\n\nint mon_get_sender_id(void);\nint monsig_emit(void);\n\nint64_t contents[1];\nstatic uint32_t front = 0;\nstatic uint32_t length = 0;\n\nstatic bool is_full(void) {\n  return length == 1;\n}\n\nbool mon_is_empty(void) {\n  return length == 0;\n}\n\nbool mon_dequeue(int64_t * m) {\n  if (mon_is_empty()) {\n    return false;\n  } else {\n    *m = contents[front];\n    front = (front + 1) % 1;\n    length--;\n    return true;\n  }\n}\n\nbool mon_enqueue(const int64_t * m) {\n  if (is_full()) {\n    return false;\n  } else {\n    contents[(front + length) % 1] = *m;\n    length++;\n    monsig_emit();\n    return true;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/includes\/sb_WPM_tracking_id_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_WPM_TRACKING_ID_MONITOR_H\n#define SB_WPM_TRACKING_ID_MONITOR_H\n\n\n#endif \/\/ SB_WPM_TRACKING_ID_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (UAV_Impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(RadioDriver_Impl_MCMP_PROC_SW_RADIO\n  SOURCES components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/\/src\/radiodriver.c components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/sb_RadioDriver_Impl.c\n  INCLUDES components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(FlightPlanner_Impl_MCMP_PROC_SW_FPLN\n  SOURCES components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/\/src\/flightplanner.c components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/sb_FlightPlanner_Impl.c\n  INCLUDES components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(WaypointManager_Impl_MCMP_PROC_SW_WPM\n  SOURCES components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/\/src\/waypointmanager.c components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/sb_WaypointManager_Impl.c\n  INCLUDES components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(UARTDriver_Impl_MCMP_PROC_SW_UART\n  SOURCES components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/\/src\/uartdriver.c components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/sb_UARTDriver_Impl.c\n  INCLUDES components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(sb_FPLN_recv_map_Monitor\n  SOURCES components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/src\/sb_FPLN_recv_map_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_FPLN_recv_map_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(sb_WPM_flight_plan_Monitor\n  SOURCES components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/src\/sb_WPM_flight_plan_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_WPM_flight_plan_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(sb_FPLN_mission_rcv_Monitor\n  SOURCES components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/src\/sb_FPLN_mission_rcv_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_FPLN_mission_rcv_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(sb_UART_mission_window_Monitor\n  SOURCES components\/sb_Monitors\/sb_UART_mission_window_Monitor\/src\/sb_UART_mission_window_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_UART_mission_window_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(sb_WPM_tracking_id_Monitor\n  SOURCES components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/src\/sb_WPM_tracking_id_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_WPM_tracking_id_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESRootserver(UAV_Impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present, CAmkES build directory will not be deleted\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/src\/sb_RadioDriver_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_RadioDriver_Impl.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_recv_map_out_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_recv_map_out_enqueue(const SW__Command_Impl * sb_recv_map_out){\n  bool sb_result = true;\n  sb_result &= sb_recv_map_out0_enqueue((SW__Command_Impl *) sb_recv_map_out);\n  return sb_result;\n}\n\n\/************************************************************************\n *  sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_RadioDriver_Impl_MCMP_PROC_SW_RADIO_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/RadioDriver_Impl_MCMP_PROC_SW_RADIO\/includes\/sb_RadioDriver_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_RADIODRIVER_IMPL_H\n#define SB_RADIODRIVER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_recv_map_out_enqueue(const SW__Command_Impl * sb_recv_map_out);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_RADIODRIVER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/src\/sb_FlightPlanner_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_FlightPlanner_Impl.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_flight_plan_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container * sb_flight_plan){\n  bool sb_result = true;\n  sb_result &= sb_flight_plan0_enqueue((sb_SW__Mission_container *) sb_flight_plan);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_mission_rcv_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * mission_rcv\n *\n ************************************************************************\/\nstatic void sb_mission_rcv_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_FlightPlanner_Impl_mission_rcv:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_mission_rcv(const bool * in_arg) {\n  mission_rcv((bool *) in_arg);\n}\n\n\/************************************************************************\n * sb_recv_map_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * recv_map\n *\n ************************************************************************\/\nstatic void sb_recv_map_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_FlightPlanner_Impl_recv_map:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_recv_map(const SW__Command_Impl * in_arg) {\n  recv_map((SW__Command_Impl *) in_arg);\n}\n\n\/************************************************************************\n *  sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port mission_rcv\n  CALLBACKOP(sb_mission_rcv_notification_reg_callback(sb_mission_rcv_notification_handler, NULL));\n\n  \/\/ register callback for EventDataPort port recv_map\n  CALLBACKOP(sb_recv_map_notification_reg_callback(sb_recv_map_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  bool sb_mission_rcv;\n  SW__Command_Impl sb_recv_map;\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_FlightPlanner_Impl_MCMP_PROC_SW_FPLN_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    while (sb_mission_rcv_dequeue((bool *) &sb_mission_rcv)) {\n      sb_entrypoint_FlightPlanner_Impl_mission_rcv(&sb_mission_rcv);\n    }\n    while (sb_recv_map_dequeue((SW__Command_Impl *) &sb_recv_map)) {\n      sb_entrypoint_FlightPlanner_Impl_recv_map(&sb_recv_map);\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/FlightPlanner_Impl_MCMP_PROC_SW_FPLN\/includes\/sb_FlightPlanner_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_FLIGHTPLANNER_IMPL_H\n#define SB_FLIGHTPLANNER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_flight_plan_enqueue(const sb_SW__Mission_container * sb_flight_plan);\n\nbool sb_mission_rcv_dequeue(bool * sb_mission_rcv);\n\nvoid mission_rcv(const bool * in_arg);\n\nbool sb_recv_map_dequeue(SW__Command_Impl * sb_recv_map);\n\nvoid recv_map(const SW__Command_Impl * in_arg);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_FLIGHTPLANNER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/src\/sb_WaypointManager_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_WaypointManager_Impl.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_flight_plan_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * flight_plan\n *\n ************************************************************************\/\nstatic void sb_flight_plan_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_WaypointManager_Impl_flight_plan:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_flight_plan(const sb_SW__Mission_container * in_arg) {\n  flight_plan((sb_SW__Mission_container *) in_arg);\n}\n\n\/************************************************************************\n * sb_mission_rcv_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_mission_rcv_enqueue(const bool * sb_mission_rcv){\n  bool sb_result = true;\n  sb_result &= sb_mission_rcv0_enqueue((bool *) sb_mission_rcv);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_mission_window_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container * sb_mission_window){\n  bool sb_result = true;\n  sb_result &= sb_mission_window0_enqueue((sb_SW__MissionWindow_container *) sb_mission_window);\n  return sb_result;\n}\n\n\/************************************************************************\n * sb_tracking_id_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * tracking_id\n *\n ************************************************************************\/\nstatic void sb_tracking_id_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_WaypointManager_Impl_tracking_id:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_tracking_id(const int64_t * in_arg) {\n  tracking_id((int64_t *) in_arg);\n}\n\n\/************************************************************************\n *  sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port flight_plan\n  CALLBACKOP(sb_flight_plan_notification_reg_callback(sb_flight_plan_notification_handler, NULL));\n\n  \/\/ register callback for EventDataPort port tracking_id\n  CALLBACKOP(sb_tracking_id_notification_reg_callback(sb_tracking_id_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  sb_SW__Mission_container sb_flight_plan;\n  int64_t sb_tracking_id;\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_WaypointManager_Impl_MCMP_PROC_SW_WPM_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    while (sb_flight_plan_dequeue((sb_SW__Mission_container *) &sb_flight_plan)) {\n      sb_entrypoint_WaypointManager_Impl_flight_plan(&sb_flight_plan);\n    }\n    while (sb_tracking_id_dequeue((int64_t *) &sb_tracking_id)) {\n      sb_entrypoint_WaypointManager_Impl_tracking_id(&sb_tracking_id);\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/WaypointManager_Impl_MCMP_PROC_SW_WPM\/includes\/sb_WaypointManager_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_WAYPOINTMANAGER_IMPL_H\n#define SB_WAYPOINTMANAGER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_flight_plan_dequeue(sb_SW__Mission_container * sb_flight_plan);\n\nvoid flight_plan(const sb_SW__Mission_container * in_arg);\n\nbool sb_mission_rcv_enqueue(const bool * sb_mission_rcv);\n\nbool sb_mission_window_enqueue(const sb_SW__MissionWindow_container * sb_mission_window);\n\nbool sb_tracking_id_dequeue(int64_t * sb_tracking_id);\n\nvoid tracking_id(const int64_t * in_arg);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_WAYPOINTMANAGER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/src\/sb_UARTDriver_Impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_UARTDriver_Impl.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_mission_window_notification_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * mission_window\n *\n ************************************************************************\/\nstatic void sb_mission_window_notification_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n}\n\n\/************************************************************************\n * sb_entrypoint_UARTDriver_Impl_mission_window:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_UARTDriver_Impl_mission_window(const sb_SW__MissionWindow_container * in_arg) {\n  mission_window((sb_SW__MissionWindow_container *) in_arg);\n}\n\n\/************************************************************************\n * sb_tracking_id_enqueue:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote event data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_tracking_id_enqueue(const int64_t * sb_tracking_id){\n  bool sb_result = true;\n  sb_result &= sb_tracking_id0_enqueue((int64_t *) sb_tracking_id);\n  return sb_result;\n}\n\n\/************************************************************************\n *  sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer(const int64_t * in_arg) {\n  init((int64_t *) in_arg);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventDataPort port mission_window\n  CALLBACKOP(sb_mission_window_notification_reg_callback(sb_mission_window_notification_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  sb_SW__MissionWindow_container sb_mission_window;\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_UARTDriver_Impl_MCMP_PROC_SW_UART_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    while (sb_mission_window_dequeue((sb_SW__MissionWindow_container *) &sb_mission_window)) {\n      sb_entrypoint_UARTDriver_Impl_mission_window(&sb_mission_window);\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/components\/UARTDriver_Impl_MCMP_PROC_SW_UART\/includes\/sb_UARTDriver_Impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_UARTDRIVER_IMPL_H\n#define SB_UARTDRIVER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_mission_window_dequeue(sb_SW__MissionWindow_container * sb_mission_window);\n\nvoid mission_window(const sb_SW__MissionWindow_container * in_arg);\n\nbool sb_tracking_id_enqueue(const int64_t * sb_tracking_id);\n\nvoid init(const int64_t *arg);\n\n#endif \/\/ SB_UARTDRIVER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef\n  struct MC__MISSING_TYPE_Impl {\n    int32_t MISSING;\n  } MC__MISSING_TYPE_Impl;\n\ntypedef\n  enum {ZigZag, StraightLine, Perimeter} SW__FlightPattern;\n\ntypedef\n  struct SW__Coordinate_Impl {\n    int32_t lat;\n    int32_t longitude;\n    int32_t alt;\n  } SW__Coordinate_Impl;\n\ntypedef SW__Coordinate_Impl SW__Map [4];\n\ntypedef\n  struct sb_SW__Map_container {\n    SW__Map f;\n  } sb_SW__Map_container;\n\ntypedef\n  struct SW__Command_Impl {\n    SW__Map Map;\n    SW__FlightPattern Pattern;\n    bool HMAC;\n  } SW__Command_Impl;\n\ntypedef SW__Coordinate_Impl SW__Mission [10];\n\ntypedef\n  struct sb_SW__Mission_container {\n    SW__Mission f;\n  } sb_SW__Mission_container;\n\ntypedef SW__Coordinate_Impl SW__MissionWindow [4];\n\ntypedef\n  struct sb_SW__MissionWindow_container {\n    SW__MissionWindow f;\n  } sb_SW__MissionWindow_container;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "simple_uav--SeL4_TB\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            INTERFACE\n            )\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           INTERFACE\n                           includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}