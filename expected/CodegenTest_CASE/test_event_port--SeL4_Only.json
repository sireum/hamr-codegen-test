{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "test_event_port--SeL4_Only\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n\n(declare-datatypes ((ComponentType 0)) ((\n  (AadlComponent)\n  (AadlVMComponent)\n  (PacerComponent)\n  (PeriodicDispatcher))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic)\n  (UNSPECIFIED_DISPATCH_PROTOCOL))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out))))\n\n(declare-datatypes ((PortType 0)) ((\n  (AadlDataPort)\n  (AadlEventPort)\n  (AadlEventDataPort))))\n\n; 2 AADLComponent\n(declare-datatypes ((AADLComponent 0)) ((\n  (top_impl_Instance_test_event_port_src); Instance of test_event_port::emitter.impl declared at \/test_event_port\/test_event_port.aadl (43, 4)\n  (top_impl_Instance_test_event_port_snk); Instance of test_event_port::consumer.impl declared at \/test_event_port\/test_event_port.aadl (44, 4)\n)))\n\n; 2 AADLDispatchProtocol\n(declare-const AADLDispatchProtocol (Array AADLComponent DispatchProtocol))\n(assert (= Sporadic (select AADLDispatchProtocol top_impl_Instance_test_event_port_src)))\n(assert (= Sporadic (select AADLDispatchProtocol top_impl_Instance_test_event_port_snk)))\n\n; 2 altAADLDispatchProtocol\n(define-fun altAADLDispatchProtocol ((_comp AADLComponent)) DispatchProtocol\n  (ite (= _comp top_impl_Instance_test_event_port_src) Sporadic\n  (ite (= _comp top_impl_Instance_test_event_port_snk) Sporadic\n  UNSPECIFIED_DISPATCH_PROTOCOL)))\n\n; 2 AADLPort\n(declare-datatypes ((AADLPort 0)) ((\n  (top_impl_Instance_test_event_port_src_e)\n  (top_impl_Instance_test_event_port_snk_s))))\n\n; 2 AADLPortComponent\n(declare-const AADLPortComponent (Array AADLPort AADLComponent))\n(assert (= top_impl_Instance_test_event_port_src (select AADLPortComponent top_impl_Instance_test_event_port_src_e)))\n(assert (= top_impl_Instance_test_event_port_snk (select AADLPortComponent top_impl_Instance_test_event_port_snk_s)))\n\n; 2 AADLPortType\n(declare-const AADLPortType (Array AADLPort PortType))\n(assert (= AadlEventPort (select AADLPortType top_impl_Instance_test_event_port_src_e)))\n(assert (= AadlEventPort (select AADLPortType top_impl_Instance_test_event_port_snk_s)))\n\n; 2 AADLPortDirection\n(declare-const AADLPortDirection (Array AADLPort Direction))\n(assert (= Out (select AADLPortDirection top_impl_Instance_test_event_port_src_e)))\n(assert (= In (select AADLPortDirection top_impl_Instance_test_event_port_snk_s)))\n\n; 1 AADLConnectionFlowTos\n(define-fun AADLConnectionFlowTos ((p1 AADLPort) (p2 AADLPort)) Bool\n  (or\n    (and (= p1 top_impl_Instance_test_event_port_src_e) (= p2 top_impl_Instance_test_event_port_snk_s))\n    false)\n)\n\n\n(declare-datatypes ((seL4PortType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n; 2 CAmkESComponent\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (test_event_port_src)\n  (test_event_port_snk)\n)))\n\n; 4 CAmkESPort\n(declare-datatypes ((CAmkESPort 0)) ((\n  (test_event_port_src_sb_e)\n  (test_event_port_src_sb_e_counter)\n  (test_event_port_snk_sb_s)\n  (test_event_port_snk_sb_s_counter)\n)))\n\n; 2 CAmkESConnection\n(declare-datatypes ((CAmkESConnection 0)) ((\n  (conn1)\n  (conn2)\n)))\n\n; 2 CAmkESConnectionType\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4PortType))\n(assert (= seL4Notification (select CAmkESConnectionType conn1)))\n(assert (= seL4SharedData (select CAmkESConnectionType conn2)))\n\n; 4 CAmkESPortComponent\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n(assert (= test_event_port_src (select CAmkESPortComponent test_event_port_src_sb_e)))\n(assert (= test_event_port_src (select CAmkESPortComponent test_event_port_src_sb_e_counter)))\n(assert (= test_event_port_snk (select CAmkESPortComponent test_event_port_snk_sb_s)))\n(assert (= test_event_port_snk (select CAmkESPortComponent test_event_port_snk_sb_s_counter)))\n\n; 2 CAmkESConnectionFlowTos\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    (and (= _conn conn1) (= _p1 test_event_port_src_sb_e) (= _p2 test_event_port_snk_sb_s))\n    (and (= _conn conn2) (= _p1 test_event_port_src_sb_e_counter) (= _p2 test_event_port_snk_sb_s_counter))\n    false))\n\n\n; 2 ComponentRefinement\n(define-fun ComponentRefinement ((ac AADLComponent) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac top_impl_Instance_test_event_port_src) (= cc test_event_port_src))\n    (and (= ac top_impl_Instance_test_event_port_snk) (= cc test_event_port_snk))\n    false))\n\n; 4 PortRefinement\n(define-fun PortRefinement ((ap AADLPort) (cp CAmkESPort)) Bool\n  (or\n    (and (= ap top_impl_Instance_test_event_port_src_e) (= cp test_event_port_src_sb_e))\n    (and (= ap top_impl_Instance_test_event_port_src_e) (= cp test_event_port_src_sb_e_counter))\n    (and (= ap top_impl_Instance_test_event_port_snk_s) (= cp test_event_port_snk_sb_s))\n    (and (= ap top_impl_Instance_test_event_port_snk_s) (= cp test_event_port_snk_sb_s_counter))\n    false))\n\n\n(define-fun AADLFlowDirectionality () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (and (= Out (select AADLPortDirection p1)) (= In (select AADLPortDirection p2))))))\n\n(define-fun AADLFlowNoSelfConnection () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AADLConnectedPortTypeMatch () Bool\n  (forall ((src AADLPort) (dst AADLPort))\n    (=> (AADLConnectionFlowTos src dst)\n        (or\n          (and (= AadlDataPort (select AADLPortType src)) (= AadlDataPort (select AADLPortType dst)))(and (= AadlEventPort (select AADLPortType src)) (= AadlEventPort (select AADLPortType dst)))(and (= AadlEventDataPort (select AADLPortType src)) (= AadlEventDataPort (select AADLPortType dst)))\n          false))))\n\n(define-fun AADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (select AADLDispatchProtocol _comp)))))\n\n(define-fun altAADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (altAADLDispatchProtocol _comp)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    altAADLDispatchProtocolSpecified\n    AADLDispatchProtocolSpecified\n    AADLFlowDirectionality\n    AADLFlowNoSelfConnection\n    AADLConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AADLComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement aadlComponent1 camkesComponent)\n        (not (exists ((aadlComponent2 AADLComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement aadlComponent2 camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AADLPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AADLPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    CAmkESFlowNoSelfConnection))\n\n(define-fun DataPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) seL4SharedData )\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun EventPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) seL4Notification )\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AADLPort) (aadlDest AADLPort))\n    (=> (AADLConnectionFlowTos aadlSource aadlDest)\n        (or\n          (and\n               (= AadlDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)) ; payload\n          (and\n               (= AadlEventPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; event counter\n               (EventPortRefinement aadlSource aadlDest)) ; event\n          (and\n               (= AadlEventDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; payload\n               (EventPortRefinement aadlSource aadlDest)) ; event\n           false))))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n        (exists ((aadlSource AADLPort) (aadlDest AADLPort))\n          (and\n            (PortRefinement aadlSource camkesSource)\n            (PortRefinement aadlDest camkesDest)\n            (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n            (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n            (AADLConnectionFlowTos aadlSource aadlDest))))))\n\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/emitter_impl_test_event_port_src\/emitter_impl_test_event_port_src.camkes",
        {
          "type" : "ITestResource",
          "content" : "component emitter_impl_test_event_port_src {\n  include <sb_types.h>;\n  include <sb_event_counter.h>;\n  control;\n  emits ReceiveEvent sb_e;\n  dataport sb_event_counter_t sb_e_counter;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/consumer_impl_test_event_port_snk\/consumer_impl_test_event_port_snk.camkes",
        {
          "type" : "ITestResource",
          "content" : "component consumer_impl_test_event_port_snk {\n  include <sb_types.h>;\n  include <sb_event_counter.h>;\n  control;\n  consumes ReceiveEvent sb_s;\n  dataport sb_event_counter_t sb_s_counter;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/top_impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/emitter_impl_test_event_port_src\/emitter_impl_test_event_port_src.camkes\";\nimport \"components\/consumer_impl_test_event_port_snk\/consumer_impl_test_event_port_snk.camkes\";\n\nassembly {\n  composition {\n    component emitter_impl_test_event_port_src test_event_port_src;\n    component consumer_impl_test_event_port_snk test_event_port_snk;\n\n    connection seL4Notification conn1(from test_event_port_src.sb_e, to test_event_port_snk.sb_s);\n    connection seL4SharedData conn2(from test_event_port_src.sb_e_counter, to test_event_port_snk.sb_s_counter);\n  }\n\n  configuration {\n    test_event_port_src.sb_e_counter_access = \"W\";\n    test_event_port_snk.sb_s_counter_access = \"R\";\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/emitter_impl_test_event_port_src\/src\/emitter.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <stdio.h>\n#include <sb_emitter_impl.h>\n\nvoid test_event_port_emitter_component_init(const int64_t *in_arg) {\n  printf(\"[%s] test_event_port_emitter_component_init called\\n\", get_instance_name());\n}\n\nvoid run_emitter(const int64_t *in_arg) {\n  printf(\"---------------------------------------\\n\");\n  sb_e_enqueue();\n  printf(\"[%s] Sent event.\\n\", get_instance_name());\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/consumer_impl_test_event_port_snk\/src\/consumer.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <stdio.h>\n#include <sb_consumer_impl.h>\n\nstatic int8_t _value;\n\nvoid test_event_port_consumer_component_init(const int64_t *in_arg) {\n  printf(\"[%s] test_event_port_consumer_component_init called\\n\", get_instance_name());\n  _value = 0;\n}\n\nvoid test_event_port_consumer_s_event_handler() {\n  int8_t old_value = _value;\n  while(sb_s_dequeue()) {\n    _value = (_value + 1) % 500;\n  }\n\n  printf(\"[%s] Callback fired.  Received %i events this dispatch, %i total\\n\", get_instance_name(), (_value - old_value), _value);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (top_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(emitter_impl_test_event_port_src\n  SOURCES components\/emitter_impl_test_event_port_src\/\/src\/emitter.c components\/emitter_impl_test_event_port_src\/src\/sb_emitter_impl.c\n  INCLUDES components\/emitter_impl_test_event_port_src\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(consumer_impl_test_event_port_snk\n  SOURCES components\/consumer_impl_test_event_port_snk\/\/src\/consumer.c components\/consumer_impl_test_event_port_snk\/src\/sb_consumer_impl.c\n  INCLUDES components\/consumer_impl_test_event_port_snk\/includes\/ types\/includes\n)\n\nDeclareCAmkESRootserver(top_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present, CAmkES build directory will not be deleted\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/emitter_impl_test_event_port_src\/src\/sb_emitter_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_emitter_impl.h>\n#include <sb_event_counter.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n * sb_e_enqueue\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to send to a remote event port.\n *\n ************************************************************************\/\nbool sb_e_enqueue(void) {\n  \/\/ sb_e_counter is a dataport (shared memory) that is written by the sender\n  \/\/ and read by the receiver(s). This counter is monotonicly increasing,\n  \/\/ but can wrap.\n  (*sb_e_counter)++;\n\n  \/\/ Release memory fence - ensure subsequent write occurs after any preceeding read or write\n  sb_e_counter_release();\n\n  sb_e_emit();\n\n  return true;\n}\n\n\n\/************************************************************************\n *  sb_entrypoint_emitter_impl_test_event_port_src_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_emitter_impl_test_event_port_src_initializer(const int64_t * in_arg) {\n  test_event_port_emitter_component_init((int64_t *) in_arg);\n}\n\nvoid pre_init(void) {\n  \/\/ initialise shared counter for event port e\n  *sb_e_counter = 0;\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_emitter_impl_test_event_port_src_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/emitter_impl_test_event_port_src\/includes\/sb_emitter_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_EMITTER_IMPL_H\n#define SB_EMITTER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_e_enqueue(void);\n\nvoid test_event_port_emitter_component_init(const int64_t *arg);\n\n#endif \/\/ SB_EMITTER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/consumer_impl_test_event_port_snk\/src\/sb_consumer_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_consumer_impl.h>\n#include <sb_event_counter.h>\n#include <string.h>\n#include <camkes.h>\n\n\/************************************************************************\n *\n * Static variables and queue management functions for event port:\n *     s\n *\n ************************************************************************\/\nstatic sb_event_counter_t sb_s_received_events = 0;\nstatic sb_event_counter_t sb_s_last_counter = 0;\n\n\/************************************************************************\n * sb_s_dequeue:\n * Invoked from local active thread.\n *\n * This is the function invoked by the active thread to decrement the\n * input event index.\n *\n ************************************************************************\/\nbool sb_s_dequeue() {\n  if(sb_s_received_events > 0) {\n    sb_s_received_events--;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\/************************************************************************\n * sb_s_is_empty;\n *\n * Helper method to determine if infrastructure port has not received\n * any new events since the last dispatch\n *\n ************************************************************************\/\nbool sb_s_is_empty() {\n  return sb_s_received_events == 0;\n}\n\nvoid sb_freeze_event_port_s() {\n  sb_event_counter_t current_sb_s_counter;\n\n  sb_s_received_events = 0; \/\/ drop any events not handled during last dispatch\n\n  \/\/ get current shared counter value\n  current_sb_s_counter = *sb_s_counter;\n\n  \/\/ Acquire memory fence - ensure preceding read occurs before any subsequent read or write\n  sb_s_counter_acquire();\n\n  \/\/ NOTE: Counters can wrap, so we must use != below instead of >\n  while(current_sb_s_counter != sb_s_last_counter){\n    sb_s_last_counter++;\n    sb_s_received_events++;\n  }\n\n  if(sb_s_received_events > 0) {\n\n    \/\/ s's queue size is 1\n    if(sb_s_received_events > 1) {\n      \/\/printf(\"consumer_impl: dropping %i event(s) from incoming event port s\\n\", (sb_s_received_events - 1));\n\n      \/\/ drop events\n      sb_s_received_events = 1;\n    }\n  }\n}\n\n\/************************************************************************\n * sb_s_handler:\n * Invoked by: seL4 notification callback\n *\n * This is the function invoked by an seL4 notification callback to \n * dispatch the component due to the arrival of an event on port\n * s\n *\n ************************************************************************\/\nstatic void sb_s_handler(void * unused) {\n  MUTEXOP(sb_dispatch_sem_post())\n  CALLBACKOP(sb_s_reg_callback(sb_s_handler, NULL));\n}\n\n\n\/************************************************************************\n *  sb_entrypoint_consumer_impl_s\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_consumer_impl_s(void){\n  test_event_port_consumer_s_event_handler();\n}\n\n\/************************************************************************\n *  sb_entrypoint_consumer_impl_test_event_port_snk_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_consumer_impl_test_event_port_snk_initializer(const int64_t * in_arg) {\n  test_event_port_consumer_component_init((int64_t *) in_arg);\n}\n\nvoid post_init(void) {\n  \/\/ register callback for EventPort port s\n  CALLBACKOP(sb_s_reg_callback(sb_s_handler, NULL));\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_consumer_impl_test_event_port_snk_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    sb_freeze_event_port_s();\n\n    {\n      if(sb_s_received_events > 0) {\n        \/\/ dequeue one event and call the event handler\n        sb_s_dequeue();\n        sb_entrypoint_consumer_impl_s();\n      }\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/components\/consumer_impl_test_event_port_snk\/includes\/sb_consumer_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CONSUMER_IMPL_H\n#define SB_CONSUMER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_s_dequeue(void);\n\nvoid test_event_port_consumer_s_event_handler(void);\n\nvoid test_event_port_consumer_component_init(const int64_t *arg);\n\n#endif \/\/ SB_CONSUMER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/types\/includes\/sb_event_counter.h",
        {
          "type" : "ITestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_event_port--SeL4_Only\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            INTERFACE\n            )\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           INTERFACE\n                           includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}