{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "VPM_ben--Linux\/src\/main\/data\/VPM_ben__Linux\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = { return F }\n\n  def Integer_example(): Integer = { return z\"0\" }\n\n  def Integer_8_example(): Integer_8 = { return s8\"0\" }\n  def Integer_16_example(): Integer_16 = { return s16\"0\" }\n  def Integer_32_example(): Integer_32 = { return s32\"0\" }\n  def Integer_64_example(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_example(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_example(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_example(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_example(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_example(): Float = { return r\"0\" }\n  def Float_32_example(): Float_32 = { return f32\"0\" }\n  def Float_64_example(): Float_64 = { return f64\"0\" }\n\n  def Character_example(): Character = { return ' ' }\n  def String_example(): String = { return \"\" }\n\n  def Bits_example(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/architecture\/VPM_ben__Linux\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager : VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge = {\n    val AttestationRequest = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationRequest\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationResponse\", mode = EventIn)\n    val TrustedIds = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TrustedIds\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_InitiateAttestation\", mode = EventIn)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TerminateAttestation\", mode = EventOut)\n\n    VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AttestationRequest = AttestationRequest,\n      AttestationResponse = AttestationResponse,\n      TrustedIds = TrustedIds,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate : VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge = {\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 5, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 6, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 7, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_In\", mode = EventIn)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 8, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_Out\", mode = EventOut)\n    val TrustedIds = Port[Base_Types.Bits] (id = 9, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_TrustedIds\", mode = EventIn)\n\n    VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge(\n      id = 1,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In,\n      Connection_Command_Out = Connection_Command_Out,\n      TrustedIds = TrustedIds\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1 : VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 10, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 11, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Suspect_Traffic_Out\", mode = EventOut)\n\n    VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge(\n      id = 2,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2 : VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 12, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 13, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Suspect_Traffic_Out\", mode = EventOut)\n\n    VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge(\n      id = 3,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low : VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge = {\n    val ADSB_Messages_In = Port[Base_Types.Bits] (id = 14, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_ADSB_Messages_In\", mode = EventIn)\n    val Response_In = Port[Base_Types.Bits] (id = 15, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Response_In\", mode = EventIn)\n    val AttestationRequest = Port[Base_Types.Bits] (id = 16, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationRequest\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Heartbeat_Out = Port[Base_Types.Bits] (id = 17, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Heartbeat_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Ownship_Out = Port[Base_Types.Bits] (id = 18, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Ownship_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Traffic_Out = Port[Base_Types.Bits] (id = 19, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Traffic_Out\", mode = EventOut)\n    val SHM_QUEUE_Response_Out = Port[Base_Types.Bits] (id = 20, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Response_Out\", mode = EventOut)\n    val SHM_QUEUE_AttestationRequest = Port[Base_Types.Bits] (id = 21, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationRequest\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 22, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_HEADER_adsb_to_ptab\", mode = EventIn)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 23, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_In\", mode = EventIn)\n    val Suspect_Traffic_In1 = Port[Base_Types.Bits] (id = 24, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In1\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out1 = Port[Base_Types.Bits] (id = 25, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out1\", mode = EventOut)\n    val Suspect_Traffic_In2 = Port[Base_Types.Bits] (id = 26, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In2\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out2 = Port[Base_Types.Bits] (id = 27, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out2\", mode = EventOut)\n    val Suspect_Traffic_In3 = Port[Base_Types.Bits] (id = 28, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In3\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out3 = Port[Base_Types.Bits] (id = 29, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out3\", mode = EventOut)\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 30, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_AttestationResponse = Port[Base_Types.Bits] (id = 31, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationResponse\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 32, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 33, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationResponse\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 34, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_Out\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 35, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_InitiateAttestation\", mode = EventOut)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 36, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_TerminateAttestation\", mode = EventIn)\n\n    VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge(\n      id = 4,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      ADSB_Messages_In = ADSB_Messages_In,\n      Response_In = Response_In,\n      AttestationRequest = AttestationRequest,\n      SHM_QUEUE_ADSB_Heartbeat_Out = SHM_QUEUE_ADSB_Heartbeat_Out,\n      SHM_QUEUE_ADSB_Ownship_Out = SHM_QUEUE_ADSB_Ownship_Out,\n      SHM_QUEUE_ADSB_Traffic_Out = SHM_QUEUE_ADSB_Traffic_Out,\n      SHM_QUEUE_Response_Out = SHM_QUEUE_Response_Out,\n      SHM_QUEUE_AttestationRequest = SHM_QUEUE_AttestationRequest,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_In = Connection_Command_In,\n      Suspect_Traffic_In1 = Suspect_Traffic_In1,\n      SHM_QUEUE_Suspect_Traffic_Out1 = SHM_QUEUE_Suspect_Traffic_Out1,\n      Suspect_Traffic_In2 = Suspect_Traffic_In2,\n      SHM_QUEUE_Suspect_Traffic_Out2 = SHM_QUEUE_Suspect_Traffic_Out2,\n      Suspect_Traffic_In3 = Suspect_Traffic_In3,\n      SHM_QUEUE_Suspect_Traffic_Out3 = SHM_QUEUE_Suspect_Traffic_Out3,\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_AttestationResponse = SHM_QUEUE_AttestationResponse,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      AttestationResponse = AttestationResponse,\n      Connection_Command_Out = Connection_Command_Out,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high : VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge = {\n    val SHM_QUEUE_ADSB_Heartbeat_In = Port[Base_Types.Bits] (id = 37, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Heartbeat_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Ownship_In = Port[Base_Types.Bits] (id = 38, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Ownship_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Traffic_In = Port[Base_Types.Bits] (id = 39, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Traffic_In\", mode = EventIn)\n    val SHM_QUEUE_Response_In = Port[Base_Types.Bits] (id = 40, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Response_In\", mode = EventIn)\n    val Response_Out = Port[Base_Types.Bits] (id = 41, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Response_Out\", mode = EventOut)\n    val ADSB_Messages_Out = Port[Base_Types.Bits] (id = 42, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_ADSB_Messages_Out\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 43, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_HEADER_adsb_to_ptab\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 44, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_Out\", mode = EventOut)\n    val Request_In = Port[Base_Types.Bits] (id = 45, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 46, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 47, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_In\", mode = EventIn)\n\n    VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge(\n      id = 5,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high\",\n      dispatchProtocol = Periodic(period = 250),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_ADSB_Heartbeat_In = SHM_QUEUE_ADSB_Heartbeat_In,\n      SHM_QUEUE_ADSB_Ownship_In = SHM_QUEUE_ADSB_Ownship_In,\n      SHM_QUEUE_ADSB_Traffic_In = SHM_QUEUE_ADSB_Traffic_In,\n      SHM_QUEUE_Response_In = SHM_QUEUE_Response_In,\n      Response_Out = Response_Out,\n      ADSB_Messages_Out = ADSB_Messages_Out,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_Out = Connection_Command_Out,\n      Request_In = Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3 : VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 48, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 49, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Suspect_Traffic_Out\", mode = EventOut)\n\n    VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge(\n      id = 6,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n    TranspilerUtil.touch()\n\n    ArchitectureDescription(\n      components = ISZ (VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager, VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate, VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1, VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2, VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low, VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high, VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3),\n\n      connections = ISZ (Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationRequest, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationRequest),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TrustedIds, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.TrustedIds),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TerminateAttestation, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.TerminateAttestation),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Request_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In1),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In2),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_Request_Out, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationResponse, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationResponse),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.InitiateAttestation, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.InitiateAttestation),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Response_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Response_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.ADSB_Messages_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_HEADER_adsb_to_ptab, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_HEADER_adsb_to_ptab),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In3))\n    )\n  }\n}\n\nobject TranspilerUtil {\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch process\/thread timing properties\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_A1_Basecard_application_proc_Core0_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_timingProperties)\n      println(Schedulers.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_timingProperties)\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      {\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_AttestationRequest(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_AttestationRequest(Base_Types.Bits_example())\n        val apiUsage_AttestationResponse: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_AttestationResponse()\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TrustedIds(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TrustedIds(Base_Types.Bits_example())\n        val apiUsage_InitiateAttestation: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_InitiateAttestation()\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n      }\n      {\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_Connection_Command_In()\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        val apiUsage_TrustedIds: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_TrustedIds()\n      }\n      {\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.get_Observed()\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      }\n      {\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.get_Observed()\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      }\n      {\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_ADSB_Messages_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_ADSB_Messages_In()\n        val apiUsage_Response_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Response_In()\n        val apiUsage_AttestationRequest: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_AttestationRequest()\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n        val apiUsage_SHM_HEADER_adsb_to_ptab: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_HEADER_adsb_to_ptab()\n        val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Connection_Command_In()\n        val apiUsage_Suspect_Traffic_In1: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In1()\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n        val apiUsage_Suspect_Traffic_In2: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In2()\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n        val apiUsage_Suspect_Traffic_In3: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In3()\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n        val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n        val apiUsage_SHM_QUEUE_AttestationResponse: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_AttestationResponse()\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_AttestationResponse(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_AttestationResponse(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n        val apiUsage_TerminateAttestation: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_TerminateAttestation()\n      }\n      {\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_SHM_QUEUE_ADSB_Heartbeat_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Heartbeat_In()\n        val apiUsage_SHM_QUEUE_ADSB_Ownship_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Ownship_In()\n        val apiUsage_SHM_QUEUE_ADSB_Traffic_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Traffic_In()\n        val apiUsage_SHM_QUEUE_Response_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_Response_In()\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Response_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Response_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n        val apiUsage_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Request_In()\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n        val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Connection_Command_In()\n      }\n      {\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logError(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logInfo(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logDebug(\"\")\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logError(\"\")\n        val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.get_Observed()\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n        VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/architecture\/VPM_ben__Linux\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject Demo extends App {\n\n  \/** @return the scheduler to use for JVM based simulation as well as the 'default' scheduler\n    *         that will be used when taking this program down to C\/Linux.  Refer to\n    *         'bin\/run.sh -h' if you want to use a specific scheduler for C.  If the scheduler\n    *         accepts a schedule and you want to provide that in C then just pass None()\n    *\n    *         If you want to use the legacy scheduler for C then you must use\n    *           bin\/transpile.cmd --legacy\n    *           bin\/compile.cmd\n    *           bin\/run.sh --legacy\n    *\/\n  def defaultScheduler(): Scheduler = {\n    return Schedulers.getRoundRobinScheduler(None())\n  }\n\n  def main(args: ISZ[String]): Z = {\n    Cli(' ').parseRun(args, 0) match {\n      case Some(o: Cli.RunOption) =>\n        val scheduler: Scheduler = o.scheduler match {\n          case Cli.RunChoice.Default => defaultScheduler()\n          case Cli.RunChoice.RoundRobin => Schedulers.getRoundRobinScheduler(None())\n          case Cli.RunChoice.Static => Schedulers.getStaticScheduler(None())\n          case Cli.RunChoice.Legacy => Schedulers.getLegacyScheduler()\n        }\n        art.Art.run(Arch.ad, scheduler)\n      case Some(o: Cli.HelpOption) =>\n      case _ => return 1\n    }\n    return 0\n  }\n}\n\nobject Cli {\n\n  @datatype trait RunTopOption\n\n  @datatype class HelpOption extends RunTopOption\n\n  @enum object RunChoice {\n    'Default\n    'RoundRobin\n    'Static\n    'Legacy\n  }\n\n  @datatype class RunOption(\n                             val help: String,\n                             val args: ISZ[String],\n                             val scheduler: RunChoice.Type\n                           ) extends RunTopOption\n}\n\nimport Cli._\n\n@record class Cli(val pathSep: C) {\n\n  def parseRunChoiceH(arg: String): Option[RunChoice.Type] = {\n    arg match {\n      case \"default\" => return Some(RunChoice.Default)\n      case \"roundRobin\" => return Some(RunChoice.RoundRobin)\n      case \"static\" => return Some(RunChoice.Static)\n      case \"legacy\" => return Some(RunChoice.Legacy)\n      case s =>\n        eprintln(s\"Expecting one of the following: { default, roundRobin, static, legacy }, but found '$s'.\")\n        return None()\n    }\n  }\n\n  def parseRunChoice(args: ISZ[String], i: Z): Option[RunChoice.Type] = {\n    if (i >= args.size) {\n      eprintln(\"Expecting one of the following: { default, roundRobin, static, legacy }, but none found.\")\n      return None()\n    }\n    val r = parseRunChoiceH(args(i))\n    return r\n  }\n\n  def parseRun(args: ISZ[String], i: Z): Option[RunTopOption] = {\n\n    def help(): Unit = {\n      println(\"Run Slang Embedded Program\")\n      println()\n      println(\"Usage: <option>*\")\n      println()\n      println(\"Available Options:\")\n      println(\"-s, --scheduler          The scheduler to use.  See Demo.scala for information\")\n      println(\"                           on 'default' (expects one of { default, roundRobin,\")\n      println(\"                           static, legacy }; default: default)\")\n      println(\"-h, --help               Display this information\")\n    }\n\n    var scheduler: RunChoice.Type = RunChoice.Default\n    var j = i\n    var isOption = T\n    while (j < args.size && isOption) {\n      var arg = args(j)\n      if (arg == \"-h\" || arg == \"--help\") {\n        help()\n        return Some(HelpOption())\n      } else if (arg == \"-s\" || arg == \"--scheduler\") {\n        val o: Option[RunChoice.Type] = parseRunChoice(args, j + 1)\n        o match {\n          case Some(v) => scheduler = v\n          case _ => return None()\n        }\n      } else {\n        eprintln(s\"Unrecognized option '$arg'.\")\n        return None()\n      }\n      j = j + 2\n    }\n\n    return Some(RunOption(\"\", args, scheduler))\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/architecture\/VPM_ben__Linux\/Schedulers.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.legacy.Legacy\nimport art.scheduling.roundrobin.RoundRobin\nimport art.scheduling.static.Schedule.{DSchedule, DScheduleSpec, Slot}\nimport art.scheduling.static.StaticScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class ProcessorTimingProperties(val clockPeriod: Option[Z],\n                                          val framePeriod: Option[Z],\n                                          val maxDomain: Option[Z],\n                                          val slotTime: Option[Z])\n\n@datatype class ThreadTimingProperties(val domain: Option[Z],\n                                       val computeExecutionTime: Option[(Z, Z)])\n\nobject Schedulers {\n\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.id\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.id\n  val VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.id\n  val VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.id\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.id\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.id\n  val VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_id: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.id\n\n  val VPM_8600B_Ext_impl_Instance_A1_Basecard_application_proc_Core0_timingProperties: ProcessorTimingProperties = ProcessorTimingProperties(\n    clockPeriod = Some(2),\n    framePeriod = Some(500),\n    maxDomain = Some(8),\n    slotTime = None())\n\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(7))\n\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(8))\n\n  val VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(4))\n\n  val VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(5))\n\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(3))\n\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(2))\n\n  val VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_timingProperties: ThreadTimingProperties = ThreadTimingProperties(\n    computeExecutionTime = Some((10, 50)),\n    domain = Some(6))\n\n  \/\/ roundRobinSchedule represents the component dispatch order\n  val roundRobinSchedule: ISZ[art.Bridge] = Arch.ad.components\n\n  val framePeriod: Z = 500\n  val numComponents: Z = Arch.ad.components.size\n  val maxExecutionTime: Z = numComponents \/ framePeriod\n\n  \/\/ staticSchedule represents the component dispatch order\n  val staticSchedule: DScheduleSpec = DScheduleSpec(0, 0, DSchedule(ISZ(\n    Slot(VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_id, maxExecutionTime),\n    Slot(VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_id, maxExecutionTime)\n  )))\n\n\n  def getRoundRobinScheduler(schedule: Option[ISZ[art.Bridge]]): RoundRobin = {\n    if(roundRobinSchedule.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return RoundRobin(s)\n      case _ => return RoundRobin(ScheduleProviderI.getRoundRobinOrder())\n    }\n  }\n\n  def getStaticScheduler(schedule: Option[DScheduleSpec]): StaticScheduler = {\n    if(staticSchedule.schedule.slots.isEmpty) {} \/\/ line needed for transpiler; do not remove\n    schedule match {\n      case Some(s) => return StaticScheduler(Arch.ad.components, s)\n      case _ => return StaticScheduler(Arch.ad.components, ScheduleProviderI.getStaticSchedule())\n    }\n  }\n\n  def getLegacyScheduler(): Legacy = {\n    return Legacy(Arch.ad.components)\n  }\n}\n\n@ext(name = \"ScheduleProvider\") object ScheduleProviderI {\n  def getRoundRobinOrder(): ISZ[art.Bridge] = $\n  def getStaticSchedule(): DScheduleSpec = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/architecture\/VPM_ben__Linux\/ScheduleProvider.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport org.sireum._\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ScheduleProvider {\n\n  def getRoundRobinOrder(): ISZ[art.Bridge] = {\n    return Schedulers.roundRobinSchedule\n  }\n\n  def getStaticSchedule(): DScheduleSpec = {\n    return Schedulers.staticSchedule\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/inspector\/VPM_ben__Linux\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/data\/VPM_ben__Linux\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi extends BridgeTestSuite[CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager) {\n\n  \/** helper function to set the values of all input ports.\n   * @param AttestationResponse payloads for event data port AttestationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AttestationResponse will be used\n   * @param InitiateAttestation payloads for event data port InitiateAttestation.\n   *   ART currently supports single element event data queues so\n   *   only the last element of InitiateAttestation will be used\n   *\/\n  def put_concrete_inputs(AttestationResponse : ISZ[Base_Types.Bits],\n                          InitiateAttestation : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- AttestationResponse){\n      put_AttestationResponse(v)\n    }\n    for(v <- InitiateAttestation){\n      put_InitiateAttestation(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AttestationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AttestationRequest'.\n   * @param TrustedIds method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'TrustedIds'.\n   * @param TerminateAttestation method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'TerminateAttestation'.\n   *\/\n  def check_concrete_output(AttestationRequest: ISZ[Base_Types.Bits] => B = AttestationRequestParam => {T},\n                            TrustedIds: ISZ[Base_Types.Bits] => B = TrustedIdsParam => {T},\n                            TerminateAttestation: ISZ[Base_Types.Bits] => B = TerminateAttestationParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AttestationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AttestationRequest().nonEmpty) AttestationRequestValue = AttestationRequestValue :+ get_AttestationRequest().get\n    if(!AttestationRequest(AttestationRequestValue)) {\n      testFailures = testFailures :+ st\"'AttestationRequest' did not match expected: received ${AttestationRequestValue.size} events with the following payloads ${AttestationRequestValue}\"\n    }\n    var TrustedIdsValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_TrustedIds().nonEmpty) TrustedIdsValue = TrustedIdsValue :+ get_TrustedIds().get\n    if(!TrustedIds(TrustedIdsValue)) {\n      testFailures = testFailures :+ st\"'TrustedIds' did not match expected: received ${TrustedIdsValue.size} events with the following payloads ${TrustedIdsValue}\"\n    }\n    var TerminateAttestationValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_TerminateAttestation().nonEmpty) TerminateAttestationValue = TerminateAttestationValue :+ get_TerminateAttestation().get\n    if(!TerminateAttestation(TerminateAttestationValue)) {\n      testFailures = testFailures :+ st\"'TerminateAttestation' did not match expected: received ${TerminateAttestationValue.size} events with the following payloads ${TerminateAttestationValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AttestationResponse(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_InitiateAttestation(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.InitiateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AttestationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AttestationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AttestationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AttestationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_TrustedIds(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_TrustedIds_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port TrustedIds.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_TrustedIds_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.TrustedIds_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_TerminateAttestation(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_TerminateAttestation_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port TerminateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_TerminateAttestation_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.TerminateAttestation_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Test extends CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AttestationRequest: Port[Base_Types.Bits],\n  AttestationResponse: Port[Base_Types.Bits],\n  TrustedIds: Port[Base_Types.Bits],\n  InitiateAttestation: Port[Base_Types.Bits],\n  TerminateAttestation: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(AttestationRequest,\n              AttestationResponse,\n              TrustedIds,\n              InitiateAttestation,\n              TerminateAttestation),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(AttestationResponse,\n                   InitiateAttestation),\n\n    eventOuts = ISZ(AttestationRequest,\n                    TrustedIds,\n                    TerminateAttestation)\n  )\n\n  val initialization_api : CASE_AttestationManager_Impl_Initialization_Api = {\n    val api = CASE_AttestationManager_Impl_Initialization_Api(\n      id,\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationManager_Impl_Operational_Api = {\n    val api = CASE_AttestationManager_Impl_Operational_Api(\n      id,\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.EntryPoints(\n      id,\n\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationManager_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationManager_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_BridgeId : Art.BridgeId,\n\n    AttestationRequest_Id : Art.PortId,\n    AttestationResponse_Id : Art.PortId,\n    TrustedIds_Id : Art.PortId,\n    InitiateAttestation_Id : Art.PortId,\n    TerminateAttestation_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_AttestationManager_Impl_Initialization_Api,\n    operational_api: CASE_AttestationManager_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(AttestationResponse_Id,\n                                              InitiateAttestation_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(AttestationRequest_Id,\n                                               TrustedIds_Id,\n                                               TerminateAttestation_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationManager_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationManager_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait CASE_AttestationManager_Impl_Api {\n  def id: Art.BridgeId\n  def AttestationRequest_Id : Art.PortId\n  def AttestationResponse_Id : Art.PortId\n  def TrustedIds_Id : Art.PortId\n  def InitiateAttestation_Id : Art.PortId\n  def TerminateAttestation_Id : Art.PortId\n\n  def put_AttestationRequest(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_TrustedIds(value : Base_Types.Bits) : Unit = {\n    Art.putValue(TrustedIds_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_TerminateAttestation(value : Base_Types.Bits) : Unit = {\n    Art.putValue(TerminateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationManager_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AttestationRequest_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends CASE_AttestationManager_Impl_Api\n\n@datatype class CASE_AttestationManager_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AttestationRequest_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends CASE_AttestationManager_Impl_Api {\n\n  def get_AttestationResponse() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AttestationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_InitiateAttestation() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(InitiateAttestation_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port InitiateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager {\n\n  def initialise(api: CASE_AttestationManager_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[VPM_ben__Linux.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi extends BridgeTestSuite[CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate) {\n\n  \/** helper function to set the values of all input ports.\n   * @param SHM_QUEUE_Request_In payloads for event data port SHM_QUEUE_Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Request_In will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   * @param TrustedIds payloads for event data port TrustedIds.\n   *   ART currently supports single element event data queues so\n   *   only the last element of TrustedIds will be used\n   *\/\n  def put_concrete_inputs(SHM_QUEUE_Request_In : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits],\n                          TrustedIds : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- SHM_QUEUE_Request_In){\n      put_SHM_QUEUE_Request_In(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n    for(v <- TrustedIds){\n      put_TrustedIds(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   *\/\n  def check_concrete_output(SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_TrustedIds(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.TrustedIds_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Test extends CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  SHM_QUEUE_Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  TrustedIds: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(SHM_QUEUE_Request_In,\n              SHM_QUEUE_Request_Out,\n              Connection_Command_In,\n              Connection_Command_Out,\n              TrustedIds),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(SHM_QUEUE_Request_In,\n                   Connection_Command_In,\n                   TrustedIds),\n\n    eventOuts = ISZ(SHM_QUEUE_Request_Out,\n                    Connection_Command_Out)\n  )\n\n  val initialization_api : CASE_AttestationGate_Impl_Initialization_Api = {\n    val api = CASE_AttestationGate_Impl_Initialization_Api(\n      id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id\n    )\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationGate_Impl_Operational_Api = {\n    val api = CASE_AttestationGate_Impl_Operational_Api(\n      id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id\n    )\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.EntryPoints(\n      id,\n\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationGate_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationGate_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_BridgeId : Art.BridgeId,\n\n    SHM_QUEUE_Request_In_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    TrustedIds_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_AttestationGate_Impl_Initialization_Api,\n    operational_api: CASE_AttestationGate_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_Request_In_Id,\n                                              Connection_Command_In_Id,\n                                              TrustedIds_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_Request_Out_Id,\n                                               Connection_Command_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationGate_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_AttestationGate_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait CASE_AttestationGate_Impl_Api {\n  def id: Art.BridgeId\n  def SHM_QUEUE_Request_In_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def TrustedIds_Id : Art.PortId\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationGate_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId) extends CASE_AttestationGate_Impl_Api\n\n@datatype class CASE_AttestationGate_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId) extends CASE_AttestationGate_Impl_Api {\n\n  def get_SHM_QUEUE_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_TrustedIds() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(TrustedIds_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port TrustedIds.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate {\n\n  def initialise(api: CASE_AttestationGate_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi extends BridgeTestSuite[CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Test extends CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor1_Impl_Initialization_Api = {\n    val api = CASE_Monitor1_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor1_Impl_Operational_Api = {\n    val api = CASE_Monitor1_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor1_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor1_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor1_Impl_Initialization_Api,\n    operational_api: CASE_Monitor1_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor1_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor1_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait CASE_Monitor1_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor1_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor1_Impl_Api\n\n@datatype class CASE_Monitor1_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor1_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 {\n\n  def initialise(api: CASE_Monitor1_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi extends BridgeTestSuite[CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Test extends CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor2_Impl_Initialization_Api = {\n    val api = CASE_Monitor2_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor2_Impl_Operational_Api = {\n    val api = CASE_Monitor2_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor2_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor2_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor2_Impl_Initialization_Api,\n    operational_api: CASE_Monitor2_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor2_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor2_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait CASE_Monitor2_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor2_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor2_Impl_Api\n\n@datatype class CASE_Monitor2_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor2_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 {\n\n  def initialise(api: CASE_Monitor2_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class adapter_low_impl_SW_adapter_low_adapter_low_TestApi extends BridgeTestSuite[adapter_low_impl_SW_adapter_low_adapter_low_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low) {\n\n  \/** helper function to set the values of all input ports.\n   * @param ADSB_Messages_In payloads for event data port ADSB_Messages_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of ADSB_Messages_In will be used\n   * @param Response_In payloads for event data port Response_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Response_In will be used\n   * @param AttestationRequest payloads for event data port AttestationRequest.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AttestationRequest will be used\n   * @param SHM_HEADER_adsb_to_ptab payloads for event data port SHM_HEADER_adsb_to_ptab.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_HEADER_adsb_to_ptab will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   * @param Suspect_Traffic_In1 payloads for event data port Suspect_Traffic_In1.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In1 will be used\n   * @param Suspect_Traffic_In2 payloads for event data port Suspect_Traffic_In2.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In2 will be used\n   * @param Suspect_Traffic_In3 payloads for event data port Suspect_Traffic_In3.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In3 will be used\n   * @param SHM_QUEUE_Request_In payloads for event data port SHM_QUEUE_Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Request_In will be used\n   * @param SHM_QUEUE_AttestationResponse payloads for event data port SHM_QUEUE_AttestationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_AttestationResponse will be used\n   * @param TerminateAttestation payloads for event data port TerminateAttestation.\n   *   ART currently supports single element event data queues so\n   *   only the last element of TerminateAttestation will be used\n   *\/\n  def put_concrete_inputs(ADSB_Messages_In : ISZ[Base_Types.Bits],\n                          Response_In : ISZ[Base_Types.Bits],\n                          AttestationRequest : ISZ[Base_Types.Bits],\n                          SHM_HEADER_adsb_to_ptab : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In1 : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In2 : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In3 : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_Request_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_AttestationResponse : ISZ[Base_Types.Bits],\n                          TerminateAttestation : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- ADSB_Messages_In){\n      put_ADSB_Messages_In(v)\n    }\n    for(v <- Response_In){\n      put_Response_In(v)\n    }\n    for(v <- AttestationRequest){\n      put_AttestationRequest(v)\n    }\n    for(v <- SHM_HEADER_adsb_to_ptab){\n      put_SHM_HEADER_adsb_to_ptab(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n    for(v <- Suspect_Traffic_In1){\n      put_Suspect_Traffic_In1(v)\n    }\n    for(v <- Suspect_Traffic_In2){\n      put_Suspect_Traffic_In2(v)\n    }\n    for(v <- Suspect_Traffic_In3){\n      put_Suspect_Traffic_In3(v)\n    }\n    for(v <- SHM_QUEUE_Request_In){\n      put_SHM_QUEUE_Request_In(v)\n    }\n    for(v <- SHM_QUEUE_AttestationResponse){\n      put_SHM_QUEUE_AttestationResponse(v)\n    }\n    for(v <- TerminateAttestation){\n      put_TerminateAttestation(v)\n    }\n  }\n\n\n  \/** helper function to check adapter_low_impl_SW_adapter_low_adapter_low's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param SHM_QUEUE_ADSB_Heartbeat_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Heartbeat_Out'.\n   * @param SHM_QUEUE_ADSB_Ownship_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Ownship_Out'.\n   * @param SHM_QUEUE_ADSB_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Traffic_Out'.\n   * @param SHM_QUEUE_Response_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Response_Out'.\n   * @param SHM_QUEUE_AttestationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_AttestationRequest'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out1 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out1'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out2 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out2'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out3 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out3'.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   * @param AttestationResponse method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AttestationResponse'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   * @param InitiateAttestation method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'InitiateAttestation'.\n   *\/\n  def check_concrete_output(SHM_QUEUE_ADSB_Heartbeat_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Heartbeat_OutParam => {T},\n                            SHM_QUEUE_ADSB_Ownship_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Ownship_OutParam => {T},\n                            SHM_QUEUE_ADSB_Traffic_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Traffic_OutParam => {T},\n                            SHM_QUEUE_Response_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Response_OutParam => {T},\n                            SHM_QUEUE_AttestationRequest: ISZ[Base_Types.Bits] => B = SHM_QUEUE_AttestationRequestParam => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out1: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out1Param => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out2: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out2Param => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out3: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out3Param => {T},\n                            SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T},\n                            AttestationResponse: ISZ[Base_Types.Bits] => B = AttestationResponseParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T},\n                            InitiateAttestation: ISZ[Base_Types.Bits] => B = InitiateAttestationParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var SHM_QUEUE_ADSB_Heartbeat_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Heartbeat_Out().nonEmpty) SHM_QUEUE_ADSB_Heartbeat_OutValue = SHM_QUEUE_ADSB_Heartbeat_OutValue :+ get_SHM_QUEUE_ADSB_Heartbeat_Out().get\n    if(!SHM_QUEUE_ADSB_Heartbeat_Out(SHM_QUEUE_ADSB_Heartbeat_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Heartbeat_Out' did not match expected: received ${SHM_QUEUE_ADSB_Heartbeat_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Heartbeat_OutValue}\"\n    }\n    var SHM_QUEUE_ADSB_Ownship_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Ownship_Out().nonEmpty) SHM_QUEUE_ADSB_Ownship_OutValue = SHM_QUEUE_ADSB_Ownship_OutValue :+ get_SHM_QUEUE_ADSB_Ownship_Out().get\n    if(!SHM_QUEUE_ADSB_Ownship_Out(SHM_QUEUE_ADSB_Ownship_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Ownship_Out' did not match expected: received ${SHM_QUEUE_ADSB_Ownship_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Ownship_OutValue}\"\n    }\n    var SHM_QUEUE_ADSB_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Traffic_Out().nonEmpty) SHM_QUEUE_ADSB_Traffic_OutValue = SHM_QUEUE_ADSB_Traffic_OutValue :+ get_SHM_QUEUE_ADSB_Traffic_Out().get\n    if(!SHM_QUEUE_ADSB_Traffic_Out(SHM_QUEUE_ADSB_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Traffic_Out' did not match expected: received ${SHM_QUEUE_ADSB_Traffic_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Traffic_OutValue}\"\n    }\n    var SHM_QUEUE_Response_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Response_Out().nonEmpty) SHM_QUEUE_Response_OutValue = SHM_QUEUE_Response_OutValue :+ get_SHM_QUEUE_Response_Out().get\n    if(!SHM_QUEUE_Response_Out(SHM_QUEUE_Response_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Response_Out' did not match expected: received ${SHM_QUEUE_Response_OutValue.size} events with the following payloads ${SHM_QUEUE_Response_OutValue}\"\n    }\n    var SHM_QUEUE_AttestationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_AttestationRequest().nonEmpty) SHM_QUEUE_AttestationRequestValue = SHM_QUEUE_AttestationRequestValue :+ get_SHM_QUEUE_AttestationRequest().get\n    if(!SHM_QUEUE_AttestationRequest(SHM_QUEUE_AttestationRequestValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_AttestationRequest' did not match expected: received ${SHM_QUEUE_AttestationRequestValue.size} events with the following payloads ${SHM_QUEUE_AttestationRequestValue}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out1Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out1().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out1Value = SHM_QUEUE_Suspect_Traffic_Out1Value :+ get_SHM_QUEUE_Suspect_Traffic_Out1().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out1(SHM_QUEUE_Suspect_Traffic_Out1Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out1' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out1Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out1Value}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out2Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out2().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out2Value = SHM_QUEUE_Suspect_Traffic_Out2Value :+ get_SHM_QUEUE_Suspect_Traffic_Out2().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out2(SHM_QUEUE_Suspect_Traffic_Out2Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out2' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out2Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out2Value}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out3Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out3().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out3Value = SHM_QUEUE_Suspect_Traffic_Out3Value :+ get_SHM_QUEUE_Suspect_Traffic_Out3().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out3(SHM_QUEUE_Suspect_Traffic_Out3Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out3' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out3Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out3Value}\"\n    }\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n    var AttestationResponseValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AttestationResponse().nonEmpty) AttestationResponseValue = AttestationResponseValue :+ get_AttestationResponse().get\n    if(!AttestationResponse(AttestationResponseValue)) {\n      testFailures = testFailures :+ st\"'AttestationResponse' did not match expected: received ${AttestationResponseValue.size} events with the following payloads ${AttestationResponseValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n    var InitiateAttestationValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_InitiateAttestation().nonEmpty) InitiateAttestationValue = InitiateAttestationValue :+ get_InitiateAttestation().get\n    if(!InitiateAttestation(InitiateAttestationValue)) {\n      testFailures = testFailures :+ st\"'InitiateAttestation' did not match expected: received ${InitiateAttestationValue.size} events with the following payloads ${InitiateAttestationValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_ADSB_Messages_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ADSB_Messages_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Response_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Response_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AttestationRequest(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_HEADER_adsb_to_ptab(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_HEADER_adsb_to_ptab_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In1(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In1_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In2(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In2_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In3(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In3_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_AttestationResponse(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_TerminateAttestation(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.TerminateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Heartbeat_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Heartbeat_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Heartbeat_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Heartbeat_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Heartbeat_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Ownship_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Ownship_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Ownship_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Ownship_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Ownship_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Response_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Response_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Response_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Response_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Response_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_AttestationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_AttestationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_AttestationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_AttestationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out1(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out1_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out1_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out1_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out2(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out2_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out2.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out2_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out2_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out3(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out3_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out3.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out3_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out3_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AttestationResponse(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AttestationResponse_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AttestationResponse_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AttestationResponse_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_InitiateAttestation(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_InitiateAttestation_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port InitiateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_InitiateAttestation_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.InitiateAttestation_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass adapter_low_impl_SW_adapter_low_adapter_low_Test extends adapter_low_impl_SW_adapter_low_adapter_low_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{adapter_low_impl_SW_adapter_low_adapter_low => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class adapter_low_impl_SW_adapter_low_adapter_low_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  ADSB_Messages_In: Port[Base_Types.Bits],\n  Response_In: Port[Base_Types.Bits],\n  AttestationRequest: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Heartbeat_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Ownship_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Traffic_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_Response_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_AttestationRequest: Port[Base_Types.Bits],\n  SHM_HEADER_adsb_to_ptab: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits],\n  Suspect_Traffic_In1: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out1: Port[Base_Types.Bits],\n  Suspect_Traffic_In2: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out2: Port[Base_Types.Bits],\n  Suspect_Traffic_In3: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out3: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_AttestationResponse: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  AttestationResponse: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  InitiateAttestation: Port[Base_Types.Bits],\n  TerminateAttestation: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(ADSB_Messages_In,\n              Response_In,\n              AttestationRequest,\n              SHM_QUEUE_ADSB_Heartbeat_Out,\n              SHM_QUEUE_ADSB_Ownship_Out,\n              SHM_QUEUE_ADSB_Traffic_Out,\n              SHM_QUEUE_Response_Out,\n              SHM_QUEUE_AttestationRequest,\n              SHM_HEADER_adsb_to_ptab,\n              Connection_Command_In,\n              Suspect_Traffic_In1,\n              SHM_QUEUE_Suspect_Traffic_Out1,\n              Suspect_Traffic_In2,\n              SHM_QUEUE_Suspect_Traffic_Out2,\n              Suspect_Traffic_In3,\n              SHM_QUEUE_Suspect_Traffic_Out3,\n              SHM_QUEUE_Request_In,\n              SHM_QUEUE_AttestationResponse,\n              SHM_QUEUE_Request_Out,\n              AttestationResponse,\n              Connection_Command_Out,\n              InitiateAttestation,\n              TerminateAttestation),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(ADSB_Messages_In,\n                   Response_In,\n                   AttestationRequest,\n                   SHM_HEADER_adsb_to_ptab,\n                   Connection_Command_In,\n                   Suspect_Traffic_In1,\n                   Suspect_Traffic_In2,\n                   Suspect_Traffic_In3,\n                   SHM_QUEUE_Request_In,\n                   SHM_QUEUE_AttestationResponse,\n                   TerminateAttestation),\n\n    eventOuts = ISZ(SHM_QUEUE_ADSB_Heartbeat_Out,\n                    SHM_QUEUE_ADSB_Ownship_Out,\n                    SHM_QUEUE_ADSB_Traffic_Out,\n                    SHM_QUEUE_Response_Out,\n                    SHM_QUEUE_AttestationRequest,\n                    SHM_QUEUE_Suspect_Traffic_Out1,\n                    SHM_QUEUE_Suspect_Traffic_Out2,\n                    SHM_QUEUE_Suspect_Traffic_Out3,\n                    SHM_QUEUE_Request_Out,\n                    AttestationResponse,\n                    Connection_Command_Out,\n                    InitiateAttestation)\n  )\n\n  val initialization_api : adapter_low_impl_Initialization_Api = {\n    val api = adapter_low_impl_Initialization_Api(\n      id,\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : adapter_low_impl_Operational_Api = {\n    val api = adapter_low_impl_Operational_Api(\n      id,\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.EntryPoints(\n      id,\n\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject adapter_low_impl_SW_adapter_low_adapter_low_Bridge {\n\n  var c_initialization_api: Option[adapter_low_impl_Initialization_Api] = None()\n  var c_operational_api: Option[adapter_low_impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    adapter_low_impl_SW_adapter_low_adapter_low_BridgeId : Art.BridgeId,\n\n    ADSB_Messages_In_Id : Art.PortId,\n    Response_In_Id : Art.PortId,\n    AttestationRequest_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n    SHM_QUEUE_Response_Out_Id : Art.PortId,\n    SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n    SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n    Suspect_Traffic_In1_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n    Suspect_Traffic_In2_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n    Suspect_Traffic_In3_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n    SHM_QUEUE_Request_In_Id : Art.PortId,\n    SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    AttestationResponse_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    InitiateAttestation_Id : Art.PortId,\n    TerminateAttestation_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: adapter_low_impl_Initialization_Api,\n    operational_api: adapter_low_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(ADSB_Messages_In_Id,\n                                              Response_In_Id,\n                                              AttestationRequest_Id,\n                                              SHM_HEADER_adsb_to_ptab_Id,\n                                              Connection_Command_In_Id,\n                                              Suspect_Traffic_In1_Id,\n                                              Suspect_Traffic_In2_Id,\n                                              Suspect_Traffic_In3_Id,\n                                              SHM_QUEUE_Request_In_Id,\n                                              SHM_QUEUE_AttestationResponse_Id,\n                                              TerminateAttestation_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_ADSB_Heartbeat_Out_Id,\n                                               SHM_QUEUE_ADSB_Ownship_Out_Id,\n                                               SHM_QUEUE_ADSB_Traffic_Out_Id,\n                                               SHM_QUEUE_Response_Out_Id,\n                                               SHM_QUEUE_AttestationRequest_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out1_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out2_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out3_Id,\n                                               SHM_QUEUE_Request_Out_Id,\n                                               AttestationResponse_Id,\n                                               Connection_Command_Out_Id,\n                                               InitiateAttestation_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: adapter_low_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/adapter_low_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait adapter_low_impl_Api {\n  def id: Art.BridgeId\n  def ADSB_Messages_In_Id : Art.PortId\n  def Response_In_Id : Art.PortId\n  def AttestationRequest_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId\n  def SHM_QUEUE_Response_Out_Id : Art.PortId\n  def SHM_QUEUE_AttestationRequest_Id : Art.PortId\n  def SHM_HEADER_adsb_to_ptab_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n  def Suspect_Traffic_In1_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId\n  def Suspect_Traffic_In2_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId\n  def Suspect_Traffic_In3_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId\n  def SHM_QUEUE_Request_In_Id : Art.PortId\n  def SHM_QUEUE_AttestationResponse_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def AttestationResponse_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def InitiateAttestation_Id : Art.PortId\n  def TerminateAttestation_Id : Art.PortId\n\n  def put_SHM_QUEUE_ADSB_Heartbeat_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Heartbeat_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_ADSB_Ownship_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Ownship_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_ADSB_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Response_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Response_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_AttestationRequest(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out1(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out1_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out2(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out2_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out3(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out3_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AttestationResponse(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_InitiateAttestation(value : Base_Types.Bits) : Unit = {\n    Art.putValue(InitiateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class adapter_low_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val ADSB_Messages_In_Id : Art.PortId,\n  val Response_In_Id : Art.PortId,\n  val AttestationRequest_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n  val SHM_QUEUE_Response_Out_Id : Art.PortId,\n  val SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Suspect_Traffic_In1_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n  val Suspect_Traffic_In2_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n  val Suspect_Traffic_In3_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends adapter_low_impl_Api\n\n@datatype class adapter_low_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val ADSB_Messages_In_Id : Art.PortId,\n  val Response_In_Id : Art.PortId,\n  val AttestationRequest_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n  val SHM_QUEUE_Response_Out_Id : Art.PortId,\n  val SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Suspect_Traffic_In1_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n  val Suspect_Traffic_In2_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n  val Suspect_Traffic_In3_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends adapter_low_impl_Api {\n\n  def get_ADSB_Messages_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(ADSB_Messages_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ADSB_Messages_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Response_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Response_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Response_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_AttestationRequest() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AttestationRequest_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_HEADER_adsb_to_ptab() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_HEADER_adsb_to_ptab_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_HEADER_adsb_to_ptab.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In1() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In1_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In2() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In2_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In2.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In3() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In3_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In3.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_AttestationResponse() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_AttestationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_TerminateAttestation() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(TerminateAttestation_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port TerminateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject adapter_low_impl_SW_adapter_low_adapter_low {\n\n  def initialise(api: adapter_low_impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def activate(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def finalise(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def recover(api: adapter_low_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class adapter_high_impl_SW_adapter_high_adapter_high_TestApi extends BridgeTestSuite[adapter_high_impl_SW_adapter_high_adapter_high_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high) {\n\n  \/** helper function to set the values of all input ports.\n   * @param SHM_QUEUE_ADSB_Heartbeat_In payloads for event data port SHM_QUEUE_ADSB_Heartbeat_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Heartbeat_In will be used\n   * @param SHM_QUEUE_ADSB_Ownship_In payloads for event data port SHM_QUEUE_ADSB_Ownship_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Ownship_In will be used\n   * @param SHM_QUEUE_ADSB_Traffic_In payloads for event data port SHM_QUEUE_ADSB_Traffic_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Traffic_In will be used\n   * @param SHM_QUEUE_Response_In payloads for event data port SHM_QUEUE_Response_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Response_In will be used\n   * @param Request_In payloads for event data port Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Request_In will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   *\/\n  def put_concrete_inputs(SHM_QUEUE_ADSB_Heartbeat_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_ADSB_Ownship_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_ADSB_Traffic_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_Response_In : ISZ[Base_Types.Bits],\n                          Request_In : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- SHM_QUEUE_ADSB_Heartbeat_In){\n      put_SHM_QUEUE_ADSB_Heartbeat_In(v)\n    }\n    for(v <- SHM_QUEUE_ADSB_Ownship_In){\n      put_SHM_QUEUE_ADSB_Ownship_In(v)\n    }\n    for(v <- SHM_QUEUE_ADSB_Traffic_In){\n      put_SHM_QUEUE_ADSB_Traffic_In(v)\n    }\n    for(v <- SHM_QUEUE_Response_In){\n      put_SHM_QUEUE_Response_In(v)\n    }\n    for(v <- Request_In){\n      put_Request_In(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n  }\n\n\n  \/** helper function to check adapter_high_impl_SW_adapter_high_adapter_high's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Response_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Response_Out'.\n   * @param ADSB_Messages_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'ADSB_Messages_Out'.\n   * @param SHM_HEADER_adsb_to_ptab method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_HEADER_adsb_to_ptab'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   *\/\n  def check_concrete_output(Response_Out: ISZ[Base_Types.Bits] => B = Response_OutParam => {T},\n                            ADSB_Messages_Out: ISZ[Base_Types.Bits] => B = ADSB_Messages_OutParam => {T},\n                            SHM_HEADER_adsb_to_ptab: ISZ[Base_Types.Bits] => B = SHM_HEADER_adsb_to_ptabParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T},\n                            SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Response_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Response_Out().nonEmpty) Response_OutValue = Response_OutValue :+ get_Response_Out().get\n    if(!Response_Out(Response_OutValue)) {\n      testFailures = testFailures :+ st\"'Response_Out' did not match expected: received ${Response_OutValue.size} events with the following payloads ${Response_OutValue}\"\n    }\n    var ADSB_Messages_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_ADSB_Messages_Out().nonEmpty) ADSB_Messages_OutValue = ADSB_Messages_OutValue :+ get_ADSB_Messages_Out().get\n    if(!ADSB_Messages_Out(ADSB_Messages_OutValue)) {\n      testFailures = testFailures :+ st\"'ADSB_Messages_Out' did not match expected: received ${ADSB_Messages_OutValue.size} events with the following payloads ${ADSB_Messages_OutValue}\"\n    }\n    var SHM_HEADER_adsb_to_ptabValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_HEADER_adsb_to_ptab().nonEmpty) SHM_HEADER_adsb_to_ptabValue = SHM_HEADER_adsb_to_ptabValue :+ get_SHM_HEADER_adsb_to_ptab().get\n    if(!SHM_HEADER_adsb_to_ptab(SHM_HEADER_adsb_to_ptabValue)) {\n      testFailures = testFailures :+ st\"'SHM_HEADER_adsb_to_ptab' did not match expected: received ${SHM_HEADER_adsb_to_ptabValue.size} events with the following payloads ${SHM_HEADER_adsb_to_ptabValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Heartbeat_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Heartbeat_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Ownship_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Ownship_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Traffic_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Traffic_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Response_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Response_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Response_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Response_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Response_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Response_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Response_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_ADSB_Messages_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_ADSB_Messages_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port ADSB_Messages_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_ADSB_Messages_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ADSB_Messages_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_HEADER_adsb_to_ptab(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_HEADER_adsb_to_ptab_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_HEADER_adsb_to_ptab.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_HEADER_adsb_to_ptab_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_HEADER_adsb_to_ptab_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass adapter_high_impl_SW_adapter_high_adapter_high_Test extends adapter_high_impl_SW_adapter_high_adapter_high_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{adapter_high_impl_SW_adapter_high_adapter_high => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class adapter_high_impl_SW_adapter_high_adapter_high_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  SHM_QUEUE_ADSB_Heartbeat_In: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Ownship_In: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Traffic_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Response_In: Port[Base_Types.Bits],\n  Response_Out: Port[Base_Types.Bits],\n  ADSB_Messages_Out: Port[Base_Types.Bits],\n  SHM_HEADER_adsb_to_ptab: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(SHM_QUEUE_ADSB_Heartbeat_In,\n              SHM_QUEUE_ADSB_Ownship_In,\n              SHM_QUEUE_ADSB_Traffic_In,\n              SHM_QUEUE_Response_In,\n              Response_Out,\n              ADSB_Messages_Out,\n              SHM_HEADER_adsb_to_ptab,\n              Connection_Command_Out,\n              Request_In,\n              SHM_QUEUE_Request_Out,\n              Connection_Command_In),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(SHM_QUEUE_ADSB_Heartbeat_In,\n                   SHM_QUEUE_ADSB_Ownship_In,\n                   SHM_QUEUE_ADSB_Traffic_In,\n                   SHM_QUEUE_Response_In,\n                   Request_In,\n                   Connection_Command_In),\n\n    eventOuts = ISZ(Response_Out,\n                    ADSB_Messages_Out,\n                    SHM_HEADER_adsb_to_ptab,\n                    Connection_Command_Out,\n                    SHM_QUEUE_Request_Out)\n  )\n\n  val initialization_api : adapter_high_impl_Initialization_Api = {\n    val api = adapter_high_impl_Initialization_Api(\n      id,\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id\n    )\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : adapter_high_impl_Operational_Api = {\n    val api = adapter_high_impl_Operational_Api(\n      id,\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id\n    )\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.EntryPoints(\n      id,\n\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject adapter_high_impl_SW_adapter_high_adapter_high_Bridge {\n\n  var c_initialization_api: Option[adapter_high_impl_Initialization_Api] = None()\n  var c_operational_api: Option[adapter_high_impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    adapter_high_impl_SW_adapter_high_adapter_high_BridgeId : Art.BridgeId,\n\n    SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n    SHM_QUEUE_Response_In_Id : Art.PortId,\n    Response_Out_Id : Art.PortId,\n    ADSB_Messages_Out_Id : Art.PortId,\n    SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    Request_In_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: adapter_high_impl_Initialization_Api,\n    operational_api: adapter_high_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_ADSB_Heartbeat_In_Id,\n                                              SHM_QUEUE_ADSB_Ownship_In_Id,\n                                              SHM_QUEUE_ADSB_Traffic_In_Id,\n                                              SHM_QUEUE_Response_In_Id,\n                                              Request_In_Id,\n                                              Connection_Command_In_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Response_Out_Id,\n                                               ADSB_Messages_Out_Id,\n                                               SHM_HEADER_adsb_to_ptab_Id,\n                                               Connection_Command_Out_Id,\n                                               SHM_QUEUE_Request_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: adapter_high_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/adapter_high_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait adapter_high_impl_Api {\n  def id: Art.BridgeId\n  def SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId\n  def SHM_QUEUE_Response_In_Id : Art.PortId\n  def Response_Out_Id : Art.PortId\n  def ADSB_Messages_Out_Id : Art.PortId\n  def SHM_HEADER_adsb_to_ptab_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def Request_In_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n\n  def put_Response_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Response_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_ADSB_Messages_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(ADSB_Messages_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_HEADER_adsb_to_ptab(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_HEADER_adsb_to_ptab_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class adapter_high_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n  val SHM_QUEUE_Response_In_Id : Art.PortId,\n  val Response_Out_Id : Art.PortId,\n  val ADSB_Messages_Out_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId) extends adapter_high_impl_Api\n\n@datatype class adapter_high_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n  val SHM_QUEUE_Response_In_Id : Art.PortId,\n  val Response_Out_Id : Art.PortId,\n  val ADSB_Messages_Out_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId) extends adapter_high_impl_Api {\n\n  def get_SHM_QUEUE_ADSB_Heartbeat_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Heartbeat_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Heartbeat_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_ADSB_Ownship_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Ownship_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Ownship_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_ADSB_Traffic_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Traffic_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Traffic_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_Response_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Response_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Response_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject adapter_high_impl_SW_adapter_high_adapter_high {\n\n  def initialise(api: adapter_high_impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def activate(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def finalise(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def recover(api: adapter_high_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/util\/VPM_ben__Linux\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport VPM_ben__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi extends BridgeTestSuite[CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/test\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Test extends CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\nimport VPM_ben__Linux.VPM.{CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor3_Impl_Initialization_Api = {\n    val api = CASE_Monitor3_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor3_Impl_Operational_Api = {\n    val api = CASE_Monitor3_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor3_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor3_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor3_Impl_Initialization_Api,\n    operational_api: CASE_Monitor3_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor3_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/bridge\/VPM_ben__Linux\/VPM\/CASE_Monitor3_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport art._\nimport VPM_ben__Linux._\n\n@sig trait CASE_Monitor3_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor3_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor3_Impl_Api\n\n@datatype class CASE_Monitor3_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor3_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux.VPM\n\nimport org.sireum._\nimport VPM_ben__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 {\n\n  def initialise(api: CASE_Monitor3_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/component\/VPM_ben__Linux\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val AttestationResponsePortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationResponse.id\n  val AttestationResponsePortIdOpt: Option[Art.PortId] = Some(AttestationResponsePortId)\n  val InitiateAttestationPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.InitiateAttestation.id\n  val InitiateAttestationPortIdOpt: Option[Art.PortId] = Some(InitiateAttestationPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, AttestationResponsePortIdOpt)\n    Platform.initialise(seed, InitiateAttestationPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AttestationResponsePortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AttestationResponsePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AttestationResponse.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(InitiateAttestationPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(InitiateAttestationPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port InitiateAttestation.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_AttestationRequest(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_AttestationRequest(Base_Types.Bits_example())\n      val apiUsage_AttestationResponse: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_AttestationResponse()\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TrustedIds(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TrustedIds(Base_Types.Bits_example())\n      val apiUsage_InitiateAttestation: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_InitiateAttestation()\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_H\n#define CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h>\n#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl, numBytes_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl);\n  api_put_AttestationRequest__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl, t0);\n\n  uint8_t t1[numBytes_VPM_ben__Linux_CASE_Proxies_WhiteList_impl];\n  byte_array_default(SF t1, numBits_VPM_ben__Linux_CASE_Proxies_WhiteList_impl, numBytes_VPM_ben__Linux_CASE_Proxies_WhiteList_impl);\n  api_put_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_VPM_ben__Linux_CASE_Proxies_WhiteList_impl, t1);\n\n  uint8_t t2[numBytes_VPM_ben__Linux_Common_Types_Unsigned_32];\n  byte_array_default(SF t2, numBits_VPM_ben__Linux_Common_Types_Unsigned_32, numBytes_VPM_ben__Linux_Common_Types_Unsigned_32);\n  api_put_TerminateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_VPM_ben__Linux_Common_Types_Unsigned_32, t2);\n\n  api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl];\n  size_t t0_numBits;\n  if(api_get_AttestationResponse__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl, \"numBits received does not match expected\");\n\n    DeclNewString(AttestationResponse_str);\n    String__append(SF (String) &AttestationResponse_str, string(\"Received on AttestationResponse: \"));\n    byte_array_string(SF (String) &AttestationResponse_str, t0, numBytes_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF (String) &AttestationResponse_str);\n  }\n\n  uint8_t t1[numBytes_VPM_ben__Linux_Common_Types_Unsigned_32];\n  size_t t1_numBits;\n  if(api_get_InitiateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_VPM_ben__Linux_Common_Types_Unsigned_32, \"numBits received does not match expected\");\n\n    DeclNewString(InitiateAttestation_str);\n    String__append(SF (String) &InitiateAttestation_str, string(\"Received on InitiateAttestation: \"));\n    byte_array_string(SF (String) &InitiateAttestation_str, t1, numBytes_VPM_ben__Linux_Common_Types_Unsigned_32);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF (String) &InitiateAttestation_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_API_H\n#define CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_AttestationRequest__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_AttestationResponse__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_InitiateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_TerminateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h>\n#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_AttestationRequest__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_AttestationRequest__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_AttestationRequest_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_AttestationResponse__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_get_AttestationResponse__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_293450 = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api(api);\n  Option_293450_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api_get_AttestationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_TrustedIds_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_InitiateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_get_InitiateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_293450 = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api(api);\n  Option_293450_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api_get_InitiateAttestation_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_TerminateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_TerminateAttestation__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_TerminateAttestation_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_95AAFD = Option[VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_95AAFD_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-schedule\/legacy.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n\nUnit art_scheduling_legacy_LegacyInterface_computePhase(STACK_FRAME IS_7E8796 bridges) {\n  printf(\"Infeasible.  You should not get here in C\");\n  exit(1);\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-schedule\/round_robin.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n#include <signal.h>\n\n__attribute__((weak)) IS_7E8796 VPM_ben__Linux_Schedulers_roundRobinSchedule(STACK_FRAME_ONLY);\n\nvolatile sig_atomic_t shouldStop = 0;\n\nvoid VPM_ben__Linux_ScheduleProviderI_getRoundRobinOrder(STACK_FRAME IS_7E8796 result) {\n\n  if(VPM_ben__Linux_Schedulers_roundRobinSchedule) {\n    IS_7E8796 order = VPM_ben__Linux_Schedulers_roundRobinSchedule();\n    memcpy(result->value, order->value, sizeof(union art_Bridge) * order->size);\n    result->size = order->size;\n\n    printf(\"Using the round robin order provided in Schedulers. Edit method \\n\");\n    printf(\"  VPM_ben__Linux_ScheduleProviderI_getRoundRobinOrder\\n\");\n    printf(\"to supply your own\\n\");\n  } else {\n    printf(\"Schedulers.roundRobinSchedule not found.  You'll need to supply your own order in C\\n\");\n    exit(-1);\n  }\n}\n\nvoid sigHandler(int signo) {\n  shouldStop = 1;\n}\n\nUnit art_scheduling_roundrobin_RoundRobinExtensions_init(STACK_FRAME_ONLY){\n  int sigs[] = {SIGINT, SIGTERM, SIGQUIT};\n  for(int i = 0; i < sizeof(sigs) \/ sizeof(int); i++){\n    if(signal(sigs[i], sigHandler) == SIG_ERR) {\n      printf(\"Error occurred while setting signal handler for %i\\n\", sigs[i]);\n      exit(-1);\n    }\n  }\n}\n\nB art_scheduling_roundrobin_RoundRobinExtensions_shouldStop(STACK_FRAME_ONLY){\n    return shouldStop == 1;\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-schedule\/static_scheduler.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n\n__attribute__((weak)) art_scheduling_static_Schedule_DScheduleSpec VPM_ben__Linux_Schedulers_staticSchedule(STACK_FRAME_ONLY);\n\nvoid VPM_ben__Linux_ScheduleProviderI_getStaticSchedule(STACK_FRAME art_scheduling_static_Schedule_DScheduleSpec result){\n\n  if(VPM_ben__Linux_Schedulers_staticSchedule) {\n    art_scheduling_static_Schedule_DScheduleSpec schedule = VPM_ben__Linux_Schedulers_staticSchedule();\n    result->hyperPeriod = schedule->hyperPeriod;\n    result->maxDomain = schedule->maxDomain;\n    memcpy(&result->schedule, &schedule->schedule, sizeof(struct art_scheduling_static_Schedule_DSchedule));\n\n    printf(\"Using the static schedule provided Schedulers. Edit method \\n\");\n    printf(\"  VPM_ben__Linux_ScheduleProviderI_getStaticSchedule\\n\");\n    printf(\"to supply your own\\n\");\n  } else {\n    printf(\"Schedulers.staticSchedule not found.  You'll need to supply your own order in C\\n\");\n    exit(-1);\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-schedule\/process.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n\n#include <sys\/time.h>\n#include <time.h>\n\n\/** Returns current system time in milliseconds\n  * NOTE: this requires returning 64bit ints\n  *\/\nS64 art_Process_time(STACK_FRAME_ONLY) {\n  struct timeval tv; \/\/Get a time structure\n  gettimeofday(&tv, NULL); \/\/Get the current time\n  int64_t t = tv.tv_sec;\n  t *= 1000;\n  t += tv.tv_usec\/1000;\n  return  t;\n}\n\nUnit Os_Ext_exit(STACK_FRAME Z code) {\n  exit(code);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val SHM_QUEUE_Request_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_In.id\n  val SHM_QUEUE_Request_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_Request_InPortId)\n  val Connection_Command_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_In.id\n  val Connection_Command_InPortIdOpt: Option[Art.PortId] = Some(Connection_Command_InPortId)\n  val TrustedIdsPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.TrustedIds.id\n  val TrustedIdsPortIdOpt: Option[Art.PortId] = Some(TrustedIdsPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_Request_InPortIdOpt)\n    Platform.initialise(seed, Connection_Command_InPortIdOpt)\n    Platform.initialise(seed, TrustedIdsPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_Request_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_Request_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Connection_Command_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Connection_Command_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Connection_Command_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(TrustedIdsPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(TrustedIdsPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port TrustedIds.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_Connection_Command_In()\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      val apiUsage_TrustedIds: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_TrustedIds()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_H\n#define CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl);\n  api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, t0);\n\n  uint8_t t1[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t1, numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, t1);\n\n  api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl];\n  size_t t0_numBits;\n  if(api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Request_In_str);\n    String__append(SF (String) &SHM_QUEUE_Request_In_str, string(\"Received on SHM_QUEUE_Request_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Request_In_str, t0, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &SHM_QUEUE_Request_In_str);\n  }\n\n  uint8_t t1[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  size_t t1_numBits;\n  if(api_get_Connection_Command_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t1, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &Connection_Command_In_str);\n  }\n\n  uint8_t t2[numBytes_VPM_ben__Linux_CASE_Proxies_WhiteList_impl];\n  size_t t2_numBits;\n  if(api_get_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_VPM_ben__Linux_CASE_Proxies_WhiteList_impl, \"numBits received does not match expected\");\n\n    DeclNewString(TrustedIds_str);\n    String__append(SF (String) &TrustedIds_str, string(\"Received on TrustedIds: \"));\n    byte_array_string(SF (String) &TrustedIds_str, t2, numBytes_VPM_ben__Linux_CASE_Proxies_WhiteList_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &TrustedIds_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_API_H\n#define CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_071A9A = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_071A9A_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api_get_SHM_QUEUE_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_06315F = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_06315F_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_Connection_Command_In__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_071A9A = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_071A9A_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_Connection_Command_Out__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_06315F = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_06315F_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_TrustedIds__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_071A9A = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_071A9A_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api_get_TrustedIds_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_06315F = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_06315F_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_06315F = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_06315F_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_06315F = Option[VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_06315F_get_(SF (VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val ObservedPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Observed.id\n  val ObservedPortIdOpt: Option[Art.PortId] = Some(ObservedPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, ObservedPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(ObservedPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(ObservedPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Observed.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.get_Observed()\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_H\n#define CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_API_H\n#define CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_26C6AD = Option[VPM_ben__Linux.VPM.CASE_Monitor1_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor1_Impl_Operational_Api(api);\n  Option_26C6AD_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_4BC576 = Option[VPM_ben__Linux.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_4BC576_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_4BC576 = Option[VPM_ben__Linux.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_4BC576_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_4BC576 = Option[VPM_ben__Linux.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_4BC576_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_4BC576 = Option[VPM_ben__Linux.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_4BC576_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val ObservedPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Observed.id\n  val ObservedPortIdOpt: Option[Art.PortId] = Some(ObservedPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, ObservedPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(ObservedPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(ObservedPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Observed.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.get_Observed()\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_H\n#define CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_API_H\n#define CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_075F24 = Option[VPM_ben__Linux.VPM.CASE_Monitor2_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor2_Impl_Operational_Api(api);\n  Option_075F24_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7DCA8E = Option[VPM_ben__Linux.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_7DCA8E_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_7DCA8E = Option[VPM_ben__Linux.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_7DCA8E_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_7DCA8E = Option[VPM_ben__Linux.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_7DCA8E_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_7DCA8E = Option[VPM_ben__Linux.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_7DCA8E_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/adapter_low_impl_SW_adapter_low_adapter_low_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject adapter_low_impl_SW_adapter_low_adapter_low_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.entryPoints\n  val appPortId: Art.PortId = IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val ADSB_Messages_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.ADSB_Messages_In.id\n  val ADSB_Messages_InPortIdOpt: Option[Art.PortId] = Some(ADSB_Messages_InPortId)\n  val Response_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Response_In.id\n  val Response_InPortIdOpt: Option[Art.PortId] = Some(Response_InPortId)\n  val AttestationRequestPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationRequest.id\n  val AttestationRequestPortIdOpt: Option[Art.PortId] = Some(AttestationRequestPortId)\n  val SHM_HEADER_adsb_to_ptabPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_HEADER_adsb_to_ptab.id\n  val SHM_HEADER_adsb_to_ptabPortIdOpt: Option[Art.PortId] = Some(SHM_HEADER_adsb_to_ptabPortId)\n  val Connection_Command_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_In.id\n  val Connection_Command_InPortIdOpt: Option[Art.PortId] = Some(Connection_Command_InPortId)\n  val Suspect_Traffic_In1PortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In1.id\n  val Suspect_Traffic_In1PortIdOpt: Option[Art.PortId] = Some(Suspect_Traffic_In1PortId)\n  val Suspect_Traffic_In2PortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In2.id\n  val Suspect_Traffic_In2PortIdOpt: Option[Art.PortId] = Some(Suspect_Traffic_In2PortId)\n  val Suspect_Traffic_In3PortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In3.id\n  val Suspect_Traffic_In3PortIdOpt: Option[Art.PortId] = Some(Suspect_Traffic_In3PortId)\n  val SHM_QUEUE_Request_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_Request_In.id\n  val SHM_QUEUE_Request_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_Request_InPortId)\n  val SHM_QUEUE_AttestationResponsePortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_AttestationResponse.id\n  val SHM_QUEUE_AttestationResponsePortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_AttestationResponsePortId)\n  val TerminateAttestationPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.TerminateAttestation.id\n  val TerminateAttestationPortIdOpt: Option[Art.PortId] = Some(TerminateAttestationPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, ADSB_Messages_InPortIdOpt)\n    Platform.initialise(seed, Response_InPortIdOpt)\n    Platform.initialise(seed, AttestationRequestPortIdOpt)\n    Platform.initialise(seed, SHM_HEADER_adsb_to_ptabPortIdOpt)\n    Platform.initialise(seed, Connection_Command_InPortIdOpt)\n    Platform.initialise(seed, Suspect_Traffic_In1PortIdOpt)\n    Platform.initialise(seed, Suspect_Traffic_In2PortIdOpt)\n    Platform.initialise(seed, Suspect_Traffic_In3PortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_Request_InPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_AttestationResponsePortIdOpt)\n    Platform.initialise(seed, TerminateAttestationPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(ADSB_Messages_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(ADSB_Messages_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port ADSB_Messages_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Response_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Response_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Response_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AttestationRequestPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AttestationRequestPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AttestationRequest.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_HEADER_adsb_to_ptabPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_HEADER_adsb_to_ptabPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_HEADER_adsb_to_ptab.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Connection_Command_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Connection_Command_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Connection_Command_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Suspect_Traffic_In1PortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Suspect_Traffic_In1PortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Suspect_Traffic_In1.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Suspect_Traffic_In2PortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Suspect_Traffic_In2PortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Suspect_Traffic_In2.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Suspect_Traffic_In3PortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Suspect_Traffic_In3PortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Suspect_Traffic_In3.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_Request_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_Request_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_AttestationResponsePortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_AttestationResponsePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_AttestationResponse.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(TerminateAttestationPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(TerminateAttestationPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port TerminateAttestation.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"adapter_low_impl_SW_adapter_low_adapter_low_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_ADSB_Messages_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_ADSB_Messages_In()\n      val apiUsage_Response_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Response_In()\n      val apiUsage_AttestationRequest: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_AttestationRequest()\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n      val apiUsage_SHM_HEADER_adsb_to_ptab: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_HEADER_adsb_to_ptab()\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Connection_Command_In()\n      val apiUsage_Suspect_Traffic_In1: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In1()\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n      val apiUsage_Suspect_Traffic_In2: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In2()\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n      val apiUsage_Suspect_Traffic_In3: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In3()\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n      val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n      val apiUsage_SHM_QUEUE_AttestationResponse: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_AttestationResponse()\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_AttestationResponse(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_AttestationResponse(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n      val apiUsage_TerminateAttestation: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_TerminateAttestation()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_H\n#define ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_low_impl_SW_adapter_low_adapter_low_api.h>\n#include <adapter_low_impl_SW_adapter_low_adapter_low.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl);\n  api_put_SHM_QUEUE_ADSB_Heartbeat_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, t0);\n\n  uint8_t t1[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl];\n  byte_array_default(SF t1, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl);\n  api_put_SHM_QUEUE_ADSB_Ownship_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl, t1);\n\n  uint8_t t2[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl];\n  byte_array_default(SF t2, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl);\n  api_put_SHM_QUEUE_ADSB_Traffic_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl, t2);\n\n  uint8_t t3[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl];\n  byte_array_default(SF t3, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl);\n  api_put_SHM_QUEUE_Response_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl, t3);\n\n  uint8_t t4[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl];\n  byte_array_default(SF t4, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl);\n  api_put_SHM_QUEUE_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl, t4);\n\n  uint8_t t5[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t5, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, t5);\n\n  uint8_t t6[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t6, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, t6);\n\n  uint8_t t7[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t7, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl, t7);\n\n  uint8_t t8[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl];\n  byte_array_default(SF t8, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl);\n  api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, t8);\n\n  uint8_t t9[numBytes_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl];\n  byte_array_default(SF t9, numBits_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl, numBytes_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl);\n  api_put_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl, t9);\n\n  uint8_t t10[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t10, numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, t10);\n\n  uint8_t t11[numBytes_VPM_ben__Linux_Common_Types_Unsigned_32];\n  byte_array_default(SF t11, numBits_VPM_ben__Linux_Common_Types_Unsigned_32, numBytes_VPM_ben__Linux_Common_Types_Unsigned_32);\n  api_put_InitiateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_VPM_ben__Linux_Common_Types_Unsigned_32, t11);\n\n  api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_ADSB_Messages_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(ADSB_Messages_In_str);\n    String__append(SF (String) &ADSB_Messages_In_str, string(\"Received on ADSB_Messages_In: \"));\n    byte_array_string(SF (String) &ADSB_Messages_In_str, t0, numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &ADSB_Messages_In_str);\n  }\n\n  uint8_t t1[numBytes_VPM_ben__Linux_DTU_Types_Response_Message_impl];\n  size_t t1_numBits;\n  if(api_get_Response_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_VPM_ben__Linux_DTU_Types_Response_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Response_In_str);\n    String__append(SF (String) &Response_In_str, string(\"Received on Response_In: \"));\n    byte_array_string(SF (String) &Response_In_str, t1, numBytes_VPM_ben__Linux_DTU_Types_Response_Message_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Response_In_str);\n  }\n\n  uint8_t t2[numBytes_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl];\n  size_t t2_numBits;\n  if(api_get_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl, \"numBits received does not match expected\");\n\n    DeclNewString(AttestationRequest_str);\n    String__append(SF (String) &AttestationRequest_str, string(\"Received on AttestationRequest: \"));\n    byte_array_string(SF (String) &AttestationRequest_str, t2, numBytes_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &AttestationRequest_str);\n  }\n\n  uint8_t t3[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl];\n  size_t t3_numBits;\n  if(api_get_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_HEADER_adsb_to_ptab_str);\n    String__append(SF (String) &SHM_HEADER_adsb_to_ptab_str, string(\"Received on SHM_HEADER_adsb_to_ptab: \"));\n    byte_array_string(SF (String) &SHM_HEADER_adsb_to_ptab_str, t3, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_HEADER_adsb_to_ptab_str);\n  }\n\n  uint8_t t4[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  size_t t4_numBits;\n  if(api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t4_numBits, t4)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t4_numBits == numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t4, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Connection_Command_In_str);\n  }\n\n  uint8_t t5[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  size_t t5_numBits;\n  if(api_get_Suspect_Traffic_In1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t5_numBits, t5)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t5_numBits == numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In1_str);\n    String__append(SF (String) &Suspect_Traffic_In1_str, string(\"Received on Suspect_Traffic_In1: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In1_str, t5, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In1_str);\n  }\n\n  uint8_t t6[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  size_t t6_numBits;\n  if(api_get_Suspect_Traffic_In2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t6_numBits, t6)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t6_numBits == numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In2_str);\n    String__append(SF (String) &Suspect_Traffic_In2_str, string(\"Received on Suspect_Traffic_In2: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In2_str, t6, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In2_str);\n  }\n\n  uint8_t t7[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  size_t t7_numBits;\n  if(api_get_Suspect_Traffic_In3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t7_numBits, t7)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t7_numBits == numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In3_str);\n    String__append(SF (String) &Suspect_Traffic_In3_str, string(\"Received on Suspect_Traffic_In3: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In3_str, t7, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In3_str);\n  }\n\n  uint8_t t8[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl];\n  size_t t8_numBits;\n  if(api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t8_numBits, t8)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t8_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Request_In_str);\n    String__append(SF (String) &SHM_QUEUE_Request_In_str, string(\"Received on SHM_QUEUE_Request_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Request_In_str, t8, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_QUEUE_Request_In_str);\n  }\n\n  uint8_t t9[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl];\n  size_t t9_numBits;\n  if(api_get_SHM_QUEUE_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t9_numBits, t9)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t9_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_AttestationResponse_str);\n    String__append(SF (String) &SHM_QUEUE_AttestationResponse_str, string(\"Received on SHM_QUEUE_AttestationResponse: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_AttestationResponse_str, t9, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_QUEUE_AttestationResponse_str);\n  }\n\n  uint8_t t10[numBytes_VPM_ben__Linux_Common_Types_Unsigned_32];\n  size_t t10_numBits;\n  if(api_get_TerminateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t10_numBits, t10)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t10_numBits == numBits_VPM_ben__Linux_Common_Types_Unsigned_32, \"numBits received does not match expected\");\n\n    DeclNewString(TerminateAttestation_str);\n    String__append(SF (String) &TerminateAttestation_str, string(\"Received on TerminateAttestation: \"));\n    byte_array_string(SF (String) &TerminateAttestation_str, t10, numBytes_VPM_ben__Linux_Common_Types_Unsigned_32);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &TerminateAttestation_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_API_H\n#define ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_ADSB_Messages_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Response_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Heartbeat_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Ownship_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Traffic_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Response_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_InitiateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_TerminateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_low_impl_SW_adapter_low_adapter_low_api.h>\n#include <adapter_low_impl_SW_adapter_low_adapter_low.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_ADSB_Messages_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_ADSB_Messages_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_ADSB_Messages_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Response_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Response_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_Response_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_AttestationRequest_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Heartbeat_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Heartbeat_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Heartbeat_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Ownship_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Ownship_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Ownship_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Traffic_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Traffic_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_Response_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Response_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Response_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_AttestationRequest__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_AttestationRequest_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_SHM_HEADER_adsb_to_ptab_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Suspect_Traffic_In1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In1_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out1__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out1_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Suspect_Traffic_In2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In2_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out2__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out2_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Suspect_Traffic_In3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In3_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out3__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out3_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_QUEUE_Request_In__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_SHM_QUEUE_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_QUEUE_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_SHM_QUEUE_AttestationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_AttestationResponse__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_AttestationResponse_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_InitiateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_InitiateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_put_InitiateAttestation_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_TerminateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_TerminateAttestation__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_AC43CD = Option[VPM_ben__Linux.VPM.adapter_low_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Operational_Api(api);\n  Option_AC43CD_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api_get_TerminateAttestation_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_B9A9DE = Option[VPM_ben__Linux.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_B9A9DE_get_(SF (VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_low_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise\", 0);\n\n  VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise\", 0);\n\n  VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_low_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/adapter_high_impl_SW_adapter_high_adapter_high_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject adapter_high_impl_SW_adapter_high_adapter_high_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.entryPoints\n  val appPortId: Art.PortId = IPCPorts.adapter_high_impl_SW_adapter_high_adapter_high_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val SHM_QUEUE_ADSB_Heartbeat_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Heartbeat_In.id\n  val SHM_QUEUE_ADSB_Heartbeat_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_ADSB_Heartbeat_InPortId)\n  val SHM_QUEUE_ADSB_Ownship_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Ownship_In.id\n  val SHM_QUEUE_ADSB_Ownship_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_ADSB_Ownship_InPortId)\n  val SHM_QUEUE_ADSB_Traffic_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Traffic_In.id\n  val SHM_QUEUE_ADSB_Traffic_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_ADSB_Traffic_InPortId)\n  val SHM_QUEUE_Response_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_Response_In.id\n  val SHM_QUEUE_Response_InPortIdOpt: Option[Art.PortId] = Some(SHM_QUEUE_Response_InPortId)\n  val Request_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Request_In.id\n  val Request_InPortIdOpt: Option[Art.PortId] = Some(Request_InPortId)\n  val Connection_Command_InPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_In.id\n  val Connection_Command_InPortIdOpt: Option[Art.PortId] = Some(Connection_Command_InPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_ADSB_Heartbeat_InPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_ADSB_Ownship_InPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_ADSB_Traffic_InPortIdOpt)\n    Platform.initialise(seed, SHM_QUEUE_Response_InPortIdOpt)\n    Platform.initialise(seed, Request_InPortIdOpt)\n    Platform.initialise(seed, Connection_Command_InPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_ADSB_Heartbeat_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_ADSB_Heartbeat_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_ADSB_Heartbeat_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_ADSB_Ownship_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_ADSB_Ownship_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_ADSB_Ownship_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_ADSB_Traffic_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_ADSB_Traffic_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_ADSB_Traffic_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(SHM_QUEUE_Response_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(SHM_QUEUE_Response_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port SHM_QUEUE_Response_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Request_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Request_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Request_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(Connection_Command_InPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(Connection_Command_InPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Connection_Command_In.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(250)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"adapter_high_impl_SW_adapter_high_adapter_high_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_SHM_QUEUE_ADSB_Heartbeat_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Heartbeat_In()\n      val apiUsage_SHM_QUEUE_ADSB_Ownship_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Ownship_In()\n      val apiUsage_SHM_QUEUE_ADSB_Traffic_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Traffic_In()\n      val apiUsage_SHM_QUEUE_Response_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_Response_In()\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Response_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Response_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      val apiUsage_Request_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Request_In()\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Connection_Command_In()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_H\n#define ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_high_impl_SW_adapter_high_adapter_high_api.h>\n#include <adapter_high_impl_SW_adapter_high_adapter_high.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_DTU_Types_Response_Message_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_DTU_Types_Response_Message_impl, numBytes_VPM_ben__Linux_DTU_Types_Response_Message_impl);\n  api_put_Response_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_VPM_ben__Linux_DTU_Types_Response_Message_impl, t0);\n\n  uint8_t t1[numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl];\n  byte_array_default(SF t1, numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl);\n  api_put_ADSB_Messages_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, t1);\n\n  uint8_t t2[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl];\n  byte_array_default(SF t2, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl);\n  api_put_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl, t2);\n\n  uint8_t t3[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t3, numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, t3);\n\n  uint8_t t4[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl];\n  byte_array_default(SF t4, numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl);\n  api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl, t4);\n\n  api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl];\n  size_t t0_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Heartbeat_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Heartbeat_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str, string(\"Received on SHM_QUEUE_ADSB_Heartbeat_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str, t0, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str);\n  }\n\n  uint8_t t1[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl];\n  size_t t1_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Ownship_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Ownship_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str, string(\"Received on SHM_QUEUE_ADSB_Ownship_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str, t1, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str);\n  }\n\n  uint8_t t2[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl];\n  size_t t2_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Traffic_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Traffic_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str, string(\"Received on SHM_QUEUE_ADSB_Traffic_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str, t2, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str);\n  }\n\n  uint8_t t3[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl];\n  size_t t3_numBits;\n  if(api_get_SHM_QUEUE_Response_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Response_In_str);\n    String__append(SF (String) &SHM_QUEUE_Response_In_str, string(\"Received on SHM_QUEUE_Response_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Response_In_str, t3, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_Response_In_str);\n  }\n\n  uint8_t t4[numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl];\n  size_t t4_numBits;\n  if(api_get_Request_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t4_numBits, t4)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t4_numBits == numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Request_In_str);\n    String__append(SF (String) &Request_In_str, string(\"Received on Request_In: \"));\n    byte_array_string(SF (String) &Request_In_str, t4, numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &Request_In_str);\n  }\n\n  uint8_t t5[numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl];\n  size_t t5_numBits;\n  if(api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t5_numBits, t5)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t5_numBits == numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t5, numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl);\n    api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &Connection_Command_In_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_API_H\n#define ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_ADSB_Heartbeat_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_ADSB_Ownship_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_ADSB_Traffic_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_Response_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Response_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_ADSB_Messages_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Request_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_high_impl_SW_adapter_high_adapter_high_api.h>\n#include <adapter_high_impl_SW_adapter_high_adapter_high.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_ADSB_Heartbeat_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Heartbeat_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Heartbeat_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_ADSB_Ownship_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Ownship_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Ownship_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_ADSB_Traffic_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Traffic_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Traffic_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_Response_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_Response_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_Response_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Response_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_Response_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_put_Response_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_ADSB_Messages_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_ADSB_Messages_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_put_ADSB_Messages_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_SHM_HEADER_adsb_to_ptab__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_put_SHM_HEADER_adsb_to_ptab_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_Connection_Command_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Request_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_Request_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_Connection_Command_In__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_CA17A5 = Option[VPM_ben__Linux.VPM.adapter_high_impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Operational_Api(api);\n  Option_CA17A5_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_A6EA6A = Option[VPM_ben__Linux.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_A6EA6A_get_(SF (VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api) &api, VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_high_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise\", 0);\n\n  VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise\", 0);\n\n  VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_adapter_high_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\nimport art.scheduling.nop.NopScheduler\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val ObservedPortId: Art.PortId = Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Observed.id\n  val ObservedPortIdOpt: Option[Art.PortId] = Some(ObservedPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, ObservedPortIdOpt)\n\n    Art.run(Arch.ad, NopScheduler())\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(ObservedPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(ObservedPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port Observed.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    VPM_ben__Linux.Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ add types used in Platform.receive and Platform.receiveAsync\n      val mbox2Boolean_Payload: MBox2[Art.PortId, DataContent] = MBox2(0, Base_Types.Boolean_Payload(T))\n      val mbox2OptionDataContent: MBox2[Art.PortId, Option[DataContent]] = MBox2(0, None())\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logError(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logInfo(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logDebug(\"\")\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.get_Observed()\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_H\n#define CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_H\n\n#include <all.h>\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(STACK_FRAME_ONLY);\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logInfo\"));\n\n  api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logDebug\"));\n\n  api_logError__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logError\"));\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_\", 0);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_API_H\n#define CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_get_Observed__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_ED6CC5 = Option[VPM_ben__Linux.VPM.CASE_Monitor3_Impl_Operational_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor3_Impl_Operational_Api(api);\n  Option_ED6CC5_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Operational_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_operational_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_put_Suspect_Traffic_Out__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_8D3E8F = Option[VPM_ben__Linux.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_8D3E8F_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logInfo__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_8D3E8F = Option[VPM_ben__Linux.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_8D3E8F_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logDebug__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_8D3E8F = Option[VPM_ben__Linux.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_8D3E8F_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logError__VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_8D3E8F = Option[VPM_ben__Linux.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewVPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_8D3E8F_get_(SF (VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(SF_LAST);\n}\n\nUnit VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered(\n  STACK_FRAME\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered\", 0);\n\n  VPM_ben__Linux_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n\/\/ example method that sets the first numBits bits of byteArray to 1\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_default\", 0);\n\n  sfAssert(SF (numBits - 1) \/ 8  + 1 <= numBytes, \"byte_array_default: numBytes * 8 must be at least numBits\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    uint8_t v = 0;\n    for(uint8_t bit = 0; bit < 8; bit++) {\n      if(byte * 8 + bit < numBits) {\n        v |= 1UL << bit;\n      }\n    }\n    byteArray[byte] = v;\n  }\n}\n\n\/\/ example method that places the hex value of the bytes in byteArray into str\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_string\", 0);\n\n  sfAssert(SF (str->size + numBytes) <= MaxString, \"byte_array_string: Insufficient maximum for String characters, consider increasing the --max-string-size option\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    U8_string_(SF str, byteArray[byte]);\n    String__append(SF str, string(\" \"));\n  }\n}\n\n\/\/ example method that directly prints the hex values of the bytes in byte_array\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"hex_dump\", 0);\n\n  printf(\"[ \");\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    if(byte != 0 && byte % 16 == 0) { printf(\"\\n  \"); }\n    printf(\"%02X \", byte_array[byte]);\n  }\n  printf(\"]\\n\");\n}",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n\/\/ bit-codec size for VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl\n#define numBits_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl 256\n#define numBytes_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl ((numBits_VPM_ben__Linux_VPM_CASE_AttestationRequestMsg_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl\n#define numBits_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl 16384\n#define numBytes_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl ((numBits_VPM_ben__Linux_VPM_CASE_AttestationResponseMsg_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_WhiteList_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_WhiteList_impl 128\n#define numBytes_VPM_ben__Linux_CASE_Proxies_WhiteList_impl ((numBits_VPM_ben__Linux_CASE_Proxies_WhiteList_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_Common_Types_Unsigned_32\n#define numBits_VPM_ben__Linux_Common_Types_Unsigned_32 32\n#define numBytes_VPM_ben__Linux_Common_Types_Unsigned_32 ((numBits_VPM_ben__Linux_Common_Types_Unsigned_32 - 1) \/ 8 + 1)\n\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes);\n\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes);\n\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes);\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_request_array_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_connection_command_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl 192\n#define numBytes_VPM_ben__Linux_CASE_Proxies_connection_command_impl ((numBits_VPM_ben__Linux_CASE_Proxies_connection_command_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl\n#define numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl 35088\n#define numBytes_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl ((numBits_VPM_ben__Linux_ADSB_Types_ADSB_Aggregated_Message_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_ADSB_Types_MonitorReport_impl\n#define numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl 4832\n#define numBytes_VPM_ben__Linux_ADSB_Types_MonitorReport_impl ((numBits_VPM_ben__Linux_ADSB_Types_MonitorReport_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_DTU_Types_Response_Message_impl\n#define numBits_VPM_ben__Linux_DTU_Types_Response_Message_impl 16384\n#define numBytes_VPM_ben__Linux_DTU_Types_Response_Message_impl ((numBits_VPM_ben__Linux_DTU_Types_Response_Message_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_Heartbeat_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_ownship_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_adsb_traffic_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_response_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_request_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl 256\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_header_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_monitor_report_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_vdtu_request_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl\n#define numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl 65792\n#define numBytes_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl ((numBits_VPM_ben__Linux_CASE_Proxies_shm_queue_attestation_response_impl - 1) \/ 8 + 1)\n#endif",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/SharedMemory.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object SharedMemory {\n  def create(id: Z): Z = $\n  def get(id: Z): Z = $\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = $\n  def receive(port: Art.PortId, out: MBox2[Art.PortId, DataContent]): Unit = $\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = $\n  def receiveAsync(port: Art.PortId, out: MBox2[Art.PortId, Option[DataContent]]): Unit = $\n  def remove(id: Z): Unit = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/SharedMemory_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject SharedMemory_Ext {\n  def create(id: Z): Z = halt(\"stub\")\n  def get(id: Z): Z = halt(\"stub\")\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = halt(\"stub\")\n  def receive(port: Art.PortId, out: MBox2[Art.PortId, DataContent]): Unit = halt(\"stub\")\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = halt(\"stub\")\n  def receiveAsync(port: Art.PortId, out: MBox2[Art.PortId, Option[DataContent]]): Unit = halt(\"stub\")\n  def remove(id: Z): Unit = halt(\"stub\")\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/IPC.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject IPCPorts {\n  val CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App: Art.PortId = 50\n  val CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App: Art.PortId = 51\n  val CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App: Art.PortId = 52\n  val CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App: Art.PortId = 53\n  val adapter_low_impl_SW_adapter_low_adapter_low_App: Art.PortId = 54\n  val adapter_high_impl_SW_adapter_high_adapter_high_App: Art.PortId = 55\n  val CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App: Art.PortId = 56\n  val Main: Art.PortId = 57\n\n  def emptyReceiveOut: MBox2[Art.PortId, DataContent] = {\n    return MBox2(-1, art.Empty())\n  }\n\n  def emptyReceiveAsyncOut: MBox2[Art.PortId, Option[DataContent]] = {\n    return MBox2(-1, None())\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/ArtNix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ArtNix {\n\n  val maxPortIds: Art.PortId = IPCPorts.Main + 1\n  val timeTriggered: TimeTriggered = TimeTriggered()\n  val noData: Option[DataContent] = None()\n  val data: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  val connection: MS[Art.PortId, ISZ[(Art.PortId, Art.PortId)]] = {\n    val r = MS.create[Art.PortId, ISZ[(Art.PortId, Art.PortId)]](maxPortIds, ISZ())\n\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationRequest.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationRequest.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TrustedIds.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.TrustedIds.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TerminateAttestation.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.TerminateAttestation.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_Out.id) = ISZ(\n      (IPCPorts.adapter_high_impl_SW_adapter_high_adapter_high_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Request_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_Out.id) = ISZ(\n      (IPCPorts.adapter_high_impl_SW_adapter_high_adapter_high_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Suspect_Traffic_Out.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In1.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Suspect_Traffic_Out.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In2.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_Request_Out.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationResponse.id) = ISZ(\n      (IPCPorts.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationResponse.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_Out.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.InitiateAttestation.id) = ISZ(\n      (IPCPorts.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.InitiateAttestation.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Response_Out.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Response_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out.id) = ISZ(\n      (IPCPorts.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Observed.id),\n      (IPCPorts.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Observed.id),\n      (IPCPorts.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App, Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Observed.id),\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.ADSB_Messages_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_HEADER_adsb_to_ptab.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_HEADER_adsb_to_ptab.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_Out.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_In.id)\n    )\n    r(Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Suspect_Traffic_Out.id) = ISZ(\n      (IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In3.id)\n    )\n\n    r\n  }\n  val eventInPorts: MS[Z, Art.PortId] = MSZ(\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationResponse.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.InitiateAttestation.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.TrustedIds.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Observed.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Observed.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.ADSB_Messages_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Response_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationRequest.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_HEADER_adsb_to_ptab.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In1.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In2.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In3.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_Request_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_AttestationResponse.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.TerminateAttestation.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Heartbeat_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Ownship_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_ADSB_Traffic_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_QUEUE_Response_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Request_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_In.id,\n    Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Observed.id\n  )\n  var frozen: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  var outgoing: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  var isTimeDispatch: B = F\n\n  def updateData(port: Art.PortId, d: DataContent): Unit = {\n    data(port) = Some(d)\n  }\n\n  def timeDispatch(): Unit = {\n    isTimeDispatch = T\n  }\n\n  def eventDispatch(): Unit = {\n    isTimeDispatch = F\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    if (isTimeDispatch) {\n      return timeTriggered\n    } else {\n      var r = ISZ[Art.PortId]()\n      for (i <- eventInPorts if data(i).nonEmpty) {\n        r = r :+ i\n      }\n      return EventTriggered(r)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    frozen = data\n    for (i <- eventPortIds) {\n      data(i) = noData\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    outgoing(portId) = Some(data)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    return frozen(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (p <- dataPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n\n    for (p <- eventPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n\n  def run(): Unit = {}\n\n  def tearDownSystemState(): Unit = {}\n\n  def setUpSystemState(): Unit = {}\n\n  def initializePhase(): Unit = {}\n\n  def computePhase(): Unit = {}\n\n  def finalizePhase(): Unit = {}\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/LegacyDemo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject LegacyDemo extends App {\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    Platform.initialise(seed, None())\n\n    val empty = art.Empty()\n\n    Platform.sendAsync(IPCPorts.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App, IPCPorts.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App, IPCPorts.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App, IPCPorts.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App, IPCPorts.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App, empty)\n    Platform.sendAsync(IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, IPCPorts.adapter_low_impl_SW_adapter_low_adapter_low_App, empty)\n    Platform.sendAsync(IPCPorts.adapter_high_impl_SW_adapter_high_adapter_high_App, IPCPorts.adapter_high_impl_SW_adapter_high_adapter_high_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App, IPCPorts.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App, empty)\n\n    Platform.finalise()\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/Platform.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Platform {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = $\n  def receive(portOpt: Option[Art.PortId],  out: MBox2[Art.PortId, DataContent]): Unit = $\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = $\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = $\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = $\n  def finalise(): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/Platform_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Platform_Ext {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = halt(\"stub\")\n  def receive(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, DataContent]) = halt(\"stub\")\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = halt(\"stub\")\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = halt(\"stub\")\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = halt(\"stub\")\n  def finalise(): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/PlatformNix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject PlatformNix {\n\n  var seed: Z = 0\n  var ids: ISZ[Z] = ISZ()\n\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = {\n    PlatformNix.seed = seed\n    portOpt match {\n      case Some(port) =>\n        val id = seed + port\n        SharedMemory.create(id)\n        ids = ids :+ id\n      case _ =>\n    }\n  }\n\n  def receive(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, DataContent]): Unit = {\n    portOpt match {\n      case Some(port) =>\n        out.value1 = port\n        SharedMemory.receive(seed + port, out)\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = {\n    SharedMemory.send(port, seed + port, data)\n  }\n\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = {\n    val r = SharedMemory.sendAsync(port, seed + port, data)\n    return r\n  }\n\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = {\n    portOpt match {\n      case Some(port) => SharedMemory.receiveAsync(seed + port, out)\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def finalise(): Unit = {\n    for (id <- ids) {\n      SharedMemory.remove(id)\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/Process.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage VPM_ben__Linux\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Process {\n  def sleep(n: Z): Unit = $\n\n  def time(): Art.Time = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/nix\/VPM_ben__Linux\/Process_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package VPM_ben__Linux\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Process_Ext {\n  def sleep(millis: Z): Unit = halt(\"stub\")\n\n  def time(): Art.Time = halt(\"stub\")\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/bin\/compile.cmd",
        {
          "type" : "TestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\n\/\/ This file was auto-generated.  Do not edit\r\n\r\nval home = Os.slashDir\r\n\r\nCli(Os.pathSepChar).parseCompile(Os.cliArgs, 0) match {\r\n  case Some(o: Cli.CompileOption) if o.args.size == 0 =>\r\n    var cmake: ISZ[String] = ISZ(\"cmake\")\r\n    if(o.boundCheck) { cmake = cmake :+ \"-DBOUND_CHECK=ON\" }\r\n    if(o.noPrint) { cmake = cmake :+ \"-DNO_PRINT=ON\" }\r\n    if(o.rangeCheck) { cmake = cmake :+ \"-DRANGE_CHECK=ON\" }\r\n    if(o.withLoc) { cmake = cmake :+ \" -DWITH_LOC=ON\" }\r\n    cmake = (cmake :+ \"-DCMAKE_BUILD_TYPE=Release\") :+ \"..\"\r\n\r\n    val nixDir = home \/ \"\/..\/nix\" \/ \"slang-build\"\r\n    if(!nixDir.up.exists){\r\n      eprintln(s\"Directory does not exist, have your run the transpiler? ${nixDir.up}\")\r\n      Os.exit(-1)\r\n    }\r\n    nixDir.mkdir()\r\n\r\n    if(Os.proc(cmake).at(nixDir).console.run().ok) {\r\n      val MAKE_ARGS: String = Os.env(\"MAKE_ARGS\") match {\r\n        case Some(o) => o\r\n        case _ => \"\"\r\n      }\r\n      if(proc\"make ${MAKE_ARGS}\".at(nixDir).console.run().ok) {\r\n        val binDir = home \/ \"slang-build\"\r\n        binDir.removeAll()\r\n        binDir.mkdir()\r\n\r\n        if(Os.isWin) {\r\n          nixDir.list.filter(p => p.ext == \"exe\").foreach((f: Os.Path) => f.moveTo(binDir \/ f.name))\r\n        } else {\r\n          nixDir.list.filter(p => ops.StringOps(p.name).endsWith(\"_App\")).foreach((f: Os.Path) => f.moveTo(binDir \/ f.name))\r\n          val candidates: ISZ[Os.Path] = ISZ[String](\"Demo\", \"LegacyDemo\").map((m: String) => nixDir \/ m)\r\n          val main: ISZ[Os.Path] = candidates.filter((p: Os.Path) => p.exists)\r\n          if(main.isEmpty || main.size > 1) {\r\n            eprintln(s\"Found ${main.size} possible main programs.  There should be only one of the following: ${candidates}\")\r\n            Os.exit(1)\r\n          }\r\n          main(0).moveTo(binDir \/ main(0).name)\r\n        }\r\n        Os.exit(0)\r\n      }\r\n    }\r\n  case Some(o: Cli.CompileOption) =>\r\n    println(o.help)\r\n    Os.exit(0)\r\n  case Some(o: Cli.HelpOption) => Os.exit(0)\r\n  case _ =>\r\n    eprintln(\"Could not recognize arguments\")\r\n}\r\n\r\nOs.exit(-1)\r\n\r\nimport org.sireum._\r\n\r\nobject Cli {\r\n\r\n  @datatype trait CompileTopOption\r\n\r\n  @datatype class HelpOption extends CompileTopOption\r\n\r\n  @datatype class CompileOption(\r\n    val help: String,\r\n    val args: ISZ[String],\r\n    val boundCheck: B,\r\n    val noPrint: B,\r\n    val rangeCheck: B,\r\n    val withLoc: B\r\n  ) extends CompileTopOption\r\n}\r\n\r\nimport Cli._\r\n\r\n@record class Cli(val pathSep: C) {\r\n\r\n  def parseCompile(args: ISZ[String], i: Z): Option[CompileTopOption] = {\r\n    val help =\r\n      st\"\"\"Compile Slang Embedded Programs\r\n          |\r\n          |Usage: <option>*\r\n          |\r\n          |Available Options:\r\n          |-b, --bound-check        Build the program with sequence bound checking\r\n          |-p, --no-print           Build the program without console output\r\n          |-r, --range-check        Build the program with range checking\r\n          |-l, --with-loc           Build the program with Slang location info\r\n          |-h, --help               Display this information\"\"\".render\r\n\r\n    var boundCheck: B = false\r\n    var noPrint: B = false\r\n    var rangeCheck: B = false\r\n    var withLoc: B = false\r\n    var j = i\r\n    var isOption = T\r\n    while (j < args.size && isOption) {\r\n      val arg = args(j)\r\n      if (ops.StringOps(arg).first == '-') {\r\n        if (args(j) == \"-h\" || args(j) == \"--help\") {\r\n          println(help)\r\n          return Some(HelpOption())\r\n        } else if (arg == \"-b\" || arg == \"--bound-check\") {\r\n           val o: Option[B] = { j = j - 1; Some(!boundCheck) }\r\n           o match {\r\n             case Some(v) => boundCheck = v\r\n             case _ => return None()\r\n           }\r\n         } else if (arg == \"-p\" || arg == \"--no-print\") {\r\n           val o: Option[B] = { j = j - 1; Some(!noPrint) }\r\n           o match {\r\n             case Some(v) => noPrint = v\r\n             case _ => return None()\r\n           }\r\n         } else if (arg == \"-r\" || arg == \"--range-check\") {\r\n           val o: Option[B] = { j = j - 1; Some(!rangeCheck) }\r\n           o match {\r\n             case Some(v) => rangeCheck = v\r\n             case _ => return None()\r\n           }\r\n         } else if (arg == \"-l\" || arg == \"--with-loc\") {\r\n           val o: Option[B] = { j = j - 1; Some(!withLoc) }\r\n           o match {\r\n             case Some(v) => withLoc = v\r\n             case _ => return None()\r\n           }\r\n         } else {\r\n          eprintln(s\"Unrecognized option '$arg'.\")\r\n          return None()\r\n        }\r\n        j = j + 2\r\n      } else {\r\n        isOption = F\r\n      }\r\n    }\r\n    return Some(CompileOption(help, parseArguments(args, j), boundCheck, noPrint, rangeCheck, withLoc))\r\n  }\r\n\r\n  def parseArguments(args: ISZ[String], i: Z): ISZ[String] = {\r\n    var r = ISZ[String]()\r\n    var j = i\r\n    while (j < args.size) {\r\n      r = r :+ args(j)\r\n      j = j + 1\r\n    }\r\n    return r\r\n  }\r\n\r\n  def parsePaths(args: ISZ[String], i: Z): Option[ISZ[String]] = {\r\n    return tokenize(args, i, \"path\", pathSep, F)\r\n  }\r\n\r\n  def parsePath(args: ISZ[String], i: Z): Option[Option[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(\"Expecting a path, but none found.\")\r\n    }\r\n    return Some(Some(args(i)))\r\n  }\r\n\r\n  def parseStrings(args: ISZ[String], i: Z, sep: C): Option[ISZ[String]] = {\r\n    tokenize(args, i, \"string\", sep, F) match {\r\n      case r@Some(_) => return r\r\n      case _ => return None()\r\n    }\r\n  }\r\n\r\n  def parseString(args: ISZ[String], i: Z): Option[Option[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(\"Expecting a string, but none found.\")\r\n      return None()\r\n    }\r\n    return Some(Some(args(i)))\r\n  }\r\n\r\n  def parseNums(args: ISZ[String], i: Z, sep: C, minOpt: Option[Z], maxOpt: Option[Z]): Option[ISZ[Z]] = {\r\n    tokenize(args, i, \"integer\", sep, T) match {\r\n      case Some(sargs) =>\r\n        var r = ISZ[Z]()\r\n        for (arg <- sargs) {\r\n          parseNumH(arg, minOpt, maxOpt) match {\r\n            case Some(n) => r = r :+ n\r\n            case _ => return None()\r\n          }\r\n        }\r\n        return Some(r)\r\n      case _ => return None()\r\n    }\r\n  }\r\n\r\n  def tokenize(args: ISZ[String], i: Z, tpe: String, sep: C, removeWhitespace: B): Option[ISZ[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(s\"Expecting a sequence of $tpe separated by '$sep', but none found.\")\r\n      return None()\r\n    }\r\n    val arg = args(i)\r\n    return Some(tokenizeH(arg, sep, removeWhitespace))\r\n  }\r\n\r\n  def tokenizeH(arg: String, sep: C, removeWhitespace: B): ISZ[String] = {\r\n    val argCis = conversions.String.toCis(arg)\r\n    var r = ISZ[String]()\r\n    var cis = ISZ[C]()\r\n    var j = 0\r\n    while (j < argCis.size) {\r\n      val c = argCis(j)\r\n      if (c == sep) {\r\n        r = r :+ conversions.String.fromCis(cis)\r\n        cis = ISZ[C]()\r\n      } else {\r\n        val allowed: B = c match {\r\n          case c\"\\n\" => !removeWhitespace\r\n          case c\" \" => !removeWhitespace\r\n          case c\"\\r\" => !removeWhitespace\r\n          case c\"\\t\" => !removeWhitespace\r\n          case _ => T\r\n        }\r\n        if (allowed) {\r\n          cis = cis :+ c\r\n        }\r\n      }\r\n      j = j + 1\r\n    }\r\n    if (cis.size > 0) {\r\n      r = r :+ conversions.String.fromCis(cis)\r\n    }\r\n    return r\r\n  }\r\n\r\n  def parseNumChoice(args: ISZ[String], i: Z, choices: ISZ[Z]): Option[Z] = {\r\n    val set = HashSet.empty[Z] ++ choices\r\n    parseNum(args, i, None(), None()) match {\r\n      case r@Some(n) =>\r\n        if (set.contains(n)) {\r\n          return r\r\n        } else {\r\n          eprintln(s\"Expecting one of the following: $set, but found $n.\")\r\n          return None()\r\n        }\r\n      case r => return r\r\n    }\r\n  }\r\n\r\n  def parseNum(args: ISZ[String], i: Z, minOpt: Option[Z], maxOpt: Option[Z]): Option[Z] = {\r\n    if (i >= args.size) {\r\n      eprintln(s\"Expecting an integer, but none found.\")\r\n      return None()\r\n    }\r\n    return parseNumH(args(i), minOpt, maxOpt)\r\n  }\r\n\r\n  def parseNumH(arg: String, minOpt: Option[Z], maxOpt: Option[Z]): Option[Z] = {\r\n    Z(arg) match {\r\n      case Some(n) =>\r\n        minOpt match {\r\n          case Some(min) =>\r\n            if (n < min) {\r\n              eprintln(s\"Expecting an integer at least $min, but found $n.\")\r\n              return None()\r\n            }\r\n          case _ =>\r\n        }\r\n        maxOpt match {\r\n          case Some(max) =>\r\n            if (n > max) {\r\n              eprintln(s\"Expecting an integer at most $max, but found $n.\")\r\n              return None()\r\n            }\r\n            return Some(n)\r\n          case _ =>\r\n        }\r\n        return Some(n)\r\n      case _ =>\r\n        eprintln(s\"Expecting an integer, but found '$arg'.\")\r\n        return None()\r\n    }\r\n  }\r\n\r\n  def select(mode: String, args: ISZ[String], i: Z, choices: ISZ[String]): Option[String] = {\r\n    val arg = args(i)\r\n    var cs = ISZ[String]()\r\n    for (c <- choices) {\r\n      if (ops.StringOps(c).startsWith(arg)) {\r\n        cs = cs :+ c\r\n      }\r\n    }\r\n    cs.size match {\r\n      case z\"0\" =>\r\n        eprintln(s\"$arg is not a mode of $mode.\")\r\n        return None()\r\n      case z\"1\" => return Some(cs(0))\r\n      case _ =>\r\n        eprintln(\r\n          st\"\"\"Which one of the following modes did you mean by '$arg'?\r\n              |${(cs, \"\\n\")}\"\"\".render)\r\n        return None()\r\n    }\r\n  }\r\n}\r\n\/\/ @formatter:on\r\n\r\n\/\/ BEGIN USER CODE\r\n\r\n\/\/ END USER CODE\r\n\r\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/bin\/run.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd $SCRIPT_HOME\n\n# Uncomment the following to prevent terminal from closing when the app shuts down or crashes\n#PREVENT_CLOSE=\"; bash -i\"\n\n\nOPTIONS=s:\nLONGOPTS=scheduler:\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-s, --scheduler        The scheduler to use (expects one of\"\n  echo \"                         { default, roundRobin, static, legacy};\"\n  echo \"                         default: default)\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nSCHEDULER=\"default\"\nwhile true; do\n  case \"$1\" in\n    -s|--scheduler)\n      case \"$2\" in\n        default|roundRobin|static|legacy)\n          SCHEDULER=\"$2\"\n          ;;\n        *)\n          echo \"Invalid scheduler: ${2}\"\n          exit 1\n          ;;\n      esac\n      shift 2\n      ;;\n    --) shift; break;\n      ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\nfunction launch() {\n  if [ \"$2\" ]; then SCHEDULER_ARG=\" -s ${2}\"; fi\n  if [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n    for APP in $1; do\n      cygstart mintty \/bin\/bash \"slang-build\/${APP}${SCHEDULER_ARG}${PREVENT_CLOSE}\" &\n    done\n  elif [[ \"$(uname)\" == \"Darwin\" ]]; then\n    for APP in $1; do\n      open -a Terminal \"slang-build\/${APP}${SCHEDULER_ARG}${PREVENT_CLOSE}\" &\n    done\n  elif [[ \"$(expr substr $(uname -s) 1 5)\" == \"Linux\" ]]; then\n    for APP in $1; do\n      x-terminal-emulator -T ${APP} -e sh -i -c \"slang-build\/${APP}${SCHEDULER_ARG}${PREVENT_CLOSE}\" &\n    done\n  else\n    >&2 echo \"Platform not supported: $(uname).\"\n    exit 1\n  fi\n}\n\nEXT=\"\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then EXT=\".exe\"; fi\n\ncase \"${SCHEDULER}\" in\n  legacy)\n    if [ ! -f .\/slang-build\/LegacyDemo${EXT} ]; then\n      if [ -f .\/slang-build\/Demo${EXT} ]; then\n        echo \"Error: Found program for Slang based schedulers.  Pass '--legacy' to the\"\n        echo \"transpiler script in order to use the legacy scheduler\"\n      else\n        echo \"Expected program not found: ${SCRIPT_HOME}\/slang-build\/LegacyDemo${EXT}.\"\n      fi\n      exit 1\n    fi\n\n    launch \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App${EXT} CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App${EXT} CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App${EXT} CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App${EXT} adapter_low_impl_SW_adapter_low_adapter_low_App${EXT} adapter_high_impl_SW_adapter_high_adapter_high_App${EXT} CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App${EXT}\";\n\n    read -p \"Press enter to initialise components ...\"\n    slang-build\/LegacyDemo${EXT}\n    read -p \"Press enter again to start ...\"\n    slang-build\/LegacyDemo${EXT}\n    ;;\n  *)\n    if [ ! -f .\/slang-build\/Demo${EXT} ]; then\n      if [ -f .\/slang-build\/LegacyDemo${EXT} ]; then\n        echo \"Error: Found program for the legacy scheduler. Either pass '-s legacy' to the\"\n        echo \"run script if you want to use the legacy scheduler, or, do not pass\"\n        echo \"'--legacy' to the transpiler script if you want to use a Slang based scheduler\"\n      else\n        echo \"Expected program not found: ${SCRIPT_HOME}\/slang-build\/Demo${EXT}\"\n      fi\n      exit 1\n    fi\n\n    launch \"Demo\" ${SCHEDULER};\n    ;;\nesac\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/bin\/stop.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nAPPS=\"Demo CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App adapter_low_impl_SW_adapter_low_adapter_low_App adapter_high_impl_SW_adapter_high_adapter_high_App CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App\"\nfor APP in ${APPS}; do\n  pkill -f -SIGTERM $APP\ndone\nME=`whoami`\n\n# message queue\nIPCS_Q=`ipcs -q | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -q $id;\ndone\n\n# shared memory\nIPCS_Q=`ipcs -m | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -m $id;\ndone\n\n# semaphores\nIPCS_Q=`ipcs -s | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -s $id;\ndone\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/c\/etc\/ipc.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n#include <sys\/types.h>\n#include <sys\/shm.h>\n#include <sys\/sem.h>\n#include <unistd.h>\n\n\/\/ This file is auto-generated.  Do not edit\n\nstatic inline void sem_op(int sid, short val) {\n    struct sembuf sem_op;\n    sem_op.sem_num = 0;\n    sem_op.sem_op = val;\n    sem_op.sem_flg = 0;\n    semop(sid, &sem_op, 1);\n}\n\nstatic inline void lock(int sid) {\n    sem_op(sid, -1);\n}\n\nstatic inline void unlock(int sid) {\n    sem_op(sid, 1);\n}\n\nstatic inline int create_sem(Z msgid) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n    int sem_set_id = semget((key_t) msgid, 1, mask | permission);\n\n    if (sem_set_id >= 0) {\n        union semun {\n            int val;\n            struct semid_ds *buf;\n            ushort *array;\n        } sem_val;\n        sem_val.val = 1;\n        semctl(sem_set_id, 0, SETVAL, sem_val);\n    }\n    return sem_set_id;\n}\n\nZ VPM_ben__Linux_SharedMemory_create(STACK_FRAME Z id) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n\n    create_sem(id);\n\n    int shmid = shmget((key_t) id, sizeof(union Option_8E9F45), (int) (permission | mask));\n    void *p = shmat(shmid, (void *) 0, 0);\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    return (Z) shmid;\n}\n\nUnit VPM_ben__Linux_SharedMemory_receive(STACK_FRAME Z port, MBox2_1CBFC4 out) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type != TSome_D29615) { \/\/ wait until there is a data\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    art_DataContent d = &p->Some_D29615.value;\n    Type_assign(&(out->value2), d, sizeOf((Type) d));\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    unlock(sid);\n}\n\nUnit VPM_ben__Linux_SharedMemory_receiveAsync(STACK_FRAME Z port, MBox2_1029D1 out) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    if (p->type == TSome_D29615) {\n        Type_assign(&(out->value2), p, sizeOf((Type) p));\n        memset(p, 0, sizeof(union Option_8E9F45));\n    } else {\n        out->value2.type = TNone_964667;\n    }\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nUnit VPM_ben__Linux_SharedMemory_send(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type == TSome_D29615) {\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nB VPM_ben__Linux_SharedMemory_sendAsync(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n    return T;\n}\n\nUnit VPM_ben__Linux_SharedMemory_remove(STACK_FRAME Z id) {\n    semctl(semget((key_t) id, 1, 0666), 0, IPC_RMID);\n    shmctl(shmget((key_t) id, sizeof(union Option_8E9F45), 0666), IPC_RMID, NULL);\n}\n\nUnit VPM_ben__Linux_Process_sleep(STACK_FRAME Z n) {\n    usleep((useconds_t) n * 1000);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/bin\/transpile.cmd",
        {
          "type" : "TestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\nimport org.sireum._\r\n\r\n\/\/ This file was auto-generated.  Do not edit\r\n\r\nval SCRIPT_HOME: Os.Path = Os.slashDir\r\nval PATH_SEP: String = Os.pathSep\r\n\r\nvar project: ISZ[String] = Cli(Os.pathSepChar).parseTranspile(Os.cliArgs, 0) match {\r\n  case Some(o: Cli.TranspileOption) =>\r\n    if(o.legacy) {\r\n      println(\"Using Legacy Scheduler\")\r\n\r\n      val main: ISZ[String] = ISZ(\r\n        \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\",\r\n        \"--output-dir\", s\"${SCRIPT_HOME}\/..\/src\/c\/nix\",\r\n        \"--name\", \"main\",\r\n        \"--apps\", \"VPM_ben__Linux.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_App,VPM_ben__Linux.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_App,VPM_ben__Linux.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_App,VPM_ben__Linux.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_App,VPM_ben__Linux.adapter_low_impl_SW_adapter_low_adapter_low_App,VPM_ben__Linux.adapter_high_impl_SW_adapter_high_adapter_high_App,VPM_ben__Linux.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_App,VPM_ben__Linux.LegacyDemo\",\r\n        \"--fingerprint\", \"3\",\r\n        \"--bits\", \"32\",\r\n        \"--string-size\", \"256\",\r\n        \"--sequence-size\", \"58\",\r\n        \"--sequence\", s\"IS[Z,art.Bridge]=7;MS[Z,Option[art.Bridge]]=7;IS[Z,art.UPort]=23;IS[Z,art.UConnection]=19;IS[Z,B]=65792\",\r\n        \"--constants\", s\"art.Art.maxComponents=7;art.Art.maxPorts=58\",\r\n        \"--forward\", \"art.ArtNative=VPM_ben__Linux.ArtNix,VPM_ben__Linux.Platform=VPM_ben__Linux.PlatformNix\",\r\n        \"--stack-size\", \"16*1024*1024\",\r\n        \"--stable-type-id\",\r\n        \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc\",\r\n        \"--exclude-build\", \"VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low,VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high,VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\")\r\n      main\r\n    } else {\r\n      val main: ISZ[String] = ISZ(\r\n        \"--sourcepath\", s\"${SCRIPT_HOME}\/..\/src\/main\",\r\n        \"--output-dir\", s\"${SCRIPT_HOME}\/..\/src\/c\/nix\",\r\n        \"--name\", \"main\",\r\n        \"--apps\", \"VPM_ben__Linux.Demo\",\r\n        \"--fingerprint\", \"3\",\r\n        \"--bits\", \"32\",\r\n        \"--string-size\", \"256\",\r\n        \"--sequence-size\", \"58\",\r\n        \"--sequence\", s\"IS[Z,art.Bridge]=7;MS[Z,Option[art.Bridge]]=7;IS[Z,art.UPort]=23;IS[Z,art.UConnection]=19;IS[Z,B]=65792\",\r\n        \"--constants\", s\"art.Art.maxComponents=7;art.Art.maxPorts=58\",\r\n        \"--forward\", \"art.ArtNative=art.ArtNativeSlang\",\r\n        \"--stack-size\", \"16*1024*1024\",\r\n        \"--stable-type-id\",\r\n        \"--exts\", s\"${SCRIPT_HOME}\/..\/src\/c\/ext-schedule${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc\",\r\n        \"--exclude-build\", \"VPM_ben__Linux.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,VPM_ben__Linux.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,VPM_ben__Linux.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,VPM_ben__Linux.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,VPM_ben__Linux.VPM.adapter_low_impl_SW_adapter_low_adapter_low,VPM_ben__Linux.VPM.adapter_high_impl_SW_adapter_high_adapter_high,VPM_ben__Linux.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\")\r\n      main\r\n    }\r\n  case Some(o: Cli.HelpOption) =>\r\n    Os.exit(0);\r\n    halt(\"\")\r\n  case _ =>\r\n    eprintln(\"Could not recognize arguments\")\r\n    Os.exit(-1)\r\n    halt(\"\")\r\n}\r\n\r\nprintln(\"Initializing runtime library ...\")\r\nSireum.initRuntimeLibrary()\r\n\r\nSireum.run(ISZ[String](\"slang\", \"transpilers\", \"c\") ++ project)\r\n\r\nimport org.sireum._\r\n\r\nobject Cli {\r\n\r\n  @datatype trait TranspileTopOption\r\n\r\n  @datatype class HelpOption extends TranspileTopOption\r\n\r\n  @datatype class TranspileOption(\r\n    val help: String,\r\n    val args: ISZ[String],\r\n    val legacy: B\r\n  ) extends TranspileTopOption\r\n}\r\n\r\nimport Cli._\r\n\r\n@record class Cli(val pathSep: C) {\r\n\r\n  def parseTranspile(args: ISZ[String], i: Z): Option[TranspileTopOption] = {\r\n    val help =\r\n      st\"\"\"Transpile Slang Embedded Program\r\n          |\r\n          |Usage: <option>*\r\n          |\r\n          |Available Options:\r\n          |-l, --legacy             Use legacy scheduler\r\n          |-h, --help               Display this information\"\"\".render\r\n\r\n    var legacy: B = false\r\n    var j = i\r\n    var isOption = T\r\n    while (j < args.size && isOption) {\r\n      val arg = args(j)\r\n      if (ops.StringOps(arg).first == '-') {\r\n        if (args(j) == \"-h\" || args(j) == \"--help\") {\r\n          println(help)\r\n          return Some(HelpOption())\r\n        } else if (arg == \"-l\" || arg == \"--legacy\") {\r\n           val o: Option[B] = { j = j - 1; Some(!legacy) }\r\n           o match {\r\n             case Some(v) => legacy = v\r\n             case _ => return None()\r\n           }\r\n         } else {\r\n          eprintln(s\"Unrecognized option '$arg'.\")\r\n          return None()\r\n        }\r\n        j = j + 2\r\n      } else {\r\n        isOption = F\r\n      }\r\n    }\r\n    return Some(TranspileOption(help, parseArguments(args, j), legacy))\r\n  }\r\n\r\n  def parseArguments(args: ISZ[String], i: Z): ISZ[String] = {\r\n    var r = ISZ[String]()\r\n    var j = i\r\n    while (j < args.size) {\r\n      r = r :+ args(j)\r\n      j = j + 1\r\n    }\r\n    return r\r\n  }\r\n\r\n  def parsePaths(args: ISZ[String], i: Z): Option[ISZ[String]] = {\r\n    return tokenize(args, i, \"path\", pathSep, F)\r\n  }\r\n\r\n  def parsePath(args: ISZ[String], i: Z): Option[Option[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(\"Expecting a path, but none found.\")\r\n    }\r\n    return Some(Some(args(i)))\r\n  }\r\n\r\n  def parseStrings(args: ISZ[String], i: Z, sep: C): Option[ISZ[String]] = {\r\n    tokenize(args, i, \"string\", sep, F) match {\r\n      case r@Some(_) => return r\r\n      case _ => return None()\r\n    }\r\n  }\r\n\r\n  def parseString(args: ISZ[String], i: Z): Option[Option[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(\"Expecting a string, but none found.\")\r\n      return None()\r\n    }\r\n    return Some(Some(args(i)))\r\n  }\r\n\r\n  def parseNums(args: ISZ[String], i: Z, sep: C, minOpt: Option[Z], maxOpt: Option[Z]): Option[ISZ[Z]] = {\r\n    tokenize(args, i, \"integer\", sep, T) match {\r\n      case Some(sargs) =>\r\n        var r = ISZ[Z]()\r\n        for (arg <- sargs) {\r\n          parseNumH(arg, minOpt, maxOpt) match {\r\n            case Some(n) => r = r :+ n\r\n            case _ => return None()\r\n          }\r\n        }\r\n        return Some(r)\r\n      case _ => return None()\r\n    }\r\n  }\r\n\r\n  def tokenize(args: ISZ[String], i: Z, tpe: String, sep: C, removeWhitespace: B): Option[ISZ[String]] = {\r\n    if (i >= args.size) {\r\n      eprintln(s\"Expecting a sequence of $tpe separated by '$sep', but none found.\")\r\n      return None()\r\n    }\r\n    val arg = args(i)\r\n    return Some(tokenizeH(arg, sep, removeWhitespace))\r\n  }\r\n\r\n  def tokenizeH(arg: String, sep: C, removeWhitespace: B): ISZ[String] = {\r\n    val argCis = conversions.String.toCis(arg)\r\n    var r = ISZ[String]()\r\n    var cis = ISZ[C]()\r\n    var j = 0\r\n    while (j < argCis.size) {\r\n      val c = argCis(j)\r\n      if (c == sep) {\r\n        r = r :+ conversions.String.fromCis(cis)\r\n        cis = ISZ[C]()\r\n      } else {\r\n        val allowed: B = c match {\r\n          case c\"\\n\" => !removeWhitespace\r\n          case c\" \" => !removeWhitespace\r\n          case c\"\\r\" => !removeWhitespace\r\n          case c\"\\t\" => !removeWhitespace\r\n          case _ => T\r\n        }\r\n        if (allowed) {\r\n          cis = cis :+ c\r\n        }\r\n      }\r\n      j = j + 1\r\n    }\r\n    if (cis.size > 0) {\r\n      r = r :+ conversions.String.fromCis(cis)\r\n    }\r\n    return r\r\n  }\r\n\r\n  def parseNumChoice(args: ISZ[String], i: Z, choices: ISZ[Z]): Option[Z] = {\r\n    val set = HashSet.empty[Z] ++ choices\r\n    parseNum(args, i, None(), None()) match {\r\n      case r@Some(n) =>\r\n        if (set.contains(n)) {\r\n          return r\r\n        } else {\r\n          eprintln(s\"Expecting one of the following: $set, but found $n.\")\r\n          return None()\r\n        }\r\n      case r => return r\r\n    }\r\n  }\r\n\r\n  def parseNum(args: ISZ[String], i: Z, minOpt: Option[Z], maxOpt: Option[Z]): Option[Z] = {\r\n    if (i >= args.size) {\r\n      eprintln(s\"Expecting an integer, but none found.\")\r\n      return None()\r\n    }\r\n    return parseNumH(args(i), minOpt, maxOpt)\r\n  }\r\n\r\n  def parseNumH(arg: String, minOpt: Option[Z], maxOpt: Option[Z]): Option[Z] = {\r\n    Z(arg) match {\r\n      case Some(n) =>\r\n        minOpt match {\r\n          case Some(min) =>\r\n            if (n < min) {\r\n              eprintln(s\"Expecting an integer at least $min, but found $n.\")\r\n              return None()\r\n            }\r\n          case _ =>\r\n        }\r\n        maxOpt match {\r\n          case Some(max) =>\r\n            if (n > max) {\r\n              eprintln(s\"Expecting an integer at most $max, but found $n.\")\r\n              return None()\r\n            }\r\n            return Some(n)\r\n          case _ =>\r\n        }\r\n        return Some(n)\r\n      case _ =>\r\n        eprintln(s\"Expecting an integer, but found '$arg'.\")\r\n        return None()\r\n    }\r\n  }\r\n\r\n  def select(mode: String, args: ISZ[String], i: Z, choices: ISZ[String]): Option[String] = {\r\n    val arg = args(i)\r\n    var cs = ISZ[String]()\r\n    for (c <- choices) {\r\n      if (ops.StringOps(c).startsWith(arg)) {\r\n        cs = cs :+ c\r\n      }\r\n    }\r\n    cs.size match {\r\n      case z\"0\" =>\r\n        eprintln(s\"$arg is not a mode of $mode.\")\r\n        return None()\r\n      case z\"1\" => return Some(cs(0))\r\n      case _ =>\r\n        eprintln(\r\n          st\"\"\"Which one of the following modes did you mean by '$arg'?\r\n              |${(cs, \"\\n\")}\"\"\".render)\r\n        return None()\r\n    }\r\n  }\r\n}\r\n\/\/ @formatter:on\r\n\r\n\/\/ BEGIN USER CODE\r\n\r\n\/\/ END USER CODE\r\n\r\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : true
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      \/\/ right now, there is no difference between treatment of data and event ports, but keep the logic\n      \/\/ separate for further refactoring\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.inInfrastructurePorts(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@ext object ArtNative {\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = $\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n\n  def tearDownSystemState(): Unit = $\n\n  def setUpSystemState(): Unit = $\n\n  \/\/ JH: Refactor\n  def initializePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def computePhase(): Unit = $\n\n  \/\/ JH: Refactor\n  def finalizePhase(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = $\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  \/\/ ** Manually added method by JH to support debugging interface\n\n  \/**\n   * Returns the value of an in infrastructure port.\n   *\n   * @param portId the id of the INPUT infrastructure port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = $\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport org.sireum.S64._\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < s64\"0\") {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridges(bridgeId).get\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = S64 \/\/ Z might be too small after transpiling\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 7\n  val maxPorts: PortId = 58\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, Option[Bridge]] = MS.create[BridgeId, Option[Bridge]](maxComponents, None[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val Some(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = Some(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  \/** The seL4 platform doesn't use the bridges data structure and its\n    * version of the loggers ignore the 'title' parameter. Not pattern matching\n    * here as that adds an Option to the stack which increases the stack size.\n    *\/\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logInfo(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logInfo(\"\", msg)\n    }\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logError(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logError(\"\", msg)\n    }\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    if(bridges(bridgeId).nonEmpty) {\n      ArtNative.logDebug(bridges(bridgeId).get.name, msg)\n    } else {\n      ArtNative.logDebug(\"\", msg)\n    }\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Define explicit assemble phase (to support both test and execution modes)\n  def assemble(system: ArchitectureDescription): Unit = {\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n  }\n\n  def run(system: ArchitectureDescription,\n          scheduler: Scheduler): Unit = {\n\n    assemble(system)\n\n    setUpArchitecture()\n    setUpPlatform()\n    setUpSystemState(scheduler)\n\n    initializePhase(scheduler)\n    computePhase(scheduler)\n    finalizePhase(scheduler)\n\n    tearDownSystemState()\n    tearDownPlatform()\n    tearDownArchitecture()\n  }\n\n  def initializePhase(scheduler: Scheduler): Unit = {\n    ArtNative.initializePhase()\n    scheduler.initializationPhase()\n  }\n\n  def computePhase(scheduler: Scheduler): Unit = {\n    ArtNative.computePhase()\n    scheduler.computePhase()\n  }\n\n  def finalizePhase(scheduler: Scheduler): Unit = {\n    ArtNative.finalizePhase()\n    scheduler.finalizePhase()\n  }\n\n  def setUpArchitecture(): Unit = {}\n  def tearDownArchitecture(): Unit = {}\n\n  def setUpPlatform(): Unit = {}\n  def tearDownPlatform(): Unit = {}\n\n  def setUpSystemState(scheduler: Scheduler): Unit = {\n    ArtNative.setUpSystemState()\n    scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    ArtNative.tearDownSystemState()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(system: ArchitectureDescription,\n                     scheduler: Scheduler): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = None()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n    \/\/ It seems to me that it might be best to do this once and for all (not for every test) as it is really\n    \/\/ a static description of the model that will not be changing.\n    assemble(system)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initSystemTest(scheduler)\n  }\n\n  \/\/  def executeSystemTest(): Unit = {\n  \/\/    ArtNative.executeTest()\n  \/\/  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    ArtNative.finalizeSystemTest()\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n\n  \/\/ JH: Refactored - manually added method to support\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeInPortValue(portId)\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortVariable(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\nimport art.scheduling.Scheduler\nimport org.sireum.S64._\nimport scala.collection.mutable.{Map => MMap}\n\nobject ArtMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET_PORT,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET_PORT,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when sendOutput transferred message from out port var of producer\n                       var sendOutputTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Art.Time = ArtMessage.UNSET_TIME,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Art.Time = ArtMessage.UNSET_TIME\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = s64\"0\"\n\n  val slowdown: Z = 1\n\n  \/\/================================================================\n  \/\/   A r c h i t e c t u r e     D e s c r i p t i o n\n  \/\/================================================================\n\n  \/\/ Architecture description includes any data structures built from Arch information\n  \/\/ to support system execution (i.e., by making certain types of lookup of Arch\n  \/\/ information easier).   This information persists across runs, i.e., it doesn't\n  \/\/ need to be changed between different runs of the system as long as the architecture\n  \/\/ has not changed.\n\n  \/\/ JH: Refactored - moved out of legacy run method to enable separate\n  \/\/ init\/compute\/finalize phase methods.\n  \/\/    This structure is essentially a helper for accessing the Arch description.\n  \/\/    We should study the Arch description to assess (more systematically)\n  \/\/    what types of helpers are needed and where they would go.\n  \/*\n  var activeBridges: ISZ[Art.BridgeId] = ISZ()\n  def setUpArchitecture() : Unit = {\n    for(e <- Art.bridges.elements if(e.nonEmpty)) {\n      activeBridges = activeBridges :+ e.get.id\n    }\n  }\n  def tearDownArchitecture() : Unit = {\n    activeBridges = ISZ()\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   P l a t f o r m     S t a t e\n  \/\/================================================================\n\n  \/\/ Architecture description includes any infrastructure necessary to\n  \/\/ support the platform including communication instrastructure and\n  \/\/ other resources that may exist across multiple executions\n\n  \/*\n  def setUpPlatform() : Unit = {\n  }\n  def tearDownPlatform() : Unit = {\n  }\n  *\/\n\n  \/\/================================================================\n  \/\/   S y s t e m     S t a t e\n  \/\/================================================================\n\n  val inInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val outInfrastructurePorts: MMap[Art.PortId, ArtMessage] = concMap()\n  val inPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val outPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n\n\n  \/\/ Initializes system state in preparation for execution of initialize, compute, and finalize phases\n  \/\/ System state includes any state associated with system execution, e.g., things that would need to be\n  \/\/ set up and cleared between runs, but does not include things related to system architecture or platform\n  \/\/ infrastructure that could persist between runs.\n\n  def setUpSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    \/\/scheduler.initialize()\n  }\n\n  def tearDownSystemState(): Unit = {\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n\n  \/\/===============================================================================\n  \/\/  Port-related AADL run-time services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/ TODO -- Consider whether changing the value from ArtMessage to Art.DataContent should happen here (instead of in getValue)\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          inInfrastructurePorts -= portId \/\/ dequeue from infrastructure port\n          inPortVariables(portId) = data \/\/ when we shift to queue size greater than 1, we would enqueue here\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case scala.Some(data) =>\n          \/\/ for data ports, we don't dequeue from infrastastructure ports\n          inPortVariables(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    val data = inPortVariables.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  \/\/ JH: Refactored\n  \/\/      - change names of port data structures\n  \/\/      - introduce a distinction between output port variables and output infrastructure ports\n  \/\/ ToDo: Introduce the concept of a distinct transfer method.\n  \/\/  The way that implementation treats outPortVariables and outInfrastructurePorts is almost nonsensical\n  \/\/  until that refactoring is made.\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n          outPortVariables -= srcPortId\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              \/\/ right now, there is no difference in the logic between data and event ports,\n              \/\/ but keep the code separate for future refactorings\n              case PortMode.DataIn | PortMode.DataOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                inInfrastructurePorts(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  \/\/ JH: Refactor\n  \/\/ Manually added by JH to support debugging framework\n  \/\/  -- to support being able to see inputs and outputs of a a thread (before\/after compute),\n  \/\/     clearing of output ports is removed from send_output.\n  \/\/  This function is called by scheduler, before calling compute to initialize the\n  \/\/  component port state\n  def clearPortVariables(bridgeId: Art.BridgeId): Unit = {\n    \/\/ val b = Art.bridge(bridgeId) -- refactor\n    \/\/ ToDo: the computation of input\/output port ids should be helper functions in Bridge\n    \/\/ compute inPortIds\n    val inPortIds = Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataIns.elements.map(_.id)\n    \/\/ iterate through inPortIds and clear the value of each corresponding port variable\n    for (portId <- inPortIds) {\n      inPortVariables -= portId;\n    }\n    \/\/ compute outPortIds\n    val outPortIds = Art.bridges(bridgeId).get.ports.eventOuts.elements.map(_.id) ++ Art.bridges(bridgeId).get.ports.dataOuts.elements.map(_.id)\n    \/\/ iterate through outPortIds and clear the value of each corresponding port variable\n    for (portId <- outPortIds) {\n      outPortVariables -= portId;\n    }\n  }\n\n  \/\/===============================================================================\n  \/\/  HAMR Library Services\n  \/\/===============================================================================\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toS64(System.currentTimeMillis())\n\n  \/\/===============================================================================\n  \/\/  AADL Thread\/Scheduling services\n  \/\/===============================================================================\n\n  \/\/ JH: Refactor to match logic in semantics, group with dispatch status\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        return Art.bridges(bridgeId).get.ports.eventIns.elements.exists(\n          port => inInfrastructurePorts.contains(port.id))\n    }\n  }\n\n  \/\/ JH: Refactored -- renamed port data structures\n  \/\/     ToDo: add comments justifying various sections of the logic by reference to standard clauses\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds = ISZ[Art.PortId](Art.bridges(bridgeId).get.ports.eventIns.elements.map(_.id).filter(inInfrastructurePorts.get(_).nonEmpty): _*)\n        val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n          \/\/ sorting function to make prioritized sequence of event port ids\n          \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n          case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n            \/\/ if p1 has a strictly less urgency it comes after p2\n            if (p1.urgency < p2.urgency) F\n            \/\/ if p1 has a strictly greater urgency, it comes before p2\n            else if (p1.urgency > p2.urgency) T\n            \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n            else inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n          case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n          case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n          case (p1: Port[_], p2: Port[_]) =>\n            inInfrastructurePorts(p1.id).dstArrivalTimestamp < inInfrastructurePorts(p2.id).dstArrivalTimestamp\n        }.map(_.id)\n        EventTriggered(urgentFifo)\n    }\n    return ret\n  }\n\n  \/\/===============================================================================\n  \/\/  AADL Execution Phases\n  \/\/\n  \/\/   Note: this could be synchronized a bit more with thread states \/ hybrid automata\n  \/\/   in AADL standard\n  \/\/===============================================================================\n\n  def initializePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Initializing component...\")\n  }\n\n  def computePhase(): Unit = {\n    logInfo(Art.logTitle, s\"Begin execution...\")\n  }\n\n  def finalizePhase(): Unit = {\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    ArtTimer_Ext.finalise()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(st\"\"\"{ \"log\" : \"$kind\", \"title\" : ${Json.Printer.printString(title)}, \"msg\" : ${Json.Printer.printString(msg)}, \"time\" : \"${time()}\" }\"\"\".render)\n    Console.out.flush()\n  }\n\n  def toS64(value: Long): S64 = S64(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values\n    inInfrastructurePorts.clear()\n    inPortVariables.clear()\n    outPortVariables.clear()\n    outInfrastructurePorts.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.testInitialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def initSystemTest(scheduler: Scheduler): Unit = {\n    Art.setUpArchitecture()\n    Art.setUpPlatform()\n    Art.setUpSystemState(scheduler)\n    logInfo(Art.logTitle, s\"Initialized system for system test\")\n  }\n\n  \/\/  def executeSystemTest(): Unit = $\n\n  \/\/ JH: Refactored\n  \/\/   add system test capability\n  def finalizeSystemTest(): Unit = {\n    Art.tearDownSystemState()\n    Art.tearDownPlatform()\n    Art.tearDownArchitecture()\n  }\n\n  \/\/ JH: Refactor\n  \/\/  Add code to address the fact that out port variables are now distinct from\n  \/\/  out infrastructure ports,  i.e., we must copy from out port variables to\n  \/\/  out infrastructure ports\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in\n   * its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via:\n    \/\/   Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/JH added:\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case scala.Some(msg) =>\n          outInfrastructurePorts(srcPortId) = outPortVariables(srcPortId)\n        case _ =>\n      }\n    }\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be\n   * used by users to manually clear the output if desired. This is useful for\n   * tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    outPortVariables.clear()\n  }\n\n  \/\/ JH: Refactor\n  \/\/ ToDo: Rename the functions below to align with the variable names inInfrastructurePort, etc.\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally\n   * this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    \/\/ note: right now, there is no difference in the logic between data and event ports, but keep the\n    \/\/ logic separate for future refactoring\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        inInfrastructurePorts(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n\n  \/\/ Manually added method to support debugging framework\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the INPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeInPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inInfrastructurePorts.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeInPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ right now, with event data port queues limited to size one, there is no difference in the logic\n    \/\/ between how data ports are treated, and how event\/event data ports are treated.\n    Art.port(portId).mode match {\n      case PortMode.DataIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case PortMode.EventIn =>\n        inPortVariables.get(portId) match {\n          case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n          case scala.None => org.sireum.None[DataContent]()\n        }\n      case _ => {\n        assert(false, \"expecting in port\")\n        org.sireum.None[DataContent]()\n      }\n    }\n  }\n\n  def observeOutPortVariable(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    outPortVariables.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/static\/StaticScheduler.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.scheduling.Scheduler\nimport art.scheduling.static.Schedule.DScheduleSpec\n\n\n@record class StaticScheduler(bridges: ISZ[art.Bridge],\n                              staticSchedule: DScheduleSpec) extends Scheduler {\n\n  override def initialize(): Unit = {\n    Schedule.dScheduleSpec = staticSchedule\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      art.Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    Explorer.runSystem()\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      art.Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/static\/Schedule.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, Bridge}\n\nobject Schedule {\n\n  \/\/ const dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n  \/\/  { .domain = 0, .length = 100 }, \/\/ all other seL4 threads, init, 200ms\n  \/\/  { .domain = 1, .length =   5 }, \/\/ pacer        10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 2, .length =   5 }, \/\/ source       10ms\n  \/\/  { .domain = 0, .length =  95 }, \/\/ domain0     190ms\n  \/\/  { .domain = 3, .length =   5 }, \/\/ destination  10ms\n  \/\/  { .domain = 0, .length = 195 }, \/\/ domain0     390ms\n  \/\/ };\n\n  \/\/ const word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n\n  @datatype class DScheduleSpec(maxDomain: Z, \/\/ the highest domain # used\n                                hyperPeriod: Z, \/\/ the hyper period in ticks\n                                schedule: DSchedule)\n\n  \/\/ contract invariants on schedule\n\n  @datatype class DSchedule(slots: ISZ[Slot])\n\n  \/\/ contract invariants on schedule\n\n  @datatype class Slot(bridgeId: art.Art.BridgeId, length: Z)\n\n  val emptyDScheduleSpec: DScheduleSpec = DScheduleSpec(0,0,DSchedule(ISZ()))\n\n  \/\/ ---------- schedule structure\n\n  var dScheduleSpec: DScheduleSpec = emptyDScheduleSpec\n  var domainToBridgeIdMap: ISZ[Art.BridgeId] = ISZ()\n\n  def setSchedule(spec: DScheduleSpec, bridgeMap: ISZ[Art.BridgeId]) : Unit = {\n    \/\/ pre-condition -- all structural invariants for the domain schedule hold\n    validDScheduleSpec(spec)\n    \/\/ checking period for each thread requires alignment with model -- cannot check that here -- client should guarantee\n    \/\/ body\n    dScheduleSpec = spec\n    domainToBridgeIdMap = bridgeMap\n    \/\/\n    \/\/ Technically, after this point, the schedule is \"frozen\" and we should have to check the invariant properties on the\n    \/\/ schedule again.\n  }\n\n  \/\/ --------- helper method for accessing schedule info\n\n  def getBridgeIdFromSlot(slot: Slot): Z = {\n    \/\/val domainId = slot.domain\n    \/\/val bridgeId = domainToBridgeIdMap(domainId).get\n    val bridgeId = slot.bridgeId\n    return bridgeId\n  }\n\n  def getBridgeIdFromSlotNumber(slotNum: Z): Z = {\n    val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n    return getBridgeIdFromSlot(slot)\n  }\n\n  def getBridgeId(scheduleState : Explorer.ScheduleState): Z = {\n    return getBridgeIdFromSlotNumber(scheduleState.slotNum)\n  }\n\n  \/\/def getDomain(slotNum: Z): Z = {\n  \/\/  val slot: Slot = dScheduleSpec.schedule.slots(slotNum)\n  \/\/  return slot.domain\n  \/\/}\n\n  \/\/def getDomain(scheduleState : Explorer.ScheduleState): Z = {\n  \/\/   return getDomain(scheduleState.slotNum)\n  \/\/}\n\n  def threadNickName(bridgeId: Art.BridgeId): String = {\n    halt(\"TODO\")\n    \/*\n    for (e <- StaticScheduling.threadNickNames.entries) {\n      if (e._2 == bridgeId) {\n        return e._1\n      }\n    }\n    return \"<not found>\"\n     *\/\n  }\n\n  def threadNickNameFromScheduleState(scheduleState: Explorer.ScheduleState) : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(scheduleState.slotNum)\n    return threadNickName(bridgeId)\n  }\n\n  \/\/ --------- helper methods for contracts -------------\n\n  def mySome[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (pred(e)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  def myAll[T](isz: ISZ[T], pred: T => B): B = {\n    for (e <- isz) {\n      if (!pred(e)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  \/\/ ------------- contract invariants on schedule -------------\n\n  \/\/ aggregate invariant on static schedule\n  def validDScheduleSpec(dScheduleSpec: DScheduleSpec): B = {\n    checkMaxDomain(dScheduleSpec)\n    checkNoMissingDomain(dScheduleSpec)\n    checkHyperPeriodTicks(dScheduleSpec)\n  }\n\n  \/\/ Invariant: no domain id referenced in a slot exceeds the specified max domain\n  def checkMaxDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/\/myAll[Slot](dScheduleSpec.schedule.slots, s => s.domain <= dScheduleSpec.maxDomain)\n    \/\/  for (s <- dScheduleSpec.schedule.slots) {\n    \/\/    if (s.domain > dScheduleSpec.maxDomain) {\n    \/\/      return false\n    \/\/    }\n    \/\/  }\n    \/\/  return true\n  }\n\n  \/\/ Invariant: every domain 0 .. maxDomain is referenced by at least one slot\n  def checkNoMissingDomain(dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    for (d <- 0 to dScheduleSpec.maxDomain) {\n      if (!mySome[Slot](dScheduleSpec.schedule.slots, s => s.domain == d)) {\n        return false\n      }\n    }\n    return true\n\n     *\/\n  }\n\n  \/\/ Invariant: the total time (in ticks) across all slots matches the specified hyper-period\n  def checkHyperPeriodTicks(dScheduleSpec: DScheduleSpec): B = {\n    var computedHyperPeriod: Z = 0\n    for (s <- dScheduleSpec.schedule.slots) {\n      computedHyperPeriod = computedHyperPeriod + s.length\n    }\n    return (computedHyperPeriod == dScheduleSpec.hyperPeriod)\n  }\n\n\n  \/\/ add Clock period\n\n  \/\/ This property is not an invariant per se, but rather a consistency property between the model-specified\n  \/\/ thread periods and the implied periods in the static schedule.  Thus, this property is omitted from the\n  \/\/ structural invariant on the static schedule.\n  \/\/\n  \/\/ Model-consistency: for a given domain, the period implied by the schedule (calculated period) matches\n  \/\/ the period (parameter) specified in the model\n  \/*\n   * @param domain identifier of domain to be checked\n   * @param period specified period of domain in ticks\n   * @param dScheduleSpec static schedule\n   *\/\n  def checkPeriodTicks(domain: Z, period: Z, dScheduleSpec: DScheduleSpec): B = {\n    halt(\"TODO\")\n    \/*\n    var computedPeriod: Z = 0 \/\/ computed period in ticks\n    var computedTicksBeforeOccurrence: Z = 0\n    \/\/ number of ticks before first occurrence\n    \/\/ used to determine period, when periods \"wraps around\" the schedule\n    var occurrence: Z = 0 \/\/ how many times has domain occurred so far in schedule\n\n    for (s <- dScheduleSpec.schedule.slots) {\n      \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n      if (s.domain == domain) { \/\/ if we are at a slot for the domain in the schedule\n        \/\/ if this is not the first occurrence, then we have computed the time (in ticks)\n        \/\/ since the last occurrence, so compare computed period to specified period\n        if (occurrence > 0) {\n          if (computedPeriod != period) {\n            return false\n          }\n        }\n        \/\/ at all occurrences (first or otherwise), increment the occurrence counter\n        occurrence = occurrence + 1\n        \/\/ re-start the accumulation of time leading to period\n        computedPeriod = s.length \/\/ \"initialize\" the computed period with length of domain's time slot\n      } else {\n        \/\/\n        if (occurrence > 0) { \/\/ if we have previously encountered the domain in the schedule\n          computedPeriod = computedPeriod + s.length \/\/ add current time slice\n        } else {\n          \/\/ if we haven't see the domain yet, add the time to the \"before occurrence\" accumulator\n          computedTicksBeforeOccurrence = computedTicksBeforeOccurrence + s.length\n        }\n      }\n    }\n    \/\/ println(occurrence, \", \", computedTicksBeforeOccurrence, \", \", computedPeriod)\n    \/\/ at this point, we have reached the end of the schedule.  We need to check for the domain\n    \/\/ as it wraps around.  Given our other invariants, we know that the domain occurs at least\n    \/\/ once.  So computedPeriod should hold the time since it was seen, whereas\n    \/\/ computedTicksBeforeOccurrence should hold the time before it was seen.\n    \/\/ The sum of these values should equal the period.\n    return (computedPeriod + computedTicksBeforeOccurrence == period)\n\n     *\/\n  }\n\n  def computeElaspedRemainingHPTicks(slotNum: Z, dScheduleSpec: DScheduleSpec) : (Z,Z) = {\n    \/\/ pre-condition\n    \/\/  TODO: well-formed dScheduleSpec\n    \/\/  TODO: valid slotNum (define function for below)\n    assert(0 <= slotNum & slotNum < dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    var elaspedHPTicks: Z = 0\n    for (s <- 0 until slotNum) {\n      elaspedHPTicks = elaspedHPTicks + dScheduleSpec.schedule.slots(0).length\n    }\n    val remainingHPTicks: Z = dScheduleSpec.hyperPeriod - elaspedHPTicks\n    return (elaspedHPTicks,remainingHPTicks)\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/static\/StateObserver.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, DataContent }\n\nobject StateObserver {\n\n\n  def observeInPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeInPortValue(portId)\n  }\n\n  def observeOutPortValue(bridgeId: Art.BridgeId, portId: Art.PortId): Option[DataContent] = {\n    Art.observeOutPortVariable(portId)\n  }\n\n  def observeInPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n\n    for (port <- bridge.ports.eventIns) {\n      portValues = portValues :+ ((port.name, Art.observeInPortValue(port.id)))\n    }\n    return portValues\n  }\n\n  def observeOutPortValues(bridgeId: Art.BridgeId): ISZ[(String,Option[DataContent])] = {\n    val bridge = Art.bridges(bridgeId).get\n    var portValues : ISZ[(String,Option[DataContent])] = ISZ()\n\n    for (port <- bridge.ports.dataOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n\n    for (port <- bridge.ports.eventOuts) {\n      portValues = portValues :+ ((port.name, Art.observeOutPortVariable(port.id)))\n    }\n    return portValues\n  }\n\n  def observeInPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeInPortValues(bridgeId)\n  }\n\n  def observeOutPortValuesByNickName(threadNickName: String): ISZ[(String,Option[DataContent])] = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return observeOutPortValues(bridgeId)\n  }\n\n  \/\/=======================================================================\n  \/\/ State Observations (primary methods for interpreting debug commands)\n  \/\/=======================================================================\n\n  def generatePortContentsInputsCurrent() : String = {\n    val bridgeId = Schedule.getBridgeIdFromSlotNumber(Explorer.scheduleState.slotNum)\n    val inPortInfo = observeInPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Next Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsOutputsCurrent() : String = {\n    val previousStateOpt: Option[Explorer.ScheduleState] =\n      Explorer.previousState(Explorer.scheduleState,Schedule.dScheduleSpec)\n\n    previousStateOpt match {\n      case Some(previousState) => {\n        val bridgeId = Schedule.getBridgeIdFromSlotNumber(previousState.slotNum)\n        val outPortInfo = observeOutPortValues(bridgeId)\n        val result =\n          st\"\"\"****************************\n              |   Previous Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n              |****************************\n              | Output Ports\n              | ===============\n              |  ${formatPortInfo(outPortInfo)}\"\"\".render\n        return result\n      }\n      case None() => {\n        return \"(initial state - no previous state to show)\"\n      }\n    }\n  }\n\n  def formatPortInfo(portVals: ISZ[(String,Option[DataContent])]): String = {\n    var result: String = \"\" \/\/ ToDo: Ask Robby if I can do this with a repeating template\n    for (e <- portVals) {\n      result = st\"\"\"$result\n                   |${e._1} = ${e._2}\"\"\".render  \/\/ how do I put in new line?\n    }\n    return result\n  }\n\n  def generatePortContents(bridgeId: Z) : String = {\n    val inPortInfo = observeInPortValues(bridgeId)\n    val outPortInfo = observeOutPortValues(bridgeId)\n    val result =\n      st\"\"\"****************************\n          |   Component: ${Schedule.threadNickName(bridgeId)} (id = $bridgeId)\n          |****************************\n          | Input Ports\n          | ===============\n          |  ${formatPortInfo(inPortInfo)}\n          |\n          | Output Ports\n          | ================\n          |  ${formatPortInfo(outPortInfo)}\"\"\".render\n    return result\n  }\n\n  def generatePortContentsByNickName(threadNickName: String) : String = {\n    halt(\"TODO\")\n    \/\/val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    \/\/return generatePortContents(bridgeId)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/static\/Explorer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.static\n\nimport org.sireum._\nimport art.{Art, ArtNative}\nimport art.scheduling.static.Schedule._\n\n\/\/ Possible commands\/concepts\n\/\/\n\/\/ init system\n\/\/ s n - step n slots; n >= 1, if n >= remaining slots in hyper-period, then run to end of hyper-period\n\/\/ h n - step n hyper-periods; n >= 1\n\/\/ executing info display mode\n\/\/  show domain \/ bridge\n\/\/  show infrastructure input \/ output ports\n\/\/  show in\/out ports for selected components\n\/\/  inject certain values on input ports (random, specific, random with constraints, generator, seeded from test vector)\n\/\/ run until various conditions\n\/\/ check contract \/ constraint (component-wise or global)\n\/\/ checkpoint state, rollback to checkpointed state\n\/\/ save step as unit tests\n\/\/ calculate dependences during execution\n\n\n\/\/ stepDSchedule(2,dScheduleSpec1)\n\n\/\/ var inpt: Z = 0\n\/\/ inpt = readInt()\n\nobject Explorer {\n\n  \/\/================ schedule state ====================\n\n  \/\/ data structure for schedule state\n  \/\/   - zero-based indexing into the time-line of the scheduler\n  @datatype class ScheduleState(slotNum: Z, hyperperiodNum: Z)\n\n  \/\/ \"invariant\" for schedule state\n  def validState(state: ScheduleState, dScheduleSpec: DScheduleSpec) : B = {\n    val slotNum = state.slotNum\n    \/\/ TODO: also check valid scheduleSpec??\n    val slotInRange: B = slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size\n    val hyperperiodInRange: B = state.hyperperiodNum >= 0\n    return  slotInRange & hyperperiodInRange\n  }\n\n  def isHyperPeriodBoundary(state: ScheduleState): B = {\n    return state.slotNum == 0\n  }\n\n  \/\/ no overloading in Slang\n  \/\/def isHyperPeriodBoundary(): B = {\n  \/\/  return isHyperPeriodBoundary(scheduleState)\n  \/\/}\n\n  \/\/ schedule state \"global\" variable\n  var scheduleState : ScheduleState = initialScheduleState()\n\n  \/\/ helper method to define initial state value\n  def initialScheduleState(): ScheduleState = {\n    ScheduleState(0,0)\n  }\n\n  \/\/ method to initialize schedule state\n  def initializeScheduleStateIMP(): Unit = {\n    scheduleState = initialScheduleState()\n  }\n\n  def isInitial(scheduleState: ScheduleState): B = {\n    return scheduleState == initialScheduleState()\n  }\n\n  def isInitialIMP(): B = {\n    return isInitial(scheduleState)\n  }\n\n  \/\/=============== stepping functions ===================\n\n  \/\/ -- methods for executing thread in a particular slot in the schedule.\n  \/\/    A thread can be referenced by slot data structure or by slot number (two different methods)\n\n  \/\/ execute thread by slot data structure\n  def executeSlotIMP(slot: Slot): Unit = {\n    \/\/val domainId: Z = slot.domain\n    \/\/val bridgeId: Art.BridgeId = Schedule.domainToBridgeIdMap(domainId).get\n    val bridgeId: Art.BridgeId = slot.bridgeId\n    \/\/ val bridge: Bridge = Art.bridges(bridgeId).get  -- debug with Robby\n    \/\/ This is cause an Invalid 'None' operation 'get' exception\n    \/\/ Art.clearPortVariables(bridgeId)\n    \/\/ bridge.entryPoints.compute()  -- debug with Robby\n    \/\/ Art.bridges(bridgeId).asInstanceOf[MSome[Bridge]].value.entryPoints.compute()\n    if(ArtNative.shouldDispatch(bridgeId)) {\n      Art.bridges(bridgeId).get.entryPoints.compute()\n    }\n  }\n\n  \/\/ execute thread by slot number\n  def executeSlotNumIMP(slotNum: Z): Unit = {\n    \/\/ pre-condition\n    assert(slotNum >= 0 & slotNum < dScheduleSpec.schedule.slots.size, s\"slotNum: ${slotNum}, Slot Size: ${dScheduleSpec.schedule.slots.size}\")\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    executeSlotIMP(slots(slotNum))\n  }\n\n  \/\/ -- methods for updating schedule state (these do not actually execute the thread)\n\n  \/\/ purely functional method to compute the next schedule state\n  def nextState(state: ScheduleState,dScheduleSpec: DScheduleSpec): ScheduleState = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    val slots = dScheduleSpec.schedule.slots\n    var nextSlotNum = state.slotNum + 1\n    var nextHyperPeriodNum = state.hyperperiodNum\n    \/\/ handle wrap around\n    if (nextSlotNum == slots.size) {\n      nextSlotNum = 0\n      nextHyperPeriodNum = nextHyperPeriodNum + 1\n    }\n    return ScheduleState(nextSlotNum,nextHyperPeriodNum)\n  }\n\n  \/\/ purely functional method to compute the next schedule state\n  def previousState(state: ScheduleState,dScheduleSpec: DScheduleSpec): Option[ScheduleState] = {\n    \/\/ pre-condition\n    assert(validState(state, dScheduleSpec))\n    \/\/ body\n    if (isInitial(state)) {\n      return None()\n    }\n\n    val slots = dScheduleSpec.schedule.slots\n\n    var nextSlotNum = state.slotNum - 1           \/\/ assume for now we don't wrap around\n    var nextHyperPeriodNum = state.hyperperiodNum \/\/ assume for now we stay at same hyper-period\n\n    \/\/ handle wrap around\n    if (state.slotNum == 0) {  \/\/ if current state has initial slot number, then wrap to end\n      nextSlotNum = slots.size - 1  \/\/ set nextSlotNum to last slot number\n      nextHyperPeriodNum = nextHyperPeriodNum - 1 \/\/ this is sound since we already checked that current state is not initial\n    }\n    return Some(ScheduleState(nextSlotNum,nextHyperPeriodNum))\n  }\n\n  \/\/ advance the state to the next schedule slot (side-effecting schedule state)\n  def advanceStateIMP() : Unit = {\n    scheduleState = nextState(scheduleState,dScheduleSpec)\n  }\n\n  def stepSystemOneSlotIMP(info: B): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert(validDScheduleSpec(dScheduleSpec))\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    \/\/   execute thread in current slot\n    val preScheduleState = scheduleState\n    executeSlotNumIMP(scheduleState.slotNum)\n    \/\/   advance the schedule state\n    advanceStateIMP()\n    val postScheduleState = scheduleState\n    if (info) {\n      halt(\"TODO\")\n      \/\/Cli.showStep(preScheduleState, postScheduleState, dScheduleSpec)\n    }\n  }\n\n  def stepSystemNSlotsIMP(numSlots :Z): Unit = {\n    \/\/ pre-condition\n    assert(numSlots > 0)\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ body\n    for (i <- 1 to numSlots) {\n      stepSystemOneSlotIMP(T)\n    }\n  }\n\n  \/\/ Steps the system one hyper-period.\n  \/\/ Does not require the system to be on a hyper-period boundary.\n  \/\/ If state indicates that hyper-period is already in progress, the method will run to the start of the next hyper-period.\n  def stepSystemOneHPIMP(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    \/\/ var currentSlotNum: Z = scheduleState.slotNum\n    val numStepsToStartOfHP : Z = dScheduleSpec.schedule.slots.size - scheduleState.slotNum\n    stepSystemNSlotsIMP(numStepsToStartOfHP)\n    \/\/ assert that current state is at the beginning of a HP\n    assert(isHyperPeriodBoundary(scheduleState))\n    halt(\"TODO\")\n    \/\/Cli.showHyperPeriodBoundary(scheduleState)\n  }\n\n  \/\/ Steps the system N hyper-periods.\n  \/\/ Make an somewhat arbitrary but rational decision that this method should not be\n  \/\/ called when the system is not on a hyper-period boundary (start of hyper-period)\n  def stepSystemNHPIMP(numHyperPeriods:Z): Unit = {\n    for (hpcount <- 1 to numHyperPeriods) {\n      \/\/ println(\"===== Hyperperiod \", scheduleState.hyperperiodNum, \" ============\")\n      stepSystemOneHPIMP()\n    }\n  }\n\n  \/\/ Runs the system to the start of the given hyper-period number\n  def runToHP(hpNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    \/\/ body\n\n    halt(\"TODO\")\n    \/\/Cli.message(s\"...Running to beginning of hyper-period# $hpNum\")\n\n    \/\/while (scheduleState.hyperperiodNum < hpNum) {\n    \/\/  stepSystemOneSlotIMP(F)\n    \/\/}\n    \/\/Cli.message(\"*********** Run to ... Completed *************\")\n    \/\/Cli.showState(scheduleState)\n  }\n\n  \/\/ Runs the system to the start of the given state (hp# and slot#)\n  def runToState(hpNum:Z, slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(hpNum >= 0)\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to state [hp = $hpNum, slot = $slotNum]\")\n    while (scheduleState.hyperperiodNum < hpNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    while (scheduleState.slotNum < slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given slot#\n  def runToSlot(slotNum:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(slotNum >= 0 & slotNum < Schedule.dScheduleSpec.schedule.slots.size)\n    \/\/ body\n    while (scheduleState.slotNum != slotNum) {\n      stepSystemOneSlotIMP(F)\n    }\n    halt(\"TODO\")\n    \/*\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n     *\/\n  }\n\n  \/\/ Runs the system to the start of the given domain\n  def runToDomain(domainId:Z): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    assert(domainId >= 0 & domainId <= Schedule.dScheduleSpec.maxDomain)\n    \/\/ body\n    halt(\"TODO\")\n    \/*\n    Cli.message(s\"...Running to domain $domainId\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n\n     *\/\n  }\n\n  \/*\n  \/\/ Runs the system to the start of the given domain\n  def runToThread(threadNickName: String): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    assert(validState(scheduleState, dScheduleSpec))\n    val bridgeId = art.StaticScheduling.threadNickNames.get(threadNickName).get \/\/ ToDo: fix error handling\n    val domainId = art.StaticScheduling.bridgeIdToDomainMap(bridgeId)\n    Cli.message(s\"...Running to thread $threadNickName (domain $domainId)\")\n    while (Schedule.dScheduleSpec.schedule.slots(scheduleState.slotNum).domain != domainId) {\n      stepSystemOneSlotIMP(F)\n    }\n    Cli.message(\"*********** Run to ... Completed *************\")\n    Cli.showState(scheduleState)\n  }\n   *\/\n\n  \/\/ Runs the system according to the static schedule without debugging, but still uses the debugging scheduling state\n  def runSystem(): Unit = {\n    \/\/ pre-condition (invariants on scheduleState and dScheduleSpec)\n    \/\/ assert valid schedule\n    \/\/ body\n    \/\/Cli.message (s\"...Running system according to static schedule\")\n    cprintln(F, \"...Running system according to static schedule\")\n    Explorer.initializeScheduleStateIMP()\n    var systemStopCondition: B = false \/\/ right now we don't have a system stop condition\n    while (!systemStopCondition) {\n      executeSlotNumIMP(scheduleState.slotNum)\n      advanceStateIMP()\n      for (i <- 1 to 100000) {\n        None[String]()\n      }\n    }\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobin.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage art.scheduling.roundrobin\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.scheduling.Scheduler\nimport art.{Art, ArtNative, DispatchPropertyProtocol}\n\n@record class RoundRobin(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  var lastDispatch: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n  var lastSporadic: MS[Art.BridgeId, Art.Time] = MS.create(bridges.size, s64\"0\")\n\n  override def initialize(): Unit = {\n    RoundRobinExtensions.init()\n  }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  def shouldDispatch(bridge: art.Bridge): B = {\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        if(Art.time() - lastDispatch(bridge.id) > conversions.Z.toS64(period)) {\n          return ArtNative.shouldDispatch(bridge.id)  \/\/ will always return true\n        } else {\n          return F\n        }\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        if(Art.time() - lastSporadic(bridge.id) < conversions.Z.toS64(minRate)) {\n          return F\n        } else {\n          \/\/ check if there are events waiting in incoming infrastructure port\n          return ArtNative.shouldDispatch(bridge.id)\n        }\n    }\n  }\n\n  override def computePhase(): Unit = {\n    while(!RoundRobinExtensions.shouldStop()) {\n      for (bridge <- bridges) {\n        if(shouldDispatch(bridge)) {\n          lastDispatch(bridge.id) = Art.time()\n          bridge.entryPoints.compute()\n\n          if(bridge.dispatchProtocol.isInstanceOf[DispatchPropertyProtocol.Sporadic]) {\n            lastSporadic(bridge.id) = Art.time()\n          }\n        }\n      }\n    }\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object RoundRobinExtensions {\n  def init(): Unit = $\n  def shouldStop(): B = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/roundrobin\/RoundRobinExtensions_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art.scheduling.roundrobin\n\nimport art.{Art, ArtNative}\nimport org.sireum.B\nimport java.util.concurrent.atomic.AtomicBoolean\n\nobject RoundRobinExtensions_Ext {\n  var terminated = new AtomicBoolean(false)\n\n  def init(): Unit = {\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    new Thread(() => {\n      Console.in.readLine()\n      terminated.set(true)\n    }).start()\n  }\n\n  def shouldStop(): B = {\n    return terminated.get()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/nop\/NopScheduler.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.nop\n\nimport org.sireum._\nimport art.scheduling.Scheduler\n\n@record class NopScheduler extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = { }\n\n  override def computePhase(): Unit = { }\n\n  override def finalizePhase(): Unit = { }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/legacy\/LegacyInterface_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art.scheduling.legacy\n\nimport art.{Art, ArtNative, ArtNative_Ext, DispatchPropertyProtocol}\nimport scala.collection.mutable.{Map => MMap}\nimport org.sireum._\n\nobject LegacyInterface_Ext {\n  val slowdown: Z = 1\n\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = {\n    var terminated = false\n    var numTerminated: Z = 0\n\n    for (bridge <- bridges) {\n\n      val (rate, isSporadic) = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => (period, F)\n        case DispatchPropertyProtocol.Sporadic(min) => (min, T)\n      }\n\n      new Thread(() => {\n        ArtNative.logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (ArtNative.shouldDispatch(bridge.id)) {\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated = true\n            }\n          }\n        }\n        ArtNative_Ext.synchronized {\n          numTerminated += 1\n        }\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    ArtNative.logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated = true\n\n    while (numTerminated != bridges.size) {\n      Thread.sleep(1000)\n    }\n  }\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/legacy\/Legacy.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling.legacy\n\nimport org.sireum._\nimport art.Art\nimport art.scheduling.Scheduler\n\n@record class Legacy(bridges: ISZ[art.Bridge]) extends Scheduler {\n\n  override def initialize(): Unit = { }\n\n  override def initializationPhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      Art.logInfo(bridge.id, s\"Initialized bridge: ${bridge.name}\")\n    }\n  }\n\n  override def computePhase(): Unit = {\n    LegacyInterface.computePhase(bridges)\n  }\n\n  override def finalizePhase(): Unit = {\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      Art.logInfo(bridge.id, s\"Finalized bridge: ${bridge.name}\")\n    }\n  }\n}\n\n@ext object LegacyInterface {\n  def computePhase(bridges: ISZ[art.Bridge]): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/scheduling\/Scheduler.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art.scheduling\n\nimport org.sireum._\n\n\/\/ msig to allow schedulers to have mutable state\n@msig trait Scheduler {\n\n  def initialize(): Unit\n\n  def initializationPhase(): Unit\n\n  def computePhase(): Unit\n\n  def finalizePhase(): Unit\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: ISZ[Bridge],\n                                        connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype trait PortProto extends UPort\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends PortProto\n\n@datatype trait UrgentPortProto extends UPort {\n  def urgency: Z\n}\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UrgentPortProto\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n\n    def testInitialise(): Unit = { println(\"Default testInitialise\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/src\/main\/art\/art\/ArtNativeSlang.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport org.sireum.S64._\nimport art.DispatchPropertyProtocol.{Periodic, Sporadic}\n\nobject ArtSlangMessage {\n  val UNSET_PORT: Art.PortId = -1\n  val UNSET_TIME: Art.Time = s64\"-1\"\n}\n\n@datatype class ArtSlangMessage(data: DataContent,\n\n                                srcPortId: Art.PortId,\n                                dstPortId: Art.PortId,\n\n                                \/\/ when putValue was called by producer\n                                putValueTimestamp: Art.Time,\n\n                                \/\/ when sendOutput transferred message from out port var of producer\n                                sendOutputTimestamp: Art.Time,\n\n                                \/\/ when message arrived via transport layer\n                                dstArrivalTimestamp: Art.Time,\n\n                                \/\/ when receiveInput transferred message to in port vars of consumer\n                                receiveInputTimestamp: Art.Time\n                               )\n\nobject ArtNativeSlang {\n\n  var inInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outInfrastructurePorts: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var inPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n  var outPortVariables: Map[Art.PortId, ArtSlangMessage] = Map.empty\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    assert(Art.bridges(bridgeId).nonEmpty, s\"Bridge ${bridgeId} does not exist\")\n\n    Art.bridges(bridgeId).get.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n\n        val eventIns = Art.bridges(bridgeId).get.ports.eventIns\n\n        var hasEvents = F\n        \/\/ transpiler workaround -- doesn't support .exists\n        for(e <- eventIns) {\n          if(inInfrastructurePorts.contains(e.id)) {\n            hasEvents = T\n          }\n        }\n        return hasEvents\n    }\n  }\n\n  def lt(a : art.UPort,b : art.UPort): B = { \/\/ reverse sort\n    val r: B = (a, b) match {\n      \/\/ sorting function to make prioritized sequence of event port ids\n      \/\/   compare p1 to p2  (p1 represents the port to process earlier, i.e., should have priority)\n      case (p1: UrgentPortProto, p2: UrgentPortProto) =>\n        \/\/ if p1 has a strictly less urgency it comes after p2\n        if (p1.urgency < p2.urgency) F\n        \/\/ if p1 has a strictly greater urgency, it comes before p2\n        else if (p1.urgency > p2.urgency) T\n        \/\/ if p1 and p2 have the same urgency, the ordering is determined by arrival timestamps\n        else inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n      case (_: UrgentPortProto, _: PortProto) => T \/\/ urgent ports take precedence\n      case (_: PortProto, _: UrgentPortProto) => F \/\/ urgent ports take precedence\n      case (p1: PortProto, p2: PortProto) =>\n        inInfrastructurePorts.get(p1.id).get.dstArrivalTimestamp < inInfrastructurePorts.get(p2.id).get.dstArrivalTimestamp\n    }\n    return r\n  }\n\n  def sort(ports: ISZ[UPort]): ISZ[UPort] = {\n    def insert(p: UPort, sorted: ISZ[UPort]): ISZ[UPort] = {\n      if(sorted.isEmpty) { return ISZ(p) }\n      else {\n        if(lt(sorted(0), p)) { return sorted(0) +: insert(p, ops.ISZOps(sorted).tail) }\n        else { return p +: sorted }\n      }\n    }\n    if(ports.isEmpty) { return ports}\n    else {\n      val sorted = sort(ops.ISZOps(ports).tail)\n      return insert(ports(0), sorted)\n    }\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val ret: DispatchStatus = Art.bridges(bridgeId).get.dispatchProtocol match {\n      case Periodic(_) => TimeTriggered()\n      case Sporadic(_) =>\n        \/\/ get ids for non-empty input event ports\n        val portIds: ISZ[Art.PortId] =\n          for(p <- Art.bridges(bridgeId).get.ports.eventIns if inInfrastructurePorts.get(p.id).nonEmpty) yield p.id\n\n        if(portIds.isEmpty) {\n          halt(s\"Unexpected: shouldDispatch() should have returned true in order to get here, however the incoming event ports are empty for bridge id ${bridgeId}\")\n        }\n\n        val urgentFifo = sort(for(p <- portIds) yield Art.port(p))\n        EventTriggered(for(p <- urgentFifo) yield p.id)\n    }\n    return ret\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(portId <- eventPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inInfrastructurePorts = inInfrastructurePorts - ((portId, data))\n          inPortVariables = inPortVariables + (portId ~> data(receiveInputTimestamp = Art.time()))\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      inInfrastructurePorts.get(portId) match {\n        case Some(data) =>\n          inPortVariables = inPortVariables + (portId ~> data)\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    \/\/ wrap the Art.DataContent value into an ArtMessage with time stamps\n    outPortVariables = outPortVariables + (portId ~>\n      ArtSlangMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time(),\n        dstPortId = ArtSlangMessage.UNSET_PORT, sendOutputTimestamp = ArtSlangMessage.UNSET_TIME, dstArrivalTimestamp = ArtSlangMessage.UNSET_TIME, receiveInputTimestamp = ArtSlangMessage.UNSET_TIME))\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ To return the value of the port to the application code, project\n    \/\/ out the actual payload value (v.data) from ArtMessage (which includes timestamps, etc.)\n    \/\/ to Art.DataContent (the \"top\"\/union data type supported by Art.\n    \/\/ The projecting preserves the option of structure of ArtMessage value.\n    if(inPortVariables.contains(portId)) {\n      return Some(inPortVariables.get(portId).get.data)\n    } else {\n      return None()\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for(srcPortId <- eventPortIds ++ dataPortIds) {\n      outPortVariables.get(srcPortId) match {\n        case Some(msg) => {\n\n          \/\/ move payload from out port port variables to the out infrastructure ports\n          outInfrastructurePorts = outInfrastructurePorts + (srcPortId ~> msg)\n          outPortVariables = outPortVariables - ((srcPortId, msg))\n\n          \/\/ simulate sending msg via transport middleware\n          for(dstPortId <- Art.connections(srcPortId)) {\n            val _msg = msg(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            \/\/ send via middleware\n\n            inInfrastructurePorts = inInfrastructurePorts + (dstPortId ~>\n              _msg(dstArrivalTimestamp = Art.time()))\n          }\n\n          \/\/ payload delivered so remove it from out infrastructure port\n          outInfrastructurePorts = outInfrastructurePorts - ((srcPortId, msg))\n        }\n        case _ =>\n      }\n    }\n    \/\/ could clear outPortVariables for passed in portids but not strictly necessary\n  }\n\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n\n  def setUpSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def tearDownSystemState(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def initializePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def computePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n  def finalizePhase(): Unit = {\n    \/\/ probably nothing to do here\n  }\n\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n\n@ext(name = \"art.ArtNative_Ext\") object Process {\n  def time(): Art.Time = $\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/bin\/project.cmd",
        {
          "type" : "TestResource",
          "content" : "::#! 2> \/dev\/null                                   #\r\n@ 2>\/dev\/null # 2>nul & echo off & goto BOF         #\r\nif [ -z ${SIREUM_HOME} ]; then                      #\r\n  echo \"Please set SIREUM_HOME env var\"             #\r\n  exit -1                                           #\r\nfi                                                  #\r\nexec ${SIREUM_HOME}\/bin\/sireum slang run \"$0\" \"$@\"  #\r\n:BOF\r\nsetlocal\r\nif not defined SIREUM_HOME (\r\n  echo Please set SIREUM_HOME env var\r\n  exit \/B -1\r\n)\r\n%SIREUM_HOME%\\\\bin\\\\sireum.bat slang run \"%0\" %*\r\nexit \/B %errorlevel%\r\n::!#\r\n\/\/ #Sireum\r\n\r\n\/\/ Example Sireum Proyek build definitions -- the contents of this file will not be overwritten\r\n\/\/\r\n\/\/ To install Sireum (Proyek and IVE) see https:\/\/github.com\/sireum\/kekinian#installing\r\n\/\/\r\n\/\/ The following commands should be executed in the parent of the 'bin' directory.\r\n\/\/\r\n\/\/ Command Line:\r\n\/\/   To run the demo from the command line using the default scheduler:\r\n\/\/     sireum proyek run . VPM_ben__Linux.Demo\r\n\/\/\r\n\/\/   To see the available CLI options:\r\n\/\/     sireum proyek run . VPM_ben__Linux.Demo -h\r\n\/\/\r\n\/\/   To run the example unit tests from the command line:\r\n\/\/     sireum proyek test .\r\n\/\/\r\n\/\/   To build an executable jar:\r\n\/\/     sireum proyek assemble --uber --main VPM_ben__Linux.Demo .\r\n\/\/\r\n\/\/ Sireum IVE:\r\n\/\/\r\n\/\/   If you prevented HAMR from running Proyek IVE then first generate the IVE project:\r\n\/\/     sireum proyek ive .\r\n\/\/\r\n\/\/   Then in IVE select 'File > Open ...' and navigate to the parent of the\r\n\/\/   'bin' directory and click 'OK'.\r\n\/\/\r\n\/\/   To run the demo from within Sireum IVE:\r\n\/\/     Right click src\/main\/architecture\/VPM_ben__Linux\/Demo.scala and choose \"Run 'Demo'\"\r\n\/\/\r\n\/\/   To run the unit test cases from within Sireum IVE:\r\n\/\/     Right click the src\/test\/bridge and choose \"Run ScalaTests in bridge\"\r\n\/\/\r\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\r\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\r\n\/\/         named 'target' and retry\r\n\r\nimport org.sireum._\r\nimport org.sireum.project.{Module, Project, Target}\r\n\r\nval home: Os.Path = Os.slashDir.up.canon\r\n\r\nval slangModule: Module = Module(\r\n  id = \"VPM_8600B_Ext_impl_Instance\",\r\n  basePath = (home \/ \"src\").string,\r\n  subPathOpt = None(),\r\n  deps = ISZ(),\r\n  targets = ISZ(Target.Jvm),\r\n  ivyDeps = ISZ(\"org.sireum.kekinian::library:\", \"com.intellij:forms_rt:\"),\r\n  sources = for(m <- ISZ(\"art\", \"architecture\", \"bridge\", \"component\", \"data\", \"nix\", \"seL4Nix\")) yield (Os.path(\"main\") \/ m).string,\r\n  resources = ISZ(),\r\n  testSources = for (m <- ISZ(\"bridge\", \"util\")) yield (Os.path(\"test\") \/ m).string,\r\n  testResources = ISZ(),\r\n  publishInfoOpt = None()\r\n)\r\n\r\nval inspectorModule: Module = slangModule(\r\n  sources = slangModule.sources :+ (Os.path(\"main\") \/ \"inspector\").string,\r\n  ivyDeps = slangModule.ivyDeps ++ ISZ(\"org.sireum:inspector-capabilities:\", \"org.sireum:inspector-gui:\", \"org.sireum:inspector-services-jvm:\")\r\n)\r\n\r\nval slangProject: Project = Project.empty + slangModule\r\nval inspectorProject: Project = Project.empty + inspectorModule\r\n\r\nval prj: Project = slangProject\r\n\/\/val prj: Project = inspectorProject()\r\n\r\nprintln(project.JSON.fromProject(prj, T))\r\n",
          "overwrite" : false,
          "makeExecutable" : true,
          "makeCRLF" : true
        }
      ],
      [
        "VPM_ben--Linux\/versions.properties",
        {
          "type" : "TestResource",
          "content" : "org.sireum.slang-embedded-art%%slang-embedded-art%=661daae\n\norg.sireum%inspector-capabilities%=0.6-SNAPSHOT\norg.sireum%inspector-gui%=0.6-SNAPSHOT\norg.sireum%inspector-services-jvm%=0.6-SNAPSHOT\n\ncom.intellij%forms_rt%=7.0.3\n\n\n# remove the following entries if you want to use the versions\n# that ship with sireum (i.e. $SIREUM_HOME\/bin\/sireum --version)\n\n# Scala compiler plugin for Slang\norg.sireum%%scalac-plugin%=4.20210812.d884dc2\n\norg.sireum.kekinian%%library%kekinianVersion%=4.20210816.dd5f584\n\norg.scala-lang%scala-library%=2.13.6\norg.scalatest%%scalatest%%=3.2.9\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill VPM_ben__Linux.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill VPM_ben__Linux.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n VPM_ben--Linux ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w VPM_ben__Linux.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `VPM_ben__Linux` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.6\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.9\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210812.d884dc2\n  val sireumScalacVersion = \"4.20210812.d884dc2\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210816.dd5f584\n  val kekinianVersion = \"4.20210816.dd5f584\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"VPM_ben__Linux.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"VPM_ben__Linux.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line using the default scheduler:\n\/\/   sbt run\n\/\/\n\/\/ To see the available CLI options:\n\/\/   sbt \"run -h\"\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/VPM_ben__Linux\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val VPM_8600B_Ext_impl_Instance = slangEmbeddedProject(\"VPM_8600B_Ext_impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.6\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.9\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210812.d884dc2\nval sireumScalacVersion = \"4.20210812.d884dc2\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210816.dd5f584\nval kekinianVersion = \"4.20210816.dd5f584\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"VPM_ben__Linux.Demo\"),\n\n  mainClass in assembly := Some(\"VPM_ben__Linux.Demo\"),\n  assemblyJarName in assembly := \"VPM_8600B_Ext_impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"VPM_ben__Linux.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "VPM_ben--Linux\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}