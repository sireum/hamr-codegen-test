{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "test_data_port_periodic--SeL4_TB\/proof\/smt2_case.smt2",
        {
          "type" : "ITestResource",
          "content" : "(set-logic ALL)\n\n\n(declare-datatypes ((ComponentType 0)) ((\n  (AadlComponent)\n  (AadlVMComponent)\n  (PacerComponent)\n  (PeriodicDispatcher))))\n\n(declare-datatypes ((DispatchProtocol 0)) ((\n  (Periodic)\n  (Sporadic)\n  (UNSPECIFIED_DISPATCH_PROTOCOL))))\n\n(declare-datatypes ((SchedulingType 0)) ((\n  (Pacing)\n  (SelfPacing)\n  (PeriodicDispatching)\n  (UNSPECIFIED_SCHEDULING_TYPE))))\n\n(declare-datatypes ((Direction 0)) ((\n  (In)\n  (Out))))\n\n(declare-datatypes ((PortType 0)) ((\n  (AadlDataPort)\n  (AadlEventPort)\n  (AadlEventDataPort))))\n\n\n(declare-const ModelSchedulingType SchedulingType)\n(assert (= ModelSchedulingType PeriodicDispatching))\n\n; 2 AADLComponent\n(declare-datatypes ((AADLComponent 0)) ((\n  (top_impl_Instance_test_data_port_periodic_src); Instance of test_data_port_periodic::source_t.impl declared at \/test_data_port_periodic\/test_data_port_periodic.aadl (45, 4)\n  (top_impl_Instance_test_data_port_periodic_dest); Instance of test_data_port_periodic::destination_t.impl declared at \/test_data_port_periodic\/test_data_port_periodic.aadl (46, 4)\n)))\n\n; 2 AADLDispatchProtocol\n(declare-const AADLDispatchProtocol (Array AADLComponent DispatchProtocol))\n(assert (= Periodic (select AADLDispatchProtocol top_impl_Instance_test_data_port_periodic_src)))\n(assert (= Periodic (select AADLDispatchProtocol top_impl_Instance_test_data_port_periodic_dest)))\n\n; 2 altAADLDispatchProtocol\n(define-fun altAADLDispatchProtocol ((_comp AADLComponent)) DispatchProtocol\n  (ite (= _comp top_impl_Instance_test_data_port_periodic_src) Periodic\n  (ite (= _comp top_impl_Instance_test_data_port_periodic_dest) Periodic\n  UNSPECIFIED_DISPATCH_PROTOCOL)))\n\n; 2 AADLPort\n(declare-datatypes ((AADLPort 0)) ((\n  (top_impl_Instance_test_data_port_periodic_src_write_port)\n  (top_impl_Instance_test_data_port_periodic_dest_read_port))))\n\n; 2 AADLPortComponent\n(declare-const AADLPortComponent (Array AADLPort AADLComponent))\n(assert (= top_impl_Instance_test_data_port_periodic_src (select AADLPortComponent top_impl_Instance_test_data_port_periodic_src_write_port)))\n(assert (= top_impl_Instance_test_data_port_periodic_dest (select AADLPortComponent top_impl_Instance_test_data_port_periodic_dest_read_port)))\n\n; 2 AADLPortType\n(declare-const AADLPortType (Array AADLPort PortType))\n(assert (= AadlDataPort (select AADLPortType top_impl_Instance_test_data_port_periodic_src_write_port)))\n(assert (= AadlDataPort (select AADLPortType top_impl_Instance_test_data_port_periodic_dest_read_port)))\n\n; 2 AADLPortDirection\n(declare-const AADLPortDirection (Array AADLPort Direction))\n(assert (= Out (select AADLPortDirection top_impl_Instance_test_data_port_periodic_src_write_port)))\n(assert (= In (select AADLPortDirection top_impl_Instance_test_data_port_periodic_dest_read_port)))\n\n; 0 AADLConnectionFlowTos\n(define-fun AADLConnectionFlowTos ((p1 AADLPort) (p2 AADLPort)) Bool\n  (or\n    false)\n)\n\n\n(declare-datatypes ((seL4PortType 0)) ((\n  (seL4GlobalAsynch)\n  (seL4GlobalAsynchCallback)\n  (seL4Notification)\n  (seL4RPCCall)\n  (seL4SharedData)\n  (seL4SharedDataWithCaps)\n  (seL4TimeServer)\n  (seL4VMDTBPassthrough)\n  (CASE_AADL_EventDataport))))\n\n; 2 CAmkESComponent\n(declare-datatypes ((CAmkESComponent 0)) ((\n  (test_data_port_periodic_src)\n  (test_data_port_periodic_dest)\n)))\n\n; 0 CAmkESPort\n(declare-datatypes ((CAmkESPort 0)) ((\n)))\n\n; 0 CAmkESConnection\n(declare-datatypes ((CAmkESConnection 0)) ((\n)))\n\n(define-fun isSelfPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType SelfPacing)\n       (or \n           false)))\n\n(define-fun isPacingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType Pacing)\n       (or \n           false)))\n\n(define-fun isPeriodicDispatchingConnection ((_conn CAmkESConnection)) Bool\n  (and (= ModelSchedulingType PeriodicDispatching)\n       (or \n            false)))\n\n; 0 CAmkESConnectionType\n(declare-const CAmkESConnectionType (Array CAmkESConnection seL4PortType))\n\n; 0 CAmkESPortComponent\n(declare-const CAmkESPortComponent (Array CAmkESPort CAmkESComponent))\n\n; 0 CAmkESConnectionFlowTos\n(define-fun CAmkESConnectionFlowTos ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort)) Bool\n  (or\n    false))\n\n\n; 2 ComponentRefinement\n(define-fun ComponentRefinement ((ac AADLComponent) (cc CAmkESComponent)) Bool\n  (or\n    (and (= ac top_impl_Instance_test_data_port_periodic_src) (= cc test_data_port_periodic_src))\n    (and (= ac top_impl_Instance_test_data_port_periodic_dest) (= cc test_data_port_periodic_dest))\n    false))\n\n; 0 PortRefinement\n(define-fun PortRefinement ((ap AADLPort) (cp CAmkESPort)) Bool\n  (or\n    false))\n\n\n(define-fun AADLFlowDirectionality () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (and (= Out (select AADLPortDirection p1)) (= In (select AADLPortDirection p2))))))\n\n(define-fun AADLFlowNoSelfConnection () Bool\n  (forall ((p1 AADLPort) (p2 AADLPort))\n    (=> (AADLConnectionFlowTos p1 p2)\n        (not (= p1 p2)))))\n\n(define-fun AADLConnectedPortTypeMatch () Bool\n  (forall ((src AADLPort) (dst AADLPort))\n    (=> (AADLConnectionFlowTos src dst)\n        (or\n          (and (= AadlDataPort (select AADLPortType src)) (= AadlDataPort (select AADLPortType dst)))(and (= AadlEventPort (select AADLPortType src)) (= AadlEventPort (select AADLPortType dst)))(and (= AadlEventDataPort (select AADLPortType src)) (= AadlEventDataPort (select AADLPortType dst)))\n          false))))\n\n(define-fun AADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (select AADLDispatchProtocol _comp)))))\n\n(define-fun altAADLDispatchProtocolSpecified () Bool\n  (forall ((_comp AADLComponent))\n    (not (= UNSPECIFIED_DISPATCH_PROTOCOL (altAADLDispatchProtocol _comp)))))\n\n(define-fun AADLWellFormedness () Bool\n  (and\n    altAADLDispatchProtocolSpecified\n    AADLDispatchProtocolSpecified\n    AADLFlowDirectionality\n    AADLFlowNoSelfConnection\n    AADLConnectedPortTypeMatch))\n\n\n(define-fun CAmkESFlowNoSelfConnection () Bool\n  (forall ((_conn CAmkESConnection) (_p1 CAmkESPort) (_p2 CAmkESPort))\n    (=> (CAmkESConnectionFlowTos _conn _p1 _p2)\n        (not (= _p1 _p2)))))\n\n(define-fun UniqueComponentRefinements () Bool\n  (forall ((aadlComponent1 AADLComponent) (camkesComponent CAmkESComponent))\n    (=> (ComponentRefinement aadlComponent1 camkesComponent)\n        (not (exists ((aadlComponent2 AADLComponent))\n               (and (not (= aadlComponent1 aadlComponent2))\n                    (ComponentRefinement aadlComponent2 camkesComponent)))))))\n\n(define-fun UniquePortRefinements () Bool\n  (forall ((aadlPort1 AADLPort) (camkesPort CAmkESPort))\n    (=> (PortRefinement aadlPort1 camkesPort)\n        (not (exists ((aadlPort2 AADLPort))\n               (and (not (= aadlPort1 aadlPort2))\n                    (PortRefinement aadlPort2 camkesPort)))))))\n\n(define-fun CAmkESWellFormedness () Bool\n  (and\n    CAmkESFlowNoSelfConnection))\n\n(define-fun DataPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n      (and (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n           (= (select CAmkESConnectionType conn) seL4SharedData )\n           (PortRefinement aadlSource camkesSource)\n           (PortRefinement aadlDest  camkesDest)\n           (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n           (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun EventPortRefinement ((aadlSource AADLPort) (aadlDest AADLPort)) Bool\n  (exists ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (and\n      (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (= (select CAmkESConnectionType conn) seL4Notification )\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest)))))\n\n(define-fun ConnectionPreservation () Bool\n  (forall ((aadlSource AADLPort) (aadlDest AADLPort))\n    (=> (AADLConnectionFlowTos aadlSource aadlDest)\n        (or\n          (and\n               (= AadlDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)) ; payload\n          (and\n               (= AadlEventPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; event counter\n               (EventPortRefinement aadlSource aadlDest)) ; event\n          (and\n               (= AadlEventDataPort (select AADLPortType aadlSource))\n               (DataPortRefinement aadlSource aadlDest)   ; payload\n               (EventPortRefinement aadlSource aadlDest)) ; event\n           false))))\n\n(define-fun isAADLConnectionRefinement ((camkesSource CAmkESPort) (camkesDest CAmkESPort)) Bool\n  (exists ((aadlSource AADLPort) (aadlDest AADLPort))\n    (and\n      (PortRefinement aadlSource camkesSource)\n      (PortRefinement aadlDest camkesDest)\n      (ComponentRefinement (select AADLPortComponent aadlSource) (select CAmkESPortComponent camkesSource))\n      (ComponentRefinement (select AADLPortComponent aadlDest) (select CAmkESPortComponent camkesDest))\n      (AADLConnectionFlowTos aadlSource aadlDest))))\n\n(define-fun isCAmkESSchedulingConnection ((_conn CAmkESConnection)) Bool\n  (or\n    (isSelfPacingConnection _conn)\n    (isPacingConnection _conn)\n    (isPeriodicDispatchingConnection _conn)\n    false))\n\n(define-fun NoNewConnections () Bool\n  (forall ((conn CAmkESConnection) (camkesSource CAmkESPort) (camkesDest CAmkESPort))\n    (=> (CAmkESConnectionFlowTos conn camkesSource camkesDest)\n      (or\n        (isAADLConnectionRefinement camkesSource camkesDest)\n        (isCAmkESSchedulingConnection conn)\n        false))))\n\n\n(echo \"RefinementProof: Shows that there is a model satisfying all the constraints (should be sat):\")\n(push)\n(assert (and\n  AADLWellFormedness\n  CAmkESWellFormedness\n  ConnectionPreservation\n  UniqueComponentRefinements\n  UniquePortRefinements\n  NoNewConnections\n))\n(check-sat)\n;(get-model)\n(pop)\n\n(echo \"AADLWellFormedness: Proves that the generated AADL evidence is well-formed (should be unsat):\")\n(push)\n(assert (not AADLWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"CAmkESWellFormedness: Proves that the generated CAmkES evidence is well-formed (should be unsat):\")\n(push)\n(assert (not CAmkESWellFormedness))\n(check-sat)\n(pop)\n\n(echo \"ConnectionPreservation: Proves that the generated CAmkES connections preserve AADL's (should be unsat):\")\n(push)\n(assert (not ConnectionPreservation))\n(check-sat)\n(pop)\n\n(echo \"NoNewConnections: Proves that the generated CAmkES connections does not contain more than AADL's (should be unsat):\")\n(push)\n(assert (not NoNewConnections))\n(check-sat)\n(pop)\n\n\n(exit)",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/source_t_impl_test_data_port_periodic_src\/source_t_impl_test_data_port_periodic_src.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_int8_t.idl4\";\nimport <std_connector.camkes>;\ncomponent source_t_impl_test_data_port_periodic_src {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_int8_t sb_write_port0;\n  consumes Notification sb_periodic_dispatch_notification;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/destination_t_impl_test_data_port_periodic_dest\/destination_t_impl_test_data_port_periodic_dest.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/interfaces\/sb_Monitor_int8_t.idl4\";\nimport <std_connector.camkes>;\ncomponent destination_t_impl_test_data_port_periodic_dest {\n  include <sb_types.h>;\n  control;\n  uses sb_Monitor_int8_t sb_read_port;\n  consumes DataportWrite sb_read_port_notification;\n  consumes Notification sb_periodic_dispatch_notification;\n  has semaphore sb_dispatch_sem;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/sb_Monitors\/sb_dest_read_port_Monitor\/sb_dest_read_port_Monitor.camkes",
        {
          "type" : "ITestResource",
          "content" : "import \"..\/..\/..\/interfaces\/sb_Monitor_int8_t.idl4\";\ncomponent sb_dest_read_port_Monitor {\n\n  provides sb_Monitor_int8_t mon;\n  emits DataportWrite monsig;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/dispatch_periodic\/dispatch_periodic.camkes",
        {
          "type" : "ITestResource",
          "content" : "import <global-connectors.camkes>;\ncomponent dispatch_periodic {\n  control;\n  uses Timer timer;\n  emits Notification sb_test_data_port_periodic_src_periodic_dispatch_notification;\n  emits Notification sb_test_data_port_periodic_dest_periodic_dispatch_notification;\n  consumes Notification timer_complete;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/top_impl_Instance.camkes",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <TimeServer\/TimeServer.camkes>;;\nimport \"components\/source_t_impl_test_data_port_periodic_src\/source_t_impl_test_data_port_periodic_src.camkes\";\nimport \"components\/destination_t_impl_test_data_port_periodic_dest\/destination_t_impl_test_data_port_periodic_dest.camkes\";\nimport \"components\/sb_Monitors\/sb_dest_read_port_Monitor\/sb_dest_read_port_Monitor.camkes\";\nimport \"components\/dispatch_periodic\/dispatch_periodic.camkes\";\n\nassembly {\n  composition {\n    component source_t_impl_test_data_port_periodic_src test_data_port_periodic_src;\n    component destination_t_impl_test_data_port_periodic_dest test_data_port_periodic_dest;\n    component sb_dest_read_port_Monitor sb_dest_read_port_monitor;\n    component dispatch_periodic dispatch_periodic_inst;\n    component TimeServer time_server;\n\n    connection seL4RPCCall conn1(from test_data_port_periodic_src.sb_write_port0, to sb_dest_read_port_monitor.mon);\n    connection seL4RPCCall conn2(from test_data_port_periodic_dest.sb_read_port, to sb_dest_read_port_monitor.mon);\n    connection seL4Notification conn3(from sb_dest_read_port_monitor.monsig, to test_data_port_periodic_dest.sb_read_port_notification);\n    connection seL4Notification conn4(from dispatch_periodic_inst.sb_test_data_port_periodic_src_periodic_dispatch_notification, to test_data_port_periodic_src.sb_periodic_dispatch_notification);\n    connection seL4Notification conn5(from dispatch_periodic_inst.sb_test_data_port_periodic_dest_periodic_dispatch_notification, to test_data_port_periodic_dest.sb_periodic_dispatch_notification);\n    connection seL4TimeServer conn6(from dispatch_periodic_inst.timer, to time_server.the_timer);\n    connection seL4GlobalAsynchCallback conn7(from time_server.timer_notification, to dispatch_periodic_inst.timer_complete);\n  }\n\n  configuration {\n    time_server.timers_per_client = 1;\n    dispatch_periodic_inst.timer_attributes = 1;\n    dispatch_periodic_inst.priority = 201;\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/source_t_impl_test_data_port_periodic_src\/src\/source.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <stdio.h>\n#include <sb_types.h>\n#include <sb_source_t_impl.h>\n\nstatic int8_t _value;\n\nvoid test_data_port_periodic_source_component_init(const int64_t *in_arg) {\n  printf(\"[%s] test_data_port_periodic_source_component_init called\\n\", get_instance_name());\n  _value = 0;\n}\n\nvoid test_data_port_periodic_source_component_time_triggered(const int64_t *arg) {\n  if (sb_write_port_write( &_value ) ) {\n    printf(\"---------------------------------------\\n\");\n    printf(\"[%s] Sent %d\\n\", get_instance_name(), _value );\n    _value = (_value + 1) % 500;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/destination_t_impl_test_data_port_periodic_dest\/src\/destination.c",
        {
          "type" : "ITestResource",
          "content" : "#include <camkes.h>\n#include <stdio.h>\n#include <sb_types.h>\n#include <sb_destination_t_impl.h>\n\nvoid test_data_port_periodic_destination_component_init(const int64_t *arg) {\n  printf(\"[%s] test_data_port_periodic_destination_component_init called\\n\", get_instance_name());\n}\n\nvoid test_data_port_periodic_destination_component_time_triggered(const int64_t *arg) {\n  int8_t value;\n\n  if(sb_read_port_read(&value)){\n    printf(\"[%s] value {%d}\\n\", get_instance_name(), value);\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/interfaces\/sb_Monitor_int8_t.idl4",
        {
          "type" : "ITestResource",
          "content" : "procedure sb_Monitor_int8_t {\n  include <sb_types.h>;\n  bool is_empty();\n  bool read(out int8_t m);\n  bool write(refin int8_t m);\n};",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/sb_Monitors\/sb_dest_read_port_Monitor\/src\/sb_dest_read_port_Monitor.c",
        {
          "type" : "ITestResource",
          "content" : "#include <sb_types.h>\n#include <sb_dest_read_port_Monitor.h>\n\nint monsig_emit(void);\n\nstatic int8_t contents;\nbool receivedData = false;\n\nbool mon_is_empty() {\n  return !receivedData;\n}\n\nbool mon_read(int8_t * m) {\n  *m = contents;\n  return receivedData;\n}\n\nbool mon_write(const int8_t * m) {\n  receivedData = true;\n  contents = *m;\n  monsig_emit();\n  return receivedData;\n}",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/sb_Monitors\/sb_dest_read_port_Monitor\/includes\/sb_dest_read_port_Monitor.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_DEST_READ_PORT_MONITOR_H\n#define SB_DEST_READ_PORT_MONITOR_H\n\n\n#endif \/\/ SB_DEST_READ_PORT_MONITOR_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (top_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nincludeGlobalComponents()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(source_t_impl_test_data_port_periodic_src\n  SOURCES components\/source_t_impl_test_data_port_periodic_src\/\/src\/source.c components\/source_t_impl_test_data_port_periodic_src\/src\/sb_source_t_impl.c\n  INCLUDES components\/source_t_impl_test_data_port_periodic_src\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(destination_t_impl_test_data_port_periodic_dest\n  SOURCES components\/destination_t_impl_test_data_port_periodic_dest\/\/src\/destination.c components\/destination_t_impl_test_data_port_periodic_dest\/src\/sb_destination_t_impl.c\n  INCLUDES components\/destination_t_impl_test_data_port_periodic_dest\/includes\/ types\/includes\n)\n\nDeclareCAmkESComponent(dispatch_periodic\n  SOURCES components\/dispatch_periodic\/src\/sb_dispatch_periodic.c\n  LIBS SB_Type_Library\n)\n\nDeclareCAmkESComponent(sb_dest_read_port_Monitor\n  SOURCES components\/sb_Monitors\/sb_dest_read_port_Monitor\/src\/sb_dest_read_port_Monitor.c\n  INCLUDES components\/sb_Monitors\/sb_dest_read_port_Monitor\/includes\/ types\/includes\n)\n\nDeclareCAmkESRootserver(top_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/bin\/run-camkes.sh",
        {
          "type" : "ITestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:sh\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate,help\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"-c, --camkes-dir       Location of CAmkES project\"\n  echo \"-n, --non-interactive  Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                         if present, CAmkES build directory will not be deleted\"\n  echo \"-o, --camkes-options   CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"-s, --simulate         Simulate via QEMU\"\n  echo \"-h, --help             Display this information\"\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\n    exit 2\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    -h|--help) usage; exit 0 ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\n  exit 3\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\ncat >${BUILD_DIR}\/sim << EOL\n#!\/usr\/bin\/env bash\n\nexport SCRIPT_HOME=\\$( cd \"\\$( dirname \"\\$0\" )\" &> \/dev\/null && pwd )\ncd \\${SCRIPT_HOME}\n\n# console output from simulation disappears when QEMU shuts down when run from\n# the CAmkES generated .\/simulate script. Instead call QEMU directly using the\n# default values .\/simulate would pass\n\nqemu-system-x86_64 \\\\\n    -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\\\n    -nographic \\\\\n    -serial mon:stdio \\\\\n    -m size=512M \\\\\n    -kernel images\/kernel-x86_64-pc99 \\\\\n    -initrd images\/capdl-loader-image-x86_64-pc99\nEOL\n\nchmod 700 ${BUILD_DIR}\/sim\necho \"Wrote: ${BUILD_DIR}\/sim\"\n\nif [ \"${SIMULATE}\" = true ]; then\n  # ${BUILD_DIR}\/simulate\n  ${BUILD_DIR}\/sim\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/source_t_impl_test_data_port_periodic_src\/src\/sb_source_t_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_source_t_impl.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic bool sb_occurred_periodic_dispatcher;\nstatic int64_t sb_time_periodic_dispatcher;\n\n\/************************************************************************\n * periodic_dispatcher_write_int64_t\n * Invoked from remote periodic dispatch thread.\n *\n * This function records the current time and triggers the active thread\n * dispatch from a periodic event.  Note that the periodic dispatch\n * thread is the *only* thread that triggers a dispatch, so we do not\n * mutex lock the function.\n *\n ************************************************************************\/\n\nbool periodic_dispatcher_write_int64_t(const int64_t * arg) {\n    sb_occurred_periodic_dispatcher = true;\n    sb_time_periodic_dispatcher = *arg;\n    MUTEXOP(sb_dispatch_sem_post());\n    return true;\n}\n\nvoid sb_periodic_dispatch_notification_callback(void *_ UNUSED) {\n   \/\/ we want time in microseconds, not nanoseconds, so we divide by 1000.\n   int64_t sb_time_periodic_dispatcher = 0; \/\/ sb_timer_time() \/ 1000LL -- timer connection disabled;\n   (void)periodic_dispatcher_write_int64_t(&sb_time_periodic_dispatcher);\n   CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n}\n\n\nvoid sb_entrypoint_source_t_impl_periodic_dispatcher(const int64_t * in_arg) {\n  test_data_port_periodic_source_component_time_triggered((int64_t *) in_arg);\n}\n\n\/************************************************************************\n * sb_write_port_write:\n * Invoked from user code in the local thread.\n *\n * This is the function invoked by the local thread to make a\n * call to write to a remote data port.\n *\n * XXX: When simulating fan out, the caller of this function will only\n * receive a positive response when all enqueues are successful. When a\n * negative response is received it only indicates that at least one\n * enqueue attempt failed.\n *\n ************************************************************************\/\nbool sb_write_port_write(const int8_t * sb_write_port){\n  bool sb_result = true;\n  sb_result &= sb_write_port0_write((int8_t *) sb_write_port);\n  return sb_result;\n}\n\n\/************************************************************************\n *  sb_entrypoint_source_t_impl_test_data_port_periodic_src_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_source_t_impl_test_data_port_periodic_src_initializer(const int64_t * in_arg) {\n  test_data_port_periodic_source_component_init((int64_t *) in_arg);\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_source_t_impl_test_data_port_periodic_src_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    if(sb_occurred_periodic_dispatcher){\n      sb_occurred_periodic_dispatcher = false;\n      sb_entrypoint_source_t_impl_periodic_dispatcher(&sb_time_periodic_dispatcher);\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/source_t_impl_test_data_port_periodic_src\/includes\/sb_source_t_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_SOURCE_T_IMPL_H\n#define SB_SOURCE_T_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_write_port_write(const int8_t * sb_write_port);\n\nvoid test_data_port_periodic_source_component_time_triggered(const int64_t *);\n\nvoid test_data_port_periodic_source_component_init(const int64_t *arg);\n\n#endif \/\/ SB_SOURCE_T_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/destination_t_impl_test_data_port_periodic_dest\/src\/sb_destination_t_impl.c",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_destination_t_impl.h>\n#include <string.h>\n#include <camkes.h>\n\nstatic bool sb_occurred_periodic_dispatcher;\nstatic int64_t sb_time_periodic_dispatcher;\n\n\/************************************************************************\n * periodic_dispatcher_write_int64_t\n * Invoked from remote periodic dispatch thread.\n *\n * This function records the current time and triggers the active thread\n * dispatch from a periodic event.  Note that the periodic dispatch\n * thread is the *only* thread that triggers a dispatch, so we do not\n * mutex lock the function.\n *\n ************************************************************************\/\n\nbool periodic_dispatcher_write_int64_t(const int64_t * arg) {\n    sb_occurred_periodic_dispatcher = true;\n    sb_time_periodic_dispatcher = *arg;\n    MUTEXOP(sb_dispatch_sem_post());\n    return true;\n}\n\nvoid sb_periodic_dispatch_notification_callback(void *_ UNUSED) {\n   \/\/ we want time in microseconds, not nanoseconds, so we divide by 1000.\n   int64_t sb_time_periodic_dispatcher = 0; \/\/ sb_timer_time() \/ 1000LL -- timer connection disabled;\n   (void)periodic_dispatcher_write_int64_t(&sb_time_periodic_dispatcher);\n   CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n}\n\n\nvoid sb_entrypoint_destination_t_impl_periodic_dispatcher(const int64_t * in_arg) {\n  test_data_port_periodic_destination_component_time_triggered((int64_t *) in_arg);\n}\n\n\/************************************************************************\n *  sb_entrypoint_destination_t_impl_test_data_port_periodic_dest_initializer:\n *\n * This is the function invoked by an active thread dispatcher to\n * call to a user-defined entrypoint function.  It sets up the dispatch\n * context for the user-defined entrypoint, then calls it.\n *\n ************************************************************************\/\nvoid sb_entrypoint_destination_t_impl_test_data_port_periodic_dest_initializer(const int64_t * in_arg) {\n  test_data_port_periodic_destination_component_init((int64_t *) in_arg);\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  CALLBACKOP(sb_periodic_dispatch_notification_reg_callback(sb_periodic_dispatch_notification_callback, NULL));\n  {\n    int64_t sb_dummy;\n    sb_entrypoint_destination_t_impl_test_data_port_periodic_dest_initializer(&sb_dummy);\n  }\n  MUTEXOP(sb_dispatch_sem_wait())\n  for(;;) {\n    MUTEXOP(sb_dispatch_sem_wait())\n    if(sb_occurred_periodic_dispatcher){\n      sb_occurred_periodic_dispatcher = false;\n      sb_entrypoint_destination_t_impl_periodic_dispatcher(&sb_time_periodic_dispatcher);\n    }\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/destination_t_impl_test_data_port_periodic_dest\/includes\/sb_destination_t_impl.h",
        {
          "type" : "ITestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_DESTINATION_T_IMPL_H\n#define SB_DESTINATION_T_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_read_port_read(int8_t * sb_read_port);\n\nvoid test_data_port_periodic_destination_component_time_triggered(const int64_t *);\n\nvoid test_data_port_periodic_destination_component_init(const int64_t *arg);\n\n#endif \/\/ SB_DESTINATION_T_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/components\/dispatch_periodic\/src\/sb_dispatch_periodic.c",
        {
          "type" : "ITestResource",
          "content" : "#include <string.h>\n#include <camkes.h>\n#include <sb_types.h>\n\n\/\/ prototypes for clock functions\nvoid clock_init();\nvoid clock_set_interval_in_ms(uint32_t interval);\nvoid clock_start_timer(void);\nvoid clock_irq_callback(void);\nuint64_t clock_get_time();\n\n\/\/ Declarations for managing periodic thread dispatch\nconst uint32_t aadl_tick_interval = 1;\nuint32_t aadl_calendar_counter = 0;\n\nvoid sb_thread_calendar() {\n  if ((aadl_calendar_counter % (1000 \/ aadl_tick_interval)) == 0) {\n    sb_test_data_port_periodic_src_periodic_dispatch_notification_emit();\n  }\n  if ((aadl_calendar_counter % (2000 \/ aadl_tick_interval)) == 0) {\n    sb_test_data_port_periodic_dest_periodic_dispatch_notification_emit();\n  }\n\n  aadl_calendar_counter++;\n}\n\nvoid timer_complete_callback() {\n  sb_thread_calendar();\n}\n\n\/\/ no op under the new time server scheme.\nvoid clock_init() { }\n\n\/\/ Set interrupt interval, in milliseconds.\nvoid clock_set_interval_in_ms(uint32_t interval) {\n  timer_periodic(0, ((uint64_t)interval) * NS_IN_MS);\n}\n\n\/\/ no op under the new time server scheme\nvoid clock_start_timer(void) { }\n\n\/\/ defer to time server\nuint64_t clock_get_time() {\n  return (timer_time() \/ NS_IN_MS);\n}\n\nint run(void) {\n  clock_init();\n  clock_set_interval_in_ms(1);\n  clock_start_timer();\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/types\/includes\/sb_types.h",
        {
          "type" : "ITestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/settings.cmake",
        {
          "type" : "ITestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n",
          "overwrite" : false,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ],
      [
        "test_data_port_periodic--SeL4_TB\/types\/CMakeLists.txt",
        {
          "type" : "ITestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            INTERFACE\n            )\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        INTERFACE\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           INTERFACE\n                           includes)\n",
          "overwrite" : true,
          "makeExecutable" : false,
          "makeCRLF" : false
        }
      ]
    ]
  }
}