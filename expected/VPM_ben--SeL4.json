{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = { return F }\n\n  def Integer_example(): Integer = { return z\"0\" }\n\n  def Integer_8_example(): Integer_8 = { return s8\"0\" }\n  def Integer_16_example(): Integer_16 = { return s16\"0\" }\n  def Integer_32_example(): Integer_32 = { return s32\"0\" }\n  def Integer_64_example(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_example(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_example(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_example(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_example(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_example(): Float = { return r\"0\" }\n  def Float_32_example(): Float_32 = { return f32\"0\" }\n  def Float_64_example(): Float_64 = { return f64\"0\" }\n\n  def Character_example(): Character = { return ' ' }\n  def String_example(): String = { return \"\" }\n\n  def Bits_example(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager : slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge = {\n    val AttestationRequest = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationRequest\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationResponse\", mode = EventIn)\n    val TrustedIds = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TrustedIds\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_InitiateAttestation\", mode = EventIn)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TerminateAttestation\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AttestationRequest = AttestationRequest,\n      AttestationResponse = AttestationResponse,\n      TrustedIds = TrustedIds,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate : slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge = {\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 5, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 6, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 7, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_In\", mode = EventIn)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 8, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_Out\", mode = EventOut)\n    val TrustedIds = Port[Base_Types.Bits] (id = 9, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_TrustedIds\", mode = EventIn)\n\n    slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge(\n      id = 1,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In,\n      Connection_Command_Out = Connection_Command_Out,\n      TrustedIds = TrustedIds\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1 : slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 10, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 11, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge(\n      id = 2,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2 : slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 12, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 13, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge(\n      id = 3,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low : slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge = {\n    val ADSB_Messages_In = Port[Base_Types.Bits] (id = 14, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_ADSB_Messages_In\", mode = EventIn)\n    val Response_In = Port[Base_Types.Bits] (id = 15, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Response_In\", mode = EventIn)\n    val AttestationRequest = Port[Base_Types.Bits] (id = 16, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationRequest\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Heartbeat_Out = Port[Base_Types.Bits] (id = 17, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Heartbeat_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Ownship_Out = Port[Base_Types.Bits] (id = 18, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Ownship_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Traffic_Out = Port[Base_Types.Bits] (id = 19, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Traffic_Out\", mode = EventOut)\n    val SHM_QUEUE_Response_Out = Port[Base_Types.Bits] (id = 20, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Response_Out\", mode = EventOut)\n    val SHM_QUEUE_AttestationRequest = Port[Base_Types.Bits] (id = 21, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationRequest\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 22, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_HEADER_adsb_to_ptab\", mode = EventIn)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 23, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_In\", mode = EventIn)\n    val Suspect_Traffic_In1 = Port[Base_Types.Bits] (id = 24, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In1\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out1 = Port[Base_Types.Bits] (id = 25, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out1\", mode = EventOut)\n    val Suspect_Traffic_In2 = Port[Base_Types.Bits] (id = 26, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In2\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out2 = Port[Base_Types.Bits] (id = 27, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out2\", mode = EventOut)\n    val Suspect_Traffic_In3 = Port[Base_Types.Bits] (id = 28, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In3\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out3 = Port[Base_Types.Bits] (id = 29, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out3\", mode = EventOut)\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 30, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_AttestationResponse = Port[Base_Types.Bits] (id = 31, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationResponse\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 32, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 33, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationResponse\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 34, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_Out\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 35, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_InitiateAttestation\", mode = EventOut)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 36, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_TerminateAttestation\", mode = EventIn)\n\n    slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge(\n      id = 4,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      ADSB_Messages_In = ADSB_Messages_In,\n      Response_In = Response_In,\n      AttestationRequest = AttestationRequest,\n      SHM_QUEUE_ADSB_Heartbeat_Out = SHM_QUEUE_ADSB_Heartbeat_Out,\n      SHM_QUEUE_ADSB_Ownship_Out = SHM_QUEUE_ADSB_Ownship_Out,\n      SHM_QUEUE_ADSB_Traffic_Out = SHM_QUEUE_ADSB_Traffic_Out,\n      SHM_QUEUE_Response_Out = SHM_QUEUE_Response_Out,\n      SHM_QUEUE_AttestationRequest = SHM_QUEUE_AttestationRequest,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_In = Connection_Command_In,\n      Suspect_Traffic_In1 = Suspect_Traffic_In1,\n      SHM_QUEUE_Suspect_Traffic_Out1 = SHM_QUEUE_Suspect_Traffic_Out1,\n      Suspect_Traffic_In2 = Suspect_Traffic_In2,\n      SHM_QUEUE_Suspect_Traffic_Out2 = SHM_QUEUE_Suspect_Traffic_Out2,\n      Suspect_Traffic_In3 = Suspect_Traffic_In3,\n      SHM_QUEUE_Suspect_Traffic_Out3 = SHM_QUEUE_Suspect_Traffic_Out3,\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_AttestationResponse = SHM_QUEUE_AttestationResponse,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      AttestationResponse = AttestationResponse,\n      Connection_Command_Out = Connection_Command_Out,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high : slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge = {\n    val SHM_QUEUE_ADSB_Heartbeat_In = Port[Base_Types.Bits] (id = 37, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Heartbeat_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Ownship_In = Port[Base_Types.Bits] (id = 38, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Ownship_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Traffic_In = Port[Base_Types.Bits] (id = 39, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Traffic_In\", mode = EventIn)\n    val SHM_QUEUE_Response_In = Port[Base_Types.Bits] (id = 40, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Response_In\", mode = EventIn)\n    val Response_Out = Port[Base_Types.Bits] (id = 41, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Response_Out\", mode = EventOut)\n    val ADSB_Messages_Out = Port[Base_Types.Bits] (id = 42, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_ADSB_Messages_Out\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 43, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_HEADER_adsb_to_ptab\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 44, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_Out\", mode = EventOut)\n    val Request_In = Port[Base_Types.Bits] (id = 45, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 46, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 47, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_In\", mode = EventIn)\n\n    slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge(\n      id = 5,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high\",\n      dispatchProtocol = Periodic(period = 250),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_ADSB_Heartbeat_In = SHM_QUEUE_ADSB_Heartbeat_In,\n      SHM_QUEUE_ADSB_Ownship_In = SHM_QUEUE_ADSB_Ownship_In,\n      SHM_QUEUE_ADSB_Traffic_In = SHM_QUEUE_ADSB_Traffic_In,\n      SHM_QUEUE_Response_In = SHM_QUEUE_Response_In,\n      Response_Out = Response_Out,\n      ADSB_Messages_Out = ADSB_Messages_Out,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_Out = Connection_Command_Out,\n      Request_In = Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In\n    )\n  }\n  val VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3 : slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 48, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 49, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge(\n      id = 6,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager, VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate, VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1, VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2, VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low, VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high, VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3),\n\n      connections = ISZ (Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationRequest, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationRequest),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TrustedIds, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.TrustedIds),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.TerminateAttestation, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.TerminateAttestation),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Request_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In1),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In2),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_QUEUE_Request_Out, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.SHM_QUEUE_Request_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.AttestationResponse, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.AttestationResponse),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.InitiateAttestation, to = VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager.InitiateAttestation),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Response_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Response_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Observed),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.ADSB_Messages_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.ADSB_Messages_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.SHM_HEADER_adsb_to_ptab, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.SHM_HEADER_adsb_to_ptab),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high.Connection_Command_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Connection_Command_In),\n                         Connection(from = VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3.Suspect_Traffic_Out, to = VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low.Suspect_Traffic_In3))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage slang_embedded\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/inspector\/slang_embedded\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi extends BridgeTestSuite[CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager) {\n\n  \/** helper function to set the values of all input ports.\n   * @param AttestationResponse payloads for event data port AttestationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AttestationResponse will be used\n   * @param InitiateAttestation payloads for event data port InitiateAttestation.\n   *   ART currently supports single element event data queues so\n   *   only the last element of InitiateAttestation will be used\n   *\/\n  def put_concrete_inputs(AttestationResponse : ISZ[Base_Types.Bits],\n                          InitiateAttestation : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- AttestationResponse){\n      put_AttestationResponse(v)\n    }\n    for(v <- InitiateAttestation){\n      put_InitiateAttestation(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AttestationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AttestationRequest'.\n   * @param TrustedIds method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'TrustedIds'.\n   * @param TerminateAttestation method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'TerminateAttestation'.\n   *\/\n  def check_concrete_output(AttestationRequest: ISZ[Base_Types.Bits] => B = AttestationRequestParam => {T},\n                            TrustedIds: ISZ[Base_Types.Bits] => B = TrustedIdsParam => {T},\n                            TerminateAttestation: ISZ[Base_Types.Bits] => B = TerminateAttestationParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AttestationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AttestationRequest().nonEmpty) AttestationRequestValue = AttestationRequestValue :+ get_AttestationRequest().get\n    if(!AttestationRequest(AttestationRequestValue)) {\n      testFailures = testFailures :+ st\"'AttestationRequest' did not match expected: received ${AttestationRequestValue.size} events with the following payloads ${AttestationRequestValue}\"\n    }\n    var TrustedIdsValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_TrustedIds().nonEmpty) TrustedIdsValue = TrustedIdsValue :+ get_TrustedIds().get\n    if(!TrustedIds(TrustedIdsValue)) {\n      testFailures = testFailures :+ st\"'TrustedIds' did not match expected: received ${TrustedIdsValue.size} events with the following payloads ${TrustedIdsValue}\"\n    }\n    var TerminateAttestationValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_TerminateAttestation().nonEmpty) TerminateAttestationValue = TerminateAttestationValue :+ get_TerminateAttestation().get\n    if(!TerminateAttestation(TerminateAttestationValue)) {\n      testFailures = testFailures :+ st\"'TerminateAttestation' did not match expected: received ${TerminateAttestationValue.size} events with the following payloads ${TerminateAttestationValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AttestationResponse(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_InitiateAttestation(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.InitiateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AttestationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AttestationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AttestationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AttestationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_TrustedIds(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_TrustedIds_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port TrustedIds.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_TrustedIds_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.TrustedIds_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_TerminateAttestation(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_TerminateAttestation_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port TerminateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_TerminateAttestation_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.TerminateAttestation_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Test extends CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AttestationRequest: Port[Base_Types.Bits],\n  AttestationResponse: Port[Base_Types.Bits],\n  TrustedIds: Port[Base_Types.Bits],\n  InitiateAttestation: Port[Base_Types.Bits],\n  TerminateAttestation: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(AttestationRequest,\n              AttestationResponse,\n              TrustedIds,\n              InitiateAttestation,\n              TerminateAttestation),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(AttestationResponse,\n                   InitiateAttestation),\n\n    eventOuts = ISZ(AttestationRequest,\n                    TrustedIds,\n                    TerminateAttestation)\n  )\n\n  val initialization_api : CASE_AttestationManager_Impl_Initialization_Api = {\n    val api = CASE_AttestationManager_Impl_Initialization_Api(\n      id,\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationManager_Impl_Operational_Api = {\n    val api = CASE_AttestationManager_Impl_Operational_Api(\n      id,\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.EntryPoints(\n      id,\n\n      AttestationRequest.id,\n      AttestationResponse.id,\n      TrustedIds.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationManager_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationManager_Impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_BridgeId : Art.BridgeId,\n\n    AttestationRequest_Id : Art.PortId,\n    AttestationResponse_Id : Art.PortId,\n    TrustedIds_Id : Art.PortId,\n    InitiateAttestation_Id : Art.PortId,\n    TerminateAttestation_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_AttestationManager_Impl_Initialization_Api,\n    operational_api: CASE_AttestationManager_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(AttestationResponse_Id,\n                                              InitiateAttestation_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(AttestationRequest_Id,\n                                               TrustedIds_Id,\n                                               TerminateAttestation_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationManager_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait CASE_AttestationManager_Impl_Api {\n  def id: Art.BridgeId\n  def AttestationRequest_Id : Art.PortId\n  def AttestationResponse_Id : Art.PortId\n  def TrustedIds_Id : Art.PortId\n  def InitiateAttestation_Id : Art.PortId\n  def TerminateAttestation_Id : Art.PortId\n\n  def put_AttestationRequest(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_TrustedIds(value : Base_Types.Bits) : Unit = {\n    Art.putValue(TrustedIds_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_TerminateAttestation(value : Base_Types.Bits) : Unit = {\n    Art.putValue(TerminateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationManager_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AttestationRequest_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends CASE_AttestationManager_Impl_Api\n\n@datatype class CASE_AttestationManager_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AttestationRequest_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends CASE_AttestationManager_Impl_Api {\n\n  def get_AttestationResponse() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AttestationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_InitiateAttestation() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(InitiateAttestation_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port InitiateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager {\n\n  def initialise(api: CASE_AttestationManager_Impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_AttestationRequest(Base_Types.Bits_example())\n    api.put_TrustedIds(Base_Types.Bits_example())\n    api.put_TerminateAttestation(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: CASE_AttestationManager_Impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_AttestationResponse: Option[Base_Types.Bits] = api.get_AttestationResponse()\n    api.logInfo(s\"Received on AttestationResponse: ${apiUsage_AttestationResponse}\")\n    val apiUsage_InitiateAttestation: Option[Base_Types.Bits] = api.get_InitiateAttestation()\n    api.logInfo(s\"Received on InitiateAttestation: ${apiUsage_InitiateAttestation}\")\n  }\n\n  def activate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_AttestationManager_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[slang_embedded.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi extends BridgeTestSuite[CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate) {\n\n  \/** helper function to set the values of all input ports.\n   * @param SHM_QUEUE_Request_In payloads for event data port SHM_QUEUE_Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Request_In will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   * @param TrustedIds payloads for event data port TrustedIds.\n   *   ART currently supports single element event data queues so\n   *   only the last element of TrustedIds will be used\n   *\/\n  def put_concrete_inputs(SHM_QUEUE_Request_In : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits],\n                          TrustedIds : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- SHM_QUEUE_Request_In){\n      put_SHM_QUEUE_Request_In(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n    for(v <- TrustedIds){\n      put_TrustedIds(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   *\/\n  def check_concrete_output(SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_TrustedIds(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.TrustedIds_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Test extends CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  SHM_QUEUE_Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  TrustedIds: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(SHM_QUEUE_Request_In,\n              SHM_QUEUE_Request_Out,\n              Connection_Command_In,\n              Connection_Command_Out,\n              TrustedIds),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(SHM_QUEUE_Request_In,\n                   Connection_Command_In,\n                   TrustedIds),\n\n    eventOuts = ISZ(SHM_QUEUE_Request_Out,\n                    Connection_Command_Out)\n  )\n\n  val initialization_api : CASE_AttestationGate_Impl_Initialization_Api = {\n    val api = CASE_AttestationGate_Impl_Initialization_Api(\n      id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id\n    )\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationGate_Impl_Operational_Api = {\n    val api = CASE_AttestationGate_Impl_Operational_Api(\n      id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id\n    )\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.EntryPoints(\n      id,\n\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n      Connection_Command_Out.id,\n      TrustedIds.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationGate_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationGate_Impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_BridgeId : Art.BridgeId,\n\n    SHM_QUEUE_Request_In_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    TrustedIds_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_AttestationGate_Impl_Initialization_Api,\n    operational_api: CASE_AttestationGate_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_Request_In_Id,\n                                              Connection_Command_In_Id,\n                                              TrustedIds_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_Request_Out_Id,\n                                               Connection_Command_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationGate_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait CASE_AttestationGate_Impl_Api {\n  def id: Art.BridgeId\n  def SHM_QUEUE_Request_In_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def TrustedIds_Id : Art.PortId\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationGate_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId) extends CASE_AttestationGate_Impl_Api\n\n@datatype class CASE_AttestationGate_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val TrustedIds_Id : Art.PortId) extends CASE_AttestationGate_Impl_Api {\n\n  def get_SHM_QUEUE_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_TrustedIds() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(TrustedIds_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port TrustedIds.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate {\n\n  def initialise(api: CASE_AttestationGate_Impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n    api.put_Connection_Command_Out(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: CASE_AttestationGate_Impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_Request_In()\n    api.logInfo(s\"Received on SHM_QUEUE_Request_In: ${apiUsage_SHM_QUEUE_Request_In}\")\n    val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = api.get_Connection_Command_In()\n    api.logInfo(s\"Received on Connection_Command_In: ${apiUsage_Connection_Command_In}\")\n    val apiUsage_TrustedIds: Option[Base_Types.Bits] = api.get_TrustedIds()\n    api.logInfo(s\"Received on TrustedIds: ${apiUsage_TrustedIds}\")\n  }\n\n  def activate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_AttestationGate_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi extends BridgeTestSuite[CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Test extends CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor1_Impl_Initialization_Api = {\n    val api = CASE_Monitor1_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor1_Impl_Operational_Api = {\n    val api = CASE_Monitor1_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor1_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor1_Impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor1_Impl_Initialization_Api,\n    operational_api: CASE_Monitor1_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor1_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor1_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor1_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait CASE_Monitor1_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor1_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor1_Impl_Api\n\n@datatype class CASE_Monitor1_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor1_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 {\n\n  def initialise(api: CASE_Monitor1_Impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: CASE_Monitor1_Impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Observed: Option[Base_Types.Bits] = api.get_Observed()\n    api.logInfo(s\"Received on Observed: ${apiUsage_Observed}\")\n  }\n\n  def activate(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor1_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi extends BridgeTestSuite[CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Test extends CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor2_Impl_Initialization_Api = {\n    val api = CASE_Monitor2_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor2_Impl_Operational_Api = {\n    val api = CASE_Monitor2_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor2_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor2_Impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor2_Impl_Initialization_Api,\n    operational_api: CASE_Monitor2_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor2_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor2_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor2_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait CASE_Monitor2_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor2_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor2_Impl_Api\n\n@datatype class CASE_Monitor2_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor2_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 {\n\n  def initialise(api: CASE_Monitor2_Impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: CASE_Monitor2_Impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Observed: Option[Base_Types.Bits] = api.get_Observed()\n    api.logInfo(s\"Received on Observed: ${apiUsage_Observed}\")\n  }\n\n  def activate(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor2_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class adapter_low_impl_SW_adapter_low_adapter_low_TestApi extends BridgeTestSuite[adapter_low_impl_SW_adapter_low_adapter_low_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low) {\n\n  \/** helper function to set the values of all input ports.\n   * @param ADSB_Messages_In payloads for event data port ADSB_Messages_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of ADSB_Messages_In will be used\n   * @param Response_In payloads for event data port Response_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Response_In will be used\n   * @param AttestationRequest payloads for event data port AttestationRequest.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AttestationRequest will be used\n   * @param SHM_HEADER_adsb_to_ptab payloads for event data port SHM_HEADER_adsb_to_ptab.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_HEADER_adsb_to_ptab will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   * @param Suspect_Traffic_In1 payloads for event data port Suspect_Traffic_In1.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In1 will be used\n   * @param Suspect_Traffic_In2 payloads for event data port Suspect_Traffic_In2.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In2 will be used\n   * @param Suspect_Traffic_In3 payloads for event data port Suspect_Traffic_In3.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Suspect_Traffic_In3 will be used\n   * @param SHM_QUEUE_Request_In payloads for event data port SHM_QUEUE_Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Request_In will be used\n   * @param SHM_QUEUE_AttestationResponse payloads for event data port SHM_QUEUE_AttestationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_AttestationResponse will be used\n   * @param TerminateAttestation payloads for event data port TerminateAttestation.\n   *   ART currently supports single element event data queues so\n   *   only the last element of TerminateAttestation will be used\n   *\/\n  def put_concrete_inputs(ADSB_Messages_In : ISZ[Base_Types.Bits],\n                          Response_In : ISZ[Base_Types.Bits],\n                          AttestationRequest : ISZ[Base_Types.Bits],\n                          SHM_HEADER_adsb_to_ptab : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In1 : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In2 : ISZ[Base_Types.Bits],\n                          Suspect_Traffic_In3 : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_Request_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_AttestationResponse : ISZ[Base_Types.Bits],\n                          TerminateAttestation : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- ADSB_Messages_In){\n      put_ADSB_Messages_In(v)\n    }\n    for(v <- Response_In){\n      put_Response_In(v)\n    }\n    for(v <- AttestationRequest){\n      put_AttestationRequest(v)\n    }\n    for(v <- SHM_HEADER_adsb_to_ptab){\n      put_SHM_HEADER_adsb_to_ptab(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n    for(v <- Suspect_Traffic_In1){\n      put_Suspect_Traffic_In1(v)\n    }\n    for(v <- Suspect_Traffic_In2){\n      put_Suspect_Traffic_In2(v)\n    }\n    for(v <- Suspect_Traffic_In3){\n      put_Suspect_Traffic_In3(v)\n    }\n    for(v <- SHM_QUEUE_Request_In){\n      put_SHM_QUEUE_Request_In(v)\n    }\n    for(v <- SHM_QUEUE_AttestationResponse){\n      put_SHM_QUEUE_AttestationResponse(v)\n    }\n    for(v <- TerminateAttestation){\n      put_TerminateAttestation(v)\n    }\n  }\n\n\n  \/** helper function to check adapter_low_impl_SW_adapter_low_adapter_low's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param SHM_QUEUE_ADSB_Heartbeat_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Heartbeat_Out'.\n   * @param SHM_QUEUE_ADSB_Ownship_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Ownship_Out'.\n   * @param SHM_QUEUE_ADSB_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_ADSB_Traffic_Out'.\n   * @param SHM_QUEUE_Response_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Response_Out'.\n   * @param SHM_QUEUE_AttestationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_AttestationRequest'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out1 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out1'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out2 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out2'.\n   * @param SHM_QUEUE_Suspect_Traffic_Out3 method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Suspect_Traffic_Out3'.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   * @param AttestationResponse method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AttestationResponse'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   * @param InitiateAttestation method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'InitiateAttestation'.\n   *\/\n  def check_concrete_output(SHM_QUEUE_ADSB_Heartbeat_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Heartbeat_OutParam => {T},\n                            SHM_QUEUE_ADSB_Ownship_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Ownship_OutParam => {T},\n                            SHM_QUEUE_ADSB_Traffic_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_ADSB_Traffic_OutParam => {T},\n                            SHM_QUEUE_Response_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Response_OutParam => {T},\n                            SHM_QUEUE_AttestationRequest: ISZ[Base_Types.Bits] => B = SHM_QUEUE_AttestationRequestParam => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out1: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out1Param => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out2: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out2Param => {T},\n                            SHM_QUEUE_Suspect_Traffic_Out3: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Suspect_Traffic_Out3Param => {T},\n                            SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T},\n                            AttestationResponse: ISZ[Base_Types.Bits] => B = AttestationResponseParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T},\n                            InitiateAttestation: ISZ[Base_Types.Bits] => B = InitiateAttestationParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var SHM_QUEUE_ADSB_Heartbeat_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Heartbeat_Out().nonEmpty) SHM_QUEUE_ADSB_Heartbeat_OutValue = SHM_QUEUE_ADSB_Heartbeat_OutValue :+ get_SHM_QUEUE_ADSB_Heartbeat_Out().get\n    if(!SHM_QUEUE_ADSB_Heartbeat_Out(SHM_QUEUE_ADSB_Heartbeat_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Heartbeat_Out' did not match expected: received ${SHM_QUEUE_ADSB_Heartbeat_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Heartbeat_OutValue}\"\n    }\n    var SHM_QUEUE_ADSB_Ownship_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Ownship_Out().nonEmpty) SHM_QUEUE_ADSB_Ownship_OutValue = SHM_QUEUE_ADSB_Ownship_OutValue :+ get_SHM_QUEUE_ADSB_Ownship_Out().get\n    if(!SHM_QUEUE_ADSB_Ownship_Out(SHM_QUEUE_ADSB_Ownship_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Ownship_Out' did not match expected: received ${SHM_QUEUE_ADSB_Ownship_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Ownship_OutValue}\"\n    }\n    var SHM_QUEUE_ADSB_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_ADSB_Traffic_Out().nonEmpty) SHM_QUEUE_ADSB_Traffic_OutValue = SHM_QUEUE_ADSB_Traffic_OutValue :+ get_SHM_QUEUE_ADSB_Traffic_Out().get\n    if(!SHM_QUEUE_ADSB_Traffic_Out(SHM_QUEUE_ADSB_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_ADSB_Traffic_Out' did not match expected: received ${SHM_QUEUE_ADSB_Traffic_OutValue.size} events with the following payloads ${SHM_QUEUE_ADSB_Traffic_OutValue}\"\n    }\n    var SHM_QUEUE_Response_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Response_Out().nonEmpty) SHM_QUEUE_Response_OutValue = SHM_QUEUE_Response_OutValue :+ get_SHM_QUEUE_Response_Out().get\n    if(!SHM_QUEUE_Response_Out(SHM_QUEUE_Response_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Response_Out' did not match expected: received ${SHM_QUEUE_Response_OutValue.size} events with the following payloads ${SHM_QUEUE_Response_OutValue}\"\n    }\n    var SHM_QUEUE_AttestationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_AttestationRequest().nonEmpty) SHM_QUEUE_AttestationRequestValue = SHM_QUEUE_AttestationRequestValue :+ get_SHM_QUEUE_AttestationRequest().get\n    if(!SHM_QUEUE_AttestationRequest(SHM_QUEUE_AttestationRequestValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_AttestationRequest' did not match expected: received ${SHM_QUEUE_AttestationRequestValue.size} events with the following payloads ${SHM_QUEUE_AttestationRequestValue}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out1Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out1().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out1Value = SHM_QUEUE_Suspect_Traffic_Out1Value :+ get_SHM_QUEUE_Suspect_Traffic_Out1().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out1(SHM_QUEUE_Suspect_Traffic_Out1Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out1' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out1Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out1Value}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out2Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out2().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out2Value = SHM_QUEUE_Suspect_Traffic_Out2Value :+ get_SHM_QUEUE_Suspect_Traffic_Out2().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out2(SHM_QUEUE_Suspect_Traffic_Out2Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out2' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out2Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out2Value}\"\n    }\n    var SHM_QUEUE_Suspect_Traffic_Out3Value: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Suspect_Traffic_Out3().nonEmpty) SHM_QUEUE_Suspect_Traffic_Out3Value = SHM_QUEUE_Suspect_Traffic_Out3Value :+ get_SHM_QUEUE_Suspect_Traffic_Out3().get\n    if(!SHM_QUEUE_Suspect_Traffic_Out3(SHM_QUEUE_Suspect_Traffic_Out3Value)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Suspect_Traffic_Out3' did not match expected: received ${SHM_QUEUE_Suspect_Traffic_Out3Value.size} events with the following payloads ${SHM_QUEUE_Suspect_Traffic_Out3Value}\"\n    }\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n    var AttestationResponseValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AttestationResponse().nonEmpty) AttestationResponseValue = AttestationResponseValue :+ get_AttestationResponse().get\n    if(!AttestationResponse(AttestationResponseValue)) {\n      testFailures = testFailures :+ st\"'AttestationResponse' did not match expected: received ${AttestationResponseValue.size} events with the following payloads ${AttestationResponseValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n    var InitiateAttestationValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_InitiateAttestation().nonEmpty) InitiateAttestationValue = InitiateAttestationValue :+ get_InitiateAttestation().get\n    if(!InitiateAttestation(InitiateAttestationValue)) {\n      testFailures = testFailures :+ st\"'InitiateAttestation' did not match expected: received ${InitiateAttestationValue.size} events with the following payloads ${InitiateAttestationValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_ADSB_Messages_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ADSB_Messages_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Response_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Response_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AttestationRequest(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_HEADER_adsb_to_ptab(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_HEADER_adsb_to_ptab_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In1(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In1_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In2(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In2_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Suspect_Traffic_In3(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Suspect_Traffic_In3_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_AttestationResponse(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_TerminateAttestation(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.TerminateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Heartbeat_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Heartbeat_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Heartbeat_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Heartbeat_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Heartbeat_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Ownship_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Ownship_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Ownship_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Ownship_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Ownship_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_ADSB_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_ADSB_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_ADSB_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_ADSB_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Response_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Response_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Response_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Response_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Response_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_AttestationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_AttestationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_AttestationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_AttestationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out1(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out1_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out1_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out1_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out2(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out2_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out2.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out2_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out2_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out3(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Suspect_Traffic_Out3_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Suspect_Traffic_Out3.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Suspect_Traffic_Out3_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Suspect_Traffic_Out3_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AttestationResponse(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AttestationResponse_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AttestationResponse_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AttestationResponse_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_InitiateAttestation(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_InitiateAttestation_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port InitiateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_InitiateAttestation_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.InitiateAttestation_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass adapter_low_impl_SW_adapter_low_adapter_low_Test extends adapter_low_impl_SW_adapter_low_adapter_low_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{adapter_low_impl_SW_adapter_low_adapter_low => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class adapter_low_impl_SW_adapter_low_adapter_low_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  ADSB_Messages_In: Port[Base_Types.Bits],\n  Response_In: Port[Base_Types.Bits],\n  AttestationRequest: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Heartbeat_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Ownship_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Traffic_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_Response_Out: Port[Base_Types.Bits],\n  SHM_QUEUE_AttestationRequest: Port[Base_Types.Bits],\n  SHM_HEADER_adsb_to_ptab: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits],\n  Suspect_Traffic_In1: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out1: Port[Base_Types.Bits],\n  Suspect_Traffic_In2: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out2: Port[Base_Types.Bits],\n  Suspect_Traffic_In3: Port[Base_Types.Bits],\n  SHM_QUEUE_Suspect_Traffic_Out3: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_AttestationResponse: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  AttestationResponse: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  InitiateAttestation: Port[Base_Types.Bits],\n  TerminateAttestation: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(ADSB_Messages_In,\n              Response_In,\n              AttestationRequest,\n              SHM_QUEUE_ADSB_Heartbeat_Out,\n              SHM_QUEUE_ADSB_Ownship_Out,\n              SHM_QUEUE_ADSB_Traffic_Out,\n              SHM_QUEUE_Response_Out,\n              SHM_QUEUE_AttestationRequest,\n              SHM_HEADER_adsb_to_ptab,\n              Connection_Command_In,\n              Suspect_Traffic_In1,\n              SHM_QUEUE_Suspect_Traffic_Out1,\n              Suspect_Traffic_In2,\n              SHM_QUEUE_Suspect_Traffic_Out2,\n              Suspect_Traffic_In3,\n              SHM_QUEUE_Suspect_Traffic_Out3,\n              SHM_QUEUE_Request_In,\n              SHM_QUEUE_AttestationResponse,\n              SHM_QUEUE_Request_Out,\n              AttestationResponse,\n              Connection_Command_Out,\n              InitiateAttestation,\n              TerminateAttestation),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(ADSB_Messages_In,\n                   Response_In,\n                   AttestationRequest,\n                   SHM_HEADER_adsb_to_ptab,\n                   Connection_Command_In,\n                   Suspect_Traffic_In1,\n                   Suspect_Traffic_In2,\n                   Suspect_Traffic_In3,\n                   SHM_QUEUE_Request_In,\n                   SHM_QUEUE_AttestationResponse,\n                   TerminateAttestation),\n\n    eventOuts = ISZ(SHM_QUEUE_ADSB_Heartbeat_Out,\n                    SHM_QUEUE_ADSB_Ownship_Out,\n                    SHM_QUEUE_ADSB_Traffic_Out,\n                    SHM_QUEUE_Response_Out,\n                    SHM_QUEUE_AttestationRequest,\n                    SHM_QUEUE_Suspect_Traffic_Out1,\n                    SHM_QUEUE_Suspect_Traffic_Out2,\n                    SHM_QUEUE_Suspect_Traffic_Out3,\n                    SHM_QUEUE_Request_Out,\n                    AttestationResponse,\n                    Connection_Command_Out,\n                    InitiateAttestation)\n  )\n\n  val initialization_api : adapter_low_impl_Initialization_Api = {\n    val api = adapter_low_impl_Initialization_Api(\n      id,\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : adapter_low_impl_Operational_Api = {\n    val api = adapter_low_impl_Operational_Api(\n      id,\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id\n    )\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    adapter_low_impl_SW_adapter_low_adapter_low_Bridge.EntryPoints(\n      id,\n\n      ADSB_Messages_In.id,\n      Response_In.id,\n      AttestationRequest.id,\n      SHM_QUEUE_ADSB_Heartbeat_Out.id,\n      SHM_QUEUE_ADSB_Ownship_Out.id,\n      SHM_QUEUE_ADSB_Traffic_Out.id,\n      SHM_QUEUE_Response_Out.id,\n      SHM_QUEUE_AttestationRequest.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_In.id,\n      Suspect_Traffic_In1.id,\n      SHM_QUEUE_Suspect_Traffic_Out1.id,\n      Suspect_Traffic_In2.id,\n      SHM_QUEUE_Suspect_Traffic_Out2.id,\n      Suspect_Traffic_In3.id,\n      SHM_QUEUE_Suspect_Traffic_Out3.id,\n      SHM_QUEUE_Request_In.id,\n      SHM_QUEUE_AttestationResponse.id,\n      SHM_QUEUE_Request_Out.id,\n      AttestationResponse.id,\n      Connection_Command_Out.id,\n      InitiateAttestation.id,\n      TerminateAttestation.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject adapter_low_impl_SW_adapter_low_adapter_low_Bridge {\n\n  var c_initialization_api: Option[adapter_low_impl_Initialization_Api] = None()\n  var c_operational_api: Option[adapter_low_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    adapter_low_impl_SW_adapter_low_adapter_low_BridgeId : Art.BridgeId,\n\n    ADSB_Messages_In_Id : Art.PortId,\n    Response_In_Id : Art.PortId,\n    AttestationRequest_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n    SHM_QUEUE_Response_Out_Id : Art.PortId,\n    SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n    SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n    Suspect_Traffic_In1_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n    Suspect_Traffic_In2_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n    Suspect_Traffic_In3_Id : Art.PortId,\n    SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n    SHM_QUEUE_Request_In_Id : Art.PortId,\n    SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    AttestationResponse_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    InitiateAttestation_Id : Art.PortId,\n    TerminateAttestation_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: adapter_low_impl_Initialization_Api,\n    operational_api: adapter_low_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(ADSB_Messages_In_Id,\n                                              Response_In_Id,\n                                              AttestationRequest_Id,\n                                              SHM_HEADER_adsb_to_ptab_Id,\n                                              Connection_Command_In_Id,\n                                              Suspect_Traffic_In1_Id,\n                                              Suspect_Traffic_In2_Id,\n                                              Suspect_Traffic_In3_Id,\n                                              SHM_QUEUE_Request_In_Id,\n                                              SHM_QUEUE_AttestationResponse_Id,\n                                              TerminateAttestation_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_ADSB_Heartbeat_Out_Id,\n                                               SHM_QUEUE_ADSB_Ownship_Out_Id,\n                                               SHM_QUEUE_ADSB_Traffic_Out_Id,\n                                               SHM_QUEUE_Response_Out_Id,\n                                               SHM_QUEUE_AttestationRequest_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out1_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out2_Id,\n                                               SHM_QUEUE_Suspect_Traffic_Out3_Id,\n                                               SHM_QUEUE_Request_Out_Id,\n                                               AttestationResponse_Id,\n                                               Connection_Command_Out_Id,\n                                               InitiateAttestation_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: adapter_low_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: adapter_low_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/adapter_low_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait adapter_low_impl_Api {\n  def id: Art.BridgeId\n  def ADSB_Messages_In_Id : Art.PortId\n  def Response_In_Id : Art.PortId\n  def AttestationRequest_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId\n  def SHM_QUEUE_Response_Out_Id : Art.PortId\n  def SHM_QUEUE_AttestationRequest_Id : Art.PortId\n  def SHM_HEADER_adsb_to_ptab_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n  def Suspect_Traffic_In1_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId\n  def Suspect_Traffic_In2_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId\n  def Suspect_Traffic_In3_Id : Art.PortId\n  def SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId\n  def SHM_QUEUE_Request_In_Id : Art.PortId\n  def SHM_QUEUE_AttestationResponse_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def AttestationResponse_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def InitiateAttestation_Id : Art.PortId\n  def TerminateAttestation_Id : Art.PortId\n\n  def put_SHM_QUEUE_ADSB_Heartbeat_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Heartbeat_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_ADSB_Ownship_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Ownship_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_ADSB_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_ADSB_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Response_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Response_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_AttestationRequest(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_AttestationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out1(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out1_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out2(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out2_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Suspect_Traffic_Out3(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Suspect_Traffic_Out3_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AttestationResponse(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AttestationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_InitiateAttestation(value : Base_Types.Bits) : Unit = {\n    Art.putValue(InitiateAttestation_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class adapter_low_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val ADSB_Messages_In_Id : Art.PortId,\n  val Response_In_Id : Art.PortId,\n  val AttestationRequest_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n  val SHM_QUEUE_Response_Out_Id : Art.PortId,\n  val SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Suspect_Traffic_In1_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n  val Suspect_Traffic_In2_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n  val Suspect_Traffic_In3_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends adapter_low_impl_Api\n\n@datatype class adapter_low_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val ADSB_Messages_In_Id : Art.PortId,\n  val Response_In_Id : Art.PortId,\n  val AttestationRequest_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Heartbeat_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_Out_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_Out_Id : Art.PortId,\n  val SHM_QUEUE_Response_Out_Id : Art.PortId,\n  val SHM_QUEUE_AttestationRequest_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId,\n  val Suspect_Traffic_In1_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out1_Id : Art.PortId,\n  val Suspect_Traffic_In2_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out2_Id : Art.PortId,\n  val Suspect_Traffic_In3_Id : Art.PortId,\n  val SHM_QUEUE_Suspect_Traffic_Out3_Id : Art.PortId,\n  val SHM_QUEUE_Request_In_Id : Art.PortId,\n  val SHM_QUEUE_AttestationResponse_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val AttestationResponse_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val InitiateAttestation_Id : Art.PortId,\n  val TerminateAttestation_Id : Art.PortId) extends adapter_low_impl_Api {\n\n  def get_ADSB_Messages_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(ADSB_Messages_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ADSB_Messages_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Response_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Response_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Response_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_AttestationRequest() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AttestationRequest_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AttestationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_HEADER_adsb_to_ptab() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_HEADER_adsb_to_ptab_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_HEADER_adsb_to_ptab.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In1() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In1_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In2() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In2_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In2.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Suspect_Traffic_In3() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Suspect_Traffic_In3_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Suspect_Traffic_In3.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_AttestationResponse() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_AttestationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_AttestationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_TerminateAttestation() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(TerminateAttestation_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port TerminateAttestation.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject adapter_low_impl_SW_adapter_low_adapter_low {\n\n  def initialise(api: adapter_low_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n    api.put_AttestationResponse(Base_Types.Bits_example())\n    api.put_Connection_Command_Out(Base_Types.Bits_example())\n    api.put_InitiateAttestation(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: adapter_low_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_ADSB_Messages_In: Option[Base_Types.Bits] = api.get_ADSB_Messages_In()\n    api.logInfo(s\"Received on ADSB_Messages_In: ${apiUsage_ADSB_Messages_In}\")\n    val apiUsage_Response_In: Option[Base_Types.Bits] = api.get_Response_In()\n    api.logInfo(s\"Received on Response_In: ${apiUsage_Response_In}\")\n    val apiUsage_AttestationRequest: Option[Base_Types.Bits] = api.get_AttestationRequest()\n    api.logInfo(s\"Received on AttestationRequest: ${apiUsage_AttestationRequest}\")\n    val apiUsage_SHM_HEADER_adsb_to_ptab: Option[Base_Types.Bits] = api.get_SHM_HEADER_adsb_to_ptab()\n    api.logInfo(s\"Received on SHM_HEADER_adsb_to_ptab: ${apiUsage_SHM_HEADER_adsb_to_ptab}\")\n    val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = api.get_Connection_Command_In()\n    api.logInfo(s\"Received on Connection_Command_In: ${apiUsage_Connection_Command_In}\")\n    val apiUsage_Suspect_Traffic_In1: Option[Base_Types.Bits] = api.get_Suspect_Traffic_In1()\n    api.logInfo(s\"Received on Suspect_Traffic_In1: ${apiUsage_Suspect_Traffic_In1}\")\n    val apiUsage_Suspect_Traffic_In2: Option[Base_Types.Bits] = api.get_Suspect_Traffic_In2()\n    api.logInfo(s\"Received on Suspect_Traffic_In2: ${apiUsage_Suspect_Traffic_In2}\")\n    val apiUsage_Suspect_Traffic_In3: Option[Base_Types.Bits] = api.get_Suspect_Traffic_In3()\n    api.logInfo(s\"Received on Suspect_Traffic_In3: ${apiUsage_Suspect_Traffic_In3}\")\n    val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_Request_In()\n    api.logInfo(s\"Received on SHM_QUEUE_Request_In: ${apiUsage_SHM_QUEUE_Request_In}\")\n    val apiUsage_SHM_QUEUE_AttestationResponse: Option[Base_Types.Bits] = api.get_SHM_QUEUE_AttestationResponse()\n    api.logInfo(s\"Received on SHM_QUEUE_AttestationResponse: ${apiUsage_SHM_QUEUE_AttestationResponse}\")\n    val apiUsage_TerminateAttestation: Option[Base_Types.Bits] = api.get_TerminateAttestation()\n    api.logInfo(s\"Received on TerminateAttestation: ${apiUsage_TerminateAttestation}\")\n  }\n\n  def activate(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def finalise(api: adapter_low_impl_Operational_Api): Unit = { }\n\n  def recover(api: adapter_low_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class adapter_high_impl_SW_adapter_high_adapter_high_TestApi extends BridgeTestSuite[adapter_high_impl_SW_adapter_high_adapter_high_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high) {\n\n  \/** helper function to set the values of all input ports.\n   * @param SHM_QUEUE_ADSB_Heartbeat_In payloads for event data port SHM_QUEUE_ADSB_Heartbeat_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Heartbeat_In will be used\n   * @param SHM_QUEUE_ADSB_Ownship_In payloads for event data port SHM_QUEUE_ADSB_Ownship_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Ownship_In will be used\n   * @param SHM_QUEUE_ADSB_Traffic_In payloads for event data port SHM_QUEUE_ADSB_Traffic_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_ADSB_Traffic_In will be used\n   * @param SHM_QUEUE_Response_In payloads for event data port SHM_QUEUE_Response_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of SHM_QUEUE_Response_In will be used\n   * @param Request_In payloads for event data port Request_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Request_In will be used\n   * @param Connection_Command_In payloads for event data port Connection_Command_In.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Connection_Command_In will be used\n   *\/\n  def put_concrete_inputs(SHM_QUEUE_ADSB_Heartbeat_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_ADSB_Ownship_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_ADSB_Traffic_In : ISZ[Base_Types.Bits],\n                          SHM_QUEUE_Response_In : ISZ[Base_Types.Bits],\n                          Request_In : ISZ[Base_Types.Bits],\n                          Connection_Command_In : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- SHM_QUEUE_ADSB_Heartbeat_In){\n      put_SHM_QUEUE_ADSB_Heartbeat_In(v)\n    }\n    for(v <- SHM_QUEUE_ADSB_Ownship_In){\n      put_SHM_QUEUE_ADSB_Ownship_In(v)\n    }\n    for(v <- SHM_QUEUE_ADSB_Traffic_In){\n      put_SHM_QUEUE_ADSB_Traffic_In(v)\n    }\n    for(v <- SHM_QUEUE_Response_In){\n      put_SHM_QUEUE_Response_In(v)\n    }\n    for(v <- Request_In){\n      put_Request_In(v)\n    }\n    for(v <- Connection_Command_In){\n      put_Connection_Command_In(v)\n    }\n  }\n\n\n  \/** helper function to check adapter_high_impl_SW_adapter_high_adapter_high's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Response_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Response_Out'.\n   * @param ADSB_Messages_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'ADSB_Messages_Out'.\n   * @param SHM_HEADER_adsb_to_ptab method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_HEADER_adsb_to_ptab'.\n   * @param Connection_Command_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Connection_Command_Out'.\n   * @param SHM_QUEUE_Request_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'SHM_QUEUE_Request_Out'.\n   *\/\n  def check_concrete_output(Response_Out: ISZ[Base_Types.Bits] => B = Response_OutParam => {T},\n                            ADSB_Messages_Out: ISZ[Base_Types.Bits] => B = ADSB_Messages_OutParam => {T},\n                            SHM_HEADER_adsb_to_ptab: ISZ[Base_Types.Bits] => B = SHM_HEADER_adsb_to_ptabParam => {T},\n                            Connection_Command_Out: ISZ[Base_Types.Bits] => B = Connection_Command_OutParam => {T},\n                            SHM_QUEUE_Request_Out: ISZ[Base_Types.Bits] => B = SHM_QUEUE_Request_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Response_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Response_Out().nonEmpty) Response_OutValue = Response_OutValue :+ get_Response_Out().get\n    if(!Response_Out(Response_OutValue)) {\n      testFailures = testFailures :+ st\"'Response_Out' did not match expected: received ${Response_OutValue.size} events with the following payloads ${Response_OutValue}\"\n    }\n    var ADSB_Messages_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_ADSB_Messages_Out().nonEmpty) ADSB_Messages_OutValue = ADSB_Messages_OutValue :+ get_ADSB_Messages_Out().get\n    if(!ADSB_Messages_Out(ADSB_Messages_OutValue)) {\n      testFailures = testFailures :+ st\"'ADSB_Messages_Out' did not match expected: received ${ADSB_Messages_OutValue.size} events with the following payloads ${ADSB_Messages_OutValue}\"\n    }\n    var SHM_HEADER_adsb_to_ptabValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_HEADER_adsb_to_ptab().nonEmpty) SHM_HEADER_adsb_to_ptabValue = SHM_HEADER_adsb_to_ptabValue :+ get_SHM_HEADER_adsb_to_ptab().get\n    if(!SHM_HEADER_adsb_to_ptab(SHM_HEADER_adsb_to_ptabValue)) {\n      testFailures = testFailures :+ st\"'SHM_HEADER_adsb_to_ptab' did not match expected: received ${SHM_HEADER_adsb_to_ptabValue.size} events with the following payloads ${SHM_HEADER_adsb_to_ptabValue}\"\n    }\n    var Connection_Command_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Connection_Command_Out().nonEmpty) Connection_Command_OutValue = Connection_Command_OutValue :+ get_Connection_Command_Out().get\n    if(!Connection_Command_Out(Connection_Command_OutValue)) {\n      testFailures = testFailures :+ st\"'Connection_Command_Out' did not match expected: received ${Connection_Command_OutValue.size} events with the following payloads ${Connection_Command_OutValue}\"\n    }\n    var SHM_QUEUE_Request_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_SHM_QUEUE_Request_Out().nonEmpty) SHM_QUEUE_Request_OutValue = SHM_QUEUE_Request_OutValue :+ get_SHM_QUEUE_Request_Out().get\n    if(!SHM_QUEUE_Request_Out(SHM_QUEUE_Request_OutValue)) {\n      testFailures = testFailures :+ st\"'SHM_QUEUE_Request_Out' did not match expected: received ${SHM_QUEUE_Request_OutValue.size} events with the following payloads ${SHM_QUEUE_Request_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Heartbeat_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Heartbeat_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Ownship_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Ownship_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_ADSB_Traffic_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_ADSB_Traffic_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_SHM_QUEUE_Response_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.SHM_QUEUE_Response_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Request_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Request_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_Connection_Command_In(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Connection_Command_In_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Response_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Response_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Response_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Response_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Response_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_ADSB_Messages_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_ADSB_Messages_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port ADSB_Messages_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_ADSB_Messages_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.ADSB_Messages_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_HEADER_adsb_to_ptab(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_HEADER_adsb_to_ptab_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_HEADER_adsb_to_ptab.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_HEADER_adsb_to_ptab_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_HEADER_adsb_to_ptab_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Connection_Command_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Connection_Command_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Connection_Command_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Connection_Command_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Connection_Command_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_SHM_QUEUE_Request_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port SHM_QUEUE_Request_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_SHM_QUEUE_Request_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.SHM_QUEUE_Request_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass adapter_high_impl_SW_adapter_high_adapter_high_Test extends adapter_high_impl_SW_adapter_high_adapter_high_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{adapter_high_impl_SW_adapter_high_adapter_high => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class adapter_high_impl_SW_adapter_high_adapter_high_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  SHM_QUEUE_ADSB_Heartbeat_In: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Ownship_In: Port[Base_Types.Bits],\n  SHM_QUEUE_ADSB_Traffic_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Response_In: Port[Base_Types.Bits],\n  Response_Out: Port[Base_Types.Bits],\n  ADSB_Messages_Out: Port[Base_Types.Bits],\n  SHM_HEADER_adsb_to_ptab: Port[Base_Types.Bits],\n  Connection_Command_Out: Port[Base_Types.Bits],\n  Request_In: Port[Base_Types.Bits],\n  SHM_QUEUE_Request_Out: Port[Base_Types.Bits],\n  Connection_Command_In: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(SHM_QUEUE_ADSB_Heartbeat_In,\n              SHM_QUEUE_ADSB_Ownship_In,\n              SHM_QUEUE_ADSB_Traffic_In,\n              SHM_QUEUE_Response_In,\n              Response_Out,\n              ADSB_Messages_Out,\n              SHM_HEADER_adsb_to_ptab,\n              Connection_Command_Out,\n              Request_In,\n              SHM_QUEUE_Request_Out,\n              Connection_Command_In),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(SHM_QUEUE_ADSB_Heartbeat_In,\n                   SHM_QUEUE_ADSB_Ownship_In,\n                   SHM_QUEUE_ADSB_Traffic_In,\n                   SHM_QUEUE_Response_In,\n                   Request_In,\n                   Connection_Command_In),\n\n    eventOuts = ISZ(Response_Out,\n                    ADSB_Messages_Out,\n                    SHM_HEADER_adsb_to_ptab,\n                    Connection_Command_Out,\n                    SHM_QUEUE_Request_Out)\n  )\n\n  val initialization_api : adapter_high_impl_Initialization_Api = {\n    val api = adapter_high_impl_Initialization_Api(\n      id,\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id\n    )\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : adapter_high_impl_Operational_Api = {\n    val api = adapter_high_impl_Operational_Api(\n      id,\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id\n    )\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    adapter_high_impl_SW_adapter_high_adapter_high_Bridge.EntryPoints(\n      id,\n\n      SHM_QUEUE_ADSB_Heartbeat_In.id,\n      SHM_QUEUE_ADSB_Ownship_In.id,\n      SHM_QUEUE_ADSB_Traffic_In.id,\n      SHM_QUEUE_Response_In.id,\n      Response_Out.id,\n      ADSB_Messages_Out.id,\n      SHM_HEADER_adsb_to_ptab.id,\n      Connection_Command_Out.id,\n      Request_In.id,\n      SHM_QUEUE_Request_Out.id,\n      Connection_Command_In.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject adapter_high_impl_SW_adapter_high_adapter_high_Bridge {\n\n  var c_initialization_api: Option[adapter_high_impl_Initialization_Api] = None()\n  var c_operational_api: Option[adapter_high_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    adapter_high_impl_SW_adapter_high_adapter_high_BridgeId : Art.BridgeId,\n\n    SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n    SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n    SHM_QUEUE_Response_In_Id : Art.PortId,\n    Response_Out_Id : Art.PortId,\n    ADSB_Messages_Out_Id : Art.PortId,\n    SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n    Connection_Command_Out_Id : Art.PortId,\n    Request_In_Id : Art.PortId,\n    SHM_QUEUE_Request_Out_Id : Art.PortId,\n    Connection_Command_In_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: adapter_high_impl_Initialization_Api,\n    operational_api: adapter_high_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(SHM_QUEUE_ADSB_Heartbeat_In_Id,\n                                              SHM_QUEUE_ADSB_Ownship_In_Id,\n                                              SHM_QUEUE_ADSB_Traffic_In_Id,\n                                              SHM_QUEUE_Response_In_Id,\n                                              Request_In_Id,\n                                              Connection_Command_In_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Response_Out_Id,\n                                               ADSB_Messages_Out_Id,\n                                               SHM_HEADER_adsb_to_ptab_Id,\n                                               Connection_Command_Out_Id,\n                                               SHM_QUEUE_Request_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: adapter_high_impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: adapter_high_impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/adapter_high_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait adapter_high_impl_Api {\n  def id: Art.BridgeId\n  def SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId\n  def SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId\n  def SHM_QUEUE_Response_In_Id : Art.PortId\n  def Response_Out_Id : Art.PortId\n  def ADSB_Messages_Out_Id : Art.PortId\n  def SHM_HEADER_adsb_to_ptab_Id : Art.PortId\n  def Connection_Command_Out_Id : Art.PortId\n  def Request_In_Id : Art.PortId\n  def SHM_QUEUE_Request_Out_Id : Art.PortId\n  def Connection_Command_In_Id : Art.PortId\n\n  def put_Response_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Response_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_ADSB_Messages_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(ADSB_Messages_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_HEADER_adsb_to_ptab(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_HEADER_adsb_to_ptab_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_Connection_Command_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Connection_Command_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_SHM_QUEUE_Request_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(SHM_QUEUE_Request_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class adapter_high_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n  val SHM_QUEUE_Response_In_Id : Art.PortId,\n  val Response_Out_Id : Art.PortId,\n  val ADSB_Messages_Out_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId) extends adapter_high_impl_Api\n\n@datatype class adapter_high_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val SHM_QUEUE_ADSB_Heartbeat_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Ownship_In_Id : Art.PortId,\n  val SHM_QUEUE_ADSB_Traffic_In_Id : Art.PortId,\n  val SHM_QUEUE_Response_In_Id : Art.PortId,\n  val Response_Out_Id : Art.PortId,\n  val ADSB_Messages_Out_Id : Art.PortId,\n  val SHM_HEADER_adsb_to_ptab_Id : Art.PortId,\n  val Connection_Command_Out_Id : Art.PortId,\n  val Request_In_Id : Art.PortId,\n  val SHM_QUEUE_Request_Out_Id : Art.PortId,\n  val Connection_Command_In_Id : Art.PortId) extends adapter_high_impl_Api {\n\n  def get_SHM_QUEUE_ADSB_Heartbeat_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Heartbeat_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Heartbeat_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_ADSB_Ownship_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Ownship_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Ownship_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_ADSB_Traffic_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_ADSB_Traffic_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_ADSB_Traffic_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_SHM_QUEUE_Response_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(SHM_QUEUE_Response_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port SHM_QUEUE_Response_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Request_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Request_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Request_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_Connection_Command_In() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Connection_Command_In_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Connection_Command_In.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject adapter_high_impl_SW_adapter_high_adapter_high {\n\n  def initialise(api: adapter_high_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Response_Out(Base_Types.Bits_example())\n    api.put_ADSB_Messages_Out(Base_Types.Bits_example())\n    api.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n    api.put_Connection_Command_Out(Base_Types.Bits_example())\n    api.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: adapter_high_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_SHM_QUEUE_ADSB_Heartbeat_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_ADSB_Heartbeat_In()\n    api.logInfo(s\"Received on SHM_QUEUE_ADSB_Heartbeat_In: ${apiUsage_SHM_QUEUE_ADSB_Heartbeat_In}\")\n    val apiUsage_SHM_QUEUE_ADSB_Ownship_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_ADSB_Ownship_In()\n    api.logInfo(s\"Received on SHM_QUEUE_ADSB_Ownship_In: ${apiUsage_SHM_QUEUE_ADSB_Ownship_In}\")\n    val apiUsage_SHM_QUEUE_ADSB_Traffic_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_ADSB_Traffic_In()\n    api.logInfo(s\"Received on SHM_QUEUE_ADSB_Traffic_In: ${apiUsage_SHM_QUEUE_ADSB_Traffic_In}\")\n    val apiUsage_SHM_QUEUE_Response_In: Option[Base_Types.Bits] = api.get_SHM_QUEUE_Response_In()\n    api.logInfo(s\"Received on SHM_QUEUE_Response_In: ${apiUsage_SHM_QUEUE_Response_In}\")\n    val apiUsage_Request_In: Option[Base_Types.Bits] = api.get_Request_In()\n    api.logInfo(s\"Received on Request_In: ${apiUsage_Request_In}\")\n    val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = api.get_Connection_Command_In()\n    api.logInfo(s\"Received on Connection_Command_In: ${apiUsage_Connection_Command_In}\")\n  }\n\n  def activate(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def finalise(api: adapter_high_impl_Operational_Api): Unit = { }\n\n  def recover(api: adapter_high_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi extends BridgeTestSuite[CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge](Arch.VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3) {\n\n  \/** helper function to set the values of all input ports.\n   * @param Observed payloads for event data port Observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of Observed will be used\n   *\/\n  def put_concrete_inputs(Observed : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- Observed){\n      put_Observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param Suspect_Traffic_Out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'Suspect_Traffic_Out'.\n   *\/\n  def check_concrete_output(Suspect_Traffic_Out: ISZ[Base_Types.Bits] => B = Suspect_Traffic_OutParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var Suspect_Traffic_OutValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_Suspect_Traffic_Out().nonEmpty) Suspect_Traffic_OutValue = Suspect_Traffic_OutValue :+ get_Suspect_Traffic_Out().get\n    if(!Suspect_Traffic_Out(Suspect_Traffic_OutValue)) {\n      testFailures = testFailures :+ st\"'Suspect_Traffic_Out' did not match expected: received ${Suspect_Traffic_OutValue.size} events with the following payloads ${Suspect_Traffic_OutValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_Observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.Observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_Suspect_Traffic_Out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_Suspect_Traffic_Out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port Suspect_Traffic_Out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_Suspect_Traffic_Out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.Suspect_Traffic_Out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded.VPM._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Test extends CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.VPM.{CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  Observed: Port[Base_Types.Bits],\n  Suspect_Traffic_Out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(Observed,\n              Suspect_Traffic_Out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(Observed),\n\n    eventOuts = ISZ(Suspect_Traffic_Out)\n  )\n\n  val initialization_api : CASE_Monitor3_Impl_Initialization_Api = {\n    val api = CASE_Monitor3_Impl_Initialization_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor3_Impl_Operational_Api = {\n    val api = CASE_Monitor3_Impl_Operational_Api(\n      id,\n      Observed.id,\n      Suspect_Traffic_Out.id\n    )\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.EntryPoints(\n      id,\n\n      Observed.id,\n      Suspect_Traffic_Out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor3_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor3_Impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_BridgeId : Art.BridgeId,\n\n    Observed_Id : Art.PortId,\n    Suspect_Traffic_Out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor3_Impl_Initialization_Api,\n    operational_api: CASE_Monitor3_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(Observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(Suspect_Traffic_Out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor3_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor3_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/VPM\/CASE_Monitor3_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait CASE_Monitor3_Impl_Api {\n  def id: Art.BridgeId\n  def Observed_Id : Art.PortId\n  def Suspect_Traffic_Out_Id : Art.PortId\n\n  def put_Suspect_Traffic_Out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(Suspect_Traffic_Out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor3_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor3_Impl_Api\n\n@datatype class CASE_Monitor3_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val Observed_Id : Art.PortId,\n  val Suspect_Traffic_Out_Id : Art.PortId) extends CASE_Monitor3_Impl_Api {\n\n  def get_Observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(Observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port Observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 {\n\n  def initialise(api: CASE_Monitor3_Impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n  }\n\n  def timeTriggered(api: CASE_Monitor3_Impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_Observed: Option[Base_Types.Bits] = api.get_Observed()\n    api.logInfo(s\"Received on Observed: ${apiUsage_Observed}\")\n  }\n\n  def activate(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor3_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix\n\nobject CASE_AttestationManager extends App {\n\n  val CASE_AttestationManagerBridge : slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge = {\n    val AttestationRequest = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationRequest\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_AttestationResponse\", mode = EventIn)\n    val TrustedIds = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TrustedIds\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_InitiateAttestation\", mode = EventIn)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager_TerminateAttestation\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Manager_CASE_AttestationManager\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AttestationRequest = AttestationRequest,\n      AttestationResponse = AttestationResponse,\n      TrustedIds = TrustedIds,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_AttestationManagerBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ AttestationRequest: Out EventDataPort Base_Types.Bits\n  val AttestationRequest_id: Art.PortId = CASE_AttestationManagerBridge.AttestationRequest.id\n  var AttestationRequest_port: Option[DataContent] = noData\n\n  \/\/ AttestationResponse: In EventDataPort Base_Types.Bits\n  val AttestationResponse_id: Art.PortId = CASE_AttestationManagerBridge.AttestationResponse.id\n  var AttestationResponse_port: Option[DataContent] = noData\n\n  \/\/ TrustedIds: Out EventDataPort Base_Types.Bits\n  val TrustedIds_id: Art.PortId = CASE_AttestationManagerBridge.TrustedIds.id\n  var TrustedIds_port: Option[DataContent] = noData\n\n  \/\/ InitiateAttestation: In EventDataPort Base_Types.Bits\n  val InitiateAttestation_id: Art.PortId = CASE_AttestationManagerBridge.InitiateAttestation.id\n  var InitiateAttestation_port: Option[DataContent] = noData\n\n  \/\/ TerminateAttestation: Out EventDataPort Base_Types.Bits\n  val TerminateAttestation_id: Art.PortId = CASE_AttestationManagerBridge.TerminateAttestation.id\n  var TerminateAttestation_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == AttestationResponse_id) {\n      return AttestationResponse_port\n    } else if(portId == InitiateAttestation_id) {\n      return InitiateAttestation_port\n    } else {\n      halt(s\"Unexpected: CASE_AttestationManager.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    AttestationResponse_port = CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.AttestationResponse_Receive()\n\n    InitiateAttestation_port = CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.InitiateAttestation_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == AttestationRequest_id) {\n      AttestationRequest_port = Some(data)\n    } else if(portId == TrustedIds_id) {\n      TrustedIds_port = Some(data)\n    } else if(portId == TerminateAttestation_id) {\n      TerminateAttestation_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_AttestationManager.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(AttestationRequest_port.nonEmpty) {\n      CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.AttestationRequest_Send(AttestationRequest_port.get)\n      AttestationRequest_port = noData\n    }\n\n    if(TrustedIds_port.nonEmpty) {\n      CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.TrustedIds_Send(TrustedIds_port.get)\n      TrustedIds_port = noData\n    }\n\n    if(TerminateAttestation_port.nonEmpty) {\n      CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.TerminateAttestation_Send(TerminateAttestation_port.get)\n      TerminateAttestation_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (CASE_AttestationManagerBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_AttestationRequest(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_AttestationRequest(Base_Types.Bits_example())\n      val apiUsage_AttestationResponse: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_AttestationResponse()\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TrustedIds(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TrustedIds(Base_Types.Bits_example())\n      val apiUsage_InitiateAttestation: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.get_InitiateAttestation()\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_initialization_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge.c_operational_api.get.put_TerminateAttestation(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's AttestationRequest port\n  def AttestationRequest_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's AttestationResponse port is empty, F otherwise \n  def AttestationResponse_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AttestationResponse port \n  def AttestationResponse_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's TrustedIds port\n  def TrustedIds_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's InitiateAttestation port is empty, F otherwise \n  def InitiateAttestation_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's InitiateAttestation port \n  def InitiateAttestation_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's TerminateAttestation port\n  def TerminateAttestation_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_Ext {\n  def AttestationRequest_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AttestationResponse_IsEmpty(): B = halt(\"stub\")\n\n  def AttestationResponse_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def TrustedIds_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def InitiateAttestation_IsEmpty(): B = halt(\"stub\")\n\n  def InitiateAttestation_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def TerminateAttestation_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_H\n#define CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h>\n#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_VPM_CASE_AttestationRequestMsg_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_VPM_CASE_AttestationRequestMsg_impl, numBytes_slang_embedded_VPM_CASE_AttestationRequestMsg_impl);\n  api_put_AttestationRequest__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_slang_embedded_VPM_CASE_AttestationRequestMsg_impl, t0);\n\n  uint8_t t1[numBytes_slang_embedded_CASE_Proxies_WhiteList_impl];\n  byte_array_default(SF t1, numBits_slang_embedded_CASE_Proxies_WhiteList_impl, numBytes_slang_embedded_CASE_Proxies_WhiteList_impl);\n  api_put_TrustedIds__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_slang_embedded_CASE_Proxies_WhiteList_impl, t1);\n\n  uint8_t t2[numBytes_slang_embedded_Common_Types_Unsigned_32];\n  byte_array_default(SF t2, numBits_slang_embedded_Common_Types_Unsigned_32, numBytes_slang_embedded_Common_Types_Unsigned_32);\n  api_put_TerminateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF numBits_slang_embedded_Common_Types_Unsigned_32, t2);\n\n  api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_VPM_CASE_AttestationResponseMsg_impl];\n  size_t t0_numBits;\n  if(api_get_AttestationResponse__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_VPM_CASE_AttestationResponseMsg_impl, \"numBits received does not match expected\");\n\n    DeclNewString(AttestationResponse_str);\n    String__append(SF (String) &AttestationResponse_str, string(\"Received on AttestationResponse: \"));\n    byte_array_string(SF (String) &AttestationResponse_str, t0, numBytes_slang_embedded_VPM_CASE_AttestationResponseMsg_impl);\n    api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF (String) &AttestationResponse_str);\n  }\n\n  uint8_t t1[numBytes_slang_embedded_Common_Types_Unsigned_32];\n  size_t t1_numBits;\n  if(api_get_InitiateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_slang_embedded_Common_Types_Unsigned_32, \"numBits received does not match expected\");\n\n    DeclNewString(InitiateAttestation_str);\n    String__append(SF (String) &InitiateAttestation_str, string(\"Received on InitiateAttestation: \"));\n    byte_array_string(SF (String) &InitiateAttestation_str, t1, numBytes_slang_embedded_Common_Types_Unsigned_32);\n    api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(SF (String) &InitiateAttestation_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_API_H\n#define CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_AttestationRequest__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_AttestationResponse__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_TrustedIds__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_InitiateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_TerminateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h>\n#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_AttestationRequest__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_AttestationRequest__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_AttestationRequest_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_AttestationResponse__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_get_AttestationResponse__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E1A92D = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api(api);\n  Option_E1A92D_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api_get_AttestationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_TrustedIds__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_TrustedIds__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_TrustedIds_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_InitiateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_get_InitiateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E1A92D = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api(api);\n  Option_E1A92D_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api_get_InitiateAttestation_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_TerminateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_put_TerminateAttestation__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_put_TerminateAttestation_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"api_logError__slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\", 0);\n\n  \/\/ Option_336015 = Option[slang_embedded.VPM.CASE_AttestationManager_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api(api);\n  Option_336015_get_(SF (slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise\", 0);\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise\", 0);\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationManager_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered\", 0);\n\n  slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.h>\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_CASE_AttestationManager_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_CASE_AttestationManager_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_CASE_AttestationManager_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_entryPoints\", 0);\n\n  return slang_embedded_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_CASE_AttestationManager_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_ADAPTER_H\n#define CASE_ATTESTATIONMANAGER_IMPL_SW_ATTESTATION_MANAGER_CASE_ATTESTATIONMANAGER_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix\n\nobject CASE_AttestationGate extends App {\n\n  val CASE_AttestationGateBridge : slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge = {\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_In\", mode = EventIn)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_Connection_Command_Out\", mode = EventOut)\n    val TrustedIds = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate_TrustedIds\", mode = EventIn)\n\n    slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Attestation_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In,\n      Connection_Command_Out = Connection_Command_Out,\n      TrustedIds = TrustedIds\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_AttestationGateBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ SHM_QUEUE_Request_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Request_In_id: Art.PortId = CASE_AttestationGateBridge.SHM_QUEUE_Request_In.id\n  var SHM_QUEUE_Request_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Request_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Request_Out_id: Art.PortId = CASE_AttestationGateBridge.SHM_QUEUE_Request_Out.id\n  var SHM_QUEUE_Request_Out_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_In: In EventDataPort Base_Types.Bits\n  val Connection_Command_In_id: Art.PortId = CASE_AttestationGateBridge.Connection_Command_In.id\n  var Connection_Command_In_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_Out: Out EventDataPort Base_Types.Bits\n  val Connection_Command_Out_id: Art.PortId = CASE_AttestationGateBridge.Connection_Command_Out.id\n  var Connection_Command_Out_port: Option[DataContent] = noData\n\n  \/\/ TrustedIds: In EventDataPort Base_Types.Bits\n  val TrustedIds_id: Art.PortId = CASE_AttestationGateBridge.TrustedIds.id\n  var TrustedIds_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == SHM_QUEUE_Request_In_id) {\n      return SHM_QUEUE_Request_In_port\n    } else if(portId == Connection_Command_In_id) {\n      return Connection_Command_In_port\n    } else if(portId == TrustedIds_id) {\n      return TrustedIds_port\n    } else {\n      halt(s\"Unexpected: CASE_AttestationGate.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    SHM_QUEUE_Request_In_port = CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.SHM_QUEUE_Request_In_Receive()\n\n    Connection_Command_In_port = CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.Connection_Command_In_Receive()\n\n    TrustedIds_port = CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.TrustedIds_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == SHM_QUEUE_Request_Out_id) {\n      SHM_QUEUE_Request_Out_port = Some(data)\n    } else if(portId == Connection_Command_Out_id) {\n      Connection_Command_Out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_AttestationGate.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(SHM_QUEUE_Request_Out_port.nonEmpty) {\n      CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.SHM_QUEUE_Request_Out_Send(SHM_QUEUE_Request_Out_port.get)\n      SHM_QUEUE_Request_Out_port = noData\n    }\n\n    if(Connection_Command_Out_port.nonEmpty) {\n      CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.Connection_Command_Out_Send(Connection_Command_Out_port.get)\n      Connection_Command_Out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (CASE_AttestationGateBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_Connection_Command_In()\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      val apiUsage_TrustedIds: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_TrustedIds()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix {\n  \/\/ returns T if seL4's SHM_QUEUE_Request_In port is empty, F otherwise \n  def SHM_QUEUE_Request_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_Request_In port \n  def SHM_QUEUE_Request_In_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Request_Out port\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's Connection_Command_In port is empty, F otherwise \n  def Connection_Command_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Connection_Command_In port \n  def Connection_Command_In_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's Connection_Command_Out port\n  def Connection_Command_Out_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's TrustedIds port is empty, F otherwise \n  def TrustedIds_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's TrustedIds port \n  def TrustedIds_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Ext {\n  def SHM_QUEUE_Request_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_Request_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Connection_Command_In_IsEmpty(): B = halt(\"stub\")\n\n  def Connection_Command_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Connection_Command_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def TrustedIds_IsEmpty(): B = halt(\"stub\")\n\n  def TrustedIds_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_H\n#define CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl);\n  api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, t0);\n\n  uint8_t t1[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t1, numBits_slang_embedded_CASE_Proxies_connection_command_impl, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF numBits_slang_embedded_CASE_Proxies_connection_command_impl, t1);\n\n  api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl];\n  size_t t0_numBits;\n  if(api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Request_In_str);\n    String__append(SF (String) &SHM_QUEUE_Request_In_str, string(\"Received on SHM_QUEUE_Request_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Request_In_str, t0, numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl);\n    api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &SHM_QUEUE_Request_In_str);\n  }\n\n  uint8_t t1[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  size_t t1_numBits;\n  if(api_get_Connection_Command_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_slang_embedded_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t1, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n    api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &Connection_Command_In_str);\n  }\n\n  uint8_t t2[numBytes_slang_embedded_CASE_Proxies_WhiteList_impl];\n  size_t t2_numBits;\n  if(api_get_TrustedIds__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_slang_embedded_CASE_Proxies_WhiteList_impl, \"numBits received does not match expected\");\n\n    DeclNewString(TrustedIds_str);\n    String__append(SF (String) &TrustedIds_str, string(\"Received on TrustedIds: \"));\n    byte_array_string(SF (String) &TrustedIds_str, t2, numBytes_slang_embedded_CASE_Proxies_WhiteList_impl);\n    api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF (String) &TrustedIds_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_API_H\n#define CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_TrustedIds__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_86DBE2 = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_86DBE2_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api_get_SHM_QUEUE_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_64D74B = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_64D74B_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_Connection_Command_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_86DBE2 = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_86DBE2_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_Connection_Command_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_64D74B = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_64D74B_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_TrustedIds__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_TrustedIds__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_86DBE2 = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api(api);\n  Option_86DBE2_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api_get_TrustedIds_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_64D74B = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_64D74B_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_64D74B = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_64D74B_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logError__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_64D74B = Option[slang_embedded.VPM.CASE_AttestationGate_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api(api);\n  Option_64D74B_get_(SF (slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise\", 0);\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise\", 0);\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_AttestationGate_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered\", 0);\n\n  slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.h>\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_CASE_AttestationGate_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_CASE_AttestationGate_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_CASE_AttestationGate_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_entryPoints\", 0);\n\n  return slang_embedded_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_CASE_AttestationGate_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_ADAPTER_H\n#define CASE_ATTESTATIONGATE_IMPL_SW_ATTESTATION_GATE_CASE_ATTESTATIONGATE_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix\n\nobject CASE_Monitor1 extends App {\n\n  val CASE_Monitor1Bridge : slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Expected_Position_Monitor_CASE_Monitor1\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Monitor1Bridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ Observed: In EventDataPort Base_Types.Bits\n  val Observed_id: Art.PortId = CASE_Monitor1Bridge.Observed.id\n  var Observed_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_Out: Out EventDataPort Base_Types.Bits\n  val Suspect_Traffic_Out_id: Art.PortId = CASE_Monitor1Bridge.Suspect_Traffic_Out.id\n  var Suspect_Traffic_Out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == Observed_id) {\n      return Observed_port\n    } else {\n      halt(s\"Unexpected: CASE_Monitor1.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    Observed_port = CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix.Observed_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == Suspect_Traffic_Out_id) {\n      Suspect_Traffic_Out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_Monitor1.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(Suspect_Traffic_Out_port.nonEmpty) {\n      CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix.Suspect_Traffic_Out_Send(Suspect_Traffic_Out_port.get)\n      Suspect_Traffic_Out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (CASE_Monitor1Bridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.get_Observed()\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix {\n  \/\/ returns T if seL4's Observed port is empty, F otherwise \n  def Observed_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Observed port \n  def Observed_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's Suspect_Traffic_Out port\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Ext {\n  def Observed_IsEmpty(): B = halt(\"stub\")\n\n  def Observed_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_H\n#define CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_ADSB_Types_MonitorReport_impl, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF numBits_slang_embedded_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_API_H\n#define CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_get_Observed__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_BAC0FD = Option[slang_embedded.VPM.CASE_Monitor1_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor1_Impl_Operational_Api(api);\n  Option_BAC0FD_get_(SF (slang_embedded_VPM_CASE_Monitor1_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_76F210 = Option[slang_embedded.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_76F210_get_(SF (slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_76F210 = Option[slang_embedded.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_76F210_get_(SF (slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_76F210 = Option[slang_embedded.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_76F210_get_(SF (slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"api_logError__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\", 0);\n\n  \/\/ Option_76F210 = Option[slang_embedded.VPM.CASE_Monitor1_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api(api);\n  Option_76F210_get_(SF (slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor1_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor1_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor1_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered\", 0);\n\n  slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.h>\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_CASE_Monitor1_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_CASE_Monitor1_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_CASE_Monitor1_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_entryPoints\", 0);\n\n  return slang_embedded_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_CASE_Monitor1_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_ADAPTER_H\n#define CASE_MONITOR1_IMPL_SW_EXPECTED_POSITION_MONITOR_CASE_MONITOR1_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix\n\nobject CASE_Monitor2 extends App {\n\n  val CASE_Monitor2Bridge : slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Duplicate_Entity_Monitor_CASE_Monitor2\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Monitor2Bridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ Observed: In EventDataPort Base_Types.Bits\n  val Observed_id: Art.PortId = CASE_Monitor2Bridge.Observed.id\n  var Observed_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_Out: Out EventDataPort Base_Types.Bits\n  val Suspect_Traffic_Out_id: Art.PortId = CASE_Monitor2Bridge.Suspect_Traffic_Out.id\n  var Suspect_Traffic_Out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == Observed_id) {\n      return Observed_port\n    } else {\n      halt(s\"Unexpected: CASE_Monitor2.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    Observed_port = CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix.Observed_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == Suspect_Traffic_Out_id) {\n      Suspect_Traffic_Out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_Monitor2.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(Suspect_Traffic_Out_port.nonEmpty) {\n      CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix.Suspect_Traffic_Out_Send(Suspect_Traffic_Out_port.get)\n      Suspect_Traffic_Out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (CASE_Monitor2Bridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.get_Observed()\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix {\n  \/\/ returns T if seL4's Observed port is empty, F otherwise \n  def Observed_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Observed port \n  def Observed_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's Suspect_Traffic_Out port\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Ext {\n  def Observed_IsEmpty(): B = halt(\"stub\")\n\n  def Observed_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_H\n#define CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_ADSB_Types_MonitorReport_impl, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF numBits_slang_embedded_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_API_H\n#define CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_get_Observed__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_103B81 = Option[slang_embedded.VPM.CASE_Monitor2_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor2_Impl_Operational_Api(api);\n  Option_103B81_get_(SF (slang_embedded_VPM_CASE_Monitor2_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_D83C8A = Option[slang_embedded.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_D83C8A_get_(SF (slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_D83C8A = Option[slang_embedded.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_D83C8A_get_(SF (slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_D83C8A = Option[slang_embedded.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_D83C8A_get_(SF (slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"api_logError__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\", 0);\n\n  \/\/ Option_D83C8A = Option[slang_embedded.VPM.CASE_Monitor2_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api(api);\n  Option_D83C8A_get_(SF (slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor2_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor2_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor2_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered\", 0);\n\n  slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.h>\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_CASE_Monitor2_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_CASE_Monitor2_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_CASE_Monitor2_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_entryPoints\", 0);\n\n  return slang_embedded_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_CASE_Monitor2_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_ADAPTER_H\n#define CASE_MONITOR2_IMPL_SW_DUPLICATE_ENTITY_MONITOR_CASE_MONITOR2_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.adapter_low_impl_SW_adapter_low_adapter_low\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix\n\nobject adapter_low extends App {\n\n  val adapter_lowBridge : slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge = {\n    val ADSB_Messages_In = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_ADSB_Messages_In\", mode = EventIn)\n    val Response_In = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Response_In\", mode = EventIn)\n    val AttestationRequest = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationRequest\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Heartbeat_Out = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Heartbeat_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Ownship_Out = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Ownship_Out\", mode = EventOut)\n    val SHM_QUEUE_ADSB_Traffic_Out = Port[Base_Types.Bits] (id = 5, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_ADSB_Traffic_Out\", mode = EventOut)\n    val SHM_QUEUE_Response_Out = Port[Base_Types.Bits] (id = 6, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Response_Out\", mode = EventOut)\n    val SHM_QUEUE_AttestationRequest = Port[Base_Types.Bits] (id = 7, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationRequest\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 8, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_HEADER_adsb_to_ptab\", mode = EventIn)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 9, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_In\", mode = EventIn)\n    val Suspect_Traffic_In1 = Port[Base_Types.Bits] (id = 10, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In1\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out1 = Port[Base_Types.Bits] (id = 11, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out1\", mode = EventOut)\n    val Suspect_Traffic_In2 = Port[Base_Types.Bits] (id = 12, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In2\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out2 = Port[Base_Types.Bits] (id = 13, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out2\", mode = EventOut)\n    val Suspect_Traffic_In3 = Port[Base_Types.Bits] (id = 14, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Suspect_Traffic_In3\", mode = EventIn)\n    val SHM_QUEUE_Suspect_Traffic_Out3 = Port[Base_Types.Bits] (id = 15, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Suspect_Traffic_Out3\", mode = EventOut)\n    val SHM_QUEUE_Request_In = Port[Base_Types.Bits] (id = 16, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_In\", mode = EventIn)\n    val SHM_QUEUE_AttestationResponse = Port[Base_Types.Bits] (id = 17, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_AttestationResponse\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 18, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val AttestationResponse = Port[Base_Types.Bits] (id = 19, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_AttestationResponse\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 20, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_Connection_Command_Out\", mode = EventOut)\n    val InitiateAttestation = Port[Base_Types.Bits] (id = 21, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_InitiateAttestation\", mode = EventOut)\n    val TerminateAttestation = Port[Base_Types.Bits] (id = 22, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low_TerminateAttestation\", mode = EventIn)\n\n    slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_low_adapter_low\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      ADSB_Messages_In = ADSB_Messages_In,\n      Response_In = Response_In,\n      AttestationRequest = AttestationRequest,\n      SHM_QUEUE_ADSB_Heartbeat_Out = SHM_QUEUE_ADSB_Heartbeat_Out,\n      SHM_QUEUE_ADSB_Ownship_Out = SHM_QUEUE_ADSB_Ownship_Out,\n      SHM_QUEUE_ADSB_Traffic_Out = SHM_QUEUE_ADSB_Traffic_Out,\n      SHM_QUEUE_Response_Out = SHM_QUEUE_Response_Out,\n      SHM_QUEUE_AttestationRequest = SHM_QUEUE_AttestationRequest,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_In = Connection_Command_In,\n      Suspect_Traffic_In1 = Suspect_Traffic_In1,\n      SHM_QUEUE_Suspect_Traffic_Out1 = SHM_QUEUE_Suspect_Traffic_Out1,\n      Suspect_Traffic_In2 = Suspect_Traffic_In2,\n      SHM_QUEUE_Suspect_Traffic_Out2 = SHM_QUEUE_Suspect_Traffic_Out2,\n      Suspect_Traffic_In3 = Suspect_Traffic_In3,\n      SHM_QUEUE_Suspect_Traffic_Out3 = SHM_QUEUE_Suspect_Traffic_Out3,\n      SHM_QUEUE_Request_In = SHM_QUEUE_Request_In,\n      SHM_QUEUE_AttestationResponse = SHM_QUEUE_AttestationResponse,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      AttestationResponse = AttestationResponse,\n      Connection_Command_Out = Connection_Command_Out,\n      InitiateAttestation = InitiateAttestation,\n      TerminateAttestation = TerminateAttestation\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = adapter_lowBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ ADSB_Messages_In: In EventDataPort Base_Types.Bits\n  val ADSB_Messages_In_id: Art.PortId = adapter_lowBridge.ADSB_Messages_In.id\n  var ADSB_Messages_In_port: Option[DataContent] = noData\n\n  \/\/ Response_In: In EventDataPort Base_Types.Bits\n  val Response_In_id: Art.PortId = adapter_lowBridge.Response_In.id\n  var Response_In_port: Option[DataContent] = noData\n\n  \/\/ AttestationRequest: In EventDataPort Base_Types.Bits\n  val AttestationRequest_id: Art.PortId = adapter_lowBridge.AttestationRequest.id\n  var AttestationRequest_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_ADSB_Heartbeat_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Heartbeat_Out_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_ADSB_Heartbeat_Out.id\n  var SHM_QUEUE_ADSB_Heartbeat_Out_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_ADSB_Ownship_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Ownship_Out_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_ADSB_Ownship_Out.id\n  var SHM_QUEUE_ADSB_Ownship_Out_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_ADSB_Traffic_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Traffic_Out_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_ADSB_Traffic_Out.id\n  var SHM_QUEUE_ADSB_Traffic_Out_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Response_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Response_Out_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Response_Out.id\n  var SHM_QUEUE_Response_Out_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_AttestationRequest: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_AttestationRequest_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_AttestationRequest.id\n  var SHM_QUEUE_AttestationRequest_port: Option[DataContent] = noData\n\n  \/\/ SHM_HEADER_adsb_to_ptab: In EventDataPort Base_Types.Bits\n  val SHM_HEADER_adsb_to_ptab_id: Art.PortId = adapter_lowBridge.SHM_HEADER_adsb_to_ptab.id\n  var SHM_HEADER_adsb_to_ptab_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_In: In EventDataPort Base_Types.Bits\n  val Connection_Command_In_id: Art.PortId = adapter_lowBridge.Connection_Command_In.id\n  var Connection_Command_In_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_In1: In EventDataPort Base_Types.Bits\n  val Suspect_Traffic_In1_id: Art.PortId = adapter_lowBridge.Suspect_Traffic_In1.id\n  var Suspect_Traffic_In1_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Suspect_Traffic_Out1: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Suspect_Traffic_Out1_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Suspect_Traffic_Out1.id\n  var SHM_QUEUE_Suspect_Traffic_Out1_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_In2: In EventDataPort Base_Types.Bits\n  val Suspect_Traffic_In2_id: Art.PortId = adapter_lowBridge.Suspect_Traffic_In2.id\n  var Suspect_Traffic_In2_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Suspect_Traffic_Out2: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Suspect_Traffic_Out2_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Suspect_Traffic_Out2.id\n  var SHM_QUEUE_Suspect_Traffic_Out2_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_In3: In EventDataPort Base_Types.Bits\n  val Suspect_Traffic_In3_id: Art.PortId = adapter_lowBridge.Suspect_Traffic_In3.id\n  var Suspect_Traffic_In3_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Suspect_Traffic_Out3: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Suspect_Traffic_Out3_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Suspect_Traffic_Out3.id\n  var SHM_QUEUE_Suspect_Traffic_Out3_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Request_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Request_In_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Request_In.id\n  var SHM_QUEUE_Request_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_AttestationResponse: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_AttestationResponse_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_AttestationResponse.id\n  var SHM_QUEUE_AttestationResponse_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Request_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Request_Out_id: Art.PortId = adapter_lowBridge.SHM_QUEUE_Request_Out.id\n  var SHM_QUEUE_Request_Out_port: Option[DataContent] = noData\n\n  \/\/ AttestationResponse: Out EventDataPort Base_Types.Bits\n  val AttestationResponse_id: Art.PortId = adapter_lowBridge.AttestationResponse.id\n  var AttestationResponse_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_Out: Out EventDataPort Base_Types.Bits\n  val Connection_Command_Out_id: Art.PortId = adapter_lowBridge.Connection_Command_Out.id\n  var Connection_Command_Out_port: Option[DataContent] = noData\n\n  \/\/ InitiateAttestation: Out EventDataPort Base_Types.Bits\n  val InitiateAttestation_id: Art.PortId = adapter_lowBridge.InitiateAttestation.id\n  var InitiateAttestation_port: Option[DataContent] = noData\n\n  \/\/ TerminateAttestation: In EventDataPort Base_Types.Bits\n  val TerminateAttestation_id: Art.PortId = adapter_lowBridge.TerminateAttestation.id\n  var TerminateAttestation_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == ADSB_Messages_In_id) {\n      return ADSB_Messages_In_port\n    } else if(portId == Response_In_id) {\n      return Response_In_port\n    } else if(portId == AttestationRequest_id) {\n      return AttestationRequest_port\n    } else if(portId == SHM_HEADER_adsb_to_ptab_id) {\n      return SHM_HEADER_adsb_to_ptab_port\n    } else if(portId == Connection_Command_In_id) {\n      return Connection_Command_In_port\n    } else if(portId == Suspect_Traffic_In1_id) {\n      return Suspect_Traffic_In1_port\n    } else if(portId == Suspect_Traffic_In2_id) {\n      return Suspect_Traffic_In2_port\n    } else if(portId == Suspect_Traffic_In3_id) {\n      return Suspect_Traffic_In3_port\n    } else if(portId == SHM_QUEUE_Request_In_id) {\n      return SHM_QUEUE_Request_In_port\n    } else if(portId == SHM_QUEUE_AttestationResponse_id) {\n      return SHM_QUEUE_AttestationResponse_port\n    } else if(portId == TerminateAttestation_id) {\n      return TerminateAttestation_port\n    } else {\n      halt(s\"Unexpected: adapter_low.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    ADSB_Messages_In_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.ADSB_Messages_In_Receive()\n\n    Response_In_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Response_In_Receive()\n\n    AttestationRequest_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.AttestationRequest_Receive()\n\n    SHM_HEADER_adsb_to_ptab_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_HEADER_adsb_to_ptab_Receive()\n\n    Connection_Command_In_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Connection_Command_In_Receive()\n\n    Suspect_Traffic_In1_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Suspect_Traffic_In1_Receive()\n\n    Suspect_Traffic_In2_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Suspect_Traffic_In2_Receive()\n\n    Suspect_Traffic_In3_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Suspect_Traffic_In3_Receive()\n\n    SHM_QUEUE_Request_In_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Request_In_Receive()\n\n    SHM_QUEUE_AttestationResponse_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_AttestationResponse_Receive()\n\n    TerminateAttestation_port = adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.TerminateAttestation_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == SHM_QUEUE_ADSB_Heartbeat_Out_id) {\n      SHM_QUEUE_ADSB_Heartbeat_Out_port = Some(data)\n    } else if(portId == SHM_QUEUE_ADSB_Ownship_Out_id) {\n      SHM_QUEUE_ADSB_Ownship_Out_port = Some(data)\n    } else if(portId == SHM_QUEUE_ADSB_Traffic_Out_id) {\n      SHM_QUEUE_ADSB_Traffic_Out_port = Some(data)\n    } else if(portId == SHM_QUEUE_Response_Out_id) {\n      SHM_QUEUE_Response_Out_port = Some(data)\n    } else if(portId == SHM_QUEUE_AttestationRequest_id) {\n      SHM_QUEUE_AttestationRequest_port = Some(data)\n    } else if(portId == SHM_QUEUE_Suspect_Traffic_Out1_id) {\n      SHM_QUEUE_Suspect_Traffic_Out1_port = Some(data)\n    } else if(portId == SHM_QUEUE_Suspect_Traffic_Out2_id) {\n      SHM_QUEUE_Suspect_Traffic_Out2_port = Some(data)\n    } else if(portId == SHM_QUEUE_Suspect_Traffic_Out3_id) {\n      SHM_QUEUE_Suspect_Traffic_Out3_port = Some(data)\n    } else if(portId == SHM_QUEUE_Request_Out_id) {\n      SHM_QUEUE_Request_Out_port = Some(data)\n    } else if(portId == AttestationResponse_id) {\n      AttestationResponse_port = Some(data)\n    } else if(portId == Connection_Command_Out_id) {\n      Connection_Command_Out_port = Some(data)\n    } else if(portId == InitiateAttestation_id) {\n      InitiateAttestation_port = Some(data)\n    } else {\n      halt(s\"Unexpected: adapter_low.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(SHM_QUEUE_ADSB_Heartbeat_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_ADSB_Heartbeat_Out_Send(SHM_QUEUE_ADSB_Heartbeat_Out_port.get)\n      SHM_QUEUE_ADSB_Heartbeat_Out_port = noData\n    }\n\n    if(SHM_QUEUE_ADSB_Ownship_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_ADSB_Ownship_Out_Send(SHM_QUEUE_ADSB_Ownship_Out_port.get)\n      SHM_QUEUE_ADSB_Ownship_Out_port = noData\n    }\n\n    if(SHM_QUEUE_ADSB_Traffic_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_ADSB_Traffic_Out_Send(SHM_QUEUE_ADSB_Traffic_Out_port.get)\n      SHM_QUEUE_ADSB_Traffic_Out_port = noData\n    }\n\n    if(SHM_QUEUE_Response_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Response_Out_Send(SHM_QUEUE_Response_Out_port.get)\n      SHM_QUEUE_Response_Out_port = noData\n    }\n\n    if(SHM_QUEUE_AttestationRequest_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_AttestationRequest_Send(SHM_QUEUE_AttestationRequest_port.get)\n      SHM_QUEUE_AttestationRequest_port = noData\n    }\n\n    if(SHM_QUEUE_Suspect_Traffic_Out1_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Suspect_Traffic_Out1_Send(SHM_QUEUE_Suspect_Traffic_Out1_port.get)\n      SHM_QUEUE_Suspect_Traffic_Out1_port = noData\n    }\n\n    if(SHM_QUEUE_Suspect_Traffic_Out2_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Suspect_Traffic_Out2_Send(SHM_QUEUE_Suspect_Traffic_Out2_port.get)\n      SHM_QUEUE_Suspect_Traffic_Out2_port = noData\n    }\n\n    if(SHM_QUEUE_Suspect_Traffic_Out3_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Suspect_Traffic_Out3_Send(SHM_QUEUE_Suspect_Traffic_Out3_port.get)\n      SHM_QUEUE_Suspect_Traffic_Out3_port = noData\n    }\n\n    if(SHM_QUEUE_Request_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.SHM_QUEUE_Request_Out_Send(SHM_QUEUE_Request_Out_port.get)\n      SHM_QUEUE_Request_Out_port = noData\n    }\n\n    if(AttestationResponse_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.AttestationResponse_Send(AttestationResponse_port.get)\n      AttestationResponse_port = noData\n    }\n\n    if(Connection_Command_Out_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.Connection_Command_Out_Send(Connection_Command_Out_port.get)\n      Connection_Command_Out_port = noData\n    }\n\n    if(InitiateAttestation_port.nonEmpty) {\n      adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.InitiateAttestation_Send(InitiateAttestation_port.get)\n      InitiateAttestation_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (adapter_lowBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_ADSB_Messages_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_ADSB_Messages_In()\n      val apiUsage_Response_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Response_In()\n      val apiUsage_AttestationRequest: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_AttestationRequest()\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Heartbeat_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Ownship_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_ADSB_Traffic_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Response_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_AttestationRequest(Base_Types.Bits_example())\n      val apiUsage_SHM_HEADER_adsb_to_ptab: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_HEADER_adsb_to_ptab()\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Connection_Command_In()\n      val apiUsage_Suspect_Traffic_In1: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In1()\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out1(Base_Types.Bits_example())\n      val apiUsage_Suspect_Traffic_In2: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In2()\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out2(Base_Types.Bits_example())\n      val apiUsage_Suspect_Traffic_In3: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_Suspect_Traffic_In3()\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Suspect_Traffic_Out3(Base_Types.Bits_example())\n      val apiUsage_SHM_QUEUE_Request_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_Request_In()\n      val apiUsage_SHM_QUEUE_AttestationResponse: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_SHM_QUEUE_AttestationResponse()\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_AttestationResponse(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_AttestationResponse(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_initialization_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.put_InitiateAttestation(Base_Types.Bits_example())\n      val apiUsage_TerminateAttestation: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low_Bridge.c_operational_api.get.get_TerminateAttestation()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix {\n  \/\/ returns T if seL4's ADSB_Messages_In port is empty, F otherwise \n  def ADSB_Messages_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's ADSB_Messages_In port \n  def ADSB_Messages_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's Response_In port is empty, F otherwise \n  def Response_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Response_In port \n  def Response_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's AttestationRequest port is empty, F otherwise \n  def AttestationRequest_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's AttestationRequest port \n  def AttestationRequest_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_ADSB_Heartbeat_Out port\n  def SHM_QUEUE_ADSB_Heartbeat_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_ADSB_Ownship_Out port\n  def SHM_QUEUE_ADSB_Ownship_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_ADSB_Traffic_Out port\n  def SHM_QUEUE_ADSB_Traffic_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Response_Out port\n  def SHM_QUEUE_Response_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_AttestationRequest port\n  def SHM_QUEUE_AttestationRequest_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's SHM_HEADER_adsb_to_ptab port is empty, F otherwise \n  def SHM_HEADER_adsb_to_ptab_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_HEADER_adsb_to_ptab port \n  def SHM_HEADER_adsb_to_ptab_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's Connection_Command_In port is empty, F otherwise \n  def Connection_Command_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Connection_Command_In port \n  def Connection_Command_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's Suspect_Traffic_In1 port is empty, F otherwise \n  def Suspect_Traffic_In1_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Suspect_Traffic_In1 port \n  def Suspect_Traffic_In1_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Suspect_Traffic_Out1 port\n  def SHM_QUEUE_Suspect_Traffic_Out1_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's Suspect_Traffic_In2 port is empty, F otherwise \n  def Suspect_Traffic_In2_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Suspect_Traffic_In2 port \n  def Suspect_Traffic_In2_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Suspect_Traffic_Out2 port\n  def SHM_QUEUE_Suspect_Traffic_Out2_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's Suspect_Traffic_In3 port is empty, F otherwise \n  def Suspect_Traffic_In3_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Suspect_Traffic_In3 port \n  def Suspect_Traffic_In3_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Suspect_Traffic_Out3 port\n  def SHM_QUEUE_Suspect_Traffic_Out3_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's SHM_QUEUE_Request_In port is empty, F otherwise \n  def SHM_QUEUE_Request_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_Request_In port \n  def SHM_QUEUE_Request_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's SHM_QUEUE_AttestationResponse port is empty, F otherwise \n  def SHM_QUEUE_AttestationResponse_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_AttestationResponse port \n  def SHM_QUEUE_AttestationResponse_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Request_Out port\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's AttestationResponse port\n  def AttestationResponse_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's Connection_Command_Out port\n  def Connection_Command_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's InitiateAttestation port\n  def InitiateAttestation_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's TerminateAttestation port is empty, F otherwise \n  def TerminateAttestation_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's TerminateAttestation port \n  def TerminateAttestation_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Ext {\n  def ADSB_Messages_In_IsEmpty(): B = halt(\"stub\")\n\n  def ADSB_Messages_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Response_In_IsEmpty(): B = halt(\"stub\")\n\n  def Response_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def AttestationRequest_IsEmpty(): B = halt(\"stub\")\n\n  def AttestationRequest_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Heartbeat_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Ownship_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Traffic_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_QUEUE_Response_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_QUEUE_AttestationRequest_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_HEADER_adsb_to_ptab_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_HEADER_adsb_to_ptab_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Connection_Command_In_IsEmpty(): B = halt(\"stub\")\n\n  def Connection_Command_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Suspect_Traffic_In1_IsEmpty(): B = halt(\"stub\")\n\n  def Suspect_Traffic_In1_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Suspect_Traffic_Out1_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Suspect_Traffic_In2_IsEmpty(): B = halt(\"stub\")\n\n  def Suspect_Traffic_In2_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Suspect_Traffic_Out2_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Suspect_Traffic_In3_IsEmpty(): B = halt(\"stub\")\n\n  def Suspect_Traffic_In3_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Suspect_Traffic_Out3_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_QUEUE_Request_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_Request_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_AttestationResponse_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_AttestationResponse_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def AttestationResponse_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Connection_Command_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def InitiateAttestation_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def TerminateAttestation_IsEmpty(): B = halt(\"stub\")\n\n  def TerminateAttestation_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_H\n#define ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_low_impl_SW_adapter_low_adapter_low_api.h>\n#include <adapter_low_impl_SW_adapter_low_adapter_low.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl);\n  api_put_SHM_QUEUE_ADSB_Heartbeat_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, t0);\n\n  uint8_t t1[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl];\n  byte_array_default(SF t1, numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl);\n  api_put_SHM_QUEUE_ADSB_Ownship_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl, t1);\n\n  uint8_t t2[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl];\n  byte_array_default(SF t2, numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl);\n  api_put_SHM_QUEUE_ADSB_Traffic_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl, t2);\n\n  uint8_t t3[numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl];\n  byte_array_default(SF t3, numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl);\n  api_put_SHM_QUEUE_Response_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl, t3);\n\n  uint8_t t4[numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl];\n  byte_array_default(SF t4, numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl);\n  api_put_SHM_QUEUE_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl, t4);\n\n  uint8_t t5[numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t5, numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, t5);\n\n  uint8_t t6[numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t6, numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, t6);\n\n  uint8_t t7[numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl];\n  byte_array_default(SF t7, numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl);\n  api_put_SHM_QUEUE_Suspect_Traffic_Out3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl, t7);\n\n  uint8_t t8[numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl];\n  byte_array_default(SF t8, numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl);\n  api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, t8);\n\n  uint8_t t9[numBytes_slang_embedded_VPM_CASE_AttestationResponseMsg_impl];\n  byte_array_default(SF t9, numBits_slang_embedded_VPM_CASE_AttestationResponseMsg_impl, numBytes_slang_embedded_VPM_CASE_AttestationResponseMsg_impl);\n  api_put_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_VPM_CASE_AttestationResponseMsg_impl, t9);\n\n  uint8_t t10[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t10, numBits_slang_embedded_CASE_Proxies_connection_command_impl, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_CASE_Proxies_connection_command_impl, t10);\n\n  uint8_t t11[numBytes_slang_embedded_Common_Types_Unsigned_32];\n  byte_array_default(SF t11, numBits_slang_embedded_Common_Types_Unsigned_32, numBytes_slang_embedded_Common_Types_Unsigned_32);\n  api_put_InitiateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF numBits_slang_embedded_Common_Types_Unsigned_32, t11);\n\n  api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_ADSB_Messages_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(ADSB_Messages_In_str);\n    String__append(SF (String) &ADSB_Messages_In_str, string(\"Received on ADSB_Messages_In: \"));\n    byte_array_string(SF (String) &ADSB_Messages_In_str, t0, numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &ADSB_Messages_In_str);\n  }\n\n  uint8_t t1[numBytes_slang_embedded_DTU_Types_Response_Message_impl];\n  size_t t1_numBits;\n  if(api_get_Response_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_slang_embedded_DTU_Types_Response_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Response_In_str);\n    String__append(SF (String) &Response_In_str, string(\"Received on Response_In: \"));\n    byte_array_string(SF (String) &Response_In_str, t1, numBytes_slang_embedded_DTU_Types_Response_Message_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Response_In_str);\n  }\n\n  uint8_t t2[numBytes_slang_embedded_VPM_CASE_AttestationRequestMsg_impl];\n  size_t t2_numBits;\n  if(api_get_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_slang_embedded_VPM_CASE_AttestationRequestMsg_impl, \"numBits received does not match expected\");\n\n    DeclNewString(AttestationRequest_str);\n    String__append(SF (String) &AttestationRequest_str, string(\"Received on AttestationRequest: \"));\n    byte_array_string(SF (String) &AttestationRequest_str, t2, numBytes_slang_embedded_VPM_CASE_AttestationRequestMsg_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &AttestationRequest_str);\n  }\n\n  uint8_t t3[numBytes_slang_embedded_CASE_Proxies_shm_queue_header_impl];\n  size_t t3_numBits;\n  if(api_get_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_header_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_HEADER_adsb_to_ptab_str);\n    String__append(SF (String) &SHM_HEADER_adsb_to_ptab_str, string(\"Received on SHM_HEADER_adsb_to_ptab: \"));\n    byte_array_string(SF (String) &SHM_HEADER_adsb_to_ptab_str, t3, numBytes_slang_embedded_CASE_Proxies_shm_queue_header_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_HEADER_adsb_to_ptab_str);\n  }\n\n  uint8_t t4[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  size_t t4_numBits;\n  if(api_get_Connection_Command_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t4_numBits, t4)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t4_numBits == numBits_slang_embedded_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t4, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Connection_Command_In_str);\n  }\n\n  uint8_t t5[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  size_t t5_numBits;\n  if(api_get_Suspect_Traffic_In1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t5_numBits, t5)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t5_numBits == numBits_slang_embedded_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In1_str);\n    String__append(SF (String) &Suspect_Traffic_In1_str, string(\"Received on Suspect_Traffic_In1: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In1_str, t5, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In1_str);\n  }\n\n  uint8_t t6[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  size_t t6_numBits;\n  if(api_get_Suspect_Traffic_In2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t6_numBits, t6)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t6_numBits == numBits_slang_embedded_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In2_str);\n    String__append(SF (String) &Suspect_Traffic_In2_str, string(\"Received on Suspect_Traffic_In2: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In2_str, t6, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In2_str);\n  }\n\n  uint8_t t7[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  size_t t7_numBits;\n  if(api_get_Suspect_Traffic_In3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t7_numBits, t7)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t7_numBits == numBits_slang_embedded_ADSB_Types_MonitorReport_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Suspect_Traffic_In3_str);\n    String__append(SF (String) &Suspect_Traffic_In3_str, string(\"Received on Suspect_Traffic_In3: \"));\n    byte_array_string(SF (String) &Suspect_Traffic_In3_str, t7, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &Suspect_Traffic_In3_str);\n  }\n\n  uint8_t t8[numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl];\n  size_t t8_numBits;\n  if(api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t8_numBits, t8)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t8_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Request_In_str);\n    String__append(SF (String) &SHM_QUEUE_Request_In_str, string(\"Received on SHM_QUEUE_Request_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Request_In_str, t8, numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_QUEUE_Request_In_str);\n  }\n\n  uint8_t t9[numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl];\n  size_t t9_numBits;\n  if(api_get_SHM_QUEUE_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t9_numBits, t9)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t9_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_AttestationResponse_str);\n    String__append(SF (String) &SHM_QUEUE_AttestationResponse_str, string(\"Received on SHM_QUEUE_AttestationResponse: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_AttestationResponse_str, t9, numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &SHM_QUEUE_AttestationResponse_str);\n  }\n\n  uint8_t t10[numBytes_slang_embedded_Common_Types_Unsigned_32];\n  size_t t10_numBits;\n  if(api_get_TerminateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF &t10_numBits, t10)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t10_numBits == numBits_slang_embedded_Common_Types_Unsigned_32, \"numBits received does not match expected\");\n\n    DeclNewString(TerminateAttestation_str);\n    String__append(SF (String) &TerminateAttestation_str, string(\"Received on TerminateAttestation: \"));\n    byte_array_string(SF (String) &TerminateAttestation_str, t10, numBytes_slang_embedded_Common_Types_Unsigned_32);\n    api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(SF (String) &TerminateAttestation_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_API_H\n#define ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_ADSB_Messages_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Response_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Heartbeat_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Ownship_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_ADSB_Traffic_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Response_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Suspect_Traffic_In3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_InitiateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_TerminateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_low_impl_SW_adapter_low_adapter_low_api.h>\n#include <adapter_low_impl_SW_adapter_low_adapter_low.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_ADSB_Messages_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_ADSB_Messages_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_ADSB_Messages_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Response_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Response_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_Response_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_AttestationRequest_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Heartbeat_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Heartbeat_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Heartbeat_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Ownship_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Ownship_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Ownship_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_ADSB_Traffic_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_ADSB_Traffic_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_ADSB_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_Response_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Response_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Response_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_QUEUE_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_AttestationRequest__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_AttestationRequest_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_SHM_HEADER_adsb_to_ptab_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Connection_Command_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_Suspect_Traffic_In1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In1_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out1__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out1_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Suspect_Traffic_In2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In2_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out2__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out2_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Suspect_Traffic_In3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_Suspect_Traffic_In3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_Suspect_Traffic_In3_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Suspect_Traffic_Out3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Suspect_Traffic_Out3__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Suspect_Traffic_Out3_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_SHM_QUEUE_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_SHM_QUEUE_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_SHM_QUEUE_AttestationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_AttestationResponse__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_AttestationResponse_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_Connection_Command_Out__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_InitiateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_put_InitiateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_put_InitiateAttestation_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_TerminateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_get_TerminateAttestation__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A88A12 = Option[slang_embedded.VPM.adapter_low_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Operational_Api(api);\n  Option_A88A12_get_(SF (slang_embedded_VPM_adapter_low_impl_Operational_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Operational_Api_get_TerminateAttestation_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"api_logError__slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low\", 0);\n\n  \/\/ Option_27842F = Option[slang_embedded.VPM.adapter_low_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_low_impl_Initialization_Api(api);\n  Option_27842F_get_(SF (slang_embedded_VPM_adapter_low_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_low_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise\", 0);\n\n  slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_low_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise\", 0);\n\n  slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_low_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_api.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered\", 0);\n\n  slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_low_impl_SW_adapter_low_adapter_low_adapter.h>\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_adapter.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_adapter_low_impl_SW_adapter_low_adapter_low_adapter_low_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_adapter.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_adapter_low_impl_SW_adapter_low_adapter_low_adapter_low_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_adapter.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_adapter_low_impl_SW_adapter_low_adapter_low_adapter_low_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_low_impl_SW_adapter_low_adapter_low_adapter.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_entryPoints\", 0);\n\n  return slang_embedded_adapter_low_impl_SW_adapter_low_adapter_low_adapter_low_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_ADAPTER_H\n#define ADAPTER_LOW_IMPL_SW_ADAPTER_LOW_ADAPTER_LOW_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_adapter_low_impl_SW_adapter_low_adapter_low.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(adapter_low_impl_SW_adapter_low_adapter_low\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.adapter_high_impl_SW_adapter_high_adapter_high\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix\n\nobject adapter_high extends App {\n\n  val adapter_highBridge : slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge = {\n    val SHM_QUEUE_ADSB_Heartbeat_In = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Heartbeat_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Ownship_In = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Ownship_In\", mode = EventIn)\n    val SHM_QUEUE_ADSB_Traffic_In = Port[Base_Types.Bits] (id = 2, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_ADSB_Traffic_In\", mode = EventIn)\n    val SHM_QUEUE_Response_In = Port[Base_Types.Bits] (id = 3, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Response_In\", mode = EventIn)\n    val Response_Out = Port[Base_Types.Bits] (id = 4, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Response_Out\", mode = EventOut)\n    val ADSB_Messages_Out = Port[Base_Types.Bits] (id = 5, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_ADSB_Messages_Out\", mode = EventOut)\n    val SHM_HEADER_adsb_to_ptab = Port[Base_Types.Bits] (id = 6, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_HEADER_adsb_to_ptab\", mode = EventOut)\n    val Connection_Command_Out = Port[Base_Types.Bits] (id = 7, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_Out\", mode = EventOut)\n    val Request_In = Port[Base_Types.Bits] (id = 8, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Request_In\", mode = EventIn)\n    val SHM_QUEUE_Request_Out = Port[Base_Types.Bits] (id = 9, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_SHM_QUEUE_Request_Out\", mode = EventOut)\n    val Connection_Command_In = Port[Base_Types.Bits] (id = 10, name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high_Connection_Command_In\", mode = EventIn)\n\n    slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_adapter_high_adapter_high\",\n      dispatchProtocol = Periodic(period = 250),\n      dispatchTriggers = None(),\n\n      SHM_QUEUE_ADSB_Heartbeat_In = SHM_QUEUE_ADSB_Heartbeat_In,\n      SHM_QUEUE_ADSB_Ownship_In = SHM_QUEUE_ADSB_Ownship_In,\n      SHM_QUEUE_ADSB_Traffic_In = SHM_QUEUE_ADSB_Traffic_In,\n      SHM_QUEUE_Response_In = SHM_QUEUE_Response_In,\n      Response_Out = Response_Out,\n      ADSB_Messages_Out = ADSB_Messages_Out,\n      SHM_HEADER_adsb_to_ptab = SHM_HEADER_adsb_to_ptab,\n      Connection_Command_Out = Connection_Command_Out,\n      Request_In = Request_In,\n      SHM_QUEUE_Request_Out = SHM_QUEUE_Request_Out,\n      Connection_Command_In = Connection_Command_In\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = adapter_highBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ SHM_QUEUE_ADSB_Heartbeat_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Heartbeat_In_id: Art.PortId = adapter_highBridge.SHM_QUEUE_ADSB_Heartbeat_In.id\n  var SHM_QUEUE_ADSB_Heartbeat_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_ADSB_Ownship_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Ownship_In_id: Art.PortId = adapter_highBridge.SHM_QUEUE_ADSB_Ownship_In.id\n  var SHM_QUEUE_ADSB_Ownship_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_ADSB_Traffic_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_ADSB_Traffic_In_id: Art.PortId = adapter_highBridge.SHM_QUEUE_ADSB_Traffic_In.id\n  var SHM_QUEUE_ADSB_Traffic_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Response_In: In EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Response_In_id: Art.PortId = adapter_highBridge.SHM_QUEUE_Response_In.id\n  var SHM_QUEUE_Response_In_port: Option[DataContent] = noData\n\n  \/\/ Response_Out: Out EventDataPort Base_Types.Bits\n  val Response_Out_id: Art.PortId = adapter_highBridge.Response_Out.id\n  var Response_Out_port: Option[DataContent] = noData\n\n  \/\/ ADSB_Messages_Out: Out EventDataPort Base_Types.Bits\n  val ADSB_Messages_Out_id: Art.PortId = adapter_highBridge.ADSB_Messages_Out.id\n  var ADSB_Messages_Out_port: Option[DataContent] = noData\n\n  \/\/ SHM_HEADER_adsb_to_ptab: Out EventDataPort Base_Types.Bits\n  val SHM_HEADER_adsb_to_ptab_id: Art.PortId = adapter_highBridge.SHM_HEADER_adsb_to_ptab.id\n  var SHM_HEADER_adsb_to_ptab_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_Out: Out EventDataPort Base_Types.Bits\n  val Connection_Command_Out_id: Art.PortId = adapter_highBridge.Connection_Command_Out.id\n  var Connection_Command_Out_port: Option[DataContent] = noData\n\n  \/\/ Request_In: In EventDataPort Base_Types.Bits\n  val Request_In_id: Art.PortId = adapter_highBridge.Request_In.id\n  var Request_In_port: Option[DataContent] = noData\n\n  \/\/ SHM_QUEUE_Request_Out: Out EventDataPort Base_Types.Bits\n  val SHM_QUEUE_Request_Out_id: Art.PortId = adapter_highBridge.SHM_QUEUE_Request_Out.id\n  var SHM_QUEUE_Request_Out_port: Option[DataContent] = noData\n\n  \/\/ Connection_Command_In: In EventDataPort Base_Types.Bits\n  val Connection_Command_In_id: Art.PortId = adapter_highBridge.Connection_Command_In.id\n  var Connection_Command_In_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == SHM_QUEUE_ADSB_Heartbeat_In_id) {\n      return SHM_QUEUE_ADSB_Heartbeat_In_port\n    } else if(portId == SHM_QUEUE_ADSB_Ownship_In_id) {\n      return SHM_QUEUE_ADSB_Ownship_In_port\n    } else if(portId == SHM_QUEUE_ADSB_Traffic_In_id) {\n      return SHM_QUEUE_ADSB_Traffic_In_port\n    } else if(portId == SHM_QUEUE_Response_In_id) {\n      return SHM_QUEUE_Response_In_port\n    } else if(portId == Request_In_id) {\n      return Request_In_port\n    } else if(portId == Connection_Command_In_id) {\n      return Connection_Command_In_port\n    } else {\n      halt(s\"Unexpected: adapter_high.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    SHM_QUEUE_ADSB_Heartbeat_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_QUEUE_ADSB_Heartbeat_In_Receive()\n\n    SHM_QUEUE_ADSB_Ownship_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_QUEUE_ADSB_Ownship_In_Receive()\n\n    SHM_QUEUE_ADSB_Traffic_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_QUEUE_ADSB_Traffic_In_Receive()\n\n    SHM_QUEUE_Response_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_QUEUE_Response_In_Receive()\n\n    Request_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.Request_In_Receive()\n\n    Connection_Command_In_port = adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.Connection_Command_In_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == Response_Out_id) {\n      Response_Out_port = Some(data)\n    } else if(portId == ADSB_Messages_Out_id) {\n      ADSB_Messages_Out_port = Some(data)\n    } else if(portId == SHM_HEADER_adsb_to_ptab_id) {\n      SHM_HEADER_adsb_to_ptab_port = Some(data)\n    } else if(portId == Connection_Command_Out_id) {\n      Connection_Command_Out_port = Some(data)\n    } else if(portId == SHM_QUEUE_Request_Out_id) {\n      SHM_QUEUE_Request_Out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: adapter_high.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(Response_Out_port.nonEmpty) {\n      adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.Response_Out_Send(Response_Out_port.get)\n      Response_Out_port = noData\n    }\n\n    if(ADSB_Messages_Out_port.nonEmpty) {\n      adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.ADSB_Messages_Out_Send(ADSB_Messages_Out_port.get)\n      ADSB_Messages_Out_port = noData\n    }\n\n    if(SHM_HEADER_adsb_to_ptab_port.nonEmpty) {\n      adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_HEADER_adsb_to_ptab_Send(SHM_HEADER_adsb_to_ptab_port.get)\n      SHM_HEADER_adsb_to_ptab_port = noData\n    }\n\n    if(Connection_Command_Out_port.nonEmpty) {\n      adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.Connection_Command_Out_Send(Connection_Command_Out_port.get)\n      Connection_Command_Out_port = noData\n    }\n\n    if(SHM_QUEUE_Request_Out_port.nonEmpty) {\n      adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.SHM_QUEUE_Request_Out_Send(SHM_QUEUE_Request_Out_port.get)\n      SHM_QUEUE_Request_Out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (adapter_highBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_SHM_QUEUE_ADSB_Heartbeat_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Heartbeat_In()\n      val apiUsage_SHM_QUEUE_ADSB_Ownship_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Ownship_In()\n      val apiUsage_SHM_QUEUE_ADSB_Traffic_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_ADSB_Traffic_In()\n      val apiUsage_SHM_QUEUE_Response_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_SHM_QUEUE_Response_In()\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Response_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Response_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_ADSB_Messages_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_HEADER_adsb_to_ptab(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_Connection_Command_Out(Base_Types.Bits_example())\n      val apiUsage_Request_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Request_In()\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_initialization_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.put_SHM_QUEUE_Request_Out(Base_Types.Bits_example())\n      val apiUsage_Connection_Command_In: Option[Base_Types.Bits] = slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high_Bridge.c_operational_api.get.get_Connection_Command_In()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix {\n  \/\/ returns T if seL4's SHM_QUEUE_ADSB_Heartbeat_In port is empty, F otherwise \n  def SHM_QUEUE_ADSB_Heartbeat_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_ADSB_Heartbeat_In port \n  def SHM_QUEUE_ADSB_Heartbeat_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's SHM_QUEUE_ADSB_Ownship_In port is empty, F otherwise \n  def SHM_QUEUE_ADSB_Ownship_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_ADSB_Ownship_In port \n  def SHM_QUEUE_ADSB_Ownship_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's SHM_QUEUE_ADSB_Traffic_In port is empty, F otherwise \n  def SHM_QUEUE_ADSB_Traffic_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_ADSB_Traffic_In port \n  def SHM_QUEUE_ADSB_Traffic_In_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's SHM_QUEUE_Response_In port is empty, F otherwise \n  def SHM_QUEUE_Response_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's SHM_QUEUE_Response_In port \n  def SHM_QUEUE_Response_In_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's Response_Out port\n  def Response_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's ADSB_Messages_Out port\n  def ADSB_Messages_Out_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_HEADER_adsb_to_ptab port\n  def SHM_HEADER_adsb_to_ptab_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's Connection_Command_Out port\n  def Connection_Command_Out_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's Request_In port is empty, F otherwise \n  def Request_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Request_In port \n  def Request_In_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's SHM_QUEUE_Request_Out port\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = $\n\n  \/\/ returns T if seL4's Connection_Command_In port is empty, F otherwise \n  def Connection_Command_In_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Connection_Command_In port \n  def Connection_Command_In_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Ext {\n  def SHM_QUEUE_ADSB_Heartbeat_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Heartbeat_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Ownship_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Ownship_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Traffic_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_ADSB_Traffic_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Response_In_IsEmpty(): B = halt(\"stub\")\n\n  def SHM_QUEUE_Response_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Response_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def ADSB_Messages_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def SHM_HEADER_adsb_to_ptab_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Connection_Command_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Request_In_IsEmpty(): B = halt(\"stub\")\n\n  def Request_In_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def SHM_QUEUE_Request_Out_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def Connection_Command_In_IsEmpty(): B = halt(\"stub\")\n\n  def Connection_Command_In_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_H\n#define ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_high_impl_SW_adapter_high_adapter_high_api.h>\n#include <adapter_high_impl_SW_adapter_high_adapter_high.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_DTU_Types_Response_Message_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_DTU_Types_Response_Message_impl, numBytes_slang_embedded_DTU_Types_Response_Message_impl);\n  api_put_Response_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_slang_embedded_DTU_Types_Response_Message_impl, t0);\n\n  uint8_t t1[numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl];\n  byte_array_default(SF t1, numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl);\n  api_put_ADSB_Messages_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, t1);\n\n  uint8_t t2[numBytes_slang_embedded_CASE_Proxies_shm_queue_header_impl];\n  byte_array_default(SF t2, numBits_slang_embedded_CASE_Proxies_shm_queue_header_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_header_impl);\n  api_put_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_slang_embedded_CASE_Proxies_shm_queue_header_impl, t2);\n\n  uint8_t t3[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  byte_array_default(SF t3, numBits_slang_embedded_CASE_Proxies_connection_command_impl, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n  api_put_Connection_Command_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_slang_embedded_CASE_Proxies_connection_command_impl, t3);\n\n  uint8_t t4[numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl];\n  byte_array_default(SF t4, numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl, numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl);\n  api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl, t4);\n\n  api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl];\n  size_t t0_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Heartbeat_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Heartbeat_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str, string(\"Received on SHM_QUEUE_ADSB_Heartbeat_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str, t0, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Heartbeat_In_str);\n  }\n\n  uint8_t t1[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl];\n  size_t t1_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Ownship_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Ownship_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str, string(\"Received on SHM_QUEUE_ADSB_Ownship_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str, t1, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Ownship_In_str);\n  }\n\n  uint8_t t2[numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl];\n  size_t t2_numBits;\n  if(api_get_SHM_QUEUE_ADSB_Traffic_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_ADSB_Traffic_In_str);\n    String__append(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str, string(\"Received on SHM_QUEUE_ADSB_Traffic_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str, t2, numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_ADSB_Traffic_In_str);\n  }\n\n  uint8_t t3[numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl];\n  size_t t3_numBits;\n  if(api_get_SHM_QUEUE_Response_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl, \"numBits received does not match expected\");\n\n    DeclNewString(SHM_QUEUE_Response_In_str);\n    String__append(SF (String) &SHM_QUEUE_Response_In_str, string(\"Received on SHM_QUEUE_Response_In: \"));\n    byte_array_string(SF (String) &SHM_QUEUE_Response_In_str, t3, numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &SHM_QUEUE_Response_In_str);\n  }\n\n  uint8_t t4[numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl];\n  size_t t4_numBits;\n  if(api_get_Request_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t4_numBits, t4)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t4_numBits == numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Request_In_str);\n    String__append(SF (String) &Request_In_str, string(\"Received on Request_In: \"));\n    byte_array_string(SF (String) &Request_In_str, t4, numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &Request_In_str);\n  }\n\n  uint8_t t5[numBytes_slang_embedded_CASE_Proxies_connection_command_impl];\n  size_t t5_numBits;\n  if(api_get_Connection_Command_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF &t5_numBits, t5)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t5_numBits == numBits_slang_embedded_CASE_Proxies_connection_command_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Connection_Command_In_str);\n    String__append(SF (String) &Connection_Command_In_str, string(\"Received on Connection_Command_In: \"));\n    byte_array_string(SF (String) &Connection_Command_In_str, t5, numBytes_slang_embedded_CASE_Proxies_connection_command_impl);\n    api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(SF (String) &Connection_Command_In_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_API_H\n#define ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_ADSB_Heartbeat_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_ADSB_Ownship_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_ADSB_Traffic_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_SHM_QUEUE_Response_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Response_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_ADSB_Messages_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Request_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_high_impl_SW_adapter_high_adapter_high_api.h>\n#include <adapter_high_impl_SW_adapter_high_adapter_high.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_SHM_QUEUE_ADSB_Heartbeat_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Heartbeat_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Heartbeat_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_ADSB_Ownship_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Ownship_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Ownship_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_ADSB_Traffic_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_ADSB_Traffic_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_ADSB_Traffic_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_SHM_QUEUE_Response_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_SHM_QUEUE_Response_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_SHM_QUEUE_Response_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Response_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_Response_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_put_Response_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_ADSB_Messages_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_ADSB_Messages_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_put_ADSB_Messages_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_SHM_HEADER_adsb_to_ptab__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_put_SHM_HEADER_adsb_to_ptab_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_Connection_Command_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_Connection_Command_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_put_Connection_Command_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Request_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_Request_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_Request_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_put_SHM_QUEUE_Request_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_Connection_Command_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_get_Connection_Command_In__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_4A179B = Option[slang_embedded.VPM.adapter_high_impl_Operational_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Operational_Api(api);\n  Option_4A179B_get_(SF (slang_embedded_VPM_adapter_high_impl_Operational_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Operational_Api_get_Connection_Command_In_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"api_logError__slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high\", 0);\n\n  \/\/ Option_7E5E44 = Option[slang_embedded.VPM.adapter_high_impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_adapter_high_impl_Initialization_Api(api);\n  Option_7E5E44_get_(SF (slang_embedded_VPM_adapter_high_impl_Initialization_Api) &api, slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_high_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise\", 0);\n\n  slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_high_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise\", 0);\n\n  slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_adapter_high_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_api.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered\", 0);\n\n  slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <adapter_high_impl_SW_adapter_high_adapter_high_adapter.h>\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_adapter.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_adapter_high_impl_SW_adapter_high_adapter_high_adapter_high_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_adapter.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_adapter_high_impl_SW_adapter_high_adapter_high_adapter_high_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_adapter.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_adapter_high_impl_SW_adapter_high_adapter_high_adapter_high_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"adapter_high_impl_SW_adapter_high_adapter_high_adapter.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_entryPoints\", 0);\n\n  return slang_embedded_adapter_high_impl_SW_adapter_high_adapter_high_adapter_high_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_ADAPTER_H\n#define ADAPTER_HIGH_IMPL_SW_ADAPTER_HIGH_ADAPTER_HIGH_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_adapter_high_impl_SW_adapter_high_adapter_high.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(adapter_high_impl_SW_adapter_high_adapter_high\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix\n\nobject CASE_Monitor3 extends App {\n\n  val CASE_Monitor3Bridge : slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge = {\n    val Observed = Port[Base_Types.Bits] (id = 0, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Observed\", mode = EventIn)\n    val Suspect_Traffic_Out = Port[Base_Types.Bits] (id = 1, name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3_Suspect_Traffic_Out\", mode = EventOut)\n\n    slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge(\n      id = 0,\n      name = \"VPM_8600B_Ext_impl_Instance_SW_Teleport_Monitor_CASE_Monitor3\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      Observed = Observed,\n      Suspect_Traffic_Out = Suspect_Traffic_Out\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = CASE_Monitor3Bridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ Observed: In EventDataPort Base_Types.Bits\n  val Observed_id: Art.PortId = CASE_Monitor3Bridge.Observed.id\n  var Observed_port: Option[DataContent] = noData\n\n  \/\/ Suspect_Traffic_Out: Out EventDataPort Base_Types.Bits\n  val Suspect_Traffic_Out_id: Art.PortId = CASE_Monitor3Bridge.Suspect_Traffic_Out.id\n  var Suspect_Traffic_Out_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == Observed_id) {\n      return Observed_port\n    } else {\n      halt(s\"Unexpected: CASE_Monitor3.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    Observed_port = CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix.Observed_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == Suspect_Traffic_Out_id) {\n      Suspect_Traffic_Out_port = Some(data)\n    } else {\n      halt(s\"Unexpected: CASE_Monitor3.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(Suspect_Traffic_Out_port.nonEmpty) {\n      CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix.Suspect_Traffic_Out_Send(Suspect_Traffic_Out_port.get)\n      Suspect_Traffic_Out_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (CASE_Monitor3Bridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_Observed: Option[Base_Types.Bits] = slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.get_Observed()\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_initialization_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n      slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge.c_operational_api.get.put_Suspect_Traffic_Out(Base_Types.Bits_example())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\n\/\/ This file was auto-generated.  Do not edit\n\npackage slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\n@ext object CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix {\n  \/\/ returns T if seL4's Observed port is empty, F otherwise \n  def Observed_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's Observed port \n  def Observed_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's Suspect_Traffic_Out port\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/VPM\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.VPM\n\nimport org.sireum._\nimport art._\n\nobject CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Ext {\n  def Observed_IsEmpty(): B = halt(\"stub\")\n\n  def Observed_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def Suspect_Traffic_Out_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_H\n#define CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_MonitorReport_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_ADSB_Types_MonitorReport_impl, numBytes_slang_embedded_ADSB_Types_MonitorReport_impl);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF numBits_slang_embedded_ADSB_Types_MonitorReport_impl, t0);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_\", 0);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl];\n  size_t t0_numBits;\n  if(api_get_Observed__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl, \"numBits received does not match expected\");\n\n    DeclNewString(Observed_str);\n    String__append(SF (String) &Observed_str, string(\"Received on Observed: \"));\n    byte_array_string(SF (String) &Observed_str, t0, numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl);\n    api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF (String) &Observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_API_H\n#define CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_Observed__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_get_Observed__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_64CA4B = Option[slang_embedded.VPM.CASE_Monitor3_Impl_Operational_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor3_Impl_Operational_Api(api);\n  Option_64CA4B_get_(SF (slang_embedded_VPM_CASE_Monitor3_Impl_Operational_Api) &api, slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_Operational_Api_get_Observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_D8332C = Option[slang_embedded.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_D8332C_get_(SF (slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api_put_Suspect_Traffic_Out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_D8332C = Option[slang_embedded.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_D8332C_get_(SF (slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logDebug__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_D8332C = Option[slang_embedded.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_D8332C_get_(SF (slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"api_logError__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\", 0);\n\n  \/\/ Option_D8332C = Option[slang_embedded.VPM.CASE_Monitor3_Impl_Initialization_Api]\n  DeclNewslang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api(api);\n  Option_D8332C_get_(SF (slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api) &api, slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor3_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor3_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise\", 0);\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered(\n  STACK_FRAME\n  slang_embedded_VPM_CASE_Monitor3_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered\", 0);\n\n  slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.h>\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_CASE_Monitor3_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_CASE_Monitor3_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_CASE_Monitor3_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_entryPoints\", 0);\n\n  return slang_embedded_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_CASE_Monitor3_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_ADAPTER_H\n#define CASE_MONITOR3_IMPL_SW_TELEPORT_MONITOR_CASE_MONITOR3_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n\/\/ example method that sets the first numBits bits of byteArray to 1\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_default\", 0);\n\n  sfAssert(SF (numBits - 1) \/ 8  + 1 <= numBytes, \"byte_array_default: numBytes * 8 must be at least numBits\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    uint8_t v = 0;\n    for(uint8_t bit = 0; bit < 8; bit++) {\n      if(byte * 8 + bit < numBits) {\n        v |= 1UL << bit;\n      }\n    }\n    byteArray[byte] = v;\n  }\n}\n\n\/\/ example method that places the hex value of the bytes in byteArray into str\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_string\", 0);\n\n  sfAssert(SF (str->size + numBytes) <= MaxString, \"byte_array_string: Insufficient maximum for String characters, consider increasing the --max-string-size option\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    U8_string_(SF str, byteArray[byte]);\n    String__append(SF str, string(\" \"));\n  }\n}\n\n\/\/ example method that directly prints the hex values of the bytes in byte_array\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"hex_dump\", 0);\n\n  printf(\"[ \");\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    if(byte != 0 && byte % 16 == 0) { printf(\"\\n  \"); }\n    printf(\"%02X \", byte_array[byte]);\n  }\n  printf(\"]\\n\");\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n\/\/ bit-codec size for slang_embedded_VPM_CASE_AttestationRequestMsg_impl\n#define numBits_slang_embedded_VPM_CASE_AttestationRequestMsg_impl 256\n#define numBytes_slang_embedded_VPM_CASE_AttestationRequestMsg_impl ((numBits_slang_embedded_VPM_CASE_AttestationRequestMsg_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_VPM_CASE_AttestationResponseMsg_impl\n#define numBits_slang_embedded_VPM_CASE_AttestationResponseMsg_impl 16384\n#define numBytes_slang_embedded_VPM_CASE_AttestationResponseMsg_impl ((numBits_slang_embedded_VPM_CASE_AttestationResponseMsg_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_WhiteList_impl\n#define numBits_slang_embedded_CASE_Proxies_WhiteList_impl 128\n#define numBytes_slang_embedded_CASE_Proxies_WhiteList_impl ((numBits_slang_embedded_CASE_Proxies_WhiteList_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_Common_Types_Unsigned_32\n#define numBits_slang_embedded_Common_Types_Unsigned_32 32\n#define numBytes_slang_embedded_Common_Types_Unsigned_32 ((numBits_slang_embedded_Common_Types_Unsigned_32 - 1) \/ 8 + 1)\n\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes);\n\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes);\n\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes);\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_request_array_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_request_array_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_request_array_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_connection_command_impl\n#define numBits_slang_embedded_CASE_Proxies_connection_command_impl 192\n#define numBytes_slang_embedded_CASE_Proxies_connection_command_impl ((numBits_slang_embedded_CASE_Proxies_connection_command_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl\n#define numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl 35088\n#define numBytes_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl ((numBits_slang_embedded_ADSB_Types_ADSB_Aggregated_Message_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_ADSB_Types_MonitorReport_impl\n#define numBits_slang_embedded_ADSB_Types_MonitorReport_impl 4832\n#define numBytes_slang_embedded_ADSB_Types_MonitorReport_impl ((numBits_slang_embedded_ADSB_Types_MonitorReport_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_DTU_Types_Response_Message_impl\n#define numBits_slang_embedded_DTU_Types_Response_Message_impl 16384\n#define numBytes_slang_embedded_DTU_Types_Response_Message_impl ((numBits_slang_embedded_DTU_Types_Response_Message_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_Heartbeat_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_ownship_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_adsb_traffic_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_response_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_request_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_header_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_header_impl 256\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_header_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_header_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_monitor_report_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_vdtu_request_impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl\n#define numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl 65792\n#define numBytes_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl ((numBits_slang_embedded_CASE_Proxies_shm_queue_attestation_response_impl - 1) \/ 8 + 1)\n#endif",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/bin\/transpile-sel4.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\" \\\n  --apps \"slang_embedded.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.CASE_AttestationManager\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=5\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.CASE_AttestationManager\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\" \\\n  --apps \"slang_embedded.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.CASE_AttestationGate\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 5 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=5;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=5\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.CASE_AttestationGate\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\" \\\n  --apps \"slang_embedded.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.CASE_Monitor1\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.CASE_Monitor1\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\" \\\n  --apps \"slang_embedded.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.CASE_Monitor2\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.CASE_Monitor2\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/adapter_low_impl_SW_adapter_low_adapter_low\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/adapter_low_impl_SW_adapter_low_adapter_low\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"adapter_low_impl_SW_adapter_low_adapter_low\" \\\n  --apps \"slang_embedded.adapter_low_impl_SW_adapter_low_adapter_low.adapter_low\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 23 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=23;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=23\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_adapter_low_impl_SW_adapter_low_adapter_low.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.adapter_low_impl_SW_adapter_low_adapter_low.adapter_low\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/adapter_high_impl_SW_adapter_high_adapter_high\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/adapter_high_impl_SW_adapter_high_adapter_high\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"adapter_high_impl_SW_adapter_high_adapter_high\" \\\n  --apps \"slang_embedded.adapter_high_impl_SW_adapter_high_adapter_high.adapter_high\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 11 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=11;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=11\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_adapter_high_impl_SW_adapter_high_adapter_high.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.adapter_high_impl_SW_adapter_high_adapter_high.adapter_high\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/VPM${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --apps \"slang_embedded.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.CASE_Monitor3\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1;IS[Z,B]=65792\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.CASE_Monitor3\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.c\" \\\n  --exclude-build \"slang_embedded.VPM.CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager,slang_embedded.VPM.CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate,slang_embedded.VPM.CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1,slang_embedded.VPM.CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2,slang_embedded.VPM.adapter_low_impl_SW_adapter_low_adapter_low,slang_embedded.VPM.adapter_high_impl_SW_adapter_high_adapter_high,slang_embedded.VPM.CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"SlangTypeLibrary\" \\\n  --apps \"slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --sequence \"IS[Z,B]=65792\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --lib-only \\\n  --verbose",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    ArtDebug_Ext.start()\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 7\n  val maxPorts: PortId = 50\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang-embedded ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w slang_embedded.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `slang_embedded` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.5\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.8\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210422.4fc8eee\n  val sireumScalacVersion = \"4.20210422.4fc8eee\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210411.c273380\n  val kekinianVersion = \"4.20210411.c273380\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"slang_embedded.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"slang_embedded.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/slang_embedded\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val VPM_8600B_Ext_impl_Instance = slangEmbeddedProject(\"VPM_8600B_Ext_impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.5\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.8\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210422.4fc8eee\nval sireumScalacVersion = \"4.20210422.4fc8eee\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210411.c273380\nval kekinianVersion = \"4.20210411.c273380\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.Demo\"),\n\n  mainClass in assembly := Some(\"slang_embedded.Demo\"),\n  assemblyJarName in assembly := \"VPM_8600B_Ext_impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.camkes",
        {
          "type" : "TestResource",
          "content" : "component CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_AttestationRequest_1_notification;\n  emits ReceiveEvent sb_TrustedIds_1_notification;\n  emits ReceiveEvent sb_TerminateAttestation_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_AttestationResponse_notification;\n  consumes ReceiveEvent sb_InitiateAttestation_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_AttestationRequest_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AttestationResponse_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_TrustedIds_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_InitiateAttestation_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_TerminateAttestation_queue_1;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.camkes",
        {
          "type" : "TestResource",
          "content" : "component CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_SHM_QUEUE_Request_Out_1_notification;\n  emits ReceiveEvent sb_Connection_Command_Out_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_SHM_QUEUE_Request_In_notification;\n  consumes ReceiveEvent sb_Connection_Command_In_notification;\n  consumes ReceiveEvent sb_TrustedIds_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_SHM_QUEUE_Request_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_SHM_QUEUE_Request_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_TrustedIds_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.camkes",
        {
          "type" : "TestResource",
          "content" : "component CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_Suspect_Traffic_Out_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_Observed_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_Observed_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_Out_queue_1;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.camkes",
        {
          "type" : "TestResource",
          "content" : "component CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_Suspect_Traffic_Out_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_Observed_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_Observed_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_Out_queue_1;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.camkes",
        {
          "type" : "TestResource",
          "content" : "component adapter_low_impl_SW_adapter_low_adapter_low {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_SHM_QUEUE_Request_Out_1_notification;\n  emits ReceiveEvent sb_AttestationResponse_1_notification;\n  emits ReceiveEvent sb_Connection_Command_Out_1_notification;\n  emits ReceiveEvent sb_InitiateAttestation_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_ADSB_Messages_In_notification;\n  consumes ReceiveEvent sb_Response_In_notification;\n  consumes ReceiveEvent sb_AttestationRequest_notification;\n  consumes ReceiveEvent sb_SHM_HEADER_adsb_to_ptab_notification;\n  consumes ReceiveEvent sb_Connection_Command_In_notification;\n  consumes ReceiveEvent sb_Suspect_Traffic_In1_notification;\n  consumes ReceiveEvent sb_Suspect_Traffic_In2_notification;\n  consumes ReceiveEvent sb_Suspect_Traffic_In3_notification;\n  consumes ReceiveEvent sb_TerminateAttestation_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_ADSB_Messages_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Response_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_AttestationRequest_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_SHM_HEADER_adsb_to_ptab_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_In1_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_In2_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_In3_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_SHM_QUEUE_Request_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_AttestationResponse_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_InitiateAttestation_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_TerminateAttestation_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.camkes",
        {
          "type" : "TestResource",
          "content" : "component adapter_high_impl_SW_adapter_high_adapter_high {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_Response_Out_1_notification;\n  emits ReceiveEvent sb_ADSB_Messages_Out_1_notification;\n  emits ReceiveEvent sb_SHM_HEADER_adsb_to_ptab_1_notification;\n  emits ReceiveEvent sb_Connection_Command_Out_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_Request_In_notification;\n  consumes ReceiveEvent sb_Connection_Command_In_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_Response_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_ADSB_Messages_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_SHM_HEADER_adsb_to_ptab_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_Out_queue_1;\n  dataport sb_queue_union_art_DataContent_1_t sb_Request_In_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Connection_Command_In_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.camkes",
        {
          "type" : "TestResource",
          "content" : "component CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  emits ReceiveEvent sb_Suspect_Traffic_Out_1_notification;\n  emits TickTock sb_self_pacer_tick;\n  consumes ReceiveEvent sb_Observed_notification;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sb_queue_union_art_DataContent_1_t sb_Observed_queue;\n  dataport sb_queue_union_art_DataContent_1_t sb_Suspect_Traffic_Out_queue_1;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/VPM_8600B_Ext_impl_Instance.camkes",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager.camkes\";\nimport \"components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate.camkes\";\nimport \"components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1.camkes\";\nimport \"components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2.camkes\";\nimport \"components\/adapter_low_impl_SW_adapter_low_adapter_low\/adapter_low_impl_SW_adapter_low_adapter_low.camkes\";\nimport \"components\/adapter_high_impl_SW_adapter_high_adapter_high\/adapter_high_impl_SW_adapter_high_adapter_high.camkes\";\nimport \"components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3.camkes\";\n\nassembly {\n  composition {\n    component CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager SW_Attestation_Manager_CASE_AttestationManager;\n    component CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate SW_Attestation_Gate_CASE_AttestationGate;\n    component CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1 SW_Expected_Position_Monitor_CASE_Monitor1;\n    component CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2 SW_Duplicate_Entity_Monitor_CASE_Monitor2;\n    component adapter_low_impl_SW_adapter_low_adapter_low SW_adapter_low_adapter_low;\n    component adapter_high_impl_SW_adapter_high_adapter_high SW_adapter_high_adapter_high;\n    component CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3 SW_Teleport_Monitor_CASE_Monitor3;\n\n    connection seL4Notification conn1(from SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationRequest_1_notification, to SW_adapter_low_adapter_low.sb_AttestationRequest_notification);\n    connection seL4SharedData conn2(from SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationRequest_queue_1, to SW_adapter_low_adapter_low.sb_AttestationRequest_queue);\n    connection seL4Notification conn3(from SW_Attestation_Manager_CASE_AttestationManager.sb_TrustedIds_1_notification, to SW_Attestation_Gate_CASE_AttestationGate.sb_TrustedIds_notification);\n    connection seL4SharedData conn4(from SW_Attestation_Manager_CASE_AttestationManager.sb_TrustedIds_queue_1, to SW_Attestation_Gate_CASE_AttestationGate.sb_TrustedIds_queue);\n    connection seL4Notification conn5(from SW_Attestation_Manager_CASE_AttestationManager.sb_TerminateAttestation_1_notification, to SW_adapter_low_adapter_low.sb_TerminateAttestation_notification);\n    connection seL4SharedData conn6(from SW_Attestation_Manager_CASE_AttestationManager.sb_TerminateAttestation_queue_1, to SW_adapter_low_adapter_low.sb_TerminateAttestation_queue);\n    connection seL4Notification conn7(from SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_Out_1_notification, to SW_adapter_high_adapter_high.sb_Request_In_notification);\n    connection seL4SharedData conn8(from SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_Out_queue_1, to SW_adapter_high_adapter_high.sb_Request_In_queue);\n    connection seL4Notification conn9(from SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_Out_1_notification, to SW_adapter_high_adapter_high.sb_Connection_Command_In_notification);\n    connection seL4SharedData conn10(from SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_Out_queue_1, to SW_adapter_high_adapter_high.sb_Connection_Command_In_queue);\n    connection seL4Notification conn11(from SW_Expected_Position_Monitor_CASE_Monitor1.sb_Suspect_Traffic_Out_1_notification, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In1_notification);\n    connection seL4SharedData conn12(from SW_Expected_Position_Monitor_CASE_Monitor1.sb_Suspect_Traffic_Out_queue_1, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In1_queue);\n    connection seL4Notification conn13(from SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Suspect_Traffic_Out_1_notification, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In2_notification);\n    connection seL4SharedData conn14(from SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Suspect_Traffic_Out_queue_1, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In2_queue);\n    connection seL4Notification conn15(from SW_adapter_low_adapter_low.sb_SHM_QUEUE_Request_Out_1_notification, to SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_In_notification);\n    connection seL4SharedData conn16(from SW_adapter_low_adapter_low.sb_SHM_QUEUE_Request_Out_queue_1, to SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_In_queue);\n    connection seL4Notification conn17(from SW_adapter_low_adapter_low.sb_AttestationResponse_1_notification, to SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationResponse_notification);\n    connection seL4SharedData conn18(from SW_adapter_low_adapter_low.sb_AttestationResponse_queue_1, to SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationResponse_queue);\n    connection seL4Notification conn19(from SW_adapter_low_adapter_low.sb_Connection_Command_Out_1_notification, to SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_In_notification);\n    connection seL4SharedData conn20(from SW_adapter_low_adapter_low.sb_Connection_Command_Out_queue_1, to SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_In_queue);\n    connection seL4Notification conn21(from SW_adapter_low_adapter_low.sb_InitiateAttestation_1_notification, to SW_Attestation_Manager_CASE_AttestationManager.sb_InitiateAttestation_notification);\n    connection seL4SharedData conn22(from SW_adapter_low_adapter_low.sb_InitiateAttestation_queue_1, to SW_Attestation_Manager_CASE_AttestationManager.sb_InitiateAttestation_queue);\n    connection seL4Notification conn23(from SW_adapter_high_adapter_high.sb_Response_Out_1_notification, to SW_adapter_low_adapter_low.sb_Response_In_notification);\n    connection seL4SharedData conn24(from SW_adapter_high_adapter_high.sb_Response_Out_queue_1, to SW_adapter_low_adapter_low.sb_Response_In_queue);\n    connection seL4Notification conn25(from SW_adapter_high_adapter_high.sb_ADSB_Messages_Out_1_notification, to SW_Expected_Position_Monitor_CASE_Monitor1.sb_Observed_notification, to SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Observed_notification, to SW_Teleport_Monitor_CASE_Monitor3.sb_Observed_notification, to SW_adapter_low_adapter_low.sb_ADSB_Messages_In_notification);\n    connection seL4SharedData conn26(from SW_adapter_high_adapter_high.sb_ADSB_Messages_Out_queue_1, to SW_Expected_Position_Monitor_CASE_Monitor1.sb_Observed_queue, to SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Observed_queue, to SW_Teleport_Monitor_CASE_Monitor3.sb_Observed_queue, to SW_adapter_low_adapter_low.sb_ADSB_Messages_In_queue);\n    connection seL4Notification conn27(from SW_adapter_high_adapter_high.sb_SHM_HEADER_adsb_to_ptab_1_notification, to SW_adapter_low_adapter_low.sb_SHM_HEADER_adsb_to_ptab_notification);\n    connection seL4SharedData conn28(from SW_adapter_high_adapter_high.sb_SHM_HEADER_adsb_to_ptab_queue_1, to SW_adapter_low_adapter_low.sb_SHM_HEADER_adsb_to_ptab_queue);\n    connection seL4Notification conn29(from SW_adapter_high_adapter_high.sb_Connection_Command_Out_1_notification, to SW_adapter_low_adapter_low.sb_Connection_Command_In_notification);\n    connection seL4SharedData conn30(from SW_adapter_high_adapter_high.sb_Connection_Command_Out_queue_1, to SW_adapter_low_adapter_low.sb_Connection_Command_In_queue);\n    connection seL4Notification conn31(from SW_Teleport_Monitor_CASE_Monitor3.sb_Suspect_Traffic_Out_1_notification, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In3_notification);\n    connection seL4SharedData conn32(from SW_Teleport_Monitor_CASE_Monitor3.sb_Suspect_Traffic_Out_queue_1, to SW_adapter_low_adapter_low.sb_Suspect_Traffic_In3_queue);\n    connection seL4Notification conn33(from SW_Attestation_Manager_CASE_AttestationManager.sb_self_pacer_tick, to SW_Attestation_Manager_CASE_AttestationManager.sb_self_pacer_tock);\n    connection seL4Notification conn34(from SW_Attestation_Gate_CASE_AttestationGate.sb_self_pacer_tick, to SW_Attestation_Gate_CASE_AttestationGate.sb_self_pacer_tock);\n    connection seL4Notification conn35(from SW_Expected_Position_Monitor_CASE_Monitor1.sb_self_pacer_tick, to SW_Expected_Position_Monitor_CASE_Monitor1.sb_self_pacer_tock);\n    connection seL4Notification conn36(from SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_self_pacer_tick, to SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_self_pacer_tock);\n    connection seL4Notification conn37(from SW_adapter_low_adapter_low.sb_self_pacer_tick, to SW_adapter_low_adapter_low.sb_self_pacer_tock);\n    connection seL4Notification conn38(from SW_adapter_high_adapter_high.sb_self_pacer_tick, to SW_adapter_high_adapter_high.sb_self_pacer_tock);\n    connection seL4Notification conn39(from SW_Teleport_Monitor_CASE_Monitor3.sb_self_pacer_tick, to SW_Teleport_Monitor_CASE_Monitor3.sb_self_pacer_tock);\n  }\n\n  configuration {\n    SW_Attestation_Manager_CASE_AttestationManager._domain = 7;\n    SW_Attestation_Gate_CASE_AttestationGate._domain = 8;\n    SW_Expected_Position_Monitor_CASE_Monitor1._domain = 4;\n    SW_Duplicate_Entity_Monitor_CASE_Monitor2._domain = 5;\n    SW_adapter_low_adapter_low._domain = 3;\n    SW_adapter_high_adapter_high._domain = 2;\n    SW_Teleport_Monitor_CASE_Monitor3._domain = 6;\n    conn2.size = 69632;\n    SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationRequest_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_AttestationRequest_queue_access = \"R\";\n    conn4.size = 69632;\n    SW_Attestation_Manager_CASE_AttestationManager.sb_TrustedIds_queue_1_access = \"W\";\n    SW_Attestation_Gate_CASE_AttestationGate.sb_TrustedIds_queue_access = \"R\";\n    conn6.size = 69632;\n    SW_Attestation_Manager_CASE_AttestationManager.sb_TerminateAttestation_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_TerminateAttestation_queue_access = \"R\";\n    conn8.size = 69632;\n    SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_Out_queue_1_access = \"W\";\n    SW_adapter_high_adapter_high.sb_Request_In_queue_access = \"R\";\n    conn10.size = 69632;\n    SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_Out_queue_1_access = \"W\";\n    SW_adapter_high_adapter_high.sb_Connection_Command_In_queue_access = \"R\";\n    conn12.size = 69632;\n    SW_Expected_Position_Monitor_CASE_Monitor1.sb_Suspect_Traffic_Out_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_Suspect_Traffic_In1_queue_access = \"R\";\n    conn14.size = 69632;\n    SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Suspect_Traffic_Out_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_Suspect_Traffic_In2_queue_access = \"R\";\n    conn16.size = 69632;\n    SW_adapter_low_adapter_low.sb_SHM_QUEUE_Request_Out_queue_1_access = \"W\";\n    SW_Attestation_Gate_CASE_AttestationGate.sb_SHM_QUEUE_Request_In_queue_access = \"R\";\n    conn18.size = 69632;\n    SW_adapter_low_adapter_low.sb_AttestationResponse_queue_1_access = \"W\";\n    SW_Attestation_Manager_CASE_AttestationManager.sb_AttestationResponse_queue_access = \"R\";\n    conn20.size = 69632;\n    SW_adapter_low_adapter_low.sb_Connection_Command_Out_queue_1_access = \"W\";\n    SW_Attestation_Gate_CASE_AttestationGate.sb_Connection_Command_In_queue_access = \"R\";\n    conn22.size = 69632;\n    SW_adapter_low_adapter_low.sb_InitiateAttestation_queue_1_access = \"W\";\n    SW_Attestation_Manager_CASE_AttestationManager.sb_InitiateAttestation_queue_access = \"R\";\n    conn24.size = 69632;\n    SW_adapter_high_adapter_high.sb_Response_Out_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_Response_In_queue_access = \"R\";\n    conn26.size = 69632;\n    SW_adapter_high_adapter_high.sb_ADSB_Messages_Out_queue_1_access = \"W\";\n    SW_Expected_Position_Monitor_CASE_Monitor1.sb_Observed_queue_access = \"R\";\n    SW_Duplicate_Entity_Monitor_CASE_Monitor2.sb_Observed_queue_access = \"R\";\n    SW_Teleport_Monitor_CASE_Monitor3.sb_Observed_queue_access = \"R\";\n    SW_adapter_low_adapter_low.sb_ADSB_Messages_In_queue_access = \"R\";\n    conn28.size = 69632;\n    SW_adapter_high_adapter_high.sb_SHM_HEADER_adsb_to_ptab_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_SHM_HEADER_adsb_to_ptab_queue_access = \"R\";\n    conn30.size = 69632;\n    SW_adapter_high_adapter_high.sb_Connection_Command_Out_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_Connection_Command_In_queue_access = \"R\";\n    conn32.size = 69632;\n    SW_Teleport_Monitor_CASE_Monitor3.sb_Suspect_Traffic_Out_queue_1_access = \"W\";\n    SW_adapter_low_adapter_low.sb_Suspect_Traffic_In3_queue_access = \"R\";\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/CMake_CakeMLOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(CAKEML_DUMP_BUFFERS\n       \"Print the contents of byte-arrays being sent to CakeML\"\n       OFF)\n\nif(CAKEML_DUMP_BUFFERS OR \"$ENV{CAKEML_DUMP_BUFFERS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_DUMP_BUFFERS)\nendif()\n\noption(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n       \"Print warning messages if byte-arrays being sent to CakeML are larger than expected\"\n       OFF)\n\nif(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS OR \"$ENV{CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS)\nendif()\n\noption(CAKEML_ASSEMBLIES_PRESENT\n       \"Enable if CakeML assembly files have been included\"\n       OFF)\n\nif(CAKEML_ASSEMBLIES_PRESENT OR \"$ENV{CAKEML_ASSEMBLIES_PRESENT}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_ASSEMBLIES_PRESENT)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (VPM_8600B_Ext_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_CakeMLOptions.cmake)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/adapter_low_impl_SW_adapter_low_adapter_low)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/adapter_high_impl_SW_adapter_high_adapter_high)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\n  SOURCES components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/src\/sb_CASE_AttestationManager_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/includes\/ types\/includes\n  LIBS CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\n)\n\nDeclareCAmkESComponent(CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\n  SOURCES components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl_ffi.c components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl.S components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/includes\/ types\/includes\n  LIBS CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\n)\n\nDeclareCAmkESComponent(CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\n  SOURCES components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl_ffi.c components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl.S components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/includes\/ types\/includes\n  LIBS CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\n)\n\nDeclareCAmkESComponent(CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\n  SOURCES components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl_ffi.c components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl.S components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/includes\/ types\/includes\n  LIBS CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\n)\n\nDeclareCAmkESComponent(adapter_low_impl_SW_adapter_low_adapter_low\n  SOURCES components\/adapter_low_impl_SW_adapter_low_adapter_low\/src\/sb_adapter_low_impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/adapter_low_impl_SW_adapter_low_adapter_low\/includes\/ types\/includes\n  LIBS adapter_low_impl_SW_adapter_low_adapter_low\n)\n\nDeclareCAmkESComponent(adapter_high_impl_SW_adapter_high_adapter_high\n  SOURCES components\/adapter_high_impl_SW_adapter_high_adapter_high\/src\/sb_adapter_high_impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/adapter_high_impl_SW_adapter_high_adapter_high\/includes\/ types\/includes\n  LIBS adapter_high_impl_SW_adapter_high_adapter_high\n)\n\nDeclareCAmkESComponent(CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\n  SOURCES components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl_ffi.c components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl.S components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl.c types\/src\/sb_queue_union_art_DataContent_1.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/includes\/ types\/includes\n  LIBS CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\n)\n\nDeclareCAmkESRootserver(VPM_8600B_Ext_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:s\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"  -c, --camkes-dir      Location of CAmkES project\"\n  echo \"  -n, --non-interactive Non-interactive mode.  Symlink in apps directory will be replaced\"\n  echo \"                        if present, CAmkES build directory will not be deleted\"\n  echo \"  -o, --camkes-options  CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"  -s, --simulate        Simulate via QEMU\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    # if the project contains VMs and USE_PRECONFIGURED_ROOTFS=OFF then\n    # deleting the build directory would force the linux image to be\n    # re-downloaded, which can take a long time\n    echo \"Non-interactive mode so not deleting existing ${BUILD_DIR}\"\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\nif [ \"${SIMULATE}\" = true ]; then\n  # .\/simulate\n\n  # console output from simulation disappears when QEMU shuts down when run from\n  # generated .\/simulate script. Instead call QEMU directly using the default\n  # values .\/simulate would pass\n\n  qemu-system-x86_64 \\\n      -cpu Nehalem,-vme,+pdpe1gb,-xsave,-xsaveopt,-xsavec,-fsgsbase,-invpcid,enforce \\\n      -nographic \\\n      -serial mon:stdio \\\n      -m size=512M \\\n      -kernel images\/kernel-x86_64-pc99 \\\n      -initrd images\/capdl-loader-image-x86_64-pc99\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/src\/sb_CASE_AttestationManager_Impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_CASE_AttestationManager_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nbool sb_AttestationRequest_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AttestationRequest_queue_1, (union_art_DataContent*) data);\n  sb_AttestationRequest_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_AttestationResponse_recv_queue;\n\n\/************************************************************************\n * sb_AttestationResponse_dequeue_poll:\n ************************************************************************\/\nbool sb_AttestationResponse_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_AttestationResponse_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_AttestationResponse_dequeue:\n ************************************************************************\/\nbool sb_AttestationResponse_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_AttestationResponse_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_AttestationResponse_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_AttestationResponse_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_AttestationResponse_recv_queue);\n}\n\nbool sb_TrustedIds_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_TrustedIds_queue_1, (union_art_DataContent*) data);\n  sb_TrustedIds_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_InitiateAttestation_recv_queue;\n\n\/************************************************************************\n * sb_InitiateAttestation_dequeue_poll:\n ************************************************************************\/\nbool sb_InitiateAttestation_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_InitiateAttestation_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_InitiateAttestation_dequeue:\n ************************************************************************\/\nbool sb_InitiateAttestation_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_InitiateAttestation_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_InitiateAttestation_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_InitiateAttestation_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_InitiateAttestation_recv_queue);\n}\n\nbool sb_TerminateAttestation_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_TerminateAttestation_queue_1, (union_art_DataContent*) data);\n  sb_TerminateAttestation_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send AttestationRequest: Out EventDataPort VPM__CASE_AttestationRequestMsg_impl\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_AttestationRequest_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_AttestationRequest_Send\", 0);\n\n  sb_AttestationRequest_enqueue(d);\n}\n\n\/\/ send TrustedIds: Out EventDataPort CASE_Proxies__WhiteList_impl\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_TrustedIds_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_TrustedIds_Send\", 0);\n\n  sb_TrustedIds_enqueue(d);\n}\n\n\/\/ send TerminateAttestation: Out EventDataPort Common_Types__Unsigned_32\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_TerminateAttestation_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_TerminateAttestation_Send\", 0);\n\n  sb_TerminateAttestation_enqueue(d);\n}\n\n\/\/ is_empty AttestationResponse: In EventDataPort\nB slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_AttestationResponse_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_AttestationResponse_is_empty();\n}\n\n\/\/ receive AttestationResponse: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_AttestationResponse_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_AttestationResponse_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_AttestationResponse_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty InitiateAttestation: In EventDataPort\nB slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_InitiateAttestation_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_InitiateAttestation_is_empty();\n}\n\n\/\/ receive InitiateAttestation: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_InitiateAttestation_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_seL4Nix_InitiateAttestation_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_InitiateAttestation_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\\n\");\n\n  \/\/ initialise data structure for outgoing event data port AttestationRequest\n  sb_queue_union_art_DataContent_1_init(sb_AttestationRequest_queue_1);\n\n  \/\/ initialise data structure for incoming event data port AttestationResponse\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_AttestationResponse_recv_queue, sb_AttestationResponse_queue);\n\n  \/\/ initialise data structure for outgoing event data port TrustedIds\n  sb_queue_union_art_DataContent_1_init(sb_TrustedIds_queue_1);\n\n  \/\/ initialise data structure for incoming event data port InitiateAttestation\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_InitiateAttestation_recv_queue, sb_InitiateAttestation_queue);\n\n  \/\/ initialise data structure for outgoing event data port TerminateAttestation\n  sb_queue_union_art_DataContent_1_init(sb_TerminateAttestation_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationManager_Impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationManager_Impl_SW_Attestation_Manager_CASE_AttestationManager\/includes\/sb_CASE_AttestationManager_Impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CASE_ATTESTATIONMANAGER_IMPL_H\n#define SB_CASE_ATTESTATIONMANAGER_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_AttestationRequest_enqueue(const union_art_DataContent *);\n\nbool sb_AttestationResponse_dequeue(union_art_DataContent *);\n\nbool sb_TrustedIds_enqueue(const union_art_DataContent *);\n\nbool sb_InitiateAttestation_dequeue(union_art_DataContent *);\n\nbool sb_TerminateAttestation_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_ATTESTATIONMANAGER_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl_ffi.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.h>\n\nslang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints entryPoints;\nIS_82ABD8 event_in_port_ids;\nIS_82ABD8 data_in_port_ids;\nIS_82ABD8 event_out_port_ids;\nIS_82ABD8 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF str);\n} \n\nvoid ffiapi_get_SHM_QUEUE_Request_In(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_get_SHM_QUEUE_Request_In\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_SHM_QUEUE_Request_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_SHM_QUEUE_Request_Out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_send_SHM_QUEUE_Request_Out\", 0);\n\n  init(SF_LAST);\n  api_put_SHM_QUEUE_Request_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_get_Connection_Command_In(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_get_Connection_Command_In\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_Connection_Command_In__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_Connection_Command_Out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_send_Connection_Command_Out\", 0);\n\n  init(SF_LAST);\n  api_put_Connection_Command_Out__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_get_TrustedIds(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl_ffi.c\", \"\", \"ffiapi_get_TrustedIds\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_TrustedIds__slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tock_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tick_emit();\n  output[0] = 1;\n}\n\n\/**\n * Required by the FFI framework\n *\/\n\nvoid ffiwrite (unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n}\n\nvoid cml_exit(int arg) {\n  #ifdef DEBUG_FFI\n  {\n    fprintf(stderr,\"GCNum: %d, GCTime(us): %ld\\n\",numGC,microsecs);\n  }\n  #endif\n  exit(arg);\n}\n\n\/\/ convert big-endian 32-bit float to little-endian 64 bit double\nvoid ffifloat2double(unsigned char *parameter, long parameterSizeBytes,\n                     unsigned char *output,    long outputSizeBytes) {\n  char bytes [4];\n  assert (4 == parameterSizeBytes);\n  bytes[3] = parameter[0];\n  bytes[2] = parameter[1];\n  bytes[1] = parameter[2];\n  bytes[0] = parameter[3];\n\n  double result = *((float*)bytes);\n  memcpy(output, (unsigned char*) &result, sizeof(double));\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl.S",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/src\/sb_CASE_AttestationGate_Impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_CASE_AttestationGate_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_SHM_QUEUE_Request_In_recv_queue;\n\n\/************************************************************************\n * sb_SHM_QUEUE_Request_In_dequeue_poll:\n ************************************************************************\/\nbool sb_SHM_QUEUE_Request_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_SHM_QUEUE_Request_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_SHM_QUEUE_Request_In_dequeue:\n ************************************************************************\/\nbool sb_SHM_QUEUE_Request_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_SHM_QUEUE_Request_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_SHM_QUEUE_Request_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_SHM_QUEUE_Request_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_SHM_QUEUE_Request_In_recv_queue);\n}\n\nbool sb_SHM_QUEUE_Request_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_SHM_QUEUE_Request_Out_queue_1, (union_art_DataContent*) data);\n  sb_SHM_QUEUE_Request_Out_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Connection_Command_In_recv_queue;\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue_poll:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Connection_Command_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Connection_Command_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Connection_Command_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Connection_Command_In_recv_queue);\n}\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Connection_Command_Out_queue_1, (union_art_DataContent*) data);\n  sb_Connection_Command_Out_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_TrustedIds_recv_queue;\n\n\/************************************************************************\n * sb_TrustedIds_dequeue_poll:\n ************************************************************************\/\nbool sb_TrustedIds_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_TrustedIds_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_TrustedIds_dequeue:\n ************************************************************************\/\nbool sb_TrustedIds_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_TrustedIds_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_TrustedIds_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_TrustedIds_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_TrustedIds_recv_queue);\n}\n\n\/\/ send SHM_QUEUE_Request_Out: Out EventDataPort CASE_Proxies__shm_queue_request_array_impl\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_SHM_QUEUE_Request_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_SHM_QUEUE_Request_Out_Send\", 0);\n\n  sb_SHM_QUEUE_Request_Out_enqueue(d);\n}\n\n\/\/ send Connection_Command_Out: Out EventDataPort CASE_Proxies__connection_command_impl\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Connection_Command_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Connection_Command_Out_Send\", 0);\n\n  sb_Connection_Command_Out_enqueue(d);\n}\n\n\/\/ is_empty SHM_QUEUE_Request_In: In EventDataPort\nB slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_SHM_QUEUE_Request_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_SHM_QUEUE_Request_In_is_empty();\n}\n\n\/\/ receive SHM_QUEUE_Request_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_SHM_QUEUE_Request_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_SHM_QUEUE_Request_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_SHM_QUEUE_Request_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Connection_Command_In: In EventDataPort\nB slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Connection_Command_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Connection_Command_In_is_empty();\n}\n\n\/\/ receive Connection_Command_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Connection_Command_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_Connection_Command_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Connection_Command_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty TrustedIds: In EventDataPort\nB slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_TrustedIds_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_TrustedIds_is_empty();\n}\n\n\/\/ receive TrustedIds: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_TrustedIds_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_seL4Nix_TrustedIds_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_TrustedIds_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\\n\");\n\n  \/\/ initialise data structure for incoming event data port SHM_QUEUE_Request_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_SHM_QUEUE_Request_In_recv_queue, sb_SHM_QUEUE_Request_In_queue);\n\n  \/\/ initialise data structure for outgoing event data port SHM_QUEUE_Request_Out\n  sb_queue_union_art_DataContent_1_init(sb_SHM_QUEUE_Request_Out_queue_1);\n\n  \/\/ initialise data structure for incoming event data port Connection_Command_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Connection_Command_In_recv_queue, sb_Connection_Command_In_queue);\n\n  \/\/ initialise data structure for outgoing event data port Connection_Command_Out\n  sb_queue_union_art_DataContent_1_init(sb_Connection_Command_Out_queue_1);\n\n  \/\/ initialise data structure for incoming event data port TrustedIds\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_TrustedIds_recv_queue, sb_TrustedIds_queue);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_AttestationGate_Impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_AttestationGate_Impl_SW_Attestation_Gate_CASE_AttestationGate\/includes\/sb_CASE_AttestationGate_Impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CASE_ATTESTATIONGATE_IMPL_H\n#define SB_CASE_ATTESTATIONGATE_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_SHM_QUEUE_Request_In_dequeue(union_art_DataContent *);\n\nbool sb_SHM_QUEUE_Request_Out_enqueue(const union_art_DataContent *);\n\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *);\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *);\n\nbool sb_TrustedIds_dequeue(union_art_DataContent *);\n\n#endif \/\/ SB_CASE_ATTESTATIONGATE_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl_ffi.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_api.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.h>\n\nslang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints entryPoints;\nIS_82ABD8 event_in_port_ids;\nIS_82ABD8 data_in_port_ids;\nIS_82ABD8 event_out_port_ids;\nIS_82ABD8 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF str);\n} \n\nvoid ffiapi_get_Observed(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_get_Observed\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_Observed__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_Suspect_Traffic_Out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl_ffi.c\", \"\", \"ffiapi_send_Suspect_Traffic_Out\", 0);\n\n  init(SF_LAST);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tock_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tick_emit();\n  output[0] = 1;\n}\n\n\/**\n * Required by the FFI framework\n *\/\n\nvoid ffiwrite (unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n}\n\nvoid cml_exit(int arg) {\n  #ifdef DEBUG_FFI\n  {\n    fprintf(stderr,\"GCNum: %d, GCTime(us): %ld\\n\",numGC,microsecs);\n  }\n  #endif\n  exit(arg);\n}\n\n\/\/ convert big-endian 32-bit float to little-endian 64 bit double\nvoid ffifloat2double(unsigned char *parameter, long parameterSizeBytes,\n                     unsigned char *output,    long outputSizeBytes) {\n  char bytes [4];\n  assert (4 == parameterSizeBytes);\n  bytes[3] = parameter[0];\n  bytes[2] = parameter[1];\n  bytes[1] = parameter[2];\n  bytes[0] = parameter[3];\n\n  double result = *((float*)bytes);\n  memcpy(output, (unsigned char*) &result, sizeof(double));\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl.S",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/src\/sb_CASE_Monitor1_Impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_CASE_Monitor1_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Observed_recv_queue;\n\n\/************************************************************************\n * sb_Observed_dequeue_poll:\n ************************************************************************\/\nbool sb_Observed_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Observed_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_dequeue:\n ************************************************************************\/\nbool sb_Observed_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Observed_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Observed_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Observed_recv_queue);\n}\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Suspect_Traffic_Out_queue_1, (union_art_DataContent*) data);\n  sb_Suspect_Traffic_Out_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send Suspect_Traffic_Out: Out EventDataPort ADSB_Types__MonitorReport_impl\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Suspect_Traffic_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor1_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Suspect_Traffic_Out_Send\", 0);\n\n  sb_Suspect_Traffic_Out_enqueue(d);\n}\n\n\/\/ is_empty Observed: In EventDataPort\nB slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Observed_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Observed_is_empty();\n}\n\n\/\/ receive Observed: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Observed_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor1_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_seL4Nix_Observed_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Observed_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\\n\");\n\n  \/\/ initialise data structure for incoming event data port Observed\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Observed_recv_queue, sb_Observed_queue);\n\n  \/\/ initialise data structure for outgoing event data port Suspect_Traffic_Out\n  sb_queue_union_art_DataContent_1_init(sb_Suspect_Traffic_Out_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor1_Impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor1_Impl_SW_Expected_Position_Monitor_CASE_Monitor1\/includes\/sb_CASE_Monitor1_Impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CASE_MONITOR1_IMPL_H\n#define SB_CASE_MONITOR1_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_Observed_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_MONITOR1_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl_ffi.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_api.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.h>\n\nslang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints entryPoints;\nIS_82ABD8 event_in_port_ids;\nIS_82ABD8 data_in_port_ids;\nIS_82ABD8 event_out_port_ids;\nIS_82ABD8 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF str);\n} \n\nvoid ffiapi_get_Observed(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_get_Observed\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_Observed__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_Suspect_Traffic_Out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl_ffi.c\", \"\", \"ffiapi_send_Suspect_Traffic_Out\", 0);\n\n  init(SF_LAST);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tock_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tick_emit();\n  output[0] = 1;\n}\n\n\/**\n * Required by the FFI framework\n *\/\n\nvoid ffiwrite (unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n}\n\nvoid cml_exit(int arg) {\n  #ifdef DEBUG_FFI\n  {\n    fprintf(stderr,\"GCNum: %d, GCTime(us): %ld\\n\",numGC,microsecs);\n  }\n  #endif\n  exit(arg);\n}\n\n\/\/ convert big-endian 32-bit float to little-endian 64 bit double\nvoid ffifloat2double(unsigned char *parameter, long parameterSizeBytes,\n                     unsigned char *output,    long outputSizeBytes) {\n  char bytes [4];\n  assert (4 == parameterSizeBytes);\n  bytes[3] = parameter[0];\n  bytes[2] = parameter[1];\n  bytes[1] = parameter[2];\n  bytes[0] = parameter[3];\n\n  double result = *((float*)bytes);\n  memcpy(output, (unsigned char*) &result, sizeof(double));\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl.S",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/src\/sb_CASE_Monitor2_Impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_CASE_Monitor2_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Observed_recv_queue;\n\n\/************************************************************************\n * sb_Observed_dequeue_poll:\n ************************************************************************\/\nbool sb_Observed_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Observed_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_dequeue:\n ************************************************************************\/\nbool sb_Observed_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Observed_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Observed_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Observed_recv_queue);\n}\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Suspect_Traffic_Out_queue_1, (union_art_DataContent*) data);\n  sb_Suspect_Traffic_Out_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send Suspect_Traffic_Out: Out EventDataPort ADSB_Types__MonitorReport_impl\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Suspect_Traffic_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor2_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Suspect_Traffic_Out_Send\", 0);\n\n  sb_Suspect_Traffic_Out_enqueue(d);\n}\n\n\/\/ is_empty Observed: In EventDataPort\nB slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Observed_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Observed_is_empty();\n}\n\n\/\/ receive Observed: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Observed_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor2_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_seL4Nix_Observed_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Observed_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\\n\");\n\n  \/\/ initialise data structure for incoming event data port Observed\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Observed_recv_queue, sb_Observed_queue);\n\n  \/\/ initialise data structure for outgoing event data port Suspect_Traffic_Out\n  sb_queue_union_art_DataContent_1_init(sb_Suspect_Traffic_Out_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor2_Impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor2_Impl_SW_Duplicate_Entity_Monitor_CASE_Monitor2\/includes\/sb_CASE_Monitor2_Impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CASE_MONITOR2_IMPL_H\n#define SB_CASE_MONITOR2_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_Observed_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_MONITOR2_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_low_impl_SW_adapter_low_adapter_low\/src\/sb_adapter_low_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_adapter_low_impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <adapter_low_impl_SW_adapter_low_adapter_low_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_ADSB_Messages_In_recv_queue;\n\n\/************************************************************************\n * sb_ADSB_Messages_In_dequeue_poll:\n ************************************************************************\/\nbool sb_ADSB_Messages_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_ADSB_Messages_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_ADSB_Messages_In_dequeue:\n ************************************************************************\/\nbool sb_ADSB_Messages_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_ADSB_Messages_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_ADSB_Messages_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_ADSB_Messages_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_ADSB_Messages_In_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Response_In_recv_queue;\n\n\/************************************************************************\n * sb_Response_In_dequeue_poll:\n ************************************************************************\/\nbool sb_Response_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Response_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Response_In_dequeue:\n ************************************************************************\/\nbool sb_Response_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Response_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Response_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Response_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Response_In_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_AttestationRequest_recv_queue;\n\n\/************************************************************************\n * sb_AttestationRequest_dequeue_poll:\n ************************************************************************\/\nbool sb_AttestationRequest_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_AttestationRequest_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_AttestationRequest_dequeue:\n ************************************************************************\/\nbool sb_AttestationRequest_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_AttestationRequest_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_AttestationRequest_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_AttestationRequest_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_AttestationRequest_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_SHM_HEADER_adsb_to_ptab_recv_queue;\n\n\/************************************************************************\n * sb_SHM_HEADER_adsb_to_ptab_dequeue_poll:\n ************************************************************************\/\nbool sb_SHM_HEADER_adsb_to_ptab_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_SHM_HEADER_adsb_to_ptab_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_SHM_HEADER_adsb_to_ptab_dequeue:\n ************************************************************************\/\nbool sb_SHM_HEADER_adsb_to_ptab_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_SHM_HEADER_adsb_to_ptab_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_SHM_HEADER_adsb_to_ptab_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_SHM_HEADER_adsb_to_ptab_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_SHM_HEADER_adsb_to_ptab_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Connection_Command_In_recv_queue;\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue_poll:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Connection_Command_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Connection_Command_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Connection_Command_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Connection_Command_In_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Suspect_Traffic_In1_recv_queue;\n\n\/************************************************************************\n * sb_Suspect_Traffic_In1_dequeue_poll:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In1_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Suspect_Traffic_In1_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In1_dequeue:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In1_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Suspect_Traffic_In1_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In1_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Suspect_Traffic_In1_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Suspect_Traffic_In1_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Suspect_Traffic_In2_recv_queue;\n\n\/************************************************************************\n * sb_Suspect_Traffic_In2_dequeue_poll:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In2_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Suspect_Traffic_In2_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In2_dequeue:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In2_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Suspect_Traffic_In2_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In2_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Suspect_Traffic_In2_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Suspect_Traffic_In2_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Suspect_Traffic_In3_recv_queue;\n\n\/************************************************************************\n * sb_Suspect_Traffic_In3_dequeue_poll:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In3_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Suspect_Traffic_In3_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In3_dequeue:\n ************************************************************************\/\nbool sb_Suspect_Traffic_In3_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Suspect_Traffic_In3_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Suspect_Traffic_In3_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Suspect_Traffic_In3_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Suspect_Traffic_In3_recv_queue);\n}\n\nbool sb_SHM_QUEUE_Request_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_SHM_QUEUE_Request_Out_queue_1, (union_art_DataContent*) data);\n  sb_SHM_QUEUE_Request_Out_1_notification_emit();\n\n  return true;\n}\n\nbool sb_AttestationResponse_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_AttestationResponse_queue_1, (union_art_DataContent*) data);\n  sb_AttestationResponse_1_notification_emit();\n\n  return true;\n}\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Connection_Command_Out_queue_1, (union_art_DataContent*) data);\n  sb_Connection_Command_Out_1_notification_emit();\n\n  return true;\n}\n\nbool sb_InitiateAttestation_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_InitiateAttestation_queue_1, (union_art_DataContent*) data);\n  sb_InitiateAttestation_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_TerminateAttestation_recv_queue;\n\n\/************************************************************************\n * sb_TerminateAttestation_dequeue_poll:\n ************************************************************************\/\nbool sb_TerminateAttestation_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_TerminateAttestation_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_TerminateAttestation_dequeue:\n ************************************************************************\/\nbool sb_TerminateAttestation_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_TerminateAttestation_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_TerminateAttestation_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_TerminateAttestation_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_TerminateAttestation_recv_queue);\n}\n\n\/\/ send SHM_QUEUE_Request_Out: Out EventDataPort CASE_Proxies__shm_queue_request_array_impl\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Request_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Request_Out_Send\", 0);\n\n  sb_SHM_QUEUE_Request_Out_enqueue(d);\n}\n\n\/\/ send AttestationResponse: Out EventDataPort VPM__CASE_AttestationResponseMsg_impl\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_AttestationResponse_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_AttestationResponse_Send\", 0);\n\n  sb_AttestationResponse_enqueue(d);\n}\n\n\/\/ send Connection_Command_Out: Out EventDataPort CASE_Proxies__connection_command_impl\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Connection_Command_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Connection_Command_Out_Send\", 0);\n\n  sb_Connection_Command_Out_enqueue(d);\n}\n\n\/\/ send InitiateAttestation: Out EventDataPort Common_Types__Unsigned_32\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_InitiateAttestation_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_InitiateAttestation_Send\", 0);\n\n  sb_InitiateAttestation_enqueue(d);\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Heartbeat_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Heartbeat_Out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Ownship_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Ownship_Out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Traffic_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_ADSB_Traffic_Out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Response_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Response_Out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_AttestationRequest_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_AttestationRequest_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out1_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out1_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out2_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out2_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out3_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Suspect_Traffic_Out3_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ is_empty ADSB_Messages_In: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_ADSB_Messages_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_ADSB_Messages_In_is_empty();\n}\n\n\/\/ receive ADSB_Messages_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_ADSB_Messages_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_ADSB_Messages_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_ADSB_Messages_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Response_In: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Response_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Response_In_is_empty();\n}\n\n\/\/ receive Response_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Response_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Response_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Response_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty AttestationRequest: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_AttestationRequest_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_AttestationRequest_is_empty();\n}\n\n\/\/ receive AttestationRequest: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_AttestationRequest_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_AttestationRequest_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_AttestationRequest_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty SHM_HEADER_adsb_to_ptab: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_HEADER_adsb_to_ptab_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_SHM_HEADER_adsb_to_ptab_is_empty();\n}\n\n\/\/ receive SHM_HEADER_adsb_to_ptab: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_HEADER_adsb_to_ptab_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_HEADER_adsb_to_ptab_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_SHM_HEADER_adsb_to_ptab_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Connection_Command_In: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Connection_Command_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Connection_Command_In_is_empty();\n}\n\n\/\/ receive Connection_Command_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Connection_Command_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Connection_Command_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Connection_Command_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Suspect_Traffic_In1: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In1_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Suspect_Traffic_In1_is_empty();\n}\n\n\/\/ receive Suspect_Traffic_In1: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In1_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In1_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Suspect_Traffic_In1_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Suspect_Traffic_In2: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In2_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Suspect_Traffic_In2_is_empty();\n}\n\n\/\/ receive Suspect_Traffic_In2: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In2_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In2_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Suspect_Traffic_In2_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Suspect_Traffic_In3: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In3_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Suspect_Traffic_In3_is_empty();\n}\n\n\/\/ receive Suspect_Traffic_In3: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In3_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_Suspect_Traffic_In3_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Suspect_Traffic_In3_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty TerminateAttestation: In EventDataPort\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_TerminateAttestation_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_TerminateAttestation_is_empty();\n}\n\n\/\/ receive TerminateAttestation: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_TerminateAttestation_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_TerminateAttestation_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_TerminateAttestation_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Request_In_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Request_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_Request_In_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_AttestationResponse_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_AttestationResponse_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_low_impl.c\", \"\", \"slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_seL4Nix_SHM_QUEUE_AttestationResponse_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_adapter_low_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of adapter_low_impl_SW_adapter_low_adapter_low\\n\");\n\n  \/\/ initialise data structure for incoming event data port ADSB_Messages_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_ADSB_Messages_In_recv_queue, sb_ADSB_Messages_In_queue);\n\n  \/\/ initialise data structure for incoming event data port Response_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Response_In_recv_queue, sb_Response_In_queue);\n\n  \/\/ initialise data structure for incoming event data port AttestationRequest\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_AttestationRequest_recv_queue, sb_AttestationRequest_queue);\n\n  \/\/ initialise data structure for incoming event data port SHM_HEADER_adsb_to_ptab\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_SHM_HEADER_adsb_to_ptab_recv_queue, sb_SHM_HEADER_adsb_to_ptab_queue);\n\n  \/\/ initialise data structure for incoming event data port Connection_Command_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Connection_Command_In_recv_queue, sb_Connection_Command_In_queue);\n\n  \/\/ initialise data structure for incoming event data port Suspect_Traffic_In1\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Suspect_Traffic_In1_recv_queue, sb_Suspect_Traffic_In1_queue);\n\n  \/\/ initialise data structure for incoming event data port Suspect_Traffic_In2\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Suspect_Traffic_In2_recv_queue, sb_Suspect_Traffic_In2_queue);\n\n  \/\/ initialise data structure for incoming event data port Suspect_Traffic_In3\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Suspect_Traffic_In3_recv_queue, sb_Suspect_Traffic_In3_queue);\n\n  \/\/ initialise data structure for outgoing event data port SHM_QUEUE_Request_Out\n  sb_queue_union_art_DataContent_1_init(sb_SHM_QUEUE_Request_Out_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port AttestationResponse\n  sb_queue_union_art_DataContent_1_init(sb_AttestationResponse_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port Connection_Command_Out\n  sb_queue_union_art_DataContent_1_init(sb_Connection_Command_Out_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port InitiateAttestation\n  sb_queue_union_art_DataContent_1_init(sb_InitiateAttestation_queue_1);\n\n  \/\/ initialise data structure for incoming event data port TerminateAttestation\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_TerminateAttestation_recv_queue, sb_TerminateAttestation_queue);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of adapter_low_impl_SW_adapter_low_adapter_low\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_adapter_low_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_adapter_low_impl_SW_adapter_low_adapter_low_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_low_impl_SW_adapter_low_adapter_low\/includes\/sb_adapter_low_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_ADAPTER_LOW_IMPL_H\n#define SB_ADAPTER_LOW_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_ADSB_Messages_In_dequeue(union_art_DataContent *);\n\nbool sb_Response_In_dequeue(union_art_DataContent *);\n\nbool sb_AttestationRequest_dequeue(union_art_DataContent *);\n\nbool sb_SHM_HEADER_adsb_to_ptab_dequeue(union_art_DataContent *);\n\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_In1_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_In2_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_In3_dequeue(union_art_DataContent *);\n\nbool sb_SHM_QUEUE_Request_Out_enqueue(const union_art_DataContent *);\n\nbool sb_AttestationResponse_enqueue(const union_art_DataContent *);\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *);\n\nbool sb_InitiateAttestation_enqueue(const union_art_DataContent *);\n\nbool sb_TerminateAttestation_dequeue(union_art_DataContent *);\n\n#endif \/\/ SB_ADAPTER_LOW_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_high_impl_SW_adapter_high_adapter_high\/src\/sb_adapter_high_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_adapter_high_impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <adapter_high_impl_SW_adapter_high_adapter_high_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nbool sb_Response_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Response_Out_queue_1, (union_art_DataContent*) data);\n  sb_Response_Out_1_notification_emit();\n\n  return true;\n}\n\nbool sb_ADSB_Messages_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_ADSB_Messages_Out_queue_1, (union_art_DataContent*) data);\n  sb_ADSB_Messages_Out_1_notification_emit();\n\n  return true;\n}\n\nbool sb_SHM_HEADER_adsb_to_ptab_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_SHM_HEADER_adsb_to_ptab_queue_1, (union_art_DataContent*) data);\n  sb_SHM_HEADER_adsb_to_ptab_1_notification_emit();\n\n  return true;\n}\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Connection_Command_Out_queue_1, (union_art_DataContent*) data);\n  sb_Connection_Command_Out_1_notification_emit();\n\n  return true;\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Request_In_recv_queue;\n\n\/************************************************************************\n * sb_Request_In_dequeue_poll:\n ************************************************************************\/\nbool sb_Request_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Request_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Request_In_dequeue:\n ************************************************************************\/\nbool sb_Request_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Request_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Request_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Request_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Request_In_recv_queue);\n}\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Connection_Command_In_recv_queue;\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue_poll:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Connection_Command_In_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_dequeue:\n ************************************************************************\/\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Connection_Command_In_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Connection_Command_In_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Connection_Command_In_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Connection_Command_In_recv_queue);\n}\n\n\/\/ send Response_Out: Out EventDataPort DTU_Types__Response_Message_impl\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Response_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Response_Out_Send\", 0);\n\n  sb_Response_Out_enqueue(d);\n}\n\n\/\/ send ADSB_Messages_Out: Out EventDataPort ADSB_Types__ADSB_Aggregated_Message_impl\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_ADSB_Messages_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_ADSB_Messages_Out_Send\", 0);\n\n  sb_ADSB_Messages_Out_enqueue(d);\n}\n\n\/\/ send SHM_HEADER_adsb_to_ptab: Out EventDataPort CASE_Proxies__shm_queue_header_impl\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_HEADER_adsb_to_ptab_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_HEADER_adsb_to_ptab_Send\", 0);\n\n  sb_SHM_HEADER_adsb_to_ptab_enqueue(d);\n}\n\n\/\/ send Connection_Command_Out: Out EventDataPort CASE_Proxies__connection_command_impl\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Connection_Command_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Connection_Command_Out_Send\", 0);\n\n  sb_Connection_Command_Out_enqueue(d);\n}\n\n\/\/ FIXME: dummy implementation for unconnected outgoing port\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_Request_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_Request_Out_Send\", 0);\n  \/\/ FIXME: dummy implementation\n}\n\n\/\/ is_empty Request_In: In EventDataPort\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Request_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Request_In_is_empty();\n}\n\n\/\/ receive Request_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Request_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Request_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Request_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty Connection_Command_In: In EventDataPort\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Connection_Command_In_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Connection_Command_In_is_empty();\n}\n\n\/\/ receive Connection_Command_In: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Connection_Command_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_Connection_Command_In_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Connection_Command_In_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Heartbeat_In_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Heartbeat_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Heartbeat_In_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Ownship_In_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Ownship_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Ownship_In_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Traffic_In_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Traffic_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_ADSB_Traffic_In_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nB slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_Response_In_IsEmpty(STACK_FRAME_ONLY) {\n  return T;\n}\n\n\/\/ FIXME: dummy implementation for unconnected incoming port\nUnit slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_Response_In_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_adapter_high_impl.c\", \"\", \"slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_seL4Nix_SHM_QUEUE_Response_In_Receive\", 0);\n\n  \/\/ FIXME: dummy implementation\n\n  \/\/ put None in result\n  DeclNewNone_964667(none);\n  Type_assign(result, &none, sizeof(union Option_8E9F45));\n}\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_adapter_high_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of adapter_high_impl_SW_adapter_high_adapter_high\\n\");\n\n  \/\/ initialise data structure for outgoing event data port Response_Out\n  sb_queue_union_art_DataContent_1_init(sb_Response_Out_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port ADSB_Messages_Out\n  sb_queue_union_art_DataContent_1_init(sb_ADSB_Messages_Out_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port SHM_HEADER_adsb_to_ptab\n  sb_queue_union_art_DataContent_1_init(sb_SHM_HEADER_adsb_to_ptab_queue_1);\n\n  \/\/ initialise data structure for outgoing event data port Connection_Command_Out\n  sb_queue_union_art_DataContent_1_init(sb_Connection_Command_Out_queue_1);\n\n  \/\/ initialise data structure for incoming event data port Request_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Request_In_recv_queue, sb_Request_In_queue);\n\n  \/\/ initialise data structure for incoming event data port Connection_Command_In\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Connection_Command_In_recv_queue, sb_Connection_Command_In_queue);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of adapter_high_impl_SW_adapter_high_adapter_high\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_adapter_high_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_adapter_high_impl_SW_adapter_high_adapter_high_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/adapter_high_impl_SW_adapter_high_adapter_high\/includes\/sb_adapter_high_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_ADAPTER_HIGH_IMPL_H\n#define SB_ADAPTER_HIGH_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_Response_Out_enqueue(const union_art_DataContent *);\n\nbool sb_ADSB_Messages_Out_enqueue(const union_art_DataContent *);\n\nbool sb_SHM_HEADER_adsb_to_ptab_enqueue(const union_art_DataContent *);\n\nbool sb_Connection_Command_Out_enqueue(const union_art_DataContent *);\n\nbool sb_Request_In_dequeue(union_art_DataContent *);\n\nbool sb_Connection_Command_In_dequeue(union_art_DataContent *);\n\n#endif \/\/ SB_ADAPTER_HIGH_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl_ffi.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_api.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.h>\n\nslang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints entryPoints;\nIS_82ABD8 event_in_port_ids;\nIS_82ABD8 data_in_port_ids;\nIS_82ABD8 event_out_port_ids;\nIS_82ABD8 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_82ABD8) slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF str);\n} \n\nvoid ffiapi_get_Observed(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_get_Observed\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_Observed__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes - 1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_Suspect_Traffic_Out(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl_ffi.c\", \"\", \"ffiapi_send_Suspect_Traffic_Out\", 0);\n\n  init(SF_LAST);\n  api_put_Suspect_Traffic_Out__slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tock_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tick_emit();\n  output[0] = 1;\n}\n\n\/**\n * Required by the FFI framework\n *\/\n\nvoid ffiwrite (unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n}\n\nvoid cml_exit(int arg) {\n  #ifdef DEBUG_FFI\n  {\n    fprintf(stderr,\"GCNum: %d, GCTime(us): %ld\\n\",numGC,microsecs);\n  }\n  #endif\n  exit(arg);\n}\n\n\/\/ convert big-endian 32-bit float to little-endian 64 bit double\nvoid ffifloat2double(unsigned char *parameter, long parameterSizeBytes,\n                     unsigned char *output,    long outputSizeBytes) {\n  char bytes [4];\n  assert (4 == parameterSizeBytes);\n  bytes[3] = parameter[0];\n  bytes[2] = parameter[1];\n  bytes[1] = parameter[2];\n  bytes[0] = parameter[3];\n\n  double result = *((float*)bytes);\n  memcpy(output, (unsigned char*) &result, sizeof(double));\n}\n\nvoid ffiraw_print_buffer(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n\n  int elideAfter = 20; \/\/ stop printing after this many consecutive 0's seen\n  int stopAfter = 50; \/\/ exit after this many consecutive 0's seen, lessens 'busy-wait'\n\n  U8* buffer = (U8 *) parameter;\n\n  printf(\"%i bytes\\n\", parameterSizeBytes); \/\/ doesn't include the bool byte\n\n  if(parameterSizeBytes > 0) {\n    int numZerosSeen = 0;\n    printf(\"[%02x\\n\", buffer[0]); \/\/ first byte is a bool\n    for(int i = 1; i < parameterSizeBytes + 1; i++) {\n      numZerosSeen = buffer[i] == 0 ? (numZerosSeen + 1) : 0;\n      if(numZerosSeen >= elideAfter) {\n        if(numZerosSeen % stopAfter == 0) { printf(\"...\"); break; }\n      } else {\n      \tprintf(\"%02x \", buffer[i]);\n      \tif(i % 16 == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"]\\n\");\n  }\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl.S",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/src\/sb_CASE_Monitor3_Impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_CASE_Monitor3_Impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_Observed_recv_queue;\n\n\/************************************************************************\n * sb_Observed_dequeue_poll:\n ************************************************************************\/\nbool sb_Observed_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_Observed_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_dequeue:\n ************************************************************************\/\nbool sb_Observed_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_Observed_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_Observed_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_Observed_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_Observed_recv_queue);\n}\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *data) {\n  sb_queue_union_art_DataContent_1_enqueue(sb_Suspect_Traffic_Out_queue_1, (union_art_DataContent*) data);\n  sb_Suspect_Traffic_Out_1_notification_emit();\n\n  return true;\n}\n\n\/\/ send Suspect_Traffic_Out: Out EventDataPort ADSB_Types__MonitorReport_impl\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Suspect_Traffic_Out_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor3_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Suspect_Traffic_Out_Send\", 0);\n\n  sb_Suspect_Traffic_Out_enqueue(d);\n}\n\n\/\/ is_empty Observed: In EventDataPort\nB slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Observed_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_Observed_is_empty();\n}\n\n\/\/ receive Observed: In EventDataPort union_art_DataContent\nUnit slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Observed_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_CASE_Monitor3_Impl.c\", \"\", \"slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_seL4Nix_Observed_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_Observed_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\\n\");\n\n  \/\/ initialise data structure for incoming event data port Observed\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_Observed_recv_queue, sb_Observed_queue);\n\n  \/\/ initialise data structure for outgoing event data port Suspect_Traffic_Out\n  sb_queue_union_art_DataContent_1_init(sb_Suspect_Traffic_Out_queue_1);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_CASE_Monitor3_Impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_VPM_CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/components\/CASE_Monitor3_Impl_SW_Teleport_Monitor_CASE_Monitor3\/includes\/sb_CASE_Monitor3_Impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CASE_MONITOR3_IMPL_H\n#define SB_CASE_MONITOR3_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_Observed_dequeue(union_art_DataContent *);\n\nbool sb_Suspect_Traffic_Out_enqueue(const union_art_DataContent *);\n\n#endif \/\/ SB_CASE_MONITOR3_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/types\/includes\/sb_queue_union_art_DataContent_1.h",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE-1 elements.\n#define SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_union_art_DataContent_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type union_art_DataContent \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  union_art_DataContent elt[SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE];\n\n} sb_queue_union_art_DataContent_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue, \n  union_art_DataContent *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_union_art_DataContent_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_union_art_DataContent_1_t *queue;\n\n} sb_queue_union_art_DataContent_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_union_art_DataContent_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_union_art_DataContent_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  union_art_DataContent *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/types\/src\/sb_queue_union_art_DataContent_1.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_union_art_DataContent_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue, \n  union_art_DataContent *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_queue_union_art_DataContent_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  union_art_DataContent *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_union_art_DataContent_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/types\/includes\/sb_event_counter.h",
        {
          "type" : "TestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/kernel\/domain_schedule.c",
        {
          "type" : "TestResource",
          "content" : "#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ this file will not be overwritten and is safe to edit\n\n\/************************************************************\n\n   This is a kernel data structure containing an example schedule.\n   The length is in seL4 ticks (2 ms).\n   This schedule should be generated from the AADL model\n   using execution time and data flow latency specifications.\n\n   Pacer runs at highest rate and should always be in domain 1\n\n   Properties from AADL Model\n   --------------------------\n\n     Timing_Properties::Clock_Period : 2 ms\n     Timing_Properties::Frame_Period : 500 ms\n\n     CASE_AttestationManager\n     -----------------------\n\n       CASE_Scheduling::Domain : 7\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_AttestationGate\n     --------------------\n\n       CASE_Scheduling::Domain : 8\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_Monitor1\n     -------------\n\n       CASE_Scheduling::Domain : 4\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n     CASE_Monitor2\n     -------------\n\n       CASE_Scheduling::Domain : 5\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n     adapter_low\n     -----------\n\n       CASE_Scheduling::Domain : 3\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n     adapter_high\n     ------------\n\n       CASE_Scheduling::Domain : 2\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 250 ms\n\n     CASE_Monitor3\n     -------------\n\n       CASE_Scheduling::Domain : 6\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 50 ms\n       Timing_Properties::Period : 500 ms\n\n *********************************************************\/\n\nconst dschedule_t ksDomSchedule[] = {\n  { .domain = 0, .length = 100 },  \/\/ all other seL4 threads, init, 200ms\n  { .domain = 7, .length = 25 },  \/\/ CASE_AttestationManager  50ms\n  { .domain = 8, .length = 25 },  \/\/ CASE_AttestationGate  50ms\n  { .domain = 4, .length = 25 },  \/\/ CASE_Monitor1  50ms\n  { .domain = 5, .length = 25 },  \/\/ CASE_Monitor2  50ms\n  { .domain = 3, .length = 25 },  \/\/ adapter_low  50ms\n  { .domain = 2, .length = 25 },  \/\/ adapter_high  50ms\n  { .domain = 6, .length = 25 },  \/\/ CASE_Monitor3  50ms\n  { .domain = 0, .length = -30 },  \/\/ pad rest of frame period\n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/settings.cmake",
        {
          "type" : "TestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 9 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "VPM_ben--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_union_art_DataContent_1.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ]
    ]
  }
}