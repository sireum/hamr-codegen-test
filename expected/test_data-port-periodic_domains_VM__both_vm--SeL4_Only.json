{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM_emitter_t_impl_src_process_src_thread\/VM_emitter_t_impl_src_process_src_thread.camkes",
        {
          "type" : "TestResource",
          "content" : "component VM_emitter_t_impl_src_process_src_thread {\n  include <sb_types.h>;\n  include <sp_int8_t.h>;\n  include <sb_queue_int8_t_1.h>;\n  control;\n  provides VMDTBPassthrough dtb;\n  uses FileServerInterface fs;\n  maybe uses Batch batch;\n  maybe uses PutChar guest_putchar;\n  maybe uses GetChar serial_getchar;\n  maybe uses VirtQueueDev recv;\n  maybe uses VirtQueueDrv send;\n  maybe uses VMDTBPassthrough dtb_self;\n  emits HaveNotification notification_ready_connector;\n  maybe consumes restart restart_event;\n  consumes HaveNotification notification_ready;\n  consumes Period_VM sb_pacer_period_notification;\n  dataport sp_int8_t_t sb_write_port;\n  dataport sb_queue_int8_t_1_t sb_pacer_period_queue;\n  has semaphore vm_sem;\n  \/\/ expanding: VM_INIT_DEF()\n  attribute int base_prio;\n  attribute int num_vcpus = 1;\n  attribute int num_extra_frame_caps;\n  attribute int extra_frame_map_address;\n  attribute {\n    string linux_ram_base;\n    string linux_ram_paddr_base;\n    string linux_ram_size;\n    string linux_ram_offset;\n    string dtb_addr;\n    string initrd_max_size;\n    string initrd_addr;\n  } linux_address_config;\n  attribute {\n    string linux_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string linux_bootcmdline = \"\";\n    string linux_stdout = \"\";\n  } linux_image_config;\n  \/\/ end of expansion: VM_INIT_DEF()\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM_consumer_t_impl_dst_process_dst_thread\/VM_consumer_t_impl_dst_process_dst_thread.camkes",
        {
          "type" : "TestResource",
          "content" : "component VM_consumer_t_impl_dst_process_dst_thread {\n  include <sb_types.h>;\n  include <sp_int8_t.h>;\n  include <sb_queue_int8_t_1.h>;\n  control;\n  provides VMDTBPassthrough dtb;\n  uses FileServerInterface fs;\n  maybe uses Batch batch;\n  maybe uses PutChar guest_putchar;\n  maybe uses GetChar serial_getchar;\n  maybe uses VirtQueueDev recv;\n  maybe uses VirtQueueDrv send;\n  maybe uses VMDTBPassthrough dtb_self;\n  emits HaveNotification notification_ready_connector;\n  maybe consumes restart restart_event;\n  consumes HaveNotification notification_ready;\n  consumes Period_VM sb_pacer_period_notification;\n  dataport sp_int8_t_t sb_read_port;\n  dataport sb_queue_int8_t_1_t sb_pacer_period_queue;\n  has semaphore vm_sem;\n  \/\/ expanding: VM_INIT_DEF()\n  attribute int base_prio;\n  attribute int num_vcpus = 1;\n  attribute int num_extra_frame_caps;\n  attribute int extra_frame_map_address;\n  attribute {\n    string linux_ram_base;\n    string linux_ram_paddr_base;\n    string linux_ram_size;\n    string linux_ram_offset;\n    string dtb_addr;\n    string initrd_max_size;\n    string initrd_addr;\n  } linux_address_config;\n  attribute {\n    string linux_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string linux_bootcmdline = \"\";\n    string linux_stdout = \"\";\n  } linux_image_config;\n  \/\/ end of expansion: VM_INIT_DEF()\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/Pacer\/Pacer.camkes",
        {
          "type" : "TestResource",
          "content" : "component Pacer {\n  include <sb_queue_int8_t_1.h>;\n  control;\n  emits Period_VM period_to_vmsrc_process_notification;\n  emits Period_VM period_to_vmdst_process_notification;\n  emits TickTock tick;\n  consumes TickTock tock;\n  dataport sb_queue_int8_t_1_t period_to_vmsrc_process_queue;\n  dataport sb_queue_int8_t_1_t period_to_vmdst_process_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/top_impl_Instance.camkes",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <seL4VMDTBPassthrough.idl4>;\nimport <FileServerInterface.camkes>;\nimport <FileServer\/FileServer.camkes>;\nimport <SerialServer\/SerialServer.camkes>;\nimport <TimeServer\/TimeServer.camkes>;\nimport <vm-connectors.camkes>;\nimport <devices.camkes>;\nimport \"components\/Pacer\/Pacer.camkes\";\nimport \"components\/VM_emitter_t_impl_src_process_src_thread\/VM_emitter_t_impl_src_process_src_thread.camkes\";\nimport \"components\/VM_consumer_t_impl_dst_process_dst_thread\/VM_consumer_t_impl_dst_process_dst_thread.camkes\";\n\nassembly {\n  composition {\n    component VM_emitter_t_impl_src_process_src_thread vmsrc_process;\n    component FileServer fserv;\n    component SerialServer serial;\n    component TimeServer time_server;\n    component VM_consumer_t_impl_dst_process_dst_thread vmdst_process;\n    component Pacer pacer;\n\n    connection seL4VMDTBPassthrough conn1(from vmsrc_process.dtb_self, to vmsrc_process.dtb);\n    connection seL4RPCDataport fsvmsrc_process(from vmsrc_process.fs, to fserv.fs_ctrl);\n    connection seL4GlobalAsynch notify_ready_vmsrc_process(from vmsrc_process.notification_ready_connector, to vmsrc_process.notification_ready);\n    connection seL4TimeServer serialserver_timer(from serial.timeout, to time_server.the_timer);\n    connection seL4SerialServer serial_vmsrc_process(from vmsrc_process.batch, to serial.processed_batch);\n    connection seL4SerialServer serial_input_vmsrc_process(from vmsrc_process.serial_getchar, to serial.getchar);\n    connection seL4VMDTBPassthrough conn2(from vmdst_process.dtb_self, to vmdst_process.dtb);\n    connection seL4RPCDataport fsvmdst_process(from vmdst_process.fs, to fserv.fs_ctrl);\n    connection seL4GlobalAsynch notify_ready_vmdst_process(from vmdst_process.notification_ready_connector, to vmdst_process.notification_ready);\n    connection seL4SerialServer serial_vmdst_process(from vmdst_process.batch, to serial.processed_batch);\n    connection seL4SerialServer serial_input_vmdst_process(from vmdst_process.serial_getchar, to serial.getchar);\n    connection seL4SharedDataWithCaps conn3(from vmsrc_process.sb_write_port, to vmdst_process.sb_read_port);\n    connection seL4Notification conn4(from pacer.tick, to pacer.tock);\n    connection seL4GlobalAsynch conn5(from pacer.period_to_vmsrc_process_notification, to vmsrc_process.sb_pacer_period_notification);\n    connection seL4SharedDataWithCaps conn6(from pacer.period_to_vmsrc_process_queue, to vmsrc_process.sb_pacer_period_queue);\n    connection seL4GlobalAsynch conn7(from pacer.period_to_vmdst_process_notification, to vmdst_process.sb_pacer_period_notification);\n    connection seL4SharedDataWithCaps conn8(from pacer.period_to_vmdst_process_queue, to vmdst_process.sb_pacer_period_queue);\n  }\n\n  configuration {\n    vmsrc_process.cnode_size_bits = 18;\n    vmsrc_process.simple_untyped21_pool = 12;\n    vmsrc_process.simple_untyped12_pool = 12;\n    vmsrc_process.num_extra_frame_caps = 0;\n    vmsrc_process.extra_frame_map_address = 0;\n    vmsrc_process._domain = 2;\n    vmdst_process.cnode_size_bits = 18;\n    vmdst_process.simple_untyped21_pool = 12;\n    vmdst_process.simple_untyped12_pool = 12;\n    vmdst_process.num_extra_frame_caps = 0;\n    vmdst_process.extra_frame_map_address = 0;\n    vmdst_process._domain = 3;\n    pacer._domain = 1;\n\n    fserv.heap_size = 165536;\n    vmsrc_process.fs_shmem_size = 0x100000;\n    vmsrc_process.global_endpoint_base = 1 << 27;\n    vmsrc_process.asid_pool = true;\n    vmsrc_process.simple = true;\n    vmsrc_process.base_prio = 100;\n    vmsrc_process._priority = 101;\n    vmsrc_process.sem_value = 0;\n    vmsrc_process.heap_size = 0x300000;\n    time_server.timers_per_client = 1;\n    time_server.priority = 255;\n    time_server.simple = true;\n    vmsrc_process.serial_getchar_shmem_size = 0x1000;\n    vmsrc_process.batch_shmem_size = 0x1000;\n    vmdst_process.fs_shmem_size = 0x100000;\n    vmdst_process.global_endpoint_base = 1 << 27;\n    vmdst_process.asid_pool = true;\n    vmdst_process.simple = true;\n    vmdst_process.base_prio = 100;\n    vmdst_process._priority = 101;\n    vmdst_process.sem_value = 0;\n    vmdst_process.heap_size = 0x300000;\n    vmdst_process.serial_getchar_shmem_size = 0x1000;\n    vmdst_process.batch_shmem_size = 0x1000;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/includes\/seqNum.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef _SEQNUM_H_\n#define _SEQNUM_H_\n\n\/\/ Typedef for seqNum to make it easy to change the type. Keep these consistent!\ntypedef uintmax_t seqNum_t;\n#define SEQNUM_MAX UINTMAX_MAX\n#define PRIseqNum PRIuMAX\n\n\/\/ DIRTY_SEQ_NUM is used to mark a sampling port message as dirty while it is\n\/\/ being writen. DIRTY_SEQ_NUM is not a valid sequence number. Valid sequence\n\/\/ numbers are from 0 to DIRTY_SEQ_NUM-1 is never a valid sequence number.\nstatic const seqNum_t DIRTY_SEQ_NUM = SEQNUM_MAX;\n\n#endif",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/includes\/sp_int8_t.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SP_INT8_T_H\n#define SP_INT8_T_H\n\n#include <sb_types.h>\n#include <seqNum.h>\n\n\/\/ Sampling port message with bool data\ntypedef struct sp_int8_t {\n\n  \/\/ The sampling port message data.\n  \/\/\n  int8_t data;\n\n  \/\/ Sequence number incremented by the writer every time the sampling port is\n  \/\/ written. Read by the receiver to detect dropped messages and incoherent\n  \/\/ message reads.  An incoherent message is one that is formed of parts of\n  \/\/ more than one message.  An incoherent message can occur when writing\n  \/\/ happens during read. If the component runs long enough, this counter\n  \/\/ will wrap back to zero.  This causes no problems unless the receiver is\n  \/\/ delayed for the wrap time. In that case the receiver may not detect\n  \/\/ dropped or incoherent message. But if the receiver is delayed for that\n  \/\/ long the system is probably in a very bad state. Also see DIRTY_SEQ_NUM\n  \/\/ above.\n  \/\/\n  \/\/ TODO: Currently using ggc builtin _Atomic. Would like to use c11 std, but\n  \/\/ have not figured out how to do this int the seL4 cmake build environment.\n  _Atomic seqNum_t seqNum;  \n\n} sp_int8_t_t;\n\nvoid init_sp_int8_t(sp_int8_t_t *port, seqNum_t *seqNum);\n\nbool write_sp_int8_t(sp_int8_t_t *port, const int8_t *data, seqNum_t *seqNum);\n\nbool read_sp_int8_t(sp_int8_t_t *port, int8_t *data, seqNum_t *seqNum);\n\nbool is_empty_sp_int8_t(sp_int8_t_t *port);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/src\/sp_int8_t.c",
        {
          "type" : "TestResource",
          "content" : "#include <sp_int8_t.h>\n\nvoid init_sp_int8_t(sp_int8_t_t *port, seqNum_t *seqNum) {\n  *seqNum = 0; \/\/ First message sequence number will be 1.\n  port->seqNum = DIRTY_SEQ_NUM;\n}\n\n\/\/ Write message to a sampling port (data type: int)\n\/\/\n\/\/ Returns true when successful. Otherwise returns false. Currently there is no\n\/\/ way to fail and true is always returned. But this may change in the\n\/\/ future. seqNum is incremented when a message is successfully sent. seqNum\n\/\/ should not be modified otherwise.\n\/\/\n\/\/ TODO: Encapsulate this better. seqNum state should be maintained internally. Possible solutions:\n\/\/\n\/\/    - Allow write to have read access to dataport. Then seqNum is simply in the data port.\n\/\/\n\/\/    - Create a wrapper struct.\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_RELEASE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool write_sp_int8_t(sp_int8_t_t *port, const int8_t *data, seqNum_t *seqNum) {\n  \/\/ Mark the message dirty BEFORE we start writing.\n  port->seqNum = DIRTY_SEQ_NUM;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Write the data\n  port->data = *data;\n  \/\/ Increment the sequence number. We are the only writer of seqNum, so\n  \/\/ increment does not have to be atomic.\n  *seqNum = (*seqNum + 1) % DIRTY_SEQ_NUM;\n  port->seqNum = *seqNum;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE continuing\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Can't fail for now.\n  return true;\n}\n\n\/\/ Read a message from a sampling port (data type: int)\n\/\/\n\/\/ Return true upon successful read. Data is updated with the read\n\/\/ message. The sequence number of the message is also returned. The message,\n\/\/ might be tha same previously read. The sequences number can be used to\n\/\/ detect rereading the same message or dropped messages.\n\/\/\n\/\/ Return false if we fail to read a message. For now the only way to fail is\n\/\/ when we detect the possibility of a write during read. In this case data\n\/\/ may be incoherent and should not be used. Sequence number is set to\n\/\/ DIRTY_SEQ_NUM;\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_ACQUIRE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool read_sp_int8_t(sp_int8_t_t *port, int8_t *data, seqNum_t *seqNum) {\n  seqNum_t newSeqNum = port->seqNum;\n  \/\/ Acquire memory fence - Read seqNum BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  *data = port->data;\n  \/\/ Acquire memory fence - Read data BEFORE reading seqNum again \n  \/\/atomic_thread_fence(memory_order_acquire);\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  \/\/ The following logic will NOT catch case where the writer wrapped\n  \/\/ sequence numbers since our last read. For this to happen, this reader\n  \/\/ would have to be delayed for the entire time to wrap. \n  if (newSeqNum != DIRTY_SEQ_NUM && newSeqNum == port->seqNum) {\n    \/\/ Message data is good.  Write did not occur during read. \n    *seqNum = newSeqNum;\n    return true;\n  } else {\n    \/\/ Writer may have updated data while we were reading. Do not use possibly incoherent data.\n    *seqNum = DIRTY_SEQ_NUM;\n    return false;\n  }\n}\n\nbool is_empty_sp_int8_t(sp_int8_t_t *port) {\n  return port->seqNum == DIRTY_SEQ_NUM;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (top_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/components\/VM)\n\nDeclareCAmkESComponent(Pacer\n  SOURCES components\/Pacer\/src\/Pacer.c\n  LIBS SB_Type_Library\n)\n\nDeclareCAmkESRootserver(top_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/bin\/run-camkes.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:s\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"  -c, --camkes-dir      Location of CAmkES project\"\n  echo \"  -n, --non-interactive Non-interactive mode.  Will not prompt before deleting apps and build directories\"\n  echo \"  -o, --camkes-options  CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"  -s, --simulate        Simulate via QEMU\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes-arm-vm\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes-arm-vm\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes-arm-vm project directory.\"\n  echo \"See https:\/\/github.com\/SEL4PROJ\/camkes-arm-vm\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} \\\n    -DUSE_PRECONFIGURED_ROOTFS=ON \\\n    -DPLATFORM=qemu-arm-virt \\\n    -DARM_HYP=ON \\\n    -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\n#..\/init-build.sh ${CAMKES_OPTIONS} \\\n#    -DPLATFORM=qemu-arm-virt \\\n#    -DARM_HYP=ON \\\n#    -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\nif [ \"${SIMULATE}\" = true ]; then\n  qemu-system-aarch64 \\\n      -machine virt,virtualization=on,highmem=off,secure=off \\\n      -cpu cortex-a53 \\\n      -nographic \\\n      -m size=1024 \\\n      -kernel images\/capdl-loader-image-arm-qemu-arm-virt\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/Pacer\/src\/Pacer.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ Copyright 2019 Adventium Labs\n\n#include <camkes.h>\n#include <stdio.h>\n#include <sel4\/sel4.h>\n#include <sb_queue_int8_t_1.h>\n\nextern const char *get_instance_name(void);\n\nvoid send_period_to_vmsrc_process(int8_t *data) {\n  sb_queue_int8_t_1_enqueue(period_to_vmsrc_process_queue, data);\n  period_to_vmsrc_process_notification_emit();\n}\n\nvoid send_period_to_vmdst_process(int8_t *data) {\n  sb_queue_int8_t_1_enqueue(period_to_vmdst_process_queue, data);\n  period_to_vmdst_process_notification_emit();\n}\n\nvoid pre_init(void) {\n  sb_queue_int8_t_1_init(period_to_vmsrc_process_queue);\n  sb_queue_int8_t_1_init(period_to_vmdst_process_queue);\n}\n\nint run(void) {\n\n  int8_t tickCount = 0;\n\n  while (1) {\n    \/\/printf(\"%s: Period tick %d\\n\", get_instance_name(), tickCount);\n\n    tickCount++;\n\n    tick_emit();\n\n    send_period_to_vmsrc_process(&tickCount);\n    send_period_to_vmdst_process(&tickCount);\n\n    tock_wait();\n  }\n\n  return 0;\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/includes\/sb_types.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/src\/cross_vm_connections_vmsrc_process.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2019, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <autoconf.h>\n#include <camkes.h>\n#include <vmlinux.h>\n#include <sel4vm\/guest_vm.h>\n\n#include <sel4vmmplatsupport\/drivers\/cross_vm_connection.h>\n#include <sel4vmmplatsupport\/drivers\/pci_helper.h>\n#include <pci\/helper.h>\n\n#ifdef CONFIG_PLAT_QEMU_ARM_VIRT\n#define CONNECTION_BASE_ADDRESS 0xDF000000\n#else\n#define CONNECTION_BASE_ADDRESS 0x3F000000\n#endif\n\n#define NUM_CONNECTIONS 2\nstatic struct camkes_crossvm_connection connections[NUM_CONNECTIONS];\n\nextern dataport_caps_handle_t sb_write_port_handle;\nextern dataport_caps_handle_t sb_pacer_period_queue_handle;\nseL4_Word sb_pacer_period_notification_notification_badge(void);\n\nstatic int consume_callback(vm_t *vm, void *cookie) {\n    consume_connection_event(vm, (seL4_Word) cookie, true);\n    return 0;\n}\n\nvoid init_cross_vm_connections(vm_t *vm, void *cookie) {\n    connections[0] = (struct camkes_crossvm_connection) {\n      .handle = &sb_write_port_handle,\n      .emit_fn = NULL,\n      .consume_badge = -1,\n      .connection_name = \"sb_write_port\"\n    };\n\n    connections[1] = (struct camkes_crossvm_connection) {\n      .handle = &sb_pacer_period_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_pacer_period_notification_notification_badge(),\n      .connection_name = \"sb_pacer_period_queue\"\n    };\n\n    for (int i = 0; i < NUM_CONNECTIONS; i++) {\n        if (connections[i].consume_badge != -1) {\n            int err = register_async_event_handler(connections[i].consume_badge, consume_callback, (void *)connections[i].consume_badge);\n            ZF_LOGF_IF(err, \"Failed to register_async_event_handler for init_cross_vm_connections.\");\n        }\n    }\n\n    cross_vm_connections_init(vm, CONNECTION_BASE_ADDRESS, connections, ARRAY_SIZE(connections));\n}\n\nDEFINE_MODULE(cross_vm_connections, NULL, init_cross_vm_connections)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/bin\/setup-camkes-arm-vm.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber\n\nif [ -n \"$1\" ]; then\n    CAMKES_ARM_VM_DIR=$1\nelse\n  CASE_HOME=$HOME\/CASE\n\n  if [[ ! -d \"${CASE_HOME}\" ]]; then\n    echo \"CASE home not found: ${CASE_HOME}\"\n    exit 1\n  fi\n\n  CAMKES_ARM_VM_DIR=${CASE_HOME}\/camkes-arm-vm\nfi\n\nif [[ -d \"${CAMKES_ARM_VM_DIR}\" ]]; then\n  read -p \"The following directory already exists, replace ${CAMKES_ARM_VM_DIR} [Y|y]? \" -n 1 -r; echo\n  if [[ $REPLY =~ ^[Yy]$ ]]; then\n    rm -rf ${CAMKES_ARM_VM_DIR}\n  else\n    exit -1\n  fi\nfi\n\nmkdir $CAMKES_ARM_VM_DIR\ncd $CAMKES_ARM_VM_DIR\n\necho \"Cloning camkes arm\"\nrepo init -u https:\/\/github.com\/SEL4PROJ\/camkes-arm-vm-manifest.git --depth=1\nrepo sync -j8\n\necho \"Cloning Kent's CAmkES\"\n\n(cd projects && rm -rf camkes && git clone https:\/\/github.com\/kent-mcleod\/camkes.git -b kent\/aadl)\n\ncd $CAMKES_ARM_VM_DIR\n\nln -sf projects\/camkes\/easy-settings.cmake\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/includes\/sb_event_counter.h",
        {
          "type" : "TestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/src\/cross_vm_connections_vmdst_process.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2019, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <autoconf.h>\n#include <camkes.h>\n#include <vmlinux.h>\n#include <sel4vm\/guest_vm.h>\n\n#include <sel4vmmplatsupport\/drivers\/cross_vm_connection.h>\n#include <sel4vmmplatsupport\/drivers\/pci_helper.h>\n#include <pci\/helper.h>\n\n#ifdef CONFIG_PLAT_QEMU_ARM_VIRT\n#define CONNECTION_BASE_ADDRESS 0xDF000000\n#else\n#define CONNECTION_BASE_ADDRESS 0x3F000000\n#endif\n\n#define NUM_CONNECTIONS 2\nstatic struct camkes_crossvm_connection connections[NUM_CONNECTIONS];\n\nextern dataport_caps_handle_t sb_read_port_handle;\nextern dataport_caps_handle_t sb_pacer_period_queue_handle;\nseL4_Word sb_pacer_period_notification_notification_badge(void);\n\nstatic int consume_callback(vm_t *vm, void *cookie) {\n    consume_connection_event(vm, (seL4_Word) cookie, true);\n    return 0;\n}\n\nvoid init_cross_vm_connections(vm_t *vm, void *cookie) {\n    connections[0] = (struct camkes_crossvm_connection) {\n      .handle = &sb_read_port_handle,\n      .emit_fn = NULL,\n      .consume_badge = -1,\n      .connection_name = \"sb_read_port\"\n    };\n\n    connections[1] = (struct camkes_crossvm_connection) {\n      .handle = &sb_pacer_period_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_pacer_period_notification_notification_badge(),\n      .connection_name = \"sb_pacer_period_queue\"\n    };\n\n    for (int i = 0; i < NUM_CONNECTIONS; i++) {\n        if (connections[i].consume_badge != -1) {\n            int err = register_async_event_handler(connections[i].consume_badge, consume_callback, (void *)connections[i].consume_badge);\n            ZF_LOGF_IF(err, \"Failed to register_async_event_handler for init_cross_vm_connections.\");\n        }\n    }\n\n    cross_vm_connections_init(vm, CONNECTION_BASE_ADDRESS, connections, ARRAY_SIZE(connections));\n}\n\nDEFINE_MODULE(cross_vm_connections, NULL, init_cross_vm_connections)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject(arm-vm C)\n\nincludeGlobalComponents()\nfind_package(camkes-vm REQUIRED)\nfind_package(camkes-vm-images REQUIRED)\nfind_package(camkes-arm-vm REQUIRED)\nfind_package(camkes-vm-linux REQUIRED)\ncamkes_arm_vm_import_project()\n\ninclude(${CAMKES_VM_LINUX_HELPERS_PATH})\ninclude(${CAMKES_VM_LINUX_MODULE_HELPERS_PATH})\ninclude(${CAMKES_VM_LINUX_SOURCE_HELPERS_PATH})\ninclude(ExternalProject)\ninclude(external-project-helpers)\n\noption(USE_PRECONFIGURED_ROOTFS\n       \"Use preconfigured rootfs\"\n       OFF)\n\n#MESSAGE(\"KernelARMPlatform = ${KernelARMPlatform}\")\n#MESSAGE(\"CAMKES_ARM_VM_DIR = ${CAMKES_ARM_VM_DIR}\")\n#MESSAGE(\"CAMKES_VM_IMAGES_DIR = ${CAMKES_VM_IMAGES_DIR}\")\n#MESSAGE(\"CAMKES_VM_LINUX_DIR = ${CAMKES_VM_LINUX_DIR}\")\n#MESSAGE(\"CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}\")\n#MESSAGE(\"CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}\")\n#MESSAGE(\"CMAKE_C_COMPILER = ${CMAKE_C_COMPILER}\")\n#MESSAGE(\"BASE_C_FLAGS = ${BASE_C_FLAGS}\")\n\nif(\"${KernelARMPlatform}\" STREQUAL \"qemu-arm-virt\" AND (NOT USE_PRECONFIGURED_ROOTFS))\n    MESSAGE(\"Downloading VM\")\n\n    set(cpp_flags \"-DKERNELARMPLATFORM_QEMU-ARM-VIRT\")\n    set(linux_repo \"https:\/\/git.kernel.org\/pub\/scm\/linux\/kernel\/git\/stable\/linux.git\")\n    set(linux_tag \"v4.9.189\")\n    set(linux_arch \"arm64\")\n    set(linux_cross_compile \"aarch64-linux-gnu-\")\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs.cpio.gz\")\n    # Checkout and configure linux to build crossvm module\n    ExternalProject_Add(\n        checkout_linux\n        GIT_REPOSITORY\n        ${linux_repo}\n        GIT_TAG\n        ${linux_tag}\n        GIT_SHALLOW\n        1\n        GIT_PROGRESS\n        1\n        BUILD_COMMAND\n        \"\"\n        INSTALL_COMMAND\n        \"\"\n        CONFIGURE_COMMAND\n        \"\"\n        SOURCE_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n    )\n    Message(\"Done cloning ${linux_repo}\")\n\n    # Linux config and symvers are to be copied to unpacked archive\n    set(linux_config \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/config\")\n    set(linux_symvers \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/Module.symvers\")\n    # Configure unpacked archive with config and symvers\n    ConfigureLinux(\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ${linux_config}\n        ${linux_symvers}\n        configure_vm_linux\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n    )\n\n    # Compile CrossVM Dataport Module\n    DefineLinuxModule(\n        ${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-modules\/camkes-connector-modules\/connection\n        output_module\n        output_module_target\n        KERNEL_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n        configure_vm_linux\n    )\n\n    AddFileToOverlayDir(\n        \"connection.ko\"\n        ${output_module}\n        \"lib\/modules\/4.14.87\/kernel\/drivers\/vmm\"\n        overlay\n        DEPENDS\n        output_module_target\n    )\n\n    # Add script to initialise dataport module\n    AddFileToOverlayDir(\n        \"S90crossvm_module_init\"\n        ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/cross_vm_module_init\n        \"etc\/init.d\"\n        overlay\n    )\nelse()\n    MESSAGE(\"Using pre-configured rootfs\")\n\n    # Use pre-configured rootfs file with crossvm modules and apps installed\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs_crossvm.cpio.gz\")\nendif()\n\n# Complile CrossVM Event Apps vmsrc_process and vmdst_process\nforeach(item IN ITEMS vmsrc_process vmdst_process)\n    ExternalProject_Add(\n        ${item}\n        SOURCE_DIR\n        ${CMAKE_CURRENT_SOURCE_DIR}\/apps\/${item}\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n        -DSB_Type_Library_DIR=${CMAKE_CURRENT_SOURCE_DIR}\/..\/..\/types\n        -DCMAKE_C_FLAGS=${BASE_C_FLAGS}\n    )\n\n    AddExternalProjFilesToOverlay(\n        ${item}\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        overlay\n        \"usr\/bin\"\n        FILES\n        ${item}\n    )\nendforeach()\n\nMessage(\"Done compiling CrossVM Event Apps for vmsrc_process and vmdst_process\")\n\n\n# Overwrite inittab file for using the virtio console hvc0.\nAddFileToOverlayDir(\n    \"inittab\"\n    ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/inittab_hvc0\n    \"etc\"\n    overlay\n)\n\n# Use initrd with crossvm kernel module and setup already included.\n# Construct new rootfs\nAddOverlayDirToRootfs(\n    overlay\n    ${rootfs_file}\n    \"buildroot\"\n    \"rootfs_install\"\n    output_overlayed_rootfs_location\n    rootfs_target\n    GZIP\n)\n\nAddToFileServer(\"linux-initrd-vm-client\" ${output_overlayed_rootfs_location} DEPENDS rootfs_target)\n\n# Add linux kernel image to file server\nAddToFileServer(\"linux\" \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux\")\n\nDefineCAmkESVMFileServer()\n\nCAmkESAddImportPath(${CMAKE_CURRENT_SOURCE_DIR}\/${KernelARMPlatform}\/)\n\n# Define our VM Component with our cross vm dataports glue code\nDeclareCamkesARMVM(\n  VM_emitter_t_impl_src_process_src_thread\n  EXTRA_SOURCES src\/cross_vm_connections_vmsrc_process.c\n  EXTRA_LIBS SB_Type_Library)\n\nDeclareCamkesARMVM(\n  VM_consumer_t_impl_dst_process_dst_thread\n  EXTRA_SOURCES src\/cross_vm_connections_vmdst_process.c\n  EXTRA_LIBS SB_Type_Library)\n\nCAmkESAddCPPInclude(${CAMKES_ARM_VM_DIR}\/components\/VM)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/exynos5422\/devices.camkes",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2020, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <configurations\/vm.h>\n\n#define VM_RAM_OFFSET 0\n#define VM_INITRD_MAX_SIZE 0x1900000 \/\/ 25 MB\n\n\n#define VM1_RAM_BASE       0x48000000\n#define VM1_RAM_MMIOS_BASE \"0x48000000:27\"\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x4f000000  \/\/ VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x4d700000  \/\/ VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM2_RAM_BASE       0x50000000\n#define VM2_RAM_MMIOS_BASE \"0x50000000:27\"\n#define VM2_RAM_SIZE       0x8000000\n#define VM2_DTB_ADDR       0x57000000  \/\/ VM2_RAM_BASE + 0x7000000\n#define VM2_INITRD_ADDR    0x55700000  \/\/ VM2_DTB_ADDR - VM_INITRD_MAX_SIZE\n\nassembly {\n  composition {}\n  configuration {\n    vmsrc_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR),\n    };\n    vmsrc_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 root=\/dev\/ram0 nosmp rw debug loglevel=8 pci=nomsi initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmsrc_process.mmios = [\n      \"0x10000000:0x1000:12\", \/\/ CHIP ID\n      \"0x10486000:0x1000:12\"  \/\/ VCPU\n    ];\n    vmsrc_process.untyped_mmios = [\n      VM1_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmsrc_process.irqs = [];\n    vmsrc_process.dtb = dtb([{}]);\n\n    vmdst_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM2_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM2_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM2_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM2_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM2_INITRD_ADDR),\n    };\n    vmdst_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 root=\/dev\/ram0 nosmp rw debug loglevel=8 pci=nomsi initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmdst_process.mmios = [\n      \"0x10000000:0x1000:12\", \/\/ CHIP ID\n      \"0x10486000:0x1000:12\"  \/\/ VCPU\n    ];\n    vmdst_process.untyped_mmios = [\n      VM2_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmdst_process.irqs = [];\n    vmdst_process.dtb = dtb([{}]);\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/qemu-arm-virt\/devices.camkes",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2020, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <configurations\/vm.h>\n#define VM_RAM_OFFSET      0x00000000\n#define VM_INITRD_MAX_SIZE 0x3200000 \/\/ 50 MB\n\n#define VM1_RAM_BASE       0x48000000\n#define VM1_RAM_MMIOS_BASE \"0x48000000:27\"\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x4f000000  \/\/ VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x4d700000  \/\/ VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM2_RAM_BASE       0x50000000\n#define VM2_RAM_MMIOS_BASE \"0x50000000:27\"\n#define VM2_RAM_SIZE       0x8000000\n#define VM2_DTB_ADDR       0x57000000  \/\/ VM2_RAM_BASE + 0x7000000\n#define VM2_INITRD_ADDR    0x55700000  \/\/ VM2_DTB_ADDR - VM_INITRD_MAX_SIZE\n\nassembly {\n  composition {}\n  configuration {\n    vmsrc_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR),\n    };\n    vmsrc_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 nosmp rw debug loglevel=8 pci=nomsi,realloc=off,bios initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmsrc_process.mmios = [\n      \"0x8040000:0x1000:12\", \/\/ Interrupt Controller Virtual CPU interface (Virtual Machine view)\n    ];\n    vmsrc_process.untyped_mmios = [\n      VM1_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmsrc_process.irqs = [];\n    vmsrc_process.dtb = dtb([{}]);\n\n\n    vmdst_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM2_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM2_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM2_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM2_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM2_INITRD_ADDR),\n    };\n    vmdst_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 nosmp rw debug loglevel=8 pci=nomsi,realloc=off,bios initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmdst_process.mmios = [\n      \"0x8040000:0x1000:12\", \/\/ Interrupt Controller Virtual CPU interface (Virtual Machine view)\n    ];\n    vmdst_process.untyped_mmios = [\n      VM2_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmdst_process.irqs = [];\n    vmdst_process.dtb = dtb([{}]);\n\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/overlay_files\/init_scripts\/cross_vm_module_init",
        {
          "type" : "TestResource",
          "content" : "#!\/bin\/sh\n#\n# Copyright 2020, Data61\n# Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n# ABN 41 687 119 230.\n#\n# This software may be distributed and modified according to the terms of\n# the BSD 2-Clause license. Note that NO WARRANTY is provided.\n# See \"LICENSE_BSD2.txt\" for details.\n#\n# @TAG(DATA61_BSD)\n#\n\ninsmod \/lib\/modules\/4.14.87\/kernel\/drivers\/vmm\/connection.ko",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/overlay_files\/init_scripts\/inittab_hvc0",
        {
          "type" : "TestResource",
          "content" : "# @TAG(CUSTOM)\n# \/etc\/inittab\n#\n# This file will not be overwritten so is safe to edit\n#\n# Copyright (C) 2001 Erik Andersen <andersen@codepoet.org>\n#\n# Note: BusyBox init doesn't support runlevels.  The runlevels field is\n# completely ignored by BusyBox init. If you want runlevels, use\n# sysvinit.\n#\n# Format for each entry: <id>:<runlevels>:<action>:<process>\n#\n# id        == tty to run on, or empty for \/dev\/console\n# runlevels == ignored\n# action    == one of sysinit, respawn, askfirst, wait, and once\n# process   == program to run\n\n# Startup the system\n::sysinit:\/bin\/mount -t proc proc \/proc\n::sysinit:\/bin\/mount -o remount,rw \/\n::sysinit:\/bin\/mkdir -p \/dev\/pts \/dev\/shm\n::sysinit:\/bin\/mount -a\n::sysinit:\/sbin\/swapon -a\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd \/dev\/fd\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/0 \/dev\/stdin\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/1 \/dev\/stdout\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/2 \/dev\/stderr\n::sysinit:\/bin\/hostname -F \/etc\/hostname\n# now run any rc scripts\n::sysinit:\/etc\/init.d\/rcS\n\n# Put a getty on the serial port\nhvc0:2345:respawn:\/sbin\/getty -L 9600 hvc0\n\n# Stuff to do for the 3-finger salute\n#::ctrlaltdel:\/sbin\/reboot\n\n# Stuff to do before rebooting\n::shutdown:\/etc\/init.d\/rcK\n::shutdown:\/sbin\/swapoff -a\n::shutdown:\/bin\/umount -a -r",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/apps\/vmsrc_process\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject(vmsrc_process C)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_subdirectory(${SB_Type_Library_DIR} SB_Type_Library)\n\nadd_executable(vmsrc_process vmsrc_process.c)\n\ntarget_link_libraries(vmsrc_process\n                      SB_Type_Library\n                      -static-libgcc -static)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/apps\/vmsrc_process\/vmsrc_process.c",
        {
          "type" : "TestResource",
          "content" : "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/mman.h>\n#include <errno.h>\n\n#include <sb_types.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int8_t_1.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nint main(int argc, char *argv[]) {\n  printf(\"VM App vmsrc_process started\\n\");\n  return 0;\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/apps\/vmdst_process\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject(vmdst_process C)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_subdirectory(${SB_Type_Library_DIR} SB_Type_Library)\n\nadd_executable(vmdst_process vmdst_process.c)\n\ntarget_link_libraries(vmdst_process\n                      SB_Type_Library\n                      -static-libgcc -static)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/components\/VM\/apps\/vmdst_process\/vmdst_process.c",
        {
          "type" : "TestResource",
          "content" : "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/mman.h>\n#include <errno.h>\n\n#include <sb_types.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int8_t_1.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nint main(int argc, char *argv[]) {\n  printf(\"VM App vmdst_process started\\n\");\n  return 0;\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/includes\/sb_queue_int8_t_1.h",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_INT8_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT8_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int8_t_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int8_t \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  int8_t elt[SB_QUEUE_INT8_T_1_SIZE];\n\n} sb_queue_int8_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue, \n  int8_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int8_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int8_t_1_t *queue;\n\n} sb_queue_int8_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_queue_int8_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int8_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int8_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int8_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/src\/sb_queue_int8_t_1.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int8_t_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue, \n  int8_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_INT8_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT8_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_queue_int8_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int8_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int8_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT8_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT8_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT8_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT8_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT8_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/kernel\/domain_schedule.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ Copyright 2020 Adventium Labs\n\n\/\/ This is a kernel data structure.\n\n#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ An arbitrary hand generated schedule. The length is in seL4 ticks\n\/\/ (2 ms default). This schedule should be generated from the AADL model\n\/\/ using execution time and data flow latency specifications.\n\/\/\n\/\/ Pacer runs at highest rate\n\/\/\n\/\/ This schedule is single-rate, 1Hz, run each thread at 200ms ticks for simplicity.\n\/\/ Fill space in with domain 0.\n\/\/\n\/\/         +\n\/\/ 3 dest  |        -              -              -              -      \n\/\/ 2 src   |     -              -              -              -         \n\/\/ 1 pacer |  -              -              -              -            \n\/\/ 0 dom0  |-- -- -- -------- -- -- -------- -- -- -------- -- -- ------\n\/\/         |______________|______________________________________________\\time\n\/\/           seconds      1              2              3              4 \/\n\/\/\n\/\/ Major frame is 1 seconds, since destination has 1 second period\n\/\/\nconst dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n    { .domain = 0, .length = 100 },   \/\/ all other seL4 threads, init, 200ms\n    { .domain = 1, .length =   5 },   \/\/ pacer        \n    { .domain = 0, .length =   5 },   \/\/ domain0     \n    { .domain = 2, .length = 400 },   \/\/ source      \n    { .domain = 0, .length =   5 },   \/\/ domain0     \n    { .domain = 3, .length = 400 },   \/\/ destination \n    { .domain = 0, .length =   5 },   \/\/ domain0 \n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/settings.cmake",
        {
          "type" : "TestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n# Add virtual PCI device to VMM for registering cross component connectors as\n# devices on the PCI bus.\nset(VmPCISupport ON CACHE BOOL \"\" FORCE)\n\n# Disable libusb from being compiled.\nset(LibUSB OFF CACHE BOOL \"\" FORCE)\n\n# Enables the option for the VM to open and load a seperate initrd file\nset(VmInitRdFile ON CACHE BOOL \"\" FORCE)\n\n# Enable virtio console vmm module\nset(VmVirtioConsole ON CACHE BOOL \"\" FORCE)\n\n# Make VTimers see absolute time rather than virtual time.\nset(KernelArmVtimerUpdateVOffset OFF CACHE BOOL \"\" FORCE)\n\n# Don't trap WFI or WFE instructions in a VM.\nset(KernelArmDisableWFIWFETraps ON CACHE BOOL \"\" FORCE)\n\nif(\"${PLATFORM}\" STREQUAL \"qemu-arm-virt\")\n    set(KernelArmCPU cortex-a53 CACHE STRING \"\" FORCE)\n    set(KernelArmExportPCNTUser ON CACHE BOOL \"\" FORCE)\n    set(KernelArmExportPTMRUser ON CACHE BOOL \"\" FORCE)\n\n    set(MIN_QEMU_VERSION \"4.0.0\")\n    execute_process(COMMAND ${QEMU_BINARY} -version OUTPUT_VARIABLE QEMU_VERSION_STR)\n    string(\n        REGEX\n            MATCH\n            \"[0-9](\\\\.[0-9])+\"\n            QEMU_VERSION\n            ${QEMU_VERSION_STR}\n    )\n    if(\"${QEMU_VERSION}\" VERSION_LESS \"${MIN_QEMU_VERSION}\")\n        message(WARNING \"Warning: qemu version should be at least ${MIN_QEMU_VERSION}\")\n    endif()\n\nendif()\n# Add virtual PCI device to VMM for registering cross component connectors as\n# devices on the PCI bus.\nset(VmPCISupport ON CACHE BOOL \"\" FORCE)\n\n# Disable libusb from being compiled.\nset(LibUSB OFF CACHE BOOL \"\" FORCE)\n\n# Enables the option for the VM to open and load a seperate initrd file\nset(VmInitRdFile ON CACHE BOOL \"\" FORCE)\n\n# Enable virtio console vmm module\nset(VmVirtioConsole ON CACHE BOOL \"\" FORCE)\n\n# Make VTimers see absolute time rather than virtual time.\nset(KernelArmVtimerUpdateVOffset OFF CACHE BOOL \"\" FORCE)\n\n# Don't trap WFI or WFE instructions in a VM.\nset(KernelArmDisableWFIWFETraps ON CACHE BOOL \"\" FORCE)\n\nif(\"${PLATFORM}\" STREQUAL \"qemu-arm-virt\")\n    set(KernelArmCPU cortex-a53 CACHE STRING \"\" FORCE)\n    set(KernelArmExportPCNTUser ON CACHE BOOL \"\" FORCE)\n    set(KernelArmExportPTMRUser ON CACHE BOOL \"\" FORCE)\n\n    set(MIN_QEMU_VERSION \"4.0.0\")\n    execute_process(COMMAND ${QEMU_BINARY} -version OUTPUT_VARIABLE QEMU_VERSION_STR)\n    string(\n        REGEX\n            MATCH\n            \"[0-9](\\\\.[0-9])+\"\n            QEMU_VERSION\n            ${QEMU_VERSION_STR}\n    )\n    if(\"${QEMU_VERSION}\" VERSION_LESS \"${MIN_QEMU_VERSION}\")\n        message(WARNING \"Warning: qemu version should be at least ${MIN_QEMU_VERSION}\")\n    endif()\n\nendif()\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 4 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_data-port-periodic_domains_VM__both_vm--SeL4_Only\/types\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_int8_t_1.c\n            src\/sp_int8_t.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ]
    ]
  }
}