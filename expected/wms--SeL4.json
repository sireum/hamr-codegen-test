{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "wms--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val wms_impl_Instance_tire_p_monitor : slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge = {\n    val front_pressure = Port[Base_Types.Bits] (id = 0, name = \"wms_impl_Instance_tire_p_monitor_front_pressure\", mode = DataIn)\n    val rear_pressure = Port[Base_Types.Bits] (id = 1, name = \"wms_impl_Instance_tire_p_monitor_rear_pressure\", mode = DataIn)\n    val front_inflate = Port[Base_Types.Bits] (id = 2, name = \"wms_impl_Instance_tire_p_monitor_front_inflate\", mode = DataOut)\n    val rear_inflate = Port[Base_Types.Bits] (id = 3, name = \"wms_impl_Instance_tire_p_monitor_rear_inflate\", mode = DataOut)\n\n    slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge(\n      id = 0,\n      name = \"wms_impl_Instance_tire_p_monitor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      front_pressure = front_pressure,\n      rear_pressure = rear_pressure,\n      front_inflate = front_inflate,\n      rear_inflate = rear_inflate\n    )\n  }\n  val wms_impl_Instance_front_p_sensor : slang_embedded.wms.sensor_impl_front_p_sensor_Bridge = {\n    val inflate = Port[Base_Types.Bits] (id = 4, name = \"wms_impl_Instance_front_p_sensor_inflate\", mode = DataIn)\n    val pressure = Port[Base_Types.Bits] (id = 5, name = \"wms_impl_Instance_front_p_sensor_pressure\", mode = DataOut)\n\n    slang_embedded.wms.sensor_impl_front_p_sensor_Bridge(\n      id = 1,\n      name = \"wms_impl_Instance_front_p_sensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      inflate = inflate,\n      pressure = pressure\n    )\n  }\n  val wms_impl_Instance_rear_p_sensor : slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge = {\n    val inflate = Port[Base_Types.Bits] (id = 6, name = \"wms_impl_Instance_rear_p_sensor_inflate\", mode = DataIn)\n    val pressure = Port[Base_Types.Bits] (id = 7, name = \"wms_impl_Instance_rear_p_sensor_pressure\", mode = DataOut)\n\n    slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge(\n      id = 2,\n      name = \"wms_impl_Instance_rear_p_sensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      inflate = inflate,\n      pressure = pressure\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (wms_impl_Instance_tire_p_monitor, wms_impl_Instance_front_p_sensor, wms_impl_Instance_rear_p_sensor),\n\n      connections = ISZ (Connection(from = wms_impl_Instance_tire_p_monitor.front_inflate, to = wms_impl_Instance_front_p_sensor.inflate),\n                         Connection(from = wms_impl_Instance_tire_p_monitor.rear_inflate, to = wms_impl_Instance_rear_p_sensor.inflate),\n                         Connection(from = wms_impl_Instance_front_p_sensor.pressure, to = wms_impl_Instance_tire_p_monitor.front_pressure),\n                         Connection(from = wms_impl_Instance_rear_p_sensor.pressure, to = wms_impl_Instance_tire_p_monitor.rear_pressure))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage slang_embedded\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/inspector\/slang_embedded\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class tire_monitor_impl_tire_p_monitor_TestApi extends BridgeTestSuite[tire_monitor_impl_tire_p_monitor_Bridge](Arch.wms_impl_Instance_tire_p_monitor) {\n\n  \/** helper function to set the values of all input ports.\n   * @param front_pressure payload for data port front_pressure\n   * @param rear_pressure payload for data port rear_pressure\n   *\/\n  def put_concrete_inputs(front_pressure : Base_Types.Bits,\n                          rear_pressure : Base_Types.Bits): Unit = {\n    put_front_pressure(front_pressure)\n    put_rear_pressure(rear_pressure)\n  }\n\n\n  \/** helper function to check tire_monitor_impl_tire_p_monitor's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param front_inflate method that will be called with the value of the outgoing data\n   *        port 'front_inflate'.\n   * @param rear_inflate method that will be called with the value of the outgoing data\n   *        port 'rear_inflate'.\n   *\/\n  def check_concrete_output(front_inflate: Base_Types.Bits => B = front_inflateParam => {T},\n                            rear_inflate: Base_Types.Bits => B = rear_inflateParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val front_inflateValue: Base_Types.Bits = get_front_inflate().get\n    if(!front_inflate(front_inflateValue)) {\n      testFailures = testFailures :+ st\"'front_inflate' did not match expected: value of the outgoing data port is ${front_inflateValue}\"\n    }\n    val rear_inflateValue: Base_Types.Bits = get_rear_inflate().get\n    if(!rear_inflate(rear_inflateValue)) {\n      testFailures = testFailures :+ st\"'rear_inflate' did not match expected: value of the outgoing data port is ${rear_inflateValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_front_pressure(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.front_pressure_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_rear_pressure(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.rear_pressure_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_front_inflate(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_front_inflate_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port front_inflate.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_front_inflate_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.front_inflate_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_rear_inflate(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_rear_inflate_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port rear_inflate.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_rear_inflate_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.rear_inflate_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded.wms._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass tire_monitor_impl_tire_p_monitor_Test extends tire_monitor_impl_tire_p_monitor_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.wms.{tire_monitor_impl_tire_p_monitor => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class tire_monitor_impl_tire_p_monitor_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  front_pressure: Port[Base_Types.Bits],\n  rear_pressure: Port[Base_Types.Bits],\n  front_inflate: Port[Base_Types.Bits],\n  rear_inflate: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(front_pressure,\n              rear_pressure,\n              front_inflate,\n              rear_inflate),\n\n    dataIns = ISZ(front_pressure,\n                  rear_pressure),\n\n    dataOuts = ISZ(front_inflate,\n                   rear_inflate),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : tire_monitor_impl_Initialization_Api = {\n    val api = tire_monitor_impl_Initialization_Api(\n      id,\n      front_pressure.id,\n      rear_pressure.id,\n      front_inflate.id,\n      rear_inflate.id\n    )\n    tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : tire_monitor_impl_Operational_Api = {\n    val api = tire_monitor_impl_Operational_Api(\n      id,\n      front_pressure.id,\n      rear_pressure.id,\n      front_inflate.id,\n      rear_inflate.id\n    )\n    tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    tire_monitor_impl_tire_p_monitor_Bridge.EntryPoints(\n      id,\n\n      front_pressure.id,\n      rear_pressure.id,\n      front_inflate.id,\n      rear_inflate.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject tire_monitor_impl_tire_p_monitor_Bridge {\n\n  var c_initialization_api: Option[tire_monitor_impl_Initialization_Api] = None()\n  var c_operational_api: Option[tire_monitor_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    tire_monitor_impl_tire_p_monitor_BridgeId : Art.BridgeId,\n\n    front_pressure_Id : Art.PortId,\n    rear_pressure_Id : Art.PortId,\n    front_inflate_Id : Art.PortId,\n    rear_inflate_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: tire_monitor_impl_Initialization_Api,\n    operational_api: tire_monitor_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(front_pressure_Id,\n                                             rear_pressure_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(front_inflate_Id,\n                                              rear_inflate_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/wms\/tire_monitor_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait tire_monitor_impl_Api {\n  def id: Art.BridgeId\n  def front_pressure_Id : Art.PortId\n  def rear_pressure_Id : Art.PortId\n  def front_inflate_Id : Art.PortId\n  def rear_inflate_Id : Art.PortId\n\n  def setfront_inflate(value : Base_Types.Bits) : Unit = {\n    Art.putValue(front_inflate_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def setrear_inflate(value : Base_Types.Bits) : Unit = {\n    Art.putValue(rear_inflate_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class tire_monitor_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val front_pressure_Id : Art.PortId,\n  val rear_pressure_Id : Art.PortId,\n  val front_inflate_Id : Art.PortId,\n  val rear_inflate_Id : Art.PortId) extends tire_monitor_impl_Api\n\n@datatype class tire_monitor_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val front_pressure_Id : Art.PortId,\n  val rear_pressure_Id : Art.PortId,\n  val front_inflate_Id : Art.PortId,\n  val rear_inflate_Id : Art.PortId) extends tire_monitor_impl_Api {\n\n  def getfront_pressure() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(front_pressure_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port front_pressure.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def getrear_pressure() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(rear_pressure_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port rear_pressure.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject tire_monitor_impl_tire_p_monitor {\n\n  def initialise(api: tire_monitor_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setfront_inflate(Base_Types.Bits_empty())\n    api.setrear_inflate(Base_Types.Bits_empty())\n  }\n\n  def timeTriggered(api: tire_monitor_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_front_pressure: Option[Base_Types.Bits] = api.getfront_pressure()\n    api.logInfo(s\"Received on front_pressure: ${apiUsage_front_pressure}\")\n    val apiUsage_rear_pressure: Option[Base_Types.Bits] = api.getrear_pressure()\n    api.logInfo(s\"Received on rear_pressure: ${apiUsage_rear_pressure}\")\n  }\n\n  def activate(api: tire_monitor_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: tire_monitor_impl_Operational_Api): Unit = { }\n\n  def finalise(api: tire_monitor_impl_Operational_Api): Unit = { }\n\n  def recover(api: tire_monitor_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[slang_embedded.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/wms\/sensor_impl_front_p_sensor_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class sensor_impl_front_p_sensor_TestApi extends BridgeTestSuite[sensor_impl_front_p_sensor_Bridge](Arch.wms_impl_Instance_front_p_sensor) {\n\n  \/** helper function to set the values of all input ports.\n   * @param inflate payload for data port inflate\n   *\/\n  def put_concrete_inputs(inflate : Base_Types.Bits): Unit = {\n    put_inflate(inflate)\n  }\n\n\n  \/** helper function to check sensor_impl_front_p_sensor's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param pressure method that will be called with the value of the outgoing data\n   *        port 'pressure'.\n   *\/\n  def check_concrete_output(pressure: Base_Types.Bits => B = pressureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val pressureValue: Base_Types.Bits = get_pressure().get\n    if(!pressure(pressureValue)) {\n      testFailures = testFailures :+ st\"'pressure' did not match expected: value of the outgoing data port is ${pressureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_inflate(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.inflate_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_pressure(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_pressure_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port pressure.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_pressure_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.pressure_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/wms\/sensor_impl_front_p_sensor_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded.wms._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass sensor_impl_front_p_sensor_Test extends sensor_impl_front_p_sensor_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/wms\/sensor_impl_front_p_sensor_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.wms.{sensor_impl_front_p_sensor => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class sensor_impl_front_p_sensor_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  inflate: Port[Base_Types.Bits],\n  pressure: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(inflate,\n              pressure),\n\n    dataIns = ISZ(inflate),\n\n    dataOuts = ISZ(pressure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : sensor_impl_Initialization_Api = {\n    val api = sensor_impl_Initialization_Api(\n      id,\n      inflate.id,\n      pressure.id\n    )\n    sensor_impl_front_p_sensor_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : sensor_impl_Operational_Api = {\n    val api = sensor_impl_Operational_Api(\n      id,\n      inflate.id,\n      pressure.id\n    )\n    sensor_impl_front_p_sensor_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    sensor_impl_front_p_sensor_Bridge.EntryPoints(\n      id,\n\n      inflate.id,\n      pressure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject sensor_impl_front_p_sensor_Bridge {\n\n  var c_initialization_api: Option[sensor_impl_Initialization_Api] = None()\n  var c_operational_api: Option[sensor_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    sensor_impl_front_p_sensor_BridgeId : Art.BridgeId,\n\n    inflate_Id : Art.PortId,\n    pressure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: sensor_impl_Initialization_Api,\n    operational_api: sensor_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(inflate_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(pressure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/wms\/sensor_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait sensor_impl_Api {\n  def id: Art.BridgeId\n  def inflate_Id : Art.PortId\n  def pressure_Id : Art.PortId\n\n  def setpressure(value : Base_Types.Bits) : Unit = {\n    Art.putValue(pressure_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class sensor_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val inflate_Id : Art.PortId,\n  val pressure_Id : Art.PortId) extends sensor_impl_Api\n\n@datatype class sensor_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val inflate_Id : Art.PortId,\n  val pressure_Id : Art.PortId) extends sensor_impl_Api {\n\n  def getinflate() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(inflate_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port inflate.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/wms\/sensor_impl_front_p_sensor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject sensor_impl_front_p_sensor {\n\n  def initialise(api: sensor_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setpressure(Base_Types.Bits_empty())\n  }\n\n  def timeTriggered(api: sensor_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_inflate: Option[Base_Types.Bits] = api.getinflate()\n    api.logInfo(s\"Received on inflate: ${apiUsage_inflate}\")\n  }\n\n  def activate(api: sensor_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: sensor_impl_Operational_Api): Unit = { }\n\n  def finalise(api: sensor_impl_Operational_Api): Unit = { }\n\n  def recover(api: sensor_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/util\/slang_embedded\/wms\/sensor_impl_rear_p_sensor_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class sensor_impl_rear_p_sensor_TestApi extends BridgeTestSuite[sensor_impl_rear_p_sensor_Bridge](Arch.wms_impl_Instance_rear_p_sensor) {\n\n  \/** helper function to set the values of all input ports.\n   * @param inflate payload for data port inflate\n   *\/\n  def put_concrete_inputs(inflate : Base_Types.Bits): Unit = {\n    put_inflate(inflate)\n  }\n\n\n  \/** helper function to check sensor_impl_rear_p_sensor's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param pressure method that will be called with the value of the outgoing data\n   *        port 'pressure'.\n   *\/\n  def check_concrete_output(pressure: Base_Types.Bits => B = pressureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val pressureValue: Base_Types.Bits = get_pressure().get\n    if(!pressure(pressureValue)) {\n      testFailures = testFailures :+ st\"'pressure' did not match expected: value of the outgoing data port is ${pressureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_inflate(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.inflate_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_pressure(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_pressure_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port pressure.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_pressure_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.pressure_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/wms\/sensor_impl_rear_p_sensor_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded.wms._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass sensor_impl_rear_p_sensor_Test extends sensor_impl_rear_p_sensor_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/wms\/sensor_impl_rear_p_sensor_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.wms.{sensor_impl_rear_p_sensor => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class sensor_impl_rear_p_sensor_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  inflate: Port[Base_Types.Bits],\n  pressure: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(inflate,\n              pressure),\n\n    dataIns = ISZ(inflate),\n\n    dataOuts = ISZ(pressure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : sensor_impl_Initialization_Api = {\n    val api = sensor_impl_Initialization_Api(\n      id,\n      inflate.id,\n      pressure.id\n    )\n    sensor_impl_rear_p_sensor_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : sensor_impl_Operational_Api = {\n    val api = sensor_impl_Operational_Api(\n      id,\n      inflate.id,\n      pressure.id\n    )\n    sensor_impl_rear_p_sensor_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    sensor_impl_rear_p_sensor_Bridge.EntryPoints(\n      id,\n\n      inflate.id,\n      pressure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject sensor_impl_rear_p_sensor_Bridge {\n\n  var c_initialization_api: Option[sensor_impl_Initialization_Api] = None()\n  var c_operational_api: Option[sensor_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    sensor_impl_rear_p_sensor_BridgeId : Art.BridgeId,\n\n    inflate_Id : Art.PortId,\n    pressure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: sensor_impl_Initialization_Api,\n    operational_api: sensor_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(inflate_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(pressure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/wms\/sensor_impl_rear_p_sensor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject sensor_impl_rear_p_sensor {\n\n  def initialise(api: sensor_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setpressure(Base_Types.Bits_empty())\n  }\n\n  def timeTriggered(api: sensor_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_inflate: Option[Base_Types.Bits] = api.getinflate()\n    api.logInfo(s\"Received on inflate: ${apiUsage_inflate}\")\n  }\n\n  def activate(api: sensor_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: sensor_impl_Operational_Api): Unit = { }\n\n  def finalise(api: sensor_impl_Operational_Api): Unit = { }\n\n  def recover(api: sensor_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/tire_monitor_impl_tire_p_monitor\/monitor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.tire_monitor_impl_tire_p_monitor\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.wms.tire_monitor_impl_tire_p_monitor_seL4Nix\n\nobject monitor extends App {\n\n  val monitorBridge : slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge = {\n    val front_pressure = Port[Base_Types.Bits] (id = 0, name = \"wms_impl_Instance_tire_p_monitor_front_pressure\", mode = DataIn)\n    val rear_pressure = Port[Base_Types.Bits] (id = 1, name = \"wms_impl_Instance_tire_p_monitor_rear_pressure\", mode = DataIn)\n    val front_inflate = Port[Base_Types.Bits] (id = 2, name = \"wms_impl_Instance_tire_p_monitor_front_inflate\", mode = DataOut)\n    val rear_inflate = Port[Base_Types.Bits] (id = 3, name = \"wms_impl_Instance_tire_p_monitor_rear_inflate\", mode = DataOut)\n\n    slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge(\n      id = 0,\n      name = \"wms_impl_Instance_tire_p_monitor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      front_pressure = front_pressure,\n      rear_pressure = rear_pressure,\n      front_inflate = front_inflate,\n      rear_inflate = rear_inflate\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = monitorBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ front_pressure: In DataPort Base_Types.Bits\n  val front_pressure_id: Art.PortId = monitorBridge.front_pressure.id\n  var front_pressure_port: Option[DataContent] = noData\n\n  \/\/ rear_pressure: In DataPort Base_Types.Bits\n  val rear_pressure_id: Art.PortId = monitorBridge.rear_pressure.id\n  var rear_pressure_port: Option[DataContent] = noData\n\n  \/\/ front_inflate: Out DataPort Base_Types.Bits\n  val front_inflate_id: Art.PortId = monitorBridge.front_inflate.id\n  var front_inflate_port: Option[DataContent] = noData\n\n  \/\/ rear_inflate: Out DataPort Base_Types.Bits\n  val rear_inflate_id: Art.PortId = monitorBridge.rear_inflate.id\n  var rear_inflate_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == front_pressure_id) {\n      return front_pressure_port\n    } else if(portId == rear_pressure_id) {\n      return rear_pressure_port\n    } else {\n      halt(s\"Unexpected: monitor.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    front_pressure_port = tire_monitor_impl_tire_p_monitor_seL4Nix.front_pressure_Receive()\n\n    rear_pressure_port = tire_monitor_impl_tire_p_monitor_seL4Nix.rear_pressure_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == front_inflate_id) {\n      front_inflate_port = Some(data)\n    } else if(portId == rear_inflate_id) {\n      rear_inflate_port = Some(data)\n    } else {\n      halt(s\"Unexpected: monitor.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(front_inflate_port.nonEmpty) {\n      tire_monitor_impl_tire_p_monitor_seL4Nix.front_inflate_Send(front_inflate_port.get)\n      front_inflate_port = noData\n    }\n\n    if(rear_inflate_port.nonEmpty) {\n      tire_monitor_impl_tire_p_monitor_seL4Nix.rear_inflate_Send(rear_inflate_port.get)\n      rear_inflate_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (monitorBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_empty()))\n      printDataContent(art.Empty())\n\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_front_pressure: Option[Base_Types.Bits] = slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.getfront_pressure()\n      val apiUsage_rear_pressure: Option[Base_Types.Bits] = slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.getrear_pressure()\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api.get.setfront_inflate(Base_Types.Bits_empty())\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.setfront_inflate(Base_Types.Bits_empty())\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_initialization_api.get.setrear_inflate(Base_Types.Bits_empty())\n      slang_embedded.wms.tire_monitor_impl_tire_p_monitor_Bridge.c_operational_api.get.setrear_inflate(Base_Types.Bits_empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\n@ext object tire_monitor_impl_tire_p_monitor_seL4Nix {\n  \/\/ returns T if seL4's front_pressure port is empty, F otherwise \n  def front_pressure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's front_pressure port \n  def front_pressure_Receive(): Option[DataContent] = $\n\n  \/\/ returns T if seL4's rear_pressure port is empty, F otherwise \n  def rear_pressure_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's rear_pressure port \n  def rear_pressure_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's front_inflate port\n  def front_inflate_Send(d: DataContent): Unit = $\n\n  \/\/ send payload 'd' to components connected to seL4's rear_inflate port\n  def rear_inflate_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/tire_monitor_impl_tire_p_monitor_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\nobject tire_monitor_impl_tire_p_monitor_seL4Nix_Ext {\n  def front_pressure_IsEmpty(): B = halt(\"stub\")\n\n  def front_pressure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def rear_pressure_IsEmpty(): B = halt(\"stub\")\n\n  def rear_pressure_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def front_inflate_Send(d: DataContent): Unit = halt(\"stub\")\n\n  def rear_inflate_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef TIRE_MONITOR_IMPL_TIRE_P_MONITOR_H\n#define TIRE_MONITOR_IMPL_TIRE_P_MONITOR_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.c",
        {
          "type" : "TestResource",
          "content" : "#include <tire_monitor_impl_tire_p_monitor_api.h>\n#include <tire_monitor_impl_tire_p_monitor.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_MonitorPacket_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_wms_MonitorPacket_impl, numBytes_slang_embedded_wms_MonitorPacket_impl);\n  api_send_front_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF numBits_slang_embedded_wms_MonitorPacket_impl, t0);\n\n  uint8_t t1[numBytes_slang_embedded_wms_MonitorPacket_impl];\n  byte_array_default(SF t1, numBits_slang_embedded_wms_MonitorPacket_impl, numBytes_slang_embedded_wms_MonitorPacket_impl);\n  api_send_rear_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF numBits_slang_embedded_wms_MonitorPacket_impl, t1);\n\n  api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise_\", 0);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_SensorPacket_impl];\n  size_t t0_numBits;\n  if(api_get_front_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_wms_SensorPacket_impl, \"numBits received does not match expected\");\n\n    DeclNewString(front_pressure_str);\n    String__append(SF (String) &front_pressure_str, string(\"Received on front_pressure: \"));\n    byte_array_string(SF (String) &front_pressure_str, t0, numBytes_slang_embedded_wms_SensorPacket_impl);\n    api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF (String) &front_pressure_str);\n  }\n\n  uint8_t t1[numBytes_slang_embedded_wms_SensorPacket_impl];\n  size_t t1_numBits;\n  if(api_get_rear_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_slang_embedded_wms_SensorPacket_impl, \"numBits received does not match expected\");\n\n    DeclNewString(rear_pressure_str);\n    String__append(SF (String) &rear_pressure_str, string(\"Received on rear_pressure: \"));\n    byte_array_string(SF (String) &rear_pressure_str, t1, numBytes_slang_embedded_wms_SensorPacket_impl);\n    api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF (String) &rear_pressure_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef TIRE_MONITOR_IMPL_TIRE_P_MONITOR_API_H\n#define TIRE_MONITOR_IMPL_TIRE_P_MONITOR_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_front_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_rear_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_send_front_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_send_rear_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <tire_monitor_impl_tire_p_monitor_api.h>\n#include <tire_monitor_impl_tire_p_monitor.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_front_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_get_front_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_24E4CF = Option[slang_embedded.wms.tire_monitor_impl_Operational_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Operational_Api(api);\n  Option_24E4CF_get_(SF (slang_embedded_wms_tire_monitor_impl_Operational_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Operational_Api_getfront_pressure_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_rear_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_get_rear_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_24E4CF = Option[slang_embedded.wms.tire_monitor_impl_Operational_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Operational_Api(api);\n  Option_24E4CF_get_(SF (slang_embedded_wms_tire_monitor_impl_Operational_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Operational_Api_getrear_pressure_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_send_front_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_send_front_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_EE5230 = Option[slang_embedded.wms.tire_monitor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Initialization_Api(api);\n  Option_EE5230_get_(SF (slang_embedded_wms_tire_monitor_impl_Initialization_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api_setfront_inflate_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_send_rear_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_send_rear_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_EE5230 = Option[slang_embedded.wms.tire_monitor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Initialization_Api(api);\n  Option_EE5230_get_(SF (slang_embedded_wms_tire_monitor_impl_Initialization_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api_setrear_inflate_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  \/\/ Option_EE5230 = Option[slang_embedded.wms.tire_monitor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Initialization_Api(api);\n  Option_EE5230_get_(SF (slang_embedded_wms_tire_monitor_impl_Initialization_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_logDebug__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  \/\/ Option_EE5230 = Option[slang_embedded.wms.tire_monitor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Initialization_Api(api);\n  Option_EE5230_get_(SF (slang_embedded_wms_tire_monitor_impl_Initialization_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"api_logError__slang_embedded_wms_tire_monitor_impl_tire_p_monitor\", 0);\n\n  \/\/ Option_EE5230 = Option[slang_embedded.wms.tire_monitor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_tire_monitor_impl_Initialization_Api(api);\n  Option_EE5230_get_(SF (slang_embedded_wms_tire_monitor_impl_Initialization_Api) &api, slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise(\n  STACK_FRAME\n  slang_embedded_wms_tire_monitor_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise\", 0);\n\n  slang_embedded_wms_tire_monitor_impl_tire_p_monitor_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise(\n  STACK_FRAME\n  slang_embedded_wms_tire_monitor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise\", 0);\n\n  slang_embedded_wms_tire_monitor_impl_tire_p_monitor_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered(\n  STACK_FRAME\n  slang_embedded_wms_tire_monitor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_api.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered\", 0);\n\n  slang_embedded_wms_tire_monitor_impl_tire_p_monitor_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <tire_monitor_impl_tire_p_monitor_adapter.h>\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_adapter.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_tire_monitor_impl_tire_p_monitor_monitor_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_adapter.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_tire_monitor_impl_tire_p_monitor_monitor_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_adapter.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_tire_monitor_impl_tire_p_monitor_monitor_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"tire_monitor_impl_tire_p_monitor_adapter.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_entryPoints\", 0);\n\n  return slang_embedded_tire_monitor_impl_tire_p_monitor_monitor_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef TIRE_MONITOR_IMPL_TIRE_P_MONITOR_ADAPTER_H\n#define TIRE_MONITOR_IMPL_TIRE_P_MONITOR_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/bin\/settings_tire_monitor_impl_tire_p_monitor.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(tire_monitor_impl_tire_p_monitor\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/sensor_impl_front_p_sensor\/sensor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.sensor_impl_front_p_sensor\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.wms.sensor_impl_front_p_sensor_seL4Nix\n\nobject sensor extends App {\n\n  val sensorBridge : slang_embedded.wms.sensor_impl_front_p_sensor_Bridge = {\n    val inflate = Port[Base_Types.Bits] (id = 0, name = \"wms_impl_Instance_front_p_sensor_inflate\", mode = DataIn)\n    val pressure = Port[Base_Types.Bits] (id = 1, name = \"wms_impl_Instance_front_p_sensor_pressure\", mode = DataOut)\n\n    slang_embedded.wms.sensor_impl_front_p_sensor_Bridge(\n      id = 0,\n      name = \"wms_impl_Instance_front_p_sensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      inflate = inflate,\n      pressure = pressure\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = sensorBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ inflate: In DataPort Base_Types.Bits\n  val inflate_id: Art.PortId = sensorBridge.inflate.id\n  var inflate_port: Option[DataContent] = noData\n\n  \/\/ pressure: Out DataPort Base_Types.Bits\n  val pressure_id: Art.PortId = sensorBridge.pressure.id\n  var pressure_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == inflate_id) {\n      return inflate_port\n    } else {\n      halt(s\"Unexpected: sensor.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    inflate_port = sensor_impl_front_p_sensor_seL4Nix.inflate_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == pressure_id) {\n      pressure_port = Some(data)\n    } else {\n      halt(s\"Unexpected: sensor.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(pressure_port.nonEmpty) {\n      sensor_impl_front_p_sensor_seL4Nix.pressure_Send(pressure_port.get)\n      pressure_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (sensorBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_empty()))\n      printDataContent(art.Empty())\n\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_inflate: Option[Base_Types.Bits] = slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_operational_api.get.getinflate()\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_initialization_api.get.setpressure(Base_Types.Bits_empty())\n      slang_embedded.wms.sensor_impl_front_p_sensor_Bridge.c_operational_api.get.setpressure(Base_Types.Bits_empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/sensor_impl_front_p_sensor_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\n@ext object sensor_impl_front_p_sensor_seL4Nix {\n  \/\/ returns T if seL4's inflate port is empty, F otherwise \n  def inflate_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's inflate port \n  def inflate_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's pressure port\n  def pressure_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/sensor_impl_front_p_sensor_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\nobject sensor_impl_front_p_sensor_seL4Nix_Ext {\n  def inflate_IsEmpty(): B = halt(\"stub\")\n\n  def inflate_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def pressure_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_FRONT_P_SENSOR_H\n#define SENSOR_IMPL_FRONT_P_SENSOR_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_front_p_sensor_api.h>\n#include <sensor_impl_front_p_sensor.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_SensorPacket_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_wms_SensorPacket_impl, numBytes_slang_embedded_wms_SensorPacket_impl);\n  api_send_pressure__slang_embedded_wms_sensor_impl_front_p_sensor(SF numBits_slang_embedded_wms_SensorPacket_impl, t0);\n\n  api_logInfo__slang_embedded_wms_sensor_impl_front_p_sensor(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_wms_sensor_impl_front_p_sensor(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_wms_sensor_impl_front_p_sensor(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_finalise_\", 0);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_MonitorPacket_impl];\n  size_t t0_numBits;\n  if(api_get_inflate__slang_embedded_wms_sensor_impl_front_p_sensor(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_wms_MonitorPacket_impl, \"numBits received does not match expected\");\n\n    DeclNewString(inflate_str);\n    String__append(SF (String) &inflate_str, string(\"Received on inflate: \"));\n    byte_array_string(SF (String) &inflate_str, t0, numBytes_slang_embedded_wms_MonitorPacket_impl);\n    api_logInfo__slang_embedded_wms_sensor_impl_front_p_sensor(SF (String) &inflate_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_FRONT_P_SENSOR_API_H\n#define SENSOR_IMPL_FRONT_P_SENSOR_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_inflate__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_send_pressure__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_front_p_sensor_api.h>\n#include <sensor_impl_front_p_sensor.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_inflate__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"api_get_inflate__slang_embedded_wms_sensor_impl_front_p_sensor\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_169E49 = Option[slang_embedded.wms.sensor_impl_Operational_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Operational_Api(api);\n  Option_169E49_get_(SF (slang_embedded_wms_sensor_impl_Operational_Api) &api, slang_embedded_wms_sensor_impl_front_p_sensor_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Operational_Api_getinflate_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_send_pressure__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"api_send_pressure__slang_embedded_wms_sensor_impl_front_p_sensor\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_front_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_setpressure_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"api_logInfo__slang_embedded_wms_sensor_impl_front_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_front_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"api_logDebug__slang_embedded_wms_sensor_impl_front_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_front_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_wms_sensor_impl_front_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"api_logError__slang_embedded_wms_sensor_impl_front_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_front_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_initialise(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_initialise\", 0);\n\n  slang_embedded_wms_sensor_impl_front_p_sensor_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_finalise(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_finalise\", 0);\n\n  slang_embedded_wms_sensor_impl_front_p_sensor_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered\", 0);\n\n  slang_embedded_wms_sensor_impl_front_p_sensor_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_front_p_sensor_adapter.h>\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_sensor_impl_front_p_sensor_sensor_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_sensor_impl_front_p_sensor_sensor_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_sensor_impl_front_p_sensor_sensor_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_wms_sensor_impl_front_p_sensor_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_front_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_adapter_entryPoints\", 0);\n\n  return slang_embedded_sensor_impl_front_p_sensor_sensor_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_FRONT_P_SENSOR_ADAPTER_H\n#define SENSOR_IMPL_FRONT_P_SENSOR_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_wms_sensor_impl_front_p_sensor_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/bin\/settings_sensor_impl_front_p_sensor.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(sensor_impl_front_p_sensor\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/sensor_impl_rear_p_sensor\/sensor.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.sensor_impl_rear_p_sensor\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.wms.sensor_impl_rear_p_sensor_seL4Nix\n\nobject sensor extends App {\n\n  val sensorBridge : slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge = {\n    val inflate = Port[Base_Types.Bits] (id = 0, name = \"wms_impl_Instance_rear_p_sensor_inflate\", mode = DataIn)\n    val pressure = Port[Base_Types.Bits] (id = 1, name = \"wms_impl_Instance_rear_p_sensor_pressure\", mode = DataOut)\n\n    slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge(\n      id = 0,\n      name = \"wms_impl_Instance_rear_p_sensor\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      inflate = inflate,\n      pressure = pressure\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = sensorBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ inflate: In DataPort Base_Types.Bits\n  val inflate_id: Art.PortId = sensorBridge.inflate.id\n  var inflate_port: Option[DataContent] = noData\n\n  \/\/ pressure: Out DataPort Base_Types.Bits\n  val pressure_id: Art.PortId = sensorBridge.pressure.id\n  var pressure_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == inflate_id) {\n      return inflate_port\n    } else {\n      halt(s\"Unexpected: sensor.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    inflate_port = sensor_impl_rear_p_sensor_seL4Nix.inflate_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == pressure_id) {\n      pressure_port = Some(data)\n    } else {\n      halt(s\"Unexpected: sensor.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(pressure_port.nonEmpty) {\n      sensor_impl_rear_p_sensor_seL4Nix.pressure_Send(pressure_port.get)\n      pressure_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (sensorBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_empty()))\n      printDataContent(art.Empty())\n\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_inflate: Option[Base_Types.Bits] = slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_operational_api.get.getinflate()\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_initialization_api.get.setpressure(Base_Types.Bits_empty())\n      slang_embedded.wms.sensor_impl_rear_p_sensor_Bridge.c_operational_api.get.setpressure(Base_Types.Bits_empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/sensor_impl_rear_p_sensor_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\n@ext object sensor_impl_rear_p_sensor_seL4Nix {\n  \/\/ returns T if seL4's inflate port is empty, F otherwise \n  def inflate_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's inflate port \n  def inflate_Receive(): Option[DataContent] = $\n\n  \/\/ send payload 'd' to components connected to seL4's pressure port\n  def pressure_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/wms\/sensor_impl_rear_p_sensor_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.wms\n\nimport org.sireum._\nimport art._\n\nobject sensor_impl_rear_p_sensor_seL4Nix_Ext {\n  def inflate_IsEmpty(): B = halt(\"stub\")\n\n  def inflate_Receive(): Option[DataContent] = halt(\"stub\")\n\n  def pressure_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_REAR_P_SENSOR_H\n#define SENSOR_IMPL_REAR_P_SENSOR_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_rear_p_sensor_api.h>\n#include <sensor_impl_rear_p_sensor.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_SensorPacket_impl];\n  byte_array_default(SF t0, numBits_slang_embedded_wms_SensorPacket_impl, numBytes_slang_embedded_wms_SensorPacket_impl);\n  api_send_pressure__slang_embedded_wms_sensor_impl_rear_p_sensor(SF numBits_slang_embedded_wms_SensorPacket_impl, t0);\n\n  api_logInfo__slang_embedded_wms_sensor_impl_rear_p_sensor(SF string(\"Example logInfo\"));\n\n  api_logDebug__slang_embedded_wms_sensor_impl_rear_p_sensor(SF string(\"Example logDebug\"));\n\n  api_logError__slang_embedded_wms_sensor_impl_rear_p_sensor(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_finalise_\", 0);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_slang_embedded_wms_MonitorPacket_impl];\n  size_t t0_numBits;\n  if(api_get_inflate__slang_embedded_wms_sensor_impl_rear_p_sensor(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_slang_embedded_wms_MonitorPacket_impl, \"numBits received does not match expected\");\n\n    DeclNewString(inflate_str);\n    String__append(SF (String) &inflate_str, string(\"Received on inflate: \"));\n    byte_array_string(SF (String) &inflate_str, t0, numBytes_slang_embedded_wms_MonitorPacket_impl);\n    api_logInfo__slang_embedded_wms_sensor_impl_rear_p_sensor(SF (String) &inflate_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_REAR_P_SENSOR_API_H\n#define SENSOR_IMPL_REAR_P_SENSOR_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_inflate__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_send_pressure__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_rear_p_sensor_api.h>\n#include <sensor_impl_rear_p_sensor.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_inflate__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"api_get_inflate__slang_embedded_wms_sensor_impl_rear_p_sensor\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_169E49 = Option[slang_embedded.wms.sensor_impl_Operational_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Operational_Api(api);\n  Option_169E49_get_(SF (slang_embedded_wms_sensor_impl_Operational_Api) &api, slang_embedded_wms_sensor_impl_rear_p_sensor_Bridge_c_operational_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Operational_Api_getinflate_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_send_pressure__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"api_send_pressure__slang_embedded_wms_sensor_impl_rear_p_sensor\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_rear_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_setpressure_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"api_logInfo__slang_embedded_wms_sensor_impl_rear_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_rear_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"api_logDebug__slang_embedded_wms_sensor_impl_rear_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_rear_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_wms_sensor_impl_rear_p_sensor(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"api_logError__slang_embedded_wms_sensor_impl_rear_p_sensor\", 0);\n\n  \/\/ Option_F8A8F9 = Option[slang_embedded.wms.sensor_impl_Initialization_Api]\n  DeclNewslang_embedded_wms_sensor_impl_Initialization_Api(api);\n  Option_F8A8F9_get_(SF (slang_embedded_wms_sensor_impl_Initialization_Api) &api, slang_embedded_wms_sensor_impl_rear_p_sensor_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_wms_sensor_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_initialise(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_initialise\", 0);\n\n  slang_embedded_wms_sensor_impl_rear_p_sensor_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_finalise(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_finalise\", 0);\n\n  slang_embedded_wms_sensor_impl_rear_p_sensor_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered(\n  STACK_FRAME\n  slang_embedded_wms_sensor_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_api.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered\", 0);\n\n  slang_embedded_wms_sensor_impl_rear_p_sensor_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <sensor_impl_rear_p_sensor_adapter.h>\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_sensor_impl_rear_p_sensor_sensor_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_sensor_impl_rear_p_sensor_sensor_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_sensor_impl_rear_p_sensor_sensor_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"sensor_impl_rear_p_sensor_adapter.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_entryPoints\", 0);\n\n  return slang_embedded_sensor_impl_rear_p_sensor_sensor_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/etc_seL4\/adapters\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SENSOR_IMPL_REAR_P_SENSOR_ADAPTER_H\n#define SENSOR_IMPL_REAR_P_SENSOR_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/bin\/settings_sensor_impl_rear_p_sensor.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(sensor_impl_rear_p_sensor\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <ext.h>\n\n\/\/ add c extension code here\n\n\/\/ example method that sets the first numBits bits of byteArray to 1\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_default\", 0);\n\n  sfAssert(SF (numBits - 1) \/ 8  + 1 <= numBytes, \"\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    uint8_t v = 0;\n    for(uint8_t bit = 0; bit < 8; bit++) {\n      if(byte * 8 + bit < numBits) {\n        v |= 1UL << bit;\n      }\n    }\n    byteArray[byte] = v;\n  }\n}\n\n\/\/ example method that places the hex value of byteArray into str\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_string\", 0);\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    U8_string_(SF str, byteArray[byte]);\n    String__append(SF str, string(\" \"));\n  }\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n#include <all.h>\n\nconst static size_t numBits_slang_embedded_wms_SensorPacket_impl = 32; \/\/ bit-codec size for slang_embedded_wms_SensorPacket_impl\nconst static size_t numBytes_slang_embedded_wms_SensorPacket_impl = (numBits_slang_embedded_wms_SensorPacket_impl - 1) \/ 8 + 1;\n\nconst static size_t numBits_slang_embedded_wms_MonitorPacket_impl = 1; \/\/ bit-codec size for slang_embedded_wms_MonitorPacket_impl\nconst static size_t numBytes_slang_embedded_wms_MonitorPacket_impl = (numBits_slang_embedded_wms_MonitorPacket_impl - 1) \/ 8 + 1;\n\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes);\n\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes);\n#endif",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_empty()))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/bin\/transpile-sel4.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/tire_monitor_impl_tire_p_monitor\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/wms${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/tire_monitor_impl_tire_p_monitor\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"tire_monitor_impl_tire_p_monitor\" \\\n  --apps \"slang_embedded.tire_monitor_impl_tire_p_monitor.monitor\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 4 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=4;IS[Z,art.UConnection]=1;IS[Z,B]=32\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=4\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_tire_monitor_impl_tire_p_monitor.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.tire_monitor_impl_tire_p_monitor.monitor\" \\\n  --stack-size \"61440\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor_adapter.c\" \\\n  --exclude-build \"slang_embedded.wms.tire_monitor_impl_tire_p_monitor,slang_embedded.wms.sensor_impl_front_p_sensor,slang_embedded.wms.sensor_impl_rear_p_sensor\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/sensor_impl_front_p_sensor\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/wms${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/sensor_impl_front_p_sensor\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"sensor_impl_front_p_sensor\" \\\n  --apps \"slang_embedded.sensor_impl_front_p_sensor.sensor\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1;IS[Z,B]=32\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_sensor_impl_front_p_sensor.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.sensor_impl_front_p_sensor.sensor\" \\\n  --stack-size \"61440\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor_adapter.c\" \\\n  --exclude-build \"slang_embedded.wms.tire_monitor_impl_tire_p_monitor,slang_embedded.wms.sensor_impl_front_p_sensor,slang_embedded.wms.sensor_impl_rear_p_sensor\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/sensor_impl_rear_p_sensor\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/wms${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/sensor_impl_rear_p_sensor\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"sensor_impl_rear_p_sensor\" \\\n  --apps \"slang_embedded.sensor_impl_rear_p_sensor.sensor\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 2 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=2;IS[Z,art.UConnection]=1;IS[Z,B]=32\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=2\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_sensor_impl_rear_p_sensor.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.sensor_impl_rear_p_sensor.sensor\" \\\n  --stack-size \"61440\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc_seL4\/adapters\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor_adapter.c\" \\\n  --exclude-build \"slang_embedded.wms.tire_monitor_impl_tire_p_monitor,slang_embedded.wms.sensor_impl_front_p_sensor,slang_embedded.wms.sensor_impl_rear_p_sensor\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"SlangTypeLibrary\" \\\n  --apps \"slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --sequence \"IS[Z,B]=32\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --lib-only \\\n  --verbose",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    ArtDebug_Ext.start()\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 3\n  val maxPorts: PortId = 8\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill is included with Sireum Kekinian: https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill slang_embedded.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n slang-embedded ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w slang_embedded.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `slang_embedded` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.sireum.version.scala\n  val scalaVer = \"2.13.5\"\n\n  \/\/ versions.properties key: org.sireum.version.scalatest\n  val scalaTestVersion = \"3.2.5\"\n\n  \/\/ versions.properties key: org.sireum.version.scalac-plugin\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210223.b70a539\n  val sireumScalacVersion = \"4.20210223.b70a539\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210302.b346025\n  val kekinianVersion = \"4.20210302.b346025\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"slang_embedded.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"slang_embedded.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/slang_embedded\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val wms_impl_Instance = slangEmbeddedProject(\"wms_impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.sireum.version.scala\nval scalaVer = \"2.13.5\"\n\n\/\/ versions.properties key: org.sireum.version.scalatest\nval scalaTestVersion = \"3.2.5\"\n\n\/\/ versions.properties key: org.sireum.version.scalac-plugin\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210223.b70a539\nval sireumScalacVersion = \"4.20210223.b70a539\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210302.b346025\nval kekinianVersion = \"4.20210302.b346025\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.Demo\"),\n\n  mainClass in assembly := Some(\"slang_embedded.Demo\"),\n  assemblyJarName in assembly := \"wms_impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.camkes",
        {
          "type" : "TestResource",
          "content" : "component tire_monitor_impl_tire_p_monitor {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_front_pressure;\n  dataport sp_union_art_DataContent_t sb_rear_pressure;\n  dataport sp_union_art_DataContent_t sb_front_inflate;\n  dataport sp_union_art_DataContent_t sb_rear_inflate;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.camkes",
        {
          "type" : "TestResource",
          "content" : "component sensor_impl_front_p_sensor {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_inflate;\n  dataport sp_union_art_DataContent_t sb_pressure;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.camkes",
        {
          "type" : "TestResource",
          "content" : "component sensor_impl_rear_p_sensor {\n  include <sb_types.h>;\n  include <sp_union_art_DataContent.h>;\n  control;\n  emits TickTock sb_self_pacer_tick;\n  consumes TickTock sb_self_pacer_tock;\n  dataport sp_union_art_DataContent_t sb_inflate;\n  dataport sp_union_art_DataContent_t sb_pressure;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/wms_impl_Instance.camkes",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport \"components\/tire_monitor_impl_tire_p_monitor\/tire_monitor_impl_tire_p_monitor.camkes\";\nimport \"components\/sensor_impl_front_p_sensor\/sensor_impl_front_p_sensor.camkes\";\nimport \"components\/sensor_impl_rear_p_sensor\/sensor_impl_rear_p_sensor.camkes\";\n\nassembly {\n  composition {\n    component tire_monitor_impl_tire_p_monitor tire_p_monitor;\n    component sensor_impl_front_p_sensor front_p_sensor;\n    component sensor_impl_rear_p_sensor rear_p_sensor;\n\n    connection seL4SharedData conn1(from tire_p_monitor.sb_front_inflate, to front_p_sensor.sb_inflate);\n    connection seL4SharedData conn2(from tire_p_monitor.sb_rear_inflate, to rear_p_sensor.sb_inflate);\n    connection seL4SharedData conn3(from front_p_sensor.sb_pressure, to tire_p_monitor.sb_front_pressure);\n    connection seL4SharedData conn4(from rear_p_sensor.sb_pressure, to tire_p_monitor.sb_rear_pressure);\n    connection seL4Notification conn5(from tire_p_monitor.sb_self_pacer_tick, to tire_p_monitor.sb_self_pacer_tock);\n    connection seL4Notification conn6(from front_p_sensor.sb_self_pacer_tick, to front_p_sensor.sb_self_pacer_tock);\n    connection seL4Notification conn7(from rear_p_sensor.sb_self_pacer_tick, to rear_p_sensor.sb_self_pacer_tock);\n  }\n\n  configuration {\n    tire_p_monitor._stack_size = 61440;\n    tire_p_monitor._domain = 2;\n    front_p_sensor._stack_size = 61440;\n    front_p_sensor._domain = 3;\n    rear_p_sensor._stack_size = 61440;\n    rear_p_sensor._domain = 4;\n    conn1.size = 4096;\n    tire_p_monitor.sb_front_inflate_access = \"W\";\n    front_p_sensor.sb_inflate_access = \"R\";\n    conn2.size = 4096;\n    tire_p_monitor.sb_rear_inflate_access = \"W\";\n    rear_p_sensor.sb_inflate_access = \"R\";\n    conn3.size = 4096;\n    front_p_sensor.sb_pressure_access = \"W\";\n    tire_p_monitor.sb_front_pressure_access = \"R\";\n    conn4.size = 4096;\n    rear_p_sensor.sb_pressure_access = \"W\";\n    tire_p_monitor.sb_rear_pressure_access = \"R\";\n\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/types\/includes\/seqNum.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef _SEQNUM_H_\n#define _SEQNUM_H_\n\n\/\/ Typedef for seqNum to make it easy to change the type. Keep these consistent!\ntypedef uintmax_t seqNum_t;\n#define SEQNUM_MAX UINTMAX_MAX\n#define PRIseqNum PRIuMAX\n\n\/\/ DIRTY_SEQ_NUM is used to mark a sampling port message as dirty while it is\n\/\/ being writen. DIRTY_SEQ_NUM is not a valid sequence number. Valid sequence\n\/\/ numbers are from 0 to DIRTY_SEQ_NUM-1 is never a valid sequence number.\nstatic const seqNum_t DIRTY_SEQ_NUM = SEQNUM_MAX;\n\n#endif",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/types\/includes\/sp_union_art_DataContent.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SP_UNION_ART_DATACONTENT_H\n#define SP_UNION_ART_DATACONTENT_H\n\n#include <sb_types.h>\n#include <seqNum.h>\n\n\/\/ Sampling port message with bool data\ntypedef struct sp_union_art_DataContent {\n\n  \/\/ The sampling port message data.\n  \/\/\n  union_art_DataContent data;\n\n  \/\/ Sequence number incremented by the writer every time the sampling port is\n  \/\/ written. Read by the receiver to detect dropped messages and incoherent\n  \/\/ message reads.  An incoherent message is one that is formed of parts of\n  \/\/ more than one message.  An incoherent message can occur when writing\n  \/\/ happens during read. If the component runs long enough, this counter\n  \/\/ will wrap back to zero.  This causes no problems unless the receiver is\n  \/\/ delayed for the wrap time. In that case the receiver may not detect\n  \/\/ dropped or incoherent message. But if the receiver is delayed for that\n  \/\/ long the system is probably in a very bad state. Also see DIRTY_SEQ_NUM\n  \/\/ above.\n  \/\/\n  \/\/ TODO: Currently using ggc builtin _Atomic. Would like to use c11 std, but\n  \/\/ have not figured out how to do this int the seL4 cmake build environment.\n  _Atomic seqNum_t seqNum;  \n\n} sp_union_art_DataContent_t;\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum);\n\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum);\n\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum);\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/types\/src\/sp_union_art_DataContent.c",
        {
          "type" : "TestResource",
          "content" : "#include <sp_union_art_DataContent.h>\n\nvoid init_sp_union_art_DataContent(sp_union_art_DataContent_t *port, seqNum_t *seqNum) {\n  *seqNum = 0; \/\/ First message sequence number will be 1.\n  port->seqNum = DIRTY_SEQ_NUM;\n}\n\n\/\/ Write message to a sampling port (data type: int)\n\/\/\n\/\/ Returns true when successful. Otherwise returns false. Currently there is no\n\/\/ way to fail and true is always returned. But this may change in the\n\/\/ future. seqNum is incremented when a message is successfully sent. seqNum\n\/\/ should not be modified otherwise.\n\/\/\n\/\/ TODO: Encapsulate this better. seqNum state should be maintained internally. Possible solutions:\n\/\/\n\/\/    - Allow write to have read access to dataport. Then seqNum is simply in the data port.\n\/\/\n\/\/    - Create a wrapper struct.\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_RELEASE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool write_sp_union_art_DataContent(sp_union_art_DataContent_t *port, const union_art_DataContent *data, seqNum_t *seqNum) {\n  \/\/ Mark the message dirty BEFORE we start writing.\n  port->seqNum = DIRTY_SEQ_NUM;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Write the data\n  port->data = *data;\n  \/\/ Increment the sequence number. We are the only writer of seqNum, so\n  \/\/ increment does not have to be atomic.\n  *seqNum = (*seqNum + 1) % DIRTY_SEQ_NUM;\n  port->seqNum = *seqNum;\n  \/\/ Release memory fence - ensure write above to seqNum happens BEFORE continuing\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n  \/\/ Can't fail for now.\n  return true;\n}\n\n\/\/ Read a message from a sampling port (data type: int)\n\/\/\n\/\/ Return true upon successful read. Data is updated with the read\n\/\/ message. The sequence number of the message is also returned. The message,\n\/\/ might be tha same previously read. The sequences number can be used to\n\/\/ detect rereading the same message or dropped messages.\n\/\/\n\/\/ Return false if we fail to read a message. For now the only way to fail is\n\/\/ when we detect the possibility of a write during read. In this case data\n\/\/ may be incoherent and should not be used. Sequence number is set to\n\/\/ DIRTY_SEQ_NUM;\n\/\/\n\/\/ TODO: Currently using ggc builtin __atomic_thread_fence(__ATOMIC_ACQUIRE).\n\/\/ Would like to use c11 std, but have not figured out how to do this int the\n\/\/ seL4 cmake build environment.\nbool read_sp_union_art_DataContent(sp_union_art_DataContent_t *port, union_art_DataContent *data, seqNum_t *seqNum) {\n  seqNum_t newSeqNum = port->seqNum;\n  \/\/ Acquire memory fence - Read seqNum BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  *data = port->data;\n  \/\/ Acquire memory fence - Read data BEFORE reading seqNum again \n  \/\/atomic_thread_fence(memory_order_acquire);\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n  \/\/ The following logic will NOT catch case where the writer wrapped\n  \/\/ sequence numbers since our last read. For this to happen, this reader\n  \/\/ would have to be delayed for the entire time to wrap. \n  if (newSeqNum != DIRTY_SEQ_NUM && newSeqNum == port->seqNum) {\n    \/\/ Message data is good.  Write did not occur during read. \n    *seqNum = newSeqNum;\n    return true;\n  } else {\n    \/\/ Writer may have updated data while we were reading. Do not use possibly incoherent data.\n    *seqNum = DIRTY_SEQ_NUM;\n    return false;\n  }\n}\n\nbool is_empty_sp_union_art_DataContent(sp_union_art_DataContent_t *port) {\n  return port->seqNum == DIRTY_SEQ_NUM;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/CMake_CakeMlOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(CAKEML_DUMP_BUFFERS\n       \"Print the contents of byte-arrays being sent to CakeML\"\n       OFF)\n\nif(CAKEML_DUMP_BUFFERS OR \"$ENV{CAKEML_DUMP_BUFFERS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_DUMP_BUFFERS)\nendif()\n\noption(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n       \"Print warning messages if byte-arrays being sent to CakeML are larger than expected\"\n       OFF)\n\nif(CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS OR \"$ENV{CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS)\nendif()\n\noption(CAKEML_ASSEMBLIES_PRESENT\n       \"Enable if CakeML assembly files have been included\"\n       OFF)\n\nif(CAKEML_ASSEMBLIES_PRESENT OR \"$ENV{CAKEML_ASSEMBLIES_PRESENT}\" STREQUAL \"ON\")\n   add_definitions(-DCAKEML_ASSEMBLIES_PRESENT)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (wms_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_CakeMlOptions.cmake)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/tire_monitor_impl_tire_p_monitor)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/sensor_impl_front_p_sensor)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/sensor_impl_rear_p_sensor)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nDeclareCAmkESComponent(tire_monitor_impl_tire_p_monitor\n  SOURCES components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl_ffi.c components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl.S components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/tire_monitor_impl_tire_p_monitor\/includes\/ types\/includes types\/includes types\/includes types\/includes types\/includes\n  LIBS tire_monitor_impl_tire_p_monitor\n)\n\nDeclareCAmkESComponent(sensor_impl_front_p_sensor\n  SOURCES components\/sensor_impl_front_p_sensor\/src\/sb_sensor_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/sensor_impl_front_p_sensor\/includes\/ types\/includes types\/includes types\/includes\n  LIBS sensor_impl_front_p_sensor\n)\n\nDeclareCAmkESComponent(sensor_impl_rear_p_sensor\n  SOURCES components\/sensor_impl_rear_p_sensor\/src\/sb_sensor_impl.c types\/src\/sp_union_art_DataContent.c types\/src\/sp_union_art_DataContent.c\n  INCLUDES components\/sensor_impl_rear_p_sensor\/includes\/ types\/includes types\/includes types\/includes\n  LIBS sensor_impl_rear_p_sensor\n)\n\nDeclareCAmkESRootserver(wms_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:s\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"  -c, --camkes-dir      Location of CAmkES project\"\n  echo \"  -n, --non-interactive Non-interactive mode.  Will not prompt before deleting apps and build directories\"\n  echo \"  -o, --camkes-options  CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"  -s, --simulate        Simulate via QEMU\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes project directory.\"\n  echo \"See https:\/\/docs.sel4.systems\/projects\/camkes\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\nif [ \"${SIMULATE}\" = true ]; then\n  .\/simulate\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "wms--SeL4\/components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl_ffi.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <all.h>\n#include <camkes.h>\n#include <stdbool.h>\n#include <tire_monitor_impl_tire_p_monitor_api.h>\n#include <tire_monitor_impl_tire_p_monitor_adapter.h>\n\nslang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints entryPoints;\nIS_82ABD8 event_in_port_ids;\nIS_82ABD8 data_in_port_ids;\nIS_82ABD8 event_out_port_ids;\nIS_82ABD8 data_out_port_ids;\nbool initialized = false;\n\nvoid init(STACK_FRAME_ONLY) {\n  if(!initialized) {\n    DeclNewStackFrame(caller, \"sb_tire_monitor_impl_ffi.c\", \"\", \"init\", 0);\n\n    entryPoints = (slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_entryPoints(SF_LAST);\n    event_in_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n    data_in_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n    event_out_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n    data_out_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n    initialized = true;\n  }\n}\n\nvoid ffiinitializeComponent(unsigned char *parameter, long parameterSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiinitializeComponent\", 0);\n\n  entryPoints = (slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_entryPoints(SF_LAST);\n  event_in_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_eventInPortIds_(entryPoints);\n  data_in_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_dataInPortIds_(entryPoints);\n  event_out_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_eventOutPortIds_(entryPoints);\n  data_out_port_ids = (IS_82ABD8) slang_embedded_wms_tire_monitor_impl_tire_p_monitor_Bridge_EntryPoints_dataOutPortIds_(entryPoints);\n}\n\nvoid checkAndReportBufferOverrun(STACK_FRAME long bytesWritten, long bufferSizeBytes) {\n  #ifdef CAKEML_CHECK_AND_REPORT_BUFFER_OVERRUNS\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"checkAndReportBufferOverrun\", 0);\n\n  init(SF_LAST);\n  if (bytesWritten > bufferSizeBytes) {\n    DeclNewString(_str);\n    String str = (String)&_str;\n    String__append(SF str, string(\"Wrote too many bytes to buffer\"));\n    api_logInfo__tire_monitor_impl_tire_p_monitor(SF str);\n  }\n  #endif\n}\n\nvoid dumpBuffer(STACK_FRAME size_t numBits, U8* buffer) {\n  #ifdef CAKEML_DUMP_BUFFERS\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"dumpBuffer\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  String__append(SF str, string(\"[\"));\n  size_t end = ((numBits \/ 8) > 80) ? 80 : (numBits \/ 8);\n  for (int i = 0 ; i < end ; ++i) {\n    U8_string_(SF str, buffer[i]);\n  }\n  String__append(SF str, string(\"]\"));\n  api_logInfo__tire_monitor_impl_tire_p_monitor(SF str);\n  #endif\n}\n\nvoid ffiapi_receiveInput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_receiveInput\", 0);\n\n  init(SF_LAST);\n  art_Art_receiveInput(SF event_in_port_ids, data_in_port_ids);\n}\n\nvoid ffiapi_sendOutput(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_sendOutput\", 0);\n\n  init(SF_LAST);\n  art_Art_sendOutput(SF event_out_port_ids, data_out_port_ids);\n}\n\nvoid ffiapi_logInfo(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_logInfo\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logInfo__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF str);\n} \n\nvoid ffiapi_logDebug(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_logDebug\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logDebug__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF str);\n} \n\nvoid ffiapi_logError(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_logError\", 0);\n\n  init(SF_LAST);\n  DeclNewString(_str);\n  String str = (String)&_str;\n  str->size = parameterSizeBytes;\n  memcpy(str->value, parameter, parameterSizeBytes);\n\n  api_logError__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF str);\n} \n\nvoid ffiapi_get_front_pressure(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_get_front_pressure\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_front_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes-1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_get_rear_pressure(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_get_rear_pressure\", 0);\n\n  init(SF_LAST);\n  size_t numBits = 0;\n  output[0] = api_get_rear_pressure__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF &numBits, (U8 *)(output + 1));\n  checkAndReportBufferOverrun(SF numBits \/ 8, (outputSizeBytes-1));\n  dumpBuffer(SF numBits, output);\n}\n\nvoid ffiapi_send_front_inflate(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_send_front_inflate\", 0);\n\n  init(SF_LAST);\n  api_send_front_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffiapi_send_rear_inflate(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl_ffi.c\", \"\", \"ffiapi_send_rear_inflate\", 0);\n\n  init(SF_LAST);\n  api_send_rear_inflate__slang_embedded_wms_tire_monitor_impl_tire_p_monitor(SF parameterSizeBytes*8, (U8 *)parameter);\n}\n\nvoid ffisb_pacer_notification_wait(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tock_wait();\n  output[0] = 1;\n}\n\nvoid ffisb_pacer_notification_emit(unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes) {\n  sb_self_pacer_tick_emit();\n  output[0] = 1;\n}\n\n\/**\n * Required by the FFI framework\n *\/\n\nvoid ffiwrite (unsigned char *parameter, long parameterSizeBytes, unsigned char *output, long outputSizeBytes){\n}\n\nvoid cml_exit(int arg) {\n  #ifdef DEBUG_FFI\n  {\n    fprintf(stderr,\"GCNum: %d, GCTime(us): %ld\\n\",numGC,microsecs);\n  }\n  #endif\n  exit(arg);\n}\n\n\/\/ convert big-endian 32-bit float to little-endian 64 bit double\nvoid ffifloat2double(unsigned char *parameter, long parameterSizeBytes,\n                     unsigned char *output,    long outputSizeBytes) {\n  char bytes [4];\n  assert (4 == parameterSizeBytes);\n  bytes[3] = parameter[0];\n  bytes[2] = parameter[1];\n  bytes[1] = parameter[2];\n  bytes[0] = parameter[3];\n\n  double result = *((float*)bytes);\n  memcpy(output, (unsigned char*) &result, sizeof(double));\n}\n\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl.S",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ placeholder for CakeML assembly",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/tire_monitor_impl_tire_p_monitor\/src\/sb_tire_monitor_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_tire_monitor_impl.h>\n#include <tire_monitor_impl_tire_p_monitor_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_rear_inflate_seqNum;\n\nseqNum_t sb_front_inflate_seqNum;\n\nseqNum_t sb_rear_pressure_seqNum;\n\nseqNum_t sb_front_pressure_seqNum;\n\n\/*****************************************************************\n * sb_front_pressure_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_front_pressure_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_front_pressure);\n}\n\nbool sb_front_pressure_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_front_pressure, value, &new_seqNum) ) {\n    sb_front_pressure_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\n\/*****************************************************************\n * sb_rear_pressure_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_rear_pressure_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_rear_pressure);\n}\n\nbool sb_rear_pressure_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_rear_pressure, value, &new_seqNum) ) {\n    sb_rear_pressure_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_front_inflate_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_front_inflate, value, &sb_front_inflate_seqNum);\n}\n\nbool sb_rear_inflate_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_rear_inflate, value, &sb_rear_inflate_seqNum);\n}\n\n\/\/ send front_inflate: Out DataPort wms__MonitorPacket_impl\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_front_inflate_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_tire_monitor_impl.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_front_inflate_Send\", 0);\n\n  sb_front_inflate_write(d);\n}\n\n\/\/ send rear_inflate: Out DataPort wms__MonitorPacket_impl\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_rear_inflate_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_tire_monitor_impl.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_rear_inflate_Send\", 0);\n\n  sb_rear_inflate_write(d);\n}\n\n\/\/ is_empty front_pressure: In DataPort\nB slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_front_pressure_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_front_pressure_is_empty();\n}\n\n\/\/ receive front_pressure: In DataPort union_art_DataContent\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_front_pressure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_tire_monitor_impl.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_front_pressure_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_front_pressure_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\n\/\/ is_empty rear_pressure: In DataPort\nB slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_rear_pressure_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_rear_pressure_is_empty();\n}\n\n\/\/ receive rear_pressure: In DataPort union_art_DataContent\nUnit slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_rear_pressure_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_tire_monitor_impl.c\", \"\", \"slang_embedded_wms_tire_monitor_impl_tire_p_monitor_seL4Nix_rear_pressure_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_rear_pressure_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of tire_monitor_impl_tire_p_monitor\\n\");\n\n  \/\/ initialise data structure for data port front_inflate\n  init_sp_union_art_DataContent(sb_front_inflate, &sb_front_inflate_seqNum);\n\n  \/\/ initialise data structure for data port rear_inflate\n  init_sp_union_art_DataContent(sb_rear_inflate, &sb_rear_inflate_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of tire_monitor_impl_tire_p_monitor\\n\");\n}\n\n#ifndef CAKEML_ASSEMBLIES_PRESENT\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_tire_monitor_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_wms_tire_monitor_impl_tire_p_monitor_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/tire_monitor_impl_tire_p_monitor\/includes\/sb_tire_monitor_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_TIRE_MONITOR_IMPL_H\n#define SB_TIRE_MONITOR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_front_pressure_read(union_art_DataContent * value);\n\nbool sb_rear_pressure_read(union_art_DataContent * value);\n\nbool sb_front_inflate_write(const union_art_DataContent * value);\n\nbool sb_rear_inflate_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_TIRE_MONITOR_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_front_p_sensor\/src\/sb_sensor_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_sensor_impl.h>\n#include <sensor_impl_front_p_sensor_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_pressure_seqNum;\n\nseqNum_t sb_inflate_seqNum;\n\n\/*****************************************************************\n * sb_inflate_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_inflate_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_inflate);\n}\n\nbool sb_inflate_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_inflate, value, &new_seqNum) ) {\n    sb_inflate_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_pressure_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_pressure, value, &sb_pressure_seqNum);\n}\n\n\/\/ send pressure: Out DataPort wms__SensorPacket_impl\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_seL4Nix_pressure_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_sensor_impl.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_seL4Nix_pressure_Send\", 0);\n\n  sb_pressure_write(d);\n}\n\n\/\/ is_empty inflate: In DataPort\nB slang_embedded_wms_sensor_impl_front_p_sensor_seL4Nix_inflate_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_inflate_is_empty();\n}\n\n\/\/ receive inflate: In DataPort union_art_DataContent\nUnit slang_embedded_wms_sensor_impl_front_p_sensor_seL4Nix_inflate_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_sensor_impl.c\", \"\", \"slang_embedded_wms_sensor_impl_front_p_sensor_seL4Nix_inflate_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_inflate_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_sensor_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of sensor_impl_front_p_sensor\\n\");\n\n  \/\/ initialise data structure for data port pressure\n  init_sp_union_art_DataContent(sb_pressure, &sb_pressure_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_wms_sensor_impl_front_p_sensor_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of sensor_impl_front_p_sensor\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_sensor_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_wms_sensor_impl_front_p_sensor_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_front_p_sensor\/includes\/sb_sensor_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_SENSOR_IMPL_H\n#define SB_SENSOR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_inflate_read(union_art_DataContent * value);\n\nbool sb_pressure_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_SENSOR_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_rear_p_sensor\/src\/sb_sensor_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_sensor_impl.h>\n#include <sensor_impl_rear_p_sensor_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nseqNum_t sb_pressure_seqNum;\n\nseqNum_t sb_inflate_seqNum;\n\n\/*****************************************************************\n * sb_inflate_is_empty:\n *\n * Helper method to determine if the data infrastructure port has\n * received data\n *\n ****************************************************************\/\nbool sb_inflate_is_empty() {\n  return is_empty_sp_union_art_DataContent(sb_inflate);\n}\n\nbool sb_inflate_read(union_art_DataContent * value) {\n  seqNum_t new_seqNum;\n  if ( read_sp_union_art_DataContent(sb_inflate, value, &new_seqNum) ) {\n    sb_inflate_seqNum = new_seqNum;\n    return true;\n  } else {\n    return false;\n  } \n}\n\nbool sb_pressure_write(const union_art_DataContent * value) {\n  return write_sp_union_art_DataContent(sb_pressure, value, &sb_pressure_seqNum);\n}\n\n\/\/ send pressure: Out DataPort wms__SensorPacket_impl\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_seL4Nix_pressure_Send(\n  STACK_FRAME\n  art_DataContent d) {\n  DeclNewStackFrame(caller, \"sb_sensor_impl.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_seL4Nix_pressure_Send\", 0);\n\n  sb_pressure_write(d);\n}\n\n\/\/ is_empty inflate: In DataPort\nB slang_embedded_wms_sensor_impl_rear_p_sensor_seL4Nix_inflate_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_inflate_is_empty();\n}\n\n\/\/ receive inflate: In DataPort union_art_DataContent\nUnit slang_embedded_wms_sensor_impl_rear_p_sensor_seL4Nix_inflate_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_sensor_impl.c\", \"\", \"slang_embedded_wms_sensor_impl_rear_p_sensor_seL4Nix_inflate_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_inflate_read((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_sensor_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of sensor_impl_rear_p_sensor\\n\");\n\n  \/\/ initialise data structure for data port pressure\n  init_sp_union_art_DataContent(sb_pressure, &sb_pressure_seqNum);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of sensor_impl_rear_p_sensor\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_sensor_impl.c\", \"\", \"run\", 0);\n\n  sb_self_pacer_tick_emit();\n  for(;;) {\n    sb_self_pacer_tock_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_wms_sensor_impl_rear_p_sensor_adapter_computeEntryPoint(SF_LAST);\n    sb_self_pacer_tick_emit();\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/components\/sensor_impl_rear_p_sensor\/includes\/sb_sensor_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_SENSOR_IMPL_H\n#define SB_SENSOR_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_inflate_read(union_art_DataContent * value);\n\nbool sb_pressure_write(const union_art_DataContent * value);\n\n#endif \/\/ SB_SENSOR_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/kernel\/domain_schedule.c",
        {
          "type" : "TestResource",
          "content" : "#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ this file will not be overwritten and is safe to edit\n\n\/************************************************************\n\n   This is a kernel data structure containing an example schedule.\n   The length is in seL4 ticks (2 ms).\n   This schedule should be generated from the AADL model\n   using execution time and data flow latency specifications.\n\n   Pacer runs at highest rate and should always be in domain 1\n\n   Properties from AADL Model\n   --------------------------\n\n     Timing_Properties::Clock_Period : 2 ms\n     Timing_Properties::Frame_Period : 1000 ms\n\n     monitor\n     -------\n\n       CASE_Scheduling::Domain : 2\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 10 ms\n       Timing_Properties::Period : 1000 ms\n\n     sensor\n     ------\n\n       CASE_Scheduling::Domain : 3\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 10 ms\n       Timing_Properties::Period : 1000 ms\n\n     sensor\n     ------\n\n       CASE_Scheduling::Domain : 4\n       Thread_Properties::Dispatch_Protocol : Periodic\n       Timing_Properties::Compute_Execution_Time : 10 ms\n       Timing_Properties::Period : 1000 ms\n\n *********************************************************\/\n\nconst dschedule_t ksDomSchedule[] = {\n  { .domain = 0, .length = 100 },  \/\/ all other seL4 threads, init, 200ms\n  { .domain = 2, .length = 5 },  \/\/ monitor  10ms\n  { .domain = 3, .length = 5 },  \/\/ sensor  10ms\n  { .domain = 4, .length = 5 },  \/\/ sensor  10ms\n  { .domain = 0, .length = 380 },  \/\/ pad rest of frame period\n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/settings.cmake",
        {
          "type" : "TestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 5 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "wms--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sp_union_art_DataContent.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ]
    ]
  }
}