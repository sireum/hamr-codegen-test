{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/data\/slang_embedded\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = org.sireum.B\n\n  type Integer = org.sireum.Z\n\n  type Integer_8 = org.sireum.S8\n  type Integer_16 = org.sireum.S16\n  type Integer_32 = org.sireum.S32\n  type Integer_64 = org.sireum.S64\n\n  type Unsigned_8 = org.sireum.U8\n  type Unsigned_16 = org.sireum.U16\n  type Unsigned_32 = org.sireum.U32\n  type Unsigned_64 = org.sireum.U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = org.sireum.R\n  type Float_32 = org.sireum.F32\n  type Float_64 = org.sireum.F64\n\n  type Character = org.sireum.C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[org.sireum.B]\n\n  @datatype class Boolean_Payload(value: Boolean) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Integer) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: Integer_8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: Integer_16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: Integer_32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: Integer_64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: Unsigned_8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: Unsigned_16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: Unsigned_32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: Unsigned_64) extends art.DataContent\n\n  @datatype class Float_Payload(value: Float) extends art.DataContent\n  @datatype class Float_32_Payload(value: Float_32) extends art.DataContent\n  @datatype class Float_64_Payload(value: Float_64) extends art.DataContent\n\n  @datatype class Character_Payload(value: Character) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: Bits) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val top_impl_Instance_src_process_src_thread : slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge = {\n    val write_port = Port[Base_Types.Integer_8] (id = 0, name = \"top_impl_Instance_src_process_src_thread_write_port\", mode = EventOut)\n\n    slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_src_process_src_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      write_port = write_port\n    )\n  }\n  val top_impl_Instance_dst_process_dst_thread : slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge = {\n    val read_port = Port[Base_Types.Integer_8] (id = 1, name = \"top_impl_Instance_dst_process_dst_thread_read_port\", mode = EventIn)\n\n    slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge(\n      id = 1,\n      name = \"top_impl_Instance_dst_process_dst_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      read_port = read_port\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (top_impl_Instance_src_process_src_thread, top_impl_Instance_dst_process_dst_thread),\n\n      connections = ISZ (Connection(from = top_impl_Instance_src_process_src_thread.write_port, to = top_impl_Instance_dst_process_dst_thread.read_port))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/architecture\/slang_embedded\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage slang_embedded\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_src_process_src_thread_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.test_event_data_port_periodic_domains\n\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass emitter_t_impl_src_process_src_thread_Test extends BridgeTestSuite[emitter_t_impl_src_process_src_thread_Bridge](Arch.top_impl_Instance_src_process_src_thread) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ getter for out EventDataPort\n  def get_write_port(): Option[Base_Types.Integer_8] = {\n    val value: Option[Base_Types.Integer_8] = get_write_port_payload() match {\n      case Some(Base_Types.Integer_8_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port write_port.  Expecting 'Base_Types.Integer_8_Payload' but received ${v}\")\n      case _ => None[Base_Types.Integer_8]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_write_port_payload(): Option[Base_Types.Integer_8_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.write_port_Id).asInstanceOf[Option[Base_Types.Integer_8_Payload]]\n  }\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_src_process_src_thread_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.test_event_data_port_periodic_domains.{emitter_t_impl_src_process_src_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class emitter_t_impl_src_process_src_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  write_port: Port[Base_Types.Integer_8]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(write_port),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ(write_port)\n  )\n\n  val initialization_api : emitter_t_impl_Initialization_Api = {\n    val api = emitter_t_impl_Initialization_Api(\n      id,\n      write_port.id\n    )\n    emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : emitter_t_impl_Operational_Api = {\n    val api = emitter_t_impl_Operational_Api(\n      id,\n      write_port.id\n    )\n    emitter_t_impl_src_process_src_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    emitter_t_impl_src_process_src_thread_Bridge.EntryPoints(\n      id,\n\n      write_port.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject emitter_t_impl_src_process_src_thread_Bridge {\n\n  var c_initialization_api: Option[emitter_t_impl_Initialization_Api] = None()\n  var c_operational_api: Option[emitter_t_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    emitter_t_impl_src_process_src_thread_BridgeId : Art.BridgeId,\n\n    write_port_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: emitter_t_impl_Initialization_Api,\n    operational_api: emitter_t_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(write_port_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait emitter_t_impl_Api {\n  def id: Art.BridgeId\n  def write_port_Id : Art.PortId\n\n  def sendwrite_port(value : Base_Types.Integer_8) : Unit = {\n    Art.putValue(write_port_Id, Base_Types.Integer_8_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class emitter_t_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val write_port_Id : Art.PortId) extends emitter_t_impl_Api\n\n@datatype class emitter_t_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val write_port_Id : Art.PortId) extends emitter_t_impl_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_src_process_src_thread.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject emitter_t_impl_src_process_src_thread {\n\n  def initialise(api: emitter_t_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.sendwrite_port(Base_Types.Integer_8_empty())\n  }\n\n  def timeTriggered(api: emitter_t_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    api.sendwrite_port(Base_Types.Integer_8_empty())\n  }\n\n  def activate(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def finalise(api: emitter_t_impl_Operational_Api): Unit = { }\n\n  def recover(api: emitter_t_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.test_event_data_port_periodic_domains\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[slang_embedded.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/test\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.test_event_data_port_periodic_domains\n\nimport art.{ArtNative_Ext, Empty}\nimport slang_embedded._\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass consumer_t_impl_dst_process_dst_thread_Test extends BridgeTestSuite[consumer_t_impl_dst_process_dst_thread_Bridge](Arch.top_impl_Instance_dst_process_dst_thread) {\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ HELPER FUNCTIONS \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ setter for in EventDataPort\n  def put_read_port(value : Base_Types.Integer_8): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.read_port_Id, Base_Types.Integer_8_Payload(value))\n  }\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\nimport slang_embedded.test_event_data_port_periodic_domains.{consumer_t_impl_dst_process_dst_thread => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class consumer_t_impl_dst_process_dst_thread_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  read_port: Port[Base_Types.Integer_8]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(read_port),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(read_port),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : consumer_t_impl_Initialization_Api = {\n    val api = consumer_t_impl_Initialization_Api(\n      id,\n      read_port.id\n    )\n    consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : consumer_t_impl_Operational_Api = {\n    val api = consumer_t_impl_Operational_Api(\n      id,\n      read_port.id\n    )\n    consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    consumer_t_impl_dst_process_dst_thread_Bridge.EntryPoints(\n      id,\n\n      read_port.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject consumer_t_impl_dst_process_dst_thread_Bridge {\n\n  var c_initialization_api: Option[consumer_t_impl_Initialization_Api] = None()\n  var c_operational_api: Option[consumer_t_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    consumer_t_impl_dst_process_dst_thread_BridgeId : Art.BridgeId,\n\n    read_port_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: consumer_t_impl_Initialization_Api,\n    operational_api: consumer_t_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(read_port_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/bridge\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\n@sig trait consumer_t_impl_Api {\n  def id: Art.BridgeId\n  def read_port_Id : Art.PortId\n\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class consumer_t_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val read_port_Id : Art.PortId) extends consumer_t_impl_Api\n\n@datatype class consumer_t_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val read_port_Id : Art.PortId) extends consumer_t_impl_Api {\n\n  def getread_port() : Option[Base_Types.Integer_8] = {\n    val value : Option[Base_Types.Integer_8] = Art.getValue(read_port_Id) match {\n      case Some(Base_Types.Integer_8_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port read_port.  Expecting 'Base_Types.Integer_8_Payload' but received ${v}\")\n        None[Base_Types.Integer_8]()\n      case _ => None[Base_Types.Integer_8]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport slang_embedded._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject consumer_t_impl_dst_process_dst_thread {\n\n  def initialise(api: consumer_t_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n  }\n\n  def timeTriggered(api: consumer_t_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_read_port: Option[Base_Types.Integer_8] = api.getread_port()\n  }\n\n  def activate(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def finalise(api: consumer_t_impl_Operational_Api): Unit = { }\n\n  def recover(api: consumer_t_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/component\/slang_embedded\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/emitter_t_impl_src_process_src_thread\/src_thread.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.emitter_t_impl_src_process_src_thread\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_seL4Nix\n\nobject src_thread extends App {\n\n  val src_threadBridge : slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge = {\n    val write_port = Port[Base_Types.Integer_8] (id = 0, name = \"top_impl_Instance_src_process_src_thread_write_port\", mode = EventOut)\n\n    slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_src_process_src_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      write_port = write_port\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = src_threadBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ write_port: Out EventDataPort Base_Types.Integer_8\n  val write_port_id: Art.PortId = src_threadBridge.write_port.id\n  var write_port_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    halt(s\"Unexpected: src_thread.getValue called with: ${portId}\")\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    if(portId == write_port_id) {\n      write_port_port = Some(data)\n    } else {\n      halt(s\"Unexpected: src_thread.putValue called with: ${portId}\")\n    }\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    if(write_port_port.nonEmpty) {\n      emitter_t_impl_src_process_src_thread_seL4Nix.write_port_Send(write_port_port.get)\n      write_port_port = noData\n    }\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (src_threadBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Integer_8_Payload(Base_Types.Integer_8_empty()))\n      printDataContent(art.Empty())\n\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.logError(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_initialization_api.get.sendwrite_port(Base_Types.Integer_8_empty())\n      slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread_Bridge.c_operational_api.get.sendwrite_port(Base_Types.Integer_8_empty())\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_src_process_src_thread_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\n@ext object emitter_t_impl_src_process_src_thread_seL4Nix {\n  \/\/ send payload 'd' to components connected to seL4's write_port port\n  def write_port_Send(d: DataContent): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains\/emitter_t_impl_src_process_src_thread_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\nobject emitter_t_impl_src_process_src_thread_seL4Nix_Ext {\n  def write_port_Send(d: DataContent): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n#include <ext.h>\n\n\/\/ add c extension code here",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n#endif",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(STACK_FRAME);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.c",
        {
          "type" : "TestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_api.h>\n#include <emitter_t_impl_src_process_src_thread.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(STACK_FRAME_ONLY) {\n DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_\", 0);\n\n \/\/ example api usage\n\n api_logInfo__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logInfo\"));\n api_logDebug__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logDebug\"));\n api_logError__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_\", 0);\n\n  \/\/ example finalise method\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(STACK_FRAME) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_\", 0);\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_API_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_send_write_port__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  S8 value);\n\nvoid api_logInfo__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_api.h>\n#include <emitter_t_impl_src_process_src_thread.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_send_write_port__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  S8 value) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_send_write_port__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  \/\/ Option_998CD6 = Option[slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api(api);\n  Option_998CD6_get_(SF (slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api_sendwrite_port_(\n    SF\n    &api,\n    value);\n}\n\nvoid api_logInfo__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logInfo__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  \/\/ Option_998CD6 = Option[slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api(api);\n  Option_998CD6_get_(SF (slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logDebug__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  \/\/ Option_998CD6 = Option[slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api(api);\n  Option_998CD6_get_(SF (slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"api_logError__slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread\", 0);\n\n  \/\/ Option_998CD6 = Option[slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api(api);\n  Option_998CD6_get_(SF (slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <emitter_t_impl_src_process_src_thread_adapter.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"emitter_t_impl_src_process_src_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints\", 0);\n\n  return slang_embedded_emitter_t_impl_src_process_src_thread_src_thread_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_ADAPTER_H\n#define EMITTER_T_IMPL_SRC_PROCESS_SRC_THREAD_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_test_event_data_port_periodic_domains_emitter_t_impl_src_process_src_thread_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/bin\/settings_emitter_t_impl_src_process_src_thread.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(emitter_t_impl_src_process_src_thread\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/consumer_t_impl_dst_process_dst_thread\/dst_thread.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.consumer_t_impl_dst_process_dst_thread\n\nimport org.sireum._\nimport art._\nimport art.DispatchPropertyProtocol._\nimport art.PortMode._\nimport slang_embedded._\nimport slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_seL4Nix\n\nobject dst_thread extends App {\n\n  val dst_threadBridge : slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge = {\n    val read_port = Port[Base_Types.Integer_8] (id = 0, name = \"top_impl_Instance_dst_process_dst_thread_read_port\", mode = EventIn)\n\n    slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge(\n      id = 0,\n      name = \"top_impl_Instance_dst_process_dst_thread\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      read_port = read_port\n    )\n  }\n\n  val entryPoints: Bridge.EntryPoints = dst_threadBridge.entryPoints\n  val noData: Option[DataContent] = None()\n\n  \/\/ read_port: In EventDataPort Base_Types.Integer_8\n  val read_port_id: Art.PortId = dst_threadBridge.read_port.id\n  var read_port_port: Option[DataContent] = noData\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    return TimeTriggered()\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    if(portId == read_port_id) {\n      return read_port_port\n    } else {\n      halt(s\"Unexpected: dst_thread.getValue called with: ${portId}\")\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n    read_port_port = consumer_t_impl_dst_process_dst_thread_seL4Nix.read_port_Receive()\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    halt(s\"Unexpected: dst_thread.putValue called with: ${portId}\")\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    \/\/ ignore params\n\n\n  }\n\n  def initialiseArchitecture(): Unit = {\n    val ad = ArchitectureDescription(\n      components = MSZ (dst_threadBridge),\n      connections = ISZ ()\n    )\n    Art.run(ad)\n  }\n\n  def initialiseEntryPoint(): Unit = { entryPoints.initialise() }\n\n  def computeEntryPoint(): Unit = { entryPoints.compute() }\n\n  def finaliseEntryPoint(): Unit = { entryPoints.finalise() }\n\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ need to touch the following for transpiler\n    initialiseArchitecture()\n    initialiseEntryPoint()\n    computeEntryPoint()\n    finaliseEntryPoint()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Integer_8_Payload(Base_Types.Integer_8_empty()))\n      printDataContent(art.Empty())\n\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logInfo(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logDebug(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_initialization_api.get.logError(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logInfo(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logDebug(\"\")\n      slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_read_port: Option[Base_Types.Integer_8] = slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread_Bridge.c_operational_api.get.getread_port()\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {}\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_seL4Nix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\n@ext object consumer_t_impl_dst_process_dst_thread_seL4Nix {\n  \/\/ returns T if seL4's read_port port is empty, F otherwise \n  def read_port_IsEmpty(): B = $\n\n  \/\/ returns result of dequeuing seL4's read_port port \n  def read_port_Receive(): Option[DataContent] = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains\/consumer_t_impl_dst_process_dst_thread_seL4Nix_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package slang_embedded.test_event_data_port_periodic_domains\n\nimport org.sireum._\nimport art._\n\nobject consumer_t_impl_dst_process_dst_thread_seL4Nix_Ext {\n  def read_port_IsEmpty(): B = halt(\"stub\")\n\n  def read_port_Receive(): Option[DataContent] = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(STACK_FRAME);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.c",
        {
          "type" : "TestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_api.h>\n#include <consumer_t_impl_dst_process_dst_thread.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(STACK_FRAME_ONLY) {\n DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_\", 0);\n\n \/\/ example api usage\n\n api_logInfo__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logInfo\"));\n api_logDebug__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logDebug\"));\n api_logError__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(SF string(\"Example logError\"));\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_\", 0);\n\n  \/\/ example finalise method\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(STACK_FRAME) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_\", 0);\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_API_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_read_port__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  S8 *value);\n\nvoid api_logInfo__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_api.h>\n#include <consumer_t_impl_dst_process_dst_thread.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_read_port__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  S8 *value){\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_get_read_port__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  \/\/ Option_844C02 = Option[slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_Operational_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Operational_Api(api);\n  Option_844C02_get_(SF (slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Operational_Api) &api, slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_operational_api(SF_LAST));\n\n  \/\/ Option_FC3847 = Option[S8]\n  \/\/ Some_240B2F = Some[S8]\n  DeclNewOption_FC3847(t_0);\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Operational_Api_getread_port_(\n    SF\n    (Option_FC3847) &t_0,\n    &api);\n\n  if(t_0.type == TSome_240B2F){\n    *value = t_0.Some_240B2F.value;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logInfo__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  \/\/ Option_C6DA2D = Option[slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api(api);\n  Option_C6DA2D_get_(SF (slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logDebug__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  \/\/ Option_C6DA2D = Option[slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api(api);\n  Option_C6DA2D_get_(SF (slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"api_logError__slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread\", 0);\n\n  \/\/ Option_C6DA2D = Option[slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_Initialization_Api]\n  DeclNewslang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api(api);\n  Option_C6DA2D_get_(SF (slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api) &api, slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_Bridge_c_initialization_api(SF_LAST));\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_initialise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_finalise_(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered(\n  STACK_FRAME\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_api.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered\", 0);\n\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.c",
        {
          "type" : "TestResource",
          "content" : "#include <consumer_t_impl_dst_process_dst_thread_adapter.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_initialiseArchitecture(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_initialiseEntryPoint(SF_LAST);\n}\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint\", 0);\n\n  slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_computeEntryPoint(SF_LAST);\n}\n\nart_Bridge_EntryPoints slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"consumer_t_impl_dst_process_dst_thread_adapter.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints\", 0);\n\n  return slang_embedded_consumer_t_impl_dst_process_dst_thread_dst_thread_entryPoints(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/c\/ext-c\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_ADAPTER_H\n#define CONSUMER_T_IMPL_DST_PROCESS_DST_THREAD_ADAPTER_H\n\n#include <all.h>\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(STACK_FRAME_ONLY);\n\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(STACK_FRAME_ONLY);\n\nart_Bridge_EntryPoints slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_entryPoints(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/bin\/settings_consumer_t_impl_dst_process_dst_thread.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(consumer_t_impl_dst_process_dst_thread\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\/SlangTypeLibrary.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage slang_embedded.SlangTypeLibrary\n\nimport org.sireum._\nimport art._\nimport slang_embedded._\n\nobject SlangTypeLibrary extends App {\n  def main(args: ISZ[String]): Z = {\n\n    \/\/ touch each payload\/type in case some are only used as a field in a record\n    def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n    printDataContent(Base_Types.Integer_8_Payload(Base_Types.Integer_8_empty()))\n    printDataContent(art.Empty())\n\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/bin\/settings_SlangTypeLibrary.cmake",
        {
          "type" : "TestResource",
          "content" : "add_definitions(-DCAMKES)\n\nif(TARGET muslc)\n  target_link_libraries(SlangTypeLibrary\n                        muslc)\nendif()",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/bin\/transpile-sel4.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/emitter_t_impl_src_process_src_thread\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/emitter_t_impl_src_process_src_thread\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"emitter_t_impl_src_process_src_thread\" \\\n  --apps \"slang_embedded.emitter_t_impl_src_process_src_thread.src_thread\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=1;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=1\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_emitter_t_impl_src_process_src_thread.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.emitter_t_impl_src_process_src_thread.src_thread\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/emitter_t_impl_src_process_src_thread\/emitter_t_impl_src_process_src_thread_adapter.c\" \\\n  --exclude-build \"slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread,slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/consumer_t_impl_dst_process_dst_thread\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/bridge${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/component${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/test_event_data_port_periodic_domains${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/consumer_t_impl_dst_process_dst_thread\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"consumer_t_impl_dst_process_dst_thread\" \\\n  --apps \"slang_embedded.consumer_t_impl_dst_process_dst_thread.dst_thread\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --sequence \"MS[Z,art.Bridge]=1;MS[Z,MOption[art.Bridge]]=1;IS[Z,art.UPort]=1;IS[Z,art.UConnection]=1\" \\\n  --constants \"art.Art.maxComponents=1;art.Art.maxPorts=1\" \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_consumer_t_impl_dst_process_dst_thread.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.consumer_t_impl_dst_process_dst_thread.dst_thread\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/ext.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_api.c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.h${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/ext-c\/adapters\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread_adapter.c\" \\\n  --exclude-build \"slang_embedded.test_event_data_port_periodic_domains.emitter_t_impl_src_process_src_thread,slang_embedded.test_event_data_port_periodic_domains.consumer_t_impl_dst_process_dst_thread\" \\\n  --lib-only \\\n  --verbose\n\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/..\/slang_libraries\/SlangTypeLibrary\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\/art${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/data${PATH_SEP}${SCRIPT_HOME}\/..\/src\/main\/seL4Nix\/slang_embedded\/SlangTypeLibrary\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"SlangTypeLibrary\" \\\n  --apps \"slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 1 \\\n  --cmake-includes \"+${SCRIPT_HOME}\/settings_SlangTypeLibrary.cmake\" \\\n  --forward \"art.ArtNative=slang_embedded.SlangTypeLibrary.SlangTypeLibrary\" \\\n  --stack-size \"16777216\" \\\n  --stable-type-id \\\n  --lib-only \\\n  --verbose",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 2\n  val maxPorts: PortId = 2\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtDebug_Ext.start()\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example Mill build -- the contents of this file will not be overwritten\n\/\/\n\/\/ To open the following project in VSCode, first follow Sireum Kekinian's\n\/\/ instructions for setting up a development environment using Scala Metals:\n\/\/\n\/\/   https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/\n\/\/ Then open the folder containing this file in VSCode and import the\n\/\/ mill build when asked.\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   mill slang_embedded.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   mill slang_embedded.test\n\ntrait SlangEmbeddedModule extends ScalaModule {\n  val scalaVer = \"2.13.3\"\n\n  val sireumScalacVersion = \"4.20200915.f4b7b0e\" \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20200915.f4b7b0e\n\n  val kekinianVersion = \"4.20200915.72510af\" \/\/ https:\/\/github.com\/sireum\/kekinian\/tree\/4.20200915.72510af\n\n  val scalaTestVersion = \"3.2.2\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(ivy\"org.sireum.kekinian::library::${kekinianVersion}\")\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories ++ Seq(\n    coursier.maven.MavenRepository(\"https:\/\/jitpack.io\/\"),\n  )\n}\n\ntrait AadlModule extends SlangEmbeddedModule {\n  override def sources = T.sources (\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n}\n\ntrait AadlTestModule extends AadlModule {\n  object test extends Tests {\n\n    final override def millSourcePath =\n      super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources(millSourcePath \/ \"bridge\")\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\nobject `slang_embedded` extends AadlTestModule {\n  override def mainClass = T { Some(\"slang_embedded.Demo\") }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ To open the following project in Sireum IVE select 'File > Open ...' and\n\/\/ navigate to the directory containing this file then click 'OK'.  To install\n\/\/ Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\nlazy val top_impl_Instance = slangEmbeddedTestProject(\"top_impl_Instance\", \".\")\n\n\nval scalaVer = \"2.13.3\"\n\nval sireumScalacVersion = \"4.20200915.f4b7b0e\" \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20200915.f4b7b0e\n\nval kekinianVersion = \"4.20200915.72510af\" \/\/ https:\/\/github.com\/sireum\/kekinian\/tree\/4.20200915.72510af\n\nval scalaTestVersion = \"3.2.2\"\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  mainClass in (Compile, run) := Some(\"slang_embedded.Demo\"),\n\n  mainClass in assembly := Some(\"slang_embedded.Demo\"),\n  assemblyJarName in assembly := \"top_impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\ndef standardProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).settings(commonSettings)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedTestProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++\n      Seq(\n        Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n        libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\")\n    )\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/slang-embedded\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM_emitter_t_impl_src_process_src_thread\/VM_emitter_t_impl_src_process_src_thread.camkes",
        {
          "type" : "TestResource",
          "content" : "component VM_emitter_t_impl_src_process_src_thread {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  include <sb_queue_int8_t_1.h>;\n  control;\n  provides VMDTBPassthrough dtb;\n  uses FileServerInterface fs;\n  maybe uses Batch batch;\n  maybe uses PutChar guest_putchar;\n  maybe uses GetChar serial_getchar;\n  maybe uses VirtQueueDev recv;\n  maybe uses VirtQueueDrv send;\n  maybe uses VMDTBPassthrough dtb_self;\n  emits HaveNotification notification_ready_connector;\n  emits ReceiveEvent sb_write_port_1_notification;\n  maybe consumes restart restart_event;\n  consumes HaveNotification notification_ready;\n  consumes Period_VM sb_pacer_period_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_write_port_queue_1;\n  dataport sb_queue_int8_t_1_t sb_pacer_period_queue;\n  has semaphore vm_sem;\n  \/\/ expanding: VM_INIT_DEF()\n  attribute int base_prio;\n  attribute int num_vcpus = 1;\n  attribute int num_extra_frame_caps;\n  attribute int extra_frame_map_address;\n  attribute {\n    string linux_ram_base;\n    string linux_ram_paddr_base;\n    string linux_ram_size;\n    string linux_ram_offset;\n    string dtb_addr;\n    string initrd_max_size;\n    string initrd_addr;\n  } linux_address_config;\n  attribute {\n    string linux_name = \"linux\";\n    string dtb_name = \"linux-dtb\";\n    string initrd_name = \"linux-initrd\";\n    string linux_bootcmdline = \"\";\n    string linux_stdout = \"\";\n  } linux_image_config;\n  \/\/ end of expansion: VM_INIT_DEF()\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.camkes",
        {
          "type" : "TestResource",
          "content" : "component consumer_t_impl_dst_process_dst_thread {\n  include <sb_types.h>;\n  include <sb_queue_union_art_DataContent_1.h>;\n  control;\n  consumes ReceiveEvent sb_read_port_notification;\n  consumes Period sb_pacer_notification;\n  dataport sb_queue_union_art_DataContent_1_t sb_read_port_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/Pacer\/Pacer.camkes",
        {
          "type" : "TestResource",
          "content" : "component Pacer {\n  include <sb_queue_int8_t_1.h>;\n  control;\n  emits Period_VM period_to_vmsrc_process_notification;\n  emits Period period;\n  emits TickTock tick;\n  consumes TickTock tock;\n  dataport sb_queue_int8_t_1_t period_to_vmsrc_process_queue;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/top_impl_Instance.camkes",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\nimport <std_connector.camkes>;\nimport <global-connectors.camkes>;\nimport <seL4VMDTBPassthrough.idl4>;\nimport <FileServerInterface.camkes>;\nimport <FileServer\/FileServer.camkes>;\nimport <SerialServer\/SerialServer.camkes>;\nimport <TimeServer\/TimeServer.camkes>;\nimport <vm-connectors.camkes>;\nimport <devices.camkes>;\nimport \"components\/Pacer\/Pacer.camkes\";\nimport \"components\/VM_emitter_t_impl_src_process_src_thread\/VM_emitter_t_impl_src_process_src_thread.camkes\";\nimport \"components\/consumer_t_impl_dst_process_dst_thread\/consumer_t_impl_dst_process_dst_thread.camkes\";\n\nassembly {\n  composition {\n    component VM_emitter_t_impl_src_process_src_thread vmsrc_process;\n    component FileServer fserv;\n    component SerialServer serial;\n    component TimeServer time_server;\n    component consumer_t_impl_dst_process_dst_thread dst_process_dst_thread;\n    component Pacer pacer;\n\n    connection seL4VMDTBPassthrough conn1(from vmsrc_process.dtb_self, to vmsrc_process.dtb);\n    connection seL4RPCDataport fsvmsrc_process(from vmsrc_process.fs, to fserv.fs_ctrl);\n    connection seL4GlobalAsynch notify_ready_vmsrc_process(from vmsrc_process.notification_ready_connector, to vmsrc_process.notification_ready);\n    connection seL4TimeServer serialserver_timer(from serial.timeout, to time_server.the_timer);\n    connection seL4SerialServer serial_vmsrc_process(from vmsrc_process.batch, to serial.processed_batch);\n    connection seL4SerialServer serial_input_vmsrc_process(from vmsrc_process.serial_getchar, to serial.getchar);\n    connection seL4Notification conn2(from vmsrc_process.sb_write_port_1_notification, to dst_process_dst_thread.sb_read_port_notification);\n    connection seL4SharedDataWithCaps conn3(from vmsrc_process.sb_write_port_queue_1, to dst_process_dst_thread.sb_read_port_queue);\n    connection seL4Notification conn4(from pacer.tick, to pacer.tock);\n    connection seL4GlobalAsynch conn5(from pacer.period_to_vmsrc_process_notification, to vmsrc_process.sb_pacer_period_notification);\n    connection seL4SharedDataWithCaps conn6(from pacer.period_to_vmsrc_process_queue, to vmsrc_process.sb_pacer_period_queue);\n    connection seL4Notification conn7(from pacer.period, to dst_process_dst_thread.sb_pacer_notification);\n  }\n\n  configuration {\n    vmsrc_process.cnode_size_bits = 18;\n    vmsrc_process.simple_untyped21_pool = 12;\n    vmsrc_process.simple_untyped12_pool = 12;\n    vmsrc_process.num_extra_frame_caps = 0;\n    vmsrc_process.extra_frame_map_address = 0;\n    vmsrc_process._domain = 2;\n    dst_process_dst_thread._domain = 3;\n    dst_process_dst_thread.sb_read_port_queue_access = \"R\";\n    pacer._domain = 1;\n\n    fserv.heap_size = 165536;\n    vmsrc_process.fs_shmem_size = 0x100000;\n    vmsrc_process.global_endpoint_base = 1 << 27;\n    vmsrc_process.asid_pool = true;\n    vmsrc_process.simple = true;\n    vmsrc_process.base_prio = 100;\n    vmsrc_process._priority = 101;\n    vmsrc_process.sem_value = 0;\n    vmsrc_process.heap_size = 0x300000;\n    time_server.timers_per_client = 1;\n    time_server.priority = 255;\n    time_server.simple = true;\n    vmsrc_process.serial_getchar_shmem_size = 0x1000;\n    vmsrc_process.batch_shmem_size = 0x1000;\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/CMake_TranspilerOptions.cmake",
        {
          "type" : "TestResource",
          "content" : "option(BOUND_CHECK\n       \"Build the program with sequence bound checking.\"\n       OFF)\n\nif(BOUND_CHECK OR \"$ENV{BOUND_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_BOUND_CHECK)\nendif()\n\noption(NO_PRINT\n       \"Build the program without console output.\"\n       OFF)\n\nif(NO_PRINT OR \"$ENV{NO_PRINT}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_NO_PRINT)\nendif()\n\noption(RANGE_CHECK\n       \"Build the program with range checking.\"\n       OFF)\n\nif(RANGE_CHECK OR \"$ENV{RANGE_CHECK}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_RANGE_CHECK)\nendif()\n\noption(WITH_LOC\n       \"Build the program with Slang location info.\"\n       OFF)\n\nif(WITH_LOC OR \"$ENV{WITH_LOC}\" STREQUAL \"ON\")\n   add_definitions(-DSIREUM_LOC)\nendif()",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject (top_impl_Instance C)\n\nadd_definitions(-DCAMKES)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}\/CMake_TranspilerOptions.cmake)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/emitter_t_impl_src_process_src_thread)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/consumer_t_impl_dst_process_dst_thread)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/slang_libraries\/SlangTypeLibrary)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/types)\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}\/components\/VM)\n\nDeclareCAmkESComponent(consumer_t_impl_dst_process_dst_thread\n  SOURCES components\/consumer_t_impl_dst_process_dst_thread\/src\/sb_consumer_t_impl.c types\/src\/sb_queue_union_art_DataContent_1.c\n  INCLUDES components\/consumer_t_impl_dst_process_dst_thread\/includes\/ types\/includes\n  LIBS consumer_t_impl_dst_process_dst_thread\n)\n\nDeclareCAmkESComponent(Pacer\n  SOURCES components\/Pacer\/src\/Pacer.c\n  LIBS SB_Type_Library SlangTypeLibrary\n)\n\nDeclareCAmkESRootserver(top_impl_Instance.camkes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/bin\/run-camkes.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber -o nounset\n\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nexport PROJECT_HOME=$( cd \"$( dirname \"$0\" )\/..\" &> \/dev\/null && pwd )\ncd ${PROJECT_HOME}\n\n! getopt --test > \/dev\/null\nif [[ ${PIPESTATUS[0]} -ne 4 ]]; then\n  echo '`getopt --test` failed in this environment.'\n  exit 1\nfi\n\nNON_INTERACTIVE=false\nCAMKES_DIR=\"\"\nSIMULATE=false\nCAMKES_OPTIONS=\"\"\n\nOPTIONS=c:no:s\nLONGOPTS=camkes-dir:,non-interactive,camkes-options:,simulate\n\nfunction usage {\n  echo \"\"\n  echo \"Usage: <option>*\"\n  echo \"\"\n  echo \"Available Options:\"\n  echo \"  -c, --camkes-dir      Location of CAmkES project\"\n  echo \"  -n, --non-interactive Non-interactive mode.  Will not prompt before deleting apps and build directories\"\n  echo \"  -o, --camkes-options  CAmkES options (e.g -o \\\"-DWITH_LOC=ON -DCapDLLoaderMaxObjects=40000\\\")\"\n  echo \"  -s, --simulate        Simulate via QEMU\"\n  exit 2\n}\n\n! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name \"$0\" -- \"$@\")\nif [[ ${PIPESTATUS[0]} -ne 0 ]]; then\n    usage\nfi\n\neval set -- \"$PARSED\"\n\nwhile true; do\n  case \"$1\" in\n    -c|--camkes-dir) CAMKES_DIR=\"$2\"; shift 2 ;;\n    -n|--non-interactive) NON_INTERACTIVE=true; shift ;;\n    -o|--camkes-options) CAMKES_OPTIONS=\"$2\"; shift 2 ;;\n    -s|--simulate) SIMULATE=true; shift ;;\n    --) shift; break ;;\n  esac\ndone\n\n# handle non-option arguments\nif [[ $# -ne 0 ]]; then\n  echo \"$0: Unexpected non-option arguments\"\n  usage\nfi\n\n# if CAMKES_DIR option not set then look in some common locations\nif [[ -z \"${CAMKES_DIR}\" && -d \"\/host\/camkes-project\" ]]; then\n  # docker location\n  CAMKES_DIR=\"\/host\/camkes-project\"\nelif [[ -z \"$CAMKES_DIR\" && -d \"${HOME}\/CASE\/camkes-arm-vm\" ]]; then\n  # CASE Vagrant VM location\n  CAMKES_DIR=\"${HOME}\/CASE\/camkes-arm-vm\"\nfi\n\nif [[ -z \"${CAMKES_DIR}\" || ! -d \"${CAMKES_DIR}\" ]]; then\n  echo \"Directory '${CAMKES_DIR}' does not exist.  Please specify the location of your camkes-arm-vm project directory.\"\n  echo \"See https:\/\/github.com\/SEL4PROJ\/camkes-arm-vm\"\n  exit -1\nfi\n\n\n# use the directory name for the CAmkES apps directory name\nHAMR_CAMKES_PROJ=${PWD##*\/}\n\n\nCAMKES_APPS_DIR=${CAMKES_DIR}\/projects\/camkes\/apps\/$HAMR_CAMKES_PROJ\n\n# create a sym-link to the project in the CAmkES app directory\nif [ -e \"${CAMKES_APPS_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ]; then\n    rm -rf ${CAMKES_APPS_DIR}\n  else\n    read -p \"The following app directory already exists, replace ${CAMKES_APPS_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${CAMKES_APPS_DIR}\n    else\n      exit -1\n    fi\n  fi\nfi\n\nln -sv $PROJECT_HOME $CAMKES_APPS_DIR\n\n########################\n# run CAmkES\/seL4 build\n########################\n\nBUILD_DIR=${CAMKES_DIR}\/build_$HAMR_CAMKES_PROJ\n\nif [ -e \"${BUILD_DIR}\" ]; then\n  if [ \"${NON_INTERACTIVE}\" = true ];then\n    rm -rf ${BUILD_DIR}\n    mkdir ${BUILD_DIR}\n  else\n    read -p \"The following build directory already exists, replace ${BUILD_DIR} [Y|y]? \" -n 1 -r; echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n      rm -rf ${BUILD_DIR}\n      mkdir ${BUILD_DIR}\n    fi\n  fi\nelse\n  mkdir ${BUILD_DIR}\nfi\n\ncd ${BUILD_DIR}\n\n..\/init-build.sh ${CAMKES_OPTIONS} \\\n    -DUSE_PRECONFIGURED_ROOTFS=ON \\\n    -DPLATFORM=qemu-arm-virt \\\n    -DARM_HYP=ON \\\n    -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\n#..\/init-build.sh ${CAMKES_OPTIONS} \\\n#    -DPLATFORM=qemu-arm-virt \\\n#    -DARM_HYP=ON \\\n#    -DCAMKES_APP=$HAMR_CAMKES_PROJ\n\nninja\n\n########################\n# simulate via QEMU\n########################\n\nif [ \"${SIMULATE}\" = true ]; then\n  qemu-system-aarch64 \\\n      -machine virt,virtualization=on,highmem=off,secure=off \\\n      -cpu cortex-a53 \\\n      -nographic \\\n      -m size=1024 \\\n      -kernel images\/capdl-loader-image-arm-qemu-arm-virt\nfi\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/src\/sb_consumer_t_impl.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#include <sb_consumer_t_impl.h>\n#include <sb_queue_union_art_DataContent_1.h>\n#include <sb_event_counter.h>\n#include <consumer_t_impl_dst_process_dst_thread_adapter.h>\n#include <string.h>\n#include <camkes.h>\n\nsb_queue_union_art_DataContent_1_Recv_t sb_read_port_recv_queue;\n\n\/************************************************************************\n * sb_read_port_dequeue_poll:\n ************************************************************************\/\nbool sb_read_port_dequeue_poll(sb_event_counter_t *numDropped, union_art_DataContent *data) {\n  return sb_queue_union_art_DataContent_1_dequeue(&sb_read_port_recv_queue, numDropped, data);\n}\n\n\/************************************************************************\n * sb_read_port_dequeue:\n ************************************************************************\/\nbool sb_read_port_dequeue(union_art_DataContent *data) {\n  sb_event_counter_t numDropped;\n  return sb_read_port_dequeue_poll(&numDropped, data);\n}\n\n\/************************************************************************\n * sb_read_port_is_empty:\n *\n * Helper method to determine if infrastructure port has received new\n * events\n ************************************************************************\/\nbool sb_read_port_is_empty(){\n  return sb_queue_union_art_DataContent_1_is_empty(&sb_read_port_recv_queue);\n}\n\n\/\/ is_empty read_port: In EventDataPort\nB slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_read_port_IsEmpty(STACK_FRAME_ONLY) {\n  return sb_read_port_is_empty();\n}\n\n\/\/ receive read_port: In EventDataPort union_art_DataContent\nUnit slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_read_port_Receive(\n  STACK_FRAME\n  Option_8E9F45 result) {\n  DeclNewStackFrame(caller, \"sb_consumer_t_impl.c\", \"\", \"slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_seL4Nix_read_port_Receive\", 0);\n\n  union_art_DataContent val;\n  if(sb_read_port_dequeue((union_art_DataContent *) &val)) {\n    \/\/ wrap payload in Some and place in result\n    DeclNewSome_D29615(some);\n    Some_D29615_apply(SF &some, (art_DataContent) &val);\n    Type_assign(result, &some, sizeof(union Option_8E9F45));\n  } else {\n    \/\/ put None in result\n    DeclNewNone_964667(none);\n    Type_assign(result, &none, sizeof(union Option_8E9F45));\n  }\n}\n\n\nvoid pre_init(void) {\n  DeclNewStackFrame(NULL, \"sb_consumer_t_impl.c\", \"\", \"pre_init\", 0);\n\n  printf(\"Entering pre-init of consumer_t_impl_dst_process_dst_thread\\n\");\n\n  \/\/ initialise data structure for incoming event data port read_port\n  sb_queue_union_art_DataContent_1_Recv_init(&sb_read_port_recv_queue, sb_read_port_queue);\n\n  \/\/ initialise slang-embedded components\/ports\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseArchitecture(SF_LAST);\n\n  \/\/ call the component's initialise entrypoint\n  slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_initialiseEntryPoint(SF_LAST);\n\n  printf(\"Leaving pre-init of consumer_t_impl_dst_process_dst_thread\\n\");\n}\n\n\/************************************************************************\n * int run(void)\n * Main active thread function.\n ************************************************************************\/\nint run(void) {\n  DeclNewStackFrame(NULL, \"sb_consumer_t_impl.c\", \"\", \"run\", 0);\n\n  sb_pacer_notification_wait();\n  for(;;) {\n    sb_pacer_notification_wait();\n    \/\/ call the component's compute entrypoint\n    slang_embedded_test_event_data_port_periodic_domains_consumer_t_impl_dst_process_dst_thread_adapter_computeEntryPoint(SF_LAST);\n  }\n  return 0;\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/consumer_t_impl_dst_process_dst_thread\/includes\/sb_consumer_t_impl.h",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file will be regenerated, do not edit\n\n#ifndef SB_CONSUMER_T_IMPL_H\n#define SB_CONSUMER_T_IMPL_H\n\n#include <sb_types.h>\n\nbool sb_read_port_dequeue(union_art_DataContent *);\n\n#endif \/\/ SB_CONSUMER_T_IMPL_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/Pacer\/src\/Pacer.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ Copyright 2019 Adventium Labs\n\n#include <camkes.h>\n#include <stdio.h>\n#include <sel4\/sel4.h>\n#include <sb_queue_int8_t_1.h>\n\nextern const char *get_instance_name(void);\n\nvoid send_period_to_vmsrc_process(int8_t *data) {\n  sb_queue_int8_t_1_enqueue(period_to_vmsrc_process_queue, data);\n  period_to_vmsrc_process_notification_emit();\n}\n\nvoid pre_init(void) {\n  sb_queue_int8_t_1_init(period_to_vmsrc_process_queue);\n}\n\nint run(void) {\n\n  int8_t tickCount = 0;\n\n  while (1) {\n    \/\/printf(\"%s: Period tick %d\\n\", get_instance_name(), tickCount);\n\n    tickCount++;\n\n    tick_emit();\n\n    send_period_to_vmsrc_process(&tickCount);\n    period_emit();\n\n    tock_wait();\n  }\n\n  return 0;\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/includes\/sb_queue_union_art_DataContent_1.h",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE-1 elements.\n#define SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_union_art_DataContent_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type union_art_DataContent \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  union_art_DataContent elt[SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE];\n\n} sb_queue_union_art_DataContent_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue, \n  union_art_DataContent *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_union_art_DataContent_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_union_art_DataContent_1_t *queue;\n\n} sb_queue_union_art_DataContent_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_queue_union_art_DataContent_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_union_art_DataContent_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_union_art_DataContent_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  union_art_DataContent *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/src\/sb_queue_union_art_DataContent_1.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_union_art_DataContent_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_init(sb_queue_union_art_DataContent_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_union_art_DataContent_1_enqueue(\n  sb_queue_union_art_DataContent_1_t *queue, \n  union_art_DataContent *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_union_art_DataContent_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_union_art_DataContent_1_Recv_init(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_queue_union_art_DataContent_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_union_art_DataContent_1_dequeue(\n  sb_queue_union_art_DataContent_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  union_art_DataContent *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_union_art_DataContent_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_UNION_ART_DATACONTENT_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_union_art_DataContent_1_is_empty(sb_queue_union_art_DataContent_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/includes\/sb_types.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef SB_TYPES_H\n#define SB_TYPES_H\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <all.h>\n\n#ifndef SB_VERIFY\n#include <stddef.h>\n#endif \/\/ SB_VERIFY\n\n#define __SB_OS_CAMKES__\n\n#ifndef SB_VERIFY\n#define MUTEXOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define MUTEXOP(OP) OP\n#endif \/\/ SB_VERIFY\n#ifndef SB_VERIFY\n#define CALLBACKOP(OP)\\\nif((OP) != 0) {\\\n  fprintf(stderr,\"Operation \" #OP \" failed in %s at %d.\\n\",__FILE__,__LINE__);\\\n  *((int*)0)=0xdeadbeef;\\\n}\n#else\n#define CALLBACKOP(OP) OP\n#endif \/\/ SB_VERIFY\n\ntypedef union art_DataContent union_art_DataContent;\n\n#endif \/\/ SB_TYPES_H\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/src\/cross_vm_connections_vmsrc_process.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2019, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <autoconf.h>\n#include <camkes.h>\n#include <vmlinux.h>\n#include <sel4vm\/guest_vm.h>\n\n#include <sel4vmmplatsupport\/drivers\/cross_vm_connection.h>\n#include <sel4vmmplatsupport\/drivers\/pci_helper.h>\n#include <pci\/helper.h>\n\n#ifdef CONFIG_PLAT_QEMU_ARM_VIRT\n#define CONNECTION_BASE_ADDRESS 0xDF000000\n#else\n#define CONNECTION_BASE_ADDRESS 0x3F000000\n#endif\n\n#define NUM_CONNECTIONS 2\nstatic struct camkes_crossvm_connection connections[NUM_CONNECTIONS];\n\nextern dataport_caps_handle_t sb_write_port_queue_1_handle;\nvoid sb_write_port_1_notification_emit_underlying(void);\nextern dataport_caps_handle_t sb_pacer_period_queue_handle;\nseL4_Word sb_pacer_period_notification_notification_badge(void);\n\nstatic int consume_callback(vm_t *vm, void *cookie) {\n    consume_connection_event(vm, (seL4_Word) cookie, true);\n    return 0;\n}\n\nvoid init_cross_vm_connections(vm_t *vm, void *cookie) {\n    connections[0] = (struct camkes_crossvm_connection) {\n      .handle = &sb_write_port_queue_1_handle,\n      .emit_fn = sb_write_port_1_notification_emit_underlying,\n      .consume_badge = -1,\n      .connection_name = \"sb_write_port_queue_1\"\n    };\n\n    connections[1] = (struct camkes_crossvm_connection) {\n      .handle = &sb_pacer_period_queue_handle,\n      .emit_fn = NULL,\n      .consume_badge = sb_pacer_period_notification_notification_badge(),\n      .connection_name = \"sb_pacer_period_queue\"\n    };\n\n    for (int i = 0; i < NUM_CONNECTIONS; i++) {\n        if (connections[i].consume_badge != -1) {\n            int err = register_async_event_handler(connections[i].consume_badge, consume_callback, (void *)connections[i].consume_badge);\n            ZF_LOGF_IF(err, \"Failed to register_async_event_handler for init_cross_vm_connections.\");\n        }\n    }\n\n    cross_vm_connections_init(vm, CONNECTION_BASE_ADDRESS, connections, ARRAY_SIZE(connections));\n}\n\nDEFINE_MODULE(cross_vm_connections, NULL, init_cross_vm_connections)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/bin\/setup-camkes-arm-vm.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\nset -o errexit -o pipefail -o noclobber\n\nif [ -n \"$1\" ]; then\n    CAMKES_ARM_VM_DIR=$1\nelse\n  CASE_HOME=$HOME\/CASE\n\n  if [[ ! -d \"${CASE_HOME}\" ]]; then\n    echo \"CASE home not found: ${CASE_HOME}\"\n    exit 1\n  fi\n\n  CAMKES_ARM_VM_DIR=${CASE_HOME}\/camkes-arm-vm\nfi\n\nif [[ -d \"${CAMKES_ARM_VM_DIR}\" ]]; then\n  read -p \"The following directory already exists, replace ${CAMKES_ARM_VM_DIR} [Y|y]? \" -n 1 -r; echo\n  if [[ $REPLY =~ ^[Yy]$ ]]; then\n    rm -rf ${CAMKES_ARM_VM_DIR}\n  else\n    exit -1\n  fi\nfi\n\nmkdir $CAMKES_ARM_VM_DIR\ncd $CAMKES_ARM_VM_DIR\n\necho \"Cloning camkes arm\"\nrepo init -u https:\/\/github.com\/SEL4PROJ\/camkes-arm-vm-manifest.git --depth=1\nrepo sync -j8\n\necho \"Cloning Kent's CAmkES\"\n\n(cd projects && rm -rf camkes && git clone https:\/\/github.com\/kent-mcleod\/camkes.git -b kent\/aadl)\n\ncd $CAMKES_ARM_VM_DIR\n\nln -sf projects\/camkes\/easy-settings.cmake\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/includes\/sb_event_counter.h",
        {
          "type" : "TestResource",
          "content" : "#pragma once\n\n#include <stdint.h>\n\ntypedef _Atomic uintmax_t sb_event_counter_t;\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject(arm-vm C)\n\nincludeGlobalComponents()\nfind_package(camkes-vm REQUIRED)\nfind_package(camkes-vm-images REQUIRED)\nfind_package(camkes-arm-vm REQUIRED)\nfind_package(camkes-vm-linux REQUIRED)\ncamkes_arm_vm_import_project()\n\ninclude(${CAMKES_VM_LINUX_HELPERS_PATH})\ninclude(${CAMKES_VM_LINUX_MODULE_HELPERS_PATH})\ninclude(${CAMKES_VM_LINUX_SOURCE_HELPERS_PATH})\ninclude(ExternalProject)\ninclude(external-project-helpers)\n\noption(USE_PRECONFIGURED_ROOTFS\n       \"Use preconfigured rootfs\"\n       OFF)\n\n#MESSAGE(\"KernelARMPlatform = ${KernelARMPlatform}\")\n#MESSAGE(\"CAMKES_ARM_VM_DIR = ${CAMKES_ARM_VM_DIR}\")\n#MESSAGE(\"CAMKES_VM_IMAGES_DIR = ${CAMKES_VM_IMAGES_DIR}\")\n#MESSAGE(\"CAMKES_VM_LINUX_DIR = ${CAMKES_VM_LINUX_DIR}\")\n#MESSAGE(\"CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}\")\n#MESSAGE(\"CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}\")\n#MESSAGE(\"CMAKE_C_COMPILER = ${CMAKE_C_COMPILER}\")\n#MESSAGE(\"BASE_C_FLAGS = ${BASE_C_FLAGS}\")\n\nif(\"${KernelARMPlatform}\" STREQUAL \"qemu-arm-virt\" AND (NOT USE_PRECONFIGURED_ROOTFS))\n    MESSAGE(\"Downloading VM\")\n\n    set(cpp_flags \"-DKERNELARMPLATFORM_QEMU-ARM-VIRT\")\n    set(linux_repo \"https:\/\/git.kernel.org\/pub\/scm\/linux\/kernel\/git\/stable\/linux.git\")\n    set(linux_tag \"v4.9.189\")\n    set(linux_arch \"arm64\")\n    set(linux_cross_compile \"aarch64-linux-gnu-\")\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs.cpio.gz\")\n    # Checkout and configure linux to build crossvm module\n    ExternalProject_Add(\n        checkout_linux\n        GIT_REPOSITORY\n        ${linux_repo}\n        GIT_TAG\n        ${linux_tag}\n        GIT_SHALLOW\n        1\n        GIT_PROGRESS\n        1\n        BUILD_COMMAND\n        \"\"\n        INSTALL_COMMAND\n        \"\"\n        CONFIGURE_COMMAND\n        \"\"\n        SOURCE_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n    )\n    Message(\"Done cloning ${linux_repo}\")\n\n    # Linux config and symvers are to be copied to unpacked archive\n    set(linux_config \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/config\")\n    set(linux_symvers \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux_configs\/Module.symvers\")\n    # Configure unpacked archive with config and symvers\n    ConfigureLinux(\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ${linux_config}\n        ${linux_symvers}\n        configure_vm_linux\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n    )\n\n    # Compile CrossVM Dataport Module\n    DefineLinuxModule(\n        ${CAMKES_VM_LINUX_DIR}\/camkes-linux-artifacts\/camkes-linux-modules\/camkes-connector-modules\/connection\n        output_module\n        output_module_target\n        KERNEL_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/linux_out\n        ARCH\n        ${linux_arch}\n        CROSS_COMPILE\n        ${linux_cross_compile}\n        DEPENDS\n        checkout_linux\n        configure_vm_linux\n    )\n\n    AddFileToOverlayDir(\n        \"connection.ko\"\n        ${output_module}\n        \"lib\/modules\/4.14.87\/kernel\/drivers\/vmm\"\n        overlay\n        DEPENDS\n        output_module_target\n    )\n\n    # Add script to initialise dataport module\n    AddFileToOverlayDir(\n        \"S90crossvm_module_init\"\n        ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/cross_vm_module_init\n        \"etc\/init.d\"\n        overlay\n    )\nelse()\n    MESSAGE(\"Using pre-configured rootfs\")\n\n    # Use pre-configured rootfs file with crossvm modules and apps installed\n    set(rootfs_file \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/rootfs_crossvm.cpio.gz\")\nendif()\n\n# Complile CrossVM Event Apps vmsrc_process\nforeach(item IN ITEMS vmsrc_process)\n    ExternalProject_Add(\n        ${item}\n        SOURCE_DIR\n        ${CMAKE_CURRENT_SOURCE_DIR}\/apps\/${item}\n        BINARY_DIR\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        INSTALL_COMMAND\n        \"\"\n        BUILD_ALWAYS\n        ON\n        EXCLUDE_FROM_ALL\n        CMAKE_ARGS\n        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}\n        -DSlangTypeLibrary_DIR=${CMAKE_CURRENT_SOURCE_DIR}\/..\/..\/slang_libraries\/SlangTypeLibrary\n        -DSB_Type_Library_DIR=${CMAKE_CURRENT_SOURCE_DIR}\/..\/..\/types\n        -DCMAKE_C_FLAGS=${BASE_C_FLAGS}\n    )\n\n    AddExternalProjFilesToOverlay(\n        ${item}\n        ${CMAKE_CURRENT_BINARY_DIR}\/${item}\n        overlay\n        \"usr\/bin\"\n        FILES\n        ${item}\n    )\nendforeach()\n\nMessage(\"Done compiling CrossVM Event Apps for vmsrc_process\")\n\n\n# Overwrite inittab file for using the virtio console hvc0.\nAddFileToOverlayDir(\n    \"inittab\"\n    ${CMAKE_CURRENT_SOURCE_DIR}\/overlay_files\/init_scripts\/inittab_hvc0\n    \"etc\"\n    overlay\n)\n\n# Use initrd with crossvm kernel module and setup already included.\n# Construct new rootfs\nAddOverlayDirToRootfs(\n    overlay\n    ${rootfs_file}\n    \"buildroot\"\n    \"rootfs_install\"\n    output_overlayed_rootfs_location\n    rootfs_target\n    GZIP\n)\n\nAddToFileServer(\"linux-initrd-vm-client\" ${output_overlayed_rootfs_location} DEPENDS rootfs_target)\n\n# Add linux kernel image to file server\nAddToFileServer(\"linux\" \"${CAMKES_VM_IMAGES_DIR}\/${KernelARMPlatform}\/linux\")\n\nDefineCAmkESVMFileServer()\n\nCAmkESAddImportPath(${CMAKE_CURRENT_SOURCE_DIR}\/${KernelARMPlatform}\/)\n\n# Define our VM Component with our cross vm dataports glue code\nDeclareCamkesARMVM(\n  VM_emitter_t_impl_src_process_src_thread\n  EXTRA_SOURCES src\/cross_vm_connections_vmsrc_process.c\n  EXTRA_LIBS SB_Type_Library\n             SlangTypeLibrary)\n\nCAmkESAddCPPInclude(${CAMKES_ARM_VM_DIR}\/components\/VM)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/exynos5422\/devices.camkes",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2020, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <configurations\/vm.h>\n\n#define VM_RAM_OFFSET 0\n#define VM_INITRD_MAX_SIZE 0x1900000 \/\/ 25 MB\n\n\n#define VM1_RAM_BASE       0x48000000\n#define VM1_RAM_MMIOS_BASE \"0x48000000:27\"\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x4f000000  \/\/ VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x4d700000  \/\/ VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM2_RAM_BASE       0x50000000\n#define VM2_RAM_MMIOS_BASE \"0x50000000:27\"\n#define VM2_RAM_SIZE       0x8000000\n#define VM2_DTB_ADDR       0x57000000  \/\/ VM2_RAM_BASE + 0x7000000\n#define VM2_INITRD_ADDR    0x55700000  \/\/ VM2_DTB_ADDR - VM_INITRD_MAX_SIZE\n\nassembly {\n  composition {}\n  configuration {\n    vmsrc_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR),\n    };\n    vmsrc_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 root=\/dev\/ram0 nosmp rw debug loglevel=8 pci=nomsi initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmsrc_process.mmios = [\n      \"0x10000000:0x1000:12\", \/\/ CHIP ID\n      \"0x10486000:0x1000:12\"  \/\/ VCPU\n    ];\n    vmsrc_process.untyped_mmios = [\n      VM1_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmsrc_process.irqs = [];\n    vmsrc_process.dtb = dtb([{}]);\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/qemu-arm-virt\/devices.camkes",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2020, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_BSD)\n *\/\n\n#include <configurations\/vm.h>\n#define VM_RAM_OFFSET      0x00000000\n#define VM_INITRD_MAX_SIZE 0x3200000 \/\/ 50 MB\n\n#define VM1_RAM_BASE       0x48000000\n#define VM1_RAM_MMIOS_BASE \"0x48000000:27\"\n#define VM1_RAM_SIZE       0x8000000\n#define VM1_DTB_ADDR       0x4f000000  \/\/ VM1_RAM_BASE + 0x7000000\n#define VM1_INITRD_ADDR    0x4d700000  \/\/ VM1_DTB_ADDR - VM_INITRD_MAX_SIZE\n\n#define VM2_RAM_BASE       0x50000000\n#define VM2_RAM_MMIOS_BASE \"0x50000000:27\"\n#define VM2_RAM_SIZE       0x8000000\n#define VM2_DTB_ADDR       0x57000000  \/\/ VM2_RAM_BASE + 0x7000000\n#define VM2_INITRD_ADDR    0x55700000  \/\/ VM2_DTB_ADDR - VM_INITRD_MAX_SIZE\n\nassembly {\n  composition {}\n  configuration {\n    vmsrc_process.linux_address_config = {\n      \"linux_ram_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_paddr_base\" : VAR_STRINGIZE(VM1_RAM_BASE),\n      \"linux_ram_size\" : VAR_STRINGIZE(VM1_RAM_SIZE),\n      \"linux_ram_offset\" : VAR_STRINGIZE(VM_RAM_OFFSET),\n      \"dtb_addr\" : VAR_STRINGIZE(VM1_DTB_ADDR),\n      \"initrd_max_size\" : VAR_STRINGIZE(VM_INITRD_MAX_SIZE),\n      \"initrd_addr\" : VAR_STRINGIZE(VM1_INITRD_ADDR),\n    };\n    vmsrc_process.linux_image_config = {\n      \"linux_bootcmdline\" : \"console=hvc0 nosmp rw debug loglevel=8 pci=nomsi,realloc=off,bios initcall_blacklist=clk_disable_unused\",\n      \"linux_stdout\" : \"hvc0\",\n      \"dtb_name\" : \"\",\n      \"initrd_name\" : \"linux-initrd-vm-client\",\n    };\n    vmsrc_process.mmios = [\n      \"0x8040000:0x1000:12\", \/\/ Interrupt Controller Virtual CPU interface (Virtual Machine view)\n    ];\n    vmsrc_process.untyped_mmios = [\n      VM1_RAM_MMIOS_BASE  \/\/ RAM\n    ];\n    vmsrc_process.irqs = [];\n    vmsrc_process.dtb = dtb([{}]);\n\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/overlay_files\/init_scripts\/cross_vm_module_init",
        {
          "type" : "TestResource",
          "content" : "#!\/bin\/sh\n#\n# Copyright 2020, Data61\n# Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n# ABN 41 687 119 230.\n#\n# This software may be distributed and modified according to the terms of\n# the BSD 2-Clause license. Note that NO WARRANTY is provided.\n# See \"LICENSE_BSD2.txt\" for details.\n#\n# @TAG(DATA61_BSD)\n#\n\ninsmod \/lib\/modules\/4.14.87\/kernel\/drivers\/vmm\/connection.ko",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/overlay_files\/init_scripts\/inittab_hvc0",
        {
          "type" : "TestResource",
          "content" : "# @TAG(CUSTOM)\n# \/etc\/inittab\n#\n# This file will not be overwritten so is safe to edit\n#\n# Copyright (C) 2001 Erik Andersen <andersen@codepoet.org>\n#\n# Note: BusyBox init doesn't support runlevels.  The runlevels field is\n# completely ignored by BusyBox init. If you want runlevels, use\n# sysvinit.\n#\n# Format for each entry: <id>:<runlevels>:<action>:<process>\n#\n# id        == tty to run on, or empty for \/dev\/console\n# runlevels == ignored\n# action    == one of sysinit, respawn, askfirst, wait, and once\n# process   == program to run\n\n# Startup the system\n::sysinit:\/bin\/mount -t proc proc \/proc\n::sysinit:\/bin\/mount -o remount,rw \/\n::sysinit:\/bin\/mkdir -p \/dev\/pts \/dev\/shm\n::sysinit:\/bin\/mount -a\n::sysinit:\/sbin\/swapon -a\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd \/dev\/fd\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/0 \/dev\/stdin\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/1 \/dev\/stdout\nnull::sysinit:\/bin\/ln -sf \/proc\/self\/fd\/2 \/dev\/stderr\n::sysinit:\/bin\/hostname -F \/etc\/hostname\n# now run any rc scripts\n::sysinit:\/etc\/init.d\/rcS\n\n# Put a getty on the serial port\nhvc0:2345:respawn:\/sbin\/getty -L 9600 hvc0\n\n# Stuff to do for the 3-finger salute\n#::ctrlaltdel:\/sbin\/reboot\n\n# Stuff to do before rebooting\n::shutdown:\/etc\/init.d\/rcK\n::shutdown:\/sbin\/swapoff -a\n::shutdown:\/bin\/umount -a -r",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/apps\/vmsrc_process\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "cmake_minimum_required(VERSION 3.8.2)\n\nproject(vmsrc_process C)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_subdirectory(${SlangTypeLibrary_DIR} SlangTypeLibrary)\n\nadd_subdirectory(${SB_Type_Library_DIR} SB_Type_Library)\n\nadd_executable(vmsrc_process vmsrc_process.c)\n\ntarget_link_libraries(vmsrc_process\n                      SB_Type_Library\n                      SlangTypeLibrary\n                      -static-libgcc -static)",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/components\/VM\/apps\/vmsrc_process\/vmsrc_process.c",
        {
          "type" : "TestResource",
          "content" : "#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <string.h>\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <sys\/mman.h>\n#include <errno.h>\n\n#include <sb_types.h>\n#include <sb_event_counter.h>\n#include <sb_queue_int8_t_1.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nint main(int argc, char *argv[]) {\n  printf(\"VM App vmsrc_process started\\n\");\n  return 0;\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/includes\/sb_queue_int8_t_1.h",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n\/\/ Single sender multiple receiver Queue implementation for AADL Event Data\n\/\/ Ports. Every receiver receives the sent data (ie broadcast). The queue\n\/\/ operations are all non-blocking. The sender enqueue always succeeds. A\n\/\/ receiver dequeue can fail and drop data if the sender writes while the\n\/\/ receiver is reading. This situation is detected unless the sender gets\n\/\/ ahead of a receiver by more than COUNTER_MAX. Since COUNTER_MAX is typically\n\/\/ 2^64 (see sb_event_counter.h), this is extremely unlikely. If it does happen the\n\/\/ only adverse effect is that the receiver will not detect all dropped\n\/\/ elements.\n\n#pragma once\n\n#include <sb_event_counter.h> \n#include <sb_types.h>\n#include <stdbool.h>\n\n\/\/ Queue size must be an integer factor of the size for sb_event_counter_t (an unsigned\n\/\/ integer type). Since we are using standard C unsigned integers for the\n\/\/ counter, picking a queue size that is a power of 2 is a good choice. We\n\/\/ could alternatively set the size of our counter to the largest possible\n\/\/ multiple of queue size. But then we would need to do our own modulo\n\/\/ operations on the counter rather than depending on c's unsigned integer\n\/\/ operations.\n\/\/\n\/\/ Note: One cell in the queue is always considered dirty. Its the next\n\/\/ element to be written. Thus the queue can only contain \n\/\/ SB_QUEUE_INT8_T_1_SIZE-1 elements.\n#define SB_QUEUE_INT8_T_1_SIZE 2\n\n\/\/ This is the type of the seL4 dataport (shared memory) that is shared by the\n\/\/ sender and all receivers. This type is referenced in the sender and receiver\n\/\/ CAmkES component definition files. The seL4 CAmkES runtime creates an\n\/\/ instance of this struct.\ntypedef struct sb_queue_int8_t_1 {\n  \/\/ Number of elements enqueued since the sender. The implementation depends\n  \/\/ on C's standard module behaviour for unsigned integers. The counter never\n  \/\/ overflows. It just wraps modulo the size of the counter type. The counter\n  \/\/ is typically very large (see sb_event_counter.h), so this should happen very\n  \/\/ infrequently. Depending in C to initialize this to zero.\n  _Atomic sb_event_counter_t numSent;\n\n  \/\/ Queue of elements of type int8_t \n  \/\/ (see sb_types.h) implemented as a ring buffer. \n  \/\/ No initialization necessary.\n  int8_t elt[SB_QUEUE_INT8_T_1_SIZE];\n\n} sb_queue_int8_t_1_t;\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ Could split this into separate header and source file since only sender\n\/\/ code needs this.\n\n\/\/ Initialize the queue. Sender must call this exactly once before any calls to queue_enqueue();\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue);\n\n\/\/ Enqueue data. This always succeeds and never blocks. Data is copied.\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue, \n  int8_t *data);\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ Could split this into separate header and source file since only receiver\n\/\/ code needs this.\n\n\/\/ Each receiver needs to create an instance of this.\ntypedef struct sb_queue_int8_t_1_Recv {\n  \/\/ Number of elements dequeued (or dropped) by a receiver. The implementation\n  \/\/ depends on C's standard module behaviour for unsigned integers. The\n  \/\/ counter never overflows. It just wraps modulo the size of the counter\n  \/\/ type. The counter is typically very large (see counter.h), so this should\n  \/\/ happen very infrequently.\n  sb_event_counter_t numRecv;\n\n  \/\/ Pointer to the actual queue. This is the seL4 dataport (shared memory)\n  \/\/ that is shared by the sender and all receivers.\n  sb_queue_int8_t_1_t *queue;\n\n} sb_queue_int8_t_1_Recv_t;\n\n\/\/ Each receiver must call this exactly once before any calls to other queue\n\/\/ API functions.\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_queue_int8_t_1_t *queue);\n\n\/\/ Dequeue data. Never blocks but can fail if the sender writes at same\n\/\/ time. \n\n\/\/ When successful returns true. The dequeued data will be copied to\n\/\/ *data. *numDropped will contain the number of elements that were dropped\n\/\/ since the last call to queue_dequeue().\n\/\/\n\/\/ When queue is empty, returns false and *numDropped is zero. *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ When dequeue fails due to possible write of data being read, returns false\n\/\/ and *numDropped will be >= 1 specifying the number of elements that were\n\/\/ dropped since the last call to sb_queue_int8_t_1_dequeue(). *data is left in\n\/\/ unspecified state.\n\/\/\n\/\/ If the sender ever gets ahead of a receiver by more than COUNTER_MAX,\n\/\/ sb_queue_int8_t_1_dequeue will fail to count a multiple of COUNTER_MAX in\n\/\/ numDropped. Since COUNTER_MAX is very large (typically on the order of 2^64,\n\/\/ see sb_event_counter.h), this is very unlikely.  If the sender is ever this far\n\/\/ ahead of a receiver the system is probably in a very bad state.\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int8_t *data);\n\n\/\/ Is queue empty? If the queue is not empty, it will stay that way until the\n\/\/ receiver dequeues all data. If the queue is empty you can make no\n\/\/ assumptions about how long it will stay empty.\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue);\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/src\/sb_queue_int8_t_1.c",
        {
          "type" : "TestResource",
          "content" : "\/*\n * Copyright 2017, Data61\n * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\n * ABN 41 687 119 230.\n *\n * Copyright 2019 Adventium Labs\n * Modifications made to original\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(DATA61_Adventium_BSD)\n *\/\n\n#include <sb_queue_int8_t_1.h>\n#include <stdint.h>\n#include <stddef.h>\n\n\/\/------------------------------------------------------------------------------\n\/\/ Sender API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_init(sb_queue_int8_t_1_t *queue) {\n  \/\/ NOOP for now. C's struct initialization is sufficient.  If we ever do need\n  \/\/ initialization logic, we may also need to synchronize with receiver\n  \/\/ startup.\n}\n\nvoid sb_queue_int8_t_1_enqueue(\n  sb_queue_int8_t_1_t *queue, \n  int8_t *data) {\n\n  \/\/ Simple ring with one dirty element that will be written next. Only one\n  \/\/ writer, so no need for any synchronization. \n  \/\/ elt[queue->numSent % SB_QUEUE_INT8_T_1_SIZE]\n  \/\/ is always considered dirty. So do not advance queue->NumSent\n  \/\/ till AFTER data is copied.\n\n  size_t index = queue->numSent % SB_QUEUE_INT8_T_1_SIZE;\n\n  queue->elt[index] = *data; \/\/ Copy data into queue\n\n  \/\/ Release memory fence - ensure that data write above completes BEFORE we advance queue->numSent\n  __atomic_thread_fence(__ATOMIC_RELEASE);\n\n  ++(queue->numSent);\n}\n\n\/\/------------------------------------------------------------------------------\n\/\/ Receiver API\n\/\/\n\/\/ See sb_queue_int8_t_1.h for API documentation. Only implementation details are documented here.\n\nvoid sb_queue_int8_t_1_Recv_init(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_queue_int8_t_1_t *queue) {\n\n  recvQueue->numRecv = 0;\n  recvQueue->queue = queue;\n}\n\nbool sb_queue_int8_t_1_dequeue(\n  sb_queue_int8_t_1_Recv_t *recvQueue, \n  sb_event_counter_t *numDropped, \n  int8_t *data) {\n\n  sb_event_counter_t *numRecv = &recvQueue->numRecv;\n  sb_queue_int8_t_1_t *queue = recvQueue->queue;\n\n  \/\/ Get a copy of numSent so we can see if it changes during read\n  sb_event_counter_t numSent = queue->numSent;\n\n  \/\/ Acquire memory fence - ensure read of queue->numSent BEFORE reading data\n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  \/\/ How many new elements have been sent? Since we are using unsigned\n  \/\/ integers, this correctly computes the value as counters wrap.\n  sb_event_counter_t numNew = numSent - *numRecv;\n  if (0 == numNew) {\n    \/\/ Queue is empty\n    return false;\n  }\n\n  \/\/ One element in the ring buffer is always considered dirty. Its the next\n  \/\/ element we will write.  It's not safe to read it until numSent has been\n  \/\/ incremented. Thus there are really only (SB_QUEUE_INT8_T_1_SIZE - 1)\n  \/\/ elements in the queue.\n  *numDropped = (numNew <= SB_QUEUE_INT8_T_1_SIZE - 1) ? 0 : numNew - SB_QUEUE_INT8_T_1_SIZE + 1;\n\n  \/\/ Increment numRecv by *numDropped plus one for the element we are about to read.\n  *numRecv += *numDropped + 1;\n\n  \/\/ UNUSED - number of elements left to be consumed\n  \/\/sb_event_counter_t numRemaining = numSent - *numRecv;\n\n  size_t index = (*numRecv - 1) % SB_QUEUE_INT8_T_1_SIZE;\n  *data = queue->elt[index]; \/\/ Copy data\n\n  \/\/ Acquire memory fence - ensure read of data BEFORE reading queue->numSent again \n  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n\n  if (queue->numSent - *numRecv + 1 < SB_QUEUE_INT8_T_1_SIZE) {\n    \/\/ Sender did not write element we were reading. Copied data is coherent.\n    return true;\n  } else {\n    \/\/ Sender may have written element we were reading. Copied data may be incoherent.\n    \/\/ We dropped the element we were trying to read, so increment *numDropped.\n    ++(*numDropped); \n    return false;\n  }\n}\n\nbool sb_queue_int8_t_1_is_empty(sb_queue_int8_t_1_Recv_t *recvQueue) {\n  return (recvQueue->queue->numSent == recvQueue->numRecv);\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/kernel\/domain_schedule.c",
        {
          "type" : "TestResource",
          "content" : "\/\/ Copyright 2020 Adventium Labs\n\n\/\/ This is a kernel data structure.\n\n#include <config.h>\n#include <object\/structures.h>\n#include <model\/statedata.h>\n\n\/\/ An arbitrary hand generated schedule. The length is in seL4 ticks\n\/\/ (2 ms default). This schedule should be generated from the AADL model\n\/\/ using execution time and data flow latency specifications.\n\/\/\n\/\/ Pacer runs at highest rate\n\/\/\n\/\/ This schedule is single-rate, 1Hz, run each thread at 200ms ticks for simplicity.\n\/\/ Fill space in with domain 0.\n\/\/\n\/\/         +\n\/\/ 3 dest  |        -              -              -              -      \n\/\/ 2 src   |     -              -              -              -         \n\/\/ 1 pacer |  -              -              -              -            \n\/\/ 0 dom0  |-- -- -- -------- -- -- -------- -- -- -------- -- -- ------\n\/\/         |______________|______________________________________________\\time\n\/\/           seconds      1              2              3              4 \/\n\/\/\n\/\/ Major frame is 1 seconds, since destination has 1 second period\n\/\/\nconst dschedule_t ksDomSchedule[] = { \/\/ (1 tick == 2ms)\n    { .domain = 0, .length = 100 },   \/\/ all other seL4 threads, init, 200ms\n    { .domain = 1, .length =   5 },   \/\/ pacer        \n    { .domain = 0, .length =  95 },   \/\/ domain0     \n    { .domain = 2, .length = 400 },   \/\/ source      \n    { .domain = 0, .length =  95 },   \/\/ domain0     \n    { .domain = 3, .length =   5 },   \/\/ destination \n    { .domain = 0, .length =   5 },   \/\/ domain0 \n};\n\nconst word_t ksDomScheduleLength = sizeof(ksDomSchedule) \/ sizeof(dschedule_t);\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/settings.cmake",
        {
          "type" : "TestResource",
          "content" : "# This file will not be overwritten so is safe to edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\n# Add virtual PCI device to VMM for registering cross component connectors as\n# devices on the PCI bus.\nset(VmPCISupport ON CACHE BOOL \"\" FORCE)\n\n# Disable libusb from being compiled.\nset(LibUSB OFF CACHE BOOL \"\" FORCE)\n\n# Enables the option for the VM to open and load a seperate initrd file\nset(VmInitRdFile ON CACHE BOOL \"\" FORCE)\n\n# Enable virtio console vmm module\nset(VmVirtioConsole ON CACHE BOOL \"\" FORCE)\n\n# Make VTimers see absolute time rather than virtual time.\nset(KernelArmVtimerUpdateVOffset OFF CACHE BOOL \"\" FORCE)\n\n# Don't trap WFI or WFE instructions in a VM.\nset(KernelArmDisableWFIWFETraps ON CACHE BOOL \"\" FORCE)\n\nif(\"${PLATFORM}\" STREQUAL \"qemu-arm-virt\")\n    set(KernelArmCPU cortex-a53 CACHE STRING \"\" FORCE)\n    set(KernelArmExportPCNTUser ON CACHE BOOL \"\" FORCE)\n    set(KernelArmExportPTMRUser ON CACHE BOOL \"\" FORCE)\n\n    set(MIN_QEMU_VERSION \"4.0.0\")\n    execute_process(COMMAND ${QEMU_BINARY} -version OUTPUT_VARIABLE QEMU_VERSION_STR)\n    string(\n        REGEX\n            MATCH\n            \"[0-9](\\\\.[0-9])+\"\n            QEMU_VERSION\n            ${QEMU_VERSION_STR}\n    )\n    if(\"${QEMU_VERSION}\" VERSION_LESS \"${MIN_QEMU_VERSION}\")\n        message(WARNING \"Warning: qemu version should be at least ${MIN_QEMU_VERSION}\")\n    endif()\n\nendif()\nset(KernelDomainSchedule \"${CMAKE_CURRENT_LIST_DIR}\/kernel\/domain_schedule.c\" CACHE INTERNAL \"\")\nset(KernelNumDomains 4 CACHE STRING \"\" FORCE)\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "test_event_data_port_periodic_domains_VM__sender_vm--SeL4\/types\/CMakeLists.txt",
        {
          "type" : "TestResource",
          "content" : "# This file will be regenerated, do not edit\n\ncmake_minimum_required(VERSION 3.8.2)\n\nproject(SB_Type_Library)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_compile_options(-Werror)\n\nif (\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(C|c?)lang\")\n  add_compile_options(\"$<$<CONFIG:Release>:-Oz>\")\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n  add_compile_options(-fstack-usage)\n  add_compile_options(\"$<$<CONFIG:Release>:-Os>\")\nendif()\n\nadd_library(SB_Type_Library\n            src\/sb_queue_union_art_DataContent_1.c\n            src\/sb_queue_int8_t_1.c)\n\n# Assume that if the muslc target exists then this project is in an seL4 native\n# component build environment, otherwise it is in a linux userlevel environment.\n# In the linux userlevel environment, the C library will be linked automatically.\nif(TARGET muslc)\n  target_link_libraries(SB_Type_Library\n                        muslc)\nendif()\n\nadd_definitions(-DCAMKES)\n\nif(TARGET SlangTypeLibrary)\n  target_link_libraries(SB_Type_Library\n                        SlangTypeLibrary)\nendif()\n\ntarget_include_directories(SB_Type_Library\n                           PUBLIC includes)\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ]
    ]
  }
}