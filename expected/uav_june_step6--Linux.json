{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "uav_june_step6--Linux\/src\/main\/data\/uav_june_step6__Linux\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: F32) extends art.DataContent\n  @datatype class Float_64_Payload(value: F64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_example(): Boolean = { return F }\n\n  def Integer_example(): Integer = { return z\"0\" }\n\n  def Integer_8_example(): Integer_8 = { return s8\"0\" }\n  def Integer_16_example(): Integer_16 = { return s16\"0\" }\n  def Integer_32_example(): Integer_32 = { return s32\"0\" }\n  def Integer_64_example(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_example(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_example(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_example(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_example(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_example(): Float = { return r\"0\" }\n  def Float_32_example(): Float_32 = { return f32\"0\" }\n  def Float_64_example(): Float_64 = { return f64\"0\" }\n\n  def Character_example(): Character = { return ' ' }\n  def String_example(): String = { return \"\" }\n\n  def Bits_example(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/architecture\/uav_june_step6__Linux\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver : uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = 0, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_recv_data\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = 1, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_MissionCommand\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = 2, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_send_data\", mode = EventOut)\n    val AirVehicleState_WPM = Port[Base_Types.Bits] (id = 3, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_WPM\", mode = EventOut)\n    val AirVehicleState_UXAS = Port[Base_Types.Bits] (id = 4, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver_AirVehicleState_UXAS\", mode = EventOut)\n\n    uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge(\n      id = 0,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      MissionCommand = MissionCommand,\n      send_data = send_data,\n      AirVehicleState_WPM = AirVehicleState_WPM,\n      AirVehicleState_UXAS = AirVehicleState_UXAS\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation : uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge = {\n    val recv_data = Port[Base_Types.Bits] (id = 5, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_recv_data\", mode = EventIn)\n    val send_data = Port[Base_Types.Bits] (id = 6, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_send_data\", mode = EventOut)\n    val trusted_ids = Port[Base_Types.Bits] (id = 7, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_trusted_ids\", mode = EventOut)\n    val AutomationRequest = Port[Base_Types.Bits] (id = 8, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_AutomationRequest\", mode = EventOut)\n    val OperatingRegion = Port[Base_Types.Bits] (id = 9, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_OperatingRegion\", mode = EventOut)\n    val LineSearchTask = Port[Base_Types.Bits] (id = 10, name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_LineSearchTask\", mode = EventOut)\n\n    uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge(\n      id = 1,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      recv_data = recv_data,\n      send_data = send_data,\n      trusted_ids = trusted_ids,\n      AutomationRequest = AutomationRequest,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase : uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = 11, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_in_zones\", mode = DataOut)\n    val keep_out_zones = Port[Base_Types.Bits] (id = 12, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_keep_out_zones\", mode = DataOut)\n\n    uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge(\n      id = 2,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS : uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge = {\n    val AutomationRequest = Port[Base_Types.Bits] (id = 13, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationRequest\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = 14, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AirVehicleState\", mode = EventIn)\n    val OperatingRegion = Port[Base_Types.Bits] (id = 15, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_OperatingRegion\", mode = EventIn)\n    val LineSearchTask = Port[Base_Types.Bits] (id = 16, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_LineSearchTask\", mode = EventIn)\n    val AutomationResponse_MON_GEO = Port[Base_Types.Bits] (id = 17, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_GEO\", mode = EventOut)\n    val AutomationResponse_MON_REQ = Port[Base_Types.Bits] (id = 18, name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS_AutomationResponse_MON_REQ\", mode = EventOut)\n\n    uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge(\n      id = 3,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationRequest = AutomationRequest,\n      AirVehicleState = AirVehicleState,\n      OperatingRegion = OperatingRegion,\n      LineSearchTask = LineSearchTask,\n      AutomationResponse_MON_GEO = AutomationResponse_MON_GEO,\n      AutomationResponse_MON_REQ = AutomationResponse_MON_REQ\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService : uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge = {\n    val AutomationResponse = Port[Base_Types.Bits] (id = 19, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AutomationResponse\", mode = EventIn)\n    val AirVehicleState = Port[Base_Types.Bits] (id = 20, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_AirVehicleState\", mode = EventIn)\n    val MissionCommand = Port[Base_Types.Bits] (id = 21, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_MissionCommand\", mode = EventOut)\n    val ReturnHome = Port[art.Empty] (id = 22, name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService_ReturnHome\", mode = EventIn)\n\n    uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge(\n      id = 4,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      AutomationResponse = AutomationResponse,\n      AirVehicleState = AirVehicleState,\n      MissionCommand = MissionCommand,\n      ReturnHome = ReturnHome\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate : uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge = {\n    val trusted_ids = Port[Base_Types.Bits] (id = 23, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_trusted_ids\", mode = EventIn)\n    val AutomationRequest_in = Port[Base_Types.Bits] (id = 24, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_in\", mode = EventIn)\n    val AutomationRequest_out_UXAS = Port[Base_Types.Bits] (id = 25, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_UXAS\", mode = EventOut)\n    val AutomationRequest_out_MON_REQ = Port[Base_Types.Bits] (id = 26, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_AutomationRequest_out_MON_REQ\", mode = EventOut)\n    val OperatingRegion_in = Port[Base_Types.Bits] (id = 27, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_in\", mode = EventIn)\n    val OperatingRegion_out = Port[Base_Types.Bits] (id = 28, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_OperatingRegion_out\", mode = EventOut)\n    val LineSearchTask_in = Port[Base_Types.Bits] (id = 29, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_in\", mode = EventIn)\n    val LineSearchTask_out = Port[Base_Types.Bits] (id = 30, name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_LineSearchTask_out\", mode = EventOut)\n\n    uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge(\n      id = 5,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      trusted_ids = trusted_ids,\n      AutomationRequest_in = AutomationRequest_in,\n      AutomationRequest_out_UXAS = AutomationRequest_out_UXAS,\n      AutomationRequest_out_MON_REQ = AutomationRequest_out_MON_REQ,\n      OperatingRegion_in = OperatingRegion_in,\n      OperatingRegion_out = OperatingRegion_out,\n      LineSearchTask_in = LineSearchTask_in,\n      LineSearchTask_out = LineSearchTask_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST : uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge = {\n    val filter_in = Port[Base_Types.Bits] (id = 31, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_in\", mode = EventIn)\n    val filter_out = Port[Base_Types.Bits] (id = 32, name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_filter_out\", mode = EventOut)\n\n    uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge(\n      id = 6,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      filter_in = filter_in,\n      filter_out = filter_out\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req : uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge = {\n    val observed = Port[Base_Types.Bits] (id = 33, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_observed\", mode = EventIn)\n    val reference_1 = Port[Base_Types.Bits] (id = 34, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_reference_1\", mode = EventIn)\n\n    uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge(\n      id = 7,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      observed = observed,\n      reference_1 = reference_1\n    )\n  }\n  val UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo : uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge = {\n    val keep_in_zones = Port[Base_Types.Bits] (id = 35, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_in_zones\", mode = DataIn)\n    val keep_out_zones = Port[Base_Types.Bits] (id = 36, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_keep_out_zones\", mode = DataIn)\n    val observed = Port[Base_Types.Bits] (id = 37, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_observed\", mode = EventIn)\n    val output = Port[Base_Types.Bits] (id = 38, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_output\", mode = EventOut)\n    val alert = Port[art.Empty] (id = 39, name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_alert\", mode = EventOut)\n\n    uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge(\n      id = 8,\n      name = \"UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\",\n      dispatchProtocol = Periodic(period = 500),\n      dispatchTriggers = None(),\n\n      keep_in_zones = keep_in_zones,\n      keep_out_zones = keep_out_zones,\n      observed = observed,\n      output = output,\n      alert = alert\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = ISZ (UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver, UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation, UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase, UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS, UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService, UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate, UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST, UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req, UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo),\n\n      connections = ISZ (Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_WPM, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AirVehicleState),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_UXAS, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AirVehicleState),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.trusted_ids, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.trusted_ids),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.AutomationRequest, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_in),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.OperatingRegion, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_in),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.LineSearchTask, to = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_in),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_in_zones, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_in_zones),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_out_zones, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_out_zones),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_GEO, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.observed),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_REQ, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.observed),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.MissionCommand, to = UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.MissionCommand),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_UXAS, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationRequest),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_MON_REQ, to = UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.reference_1),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_out, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.OperatingRegion),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_out, to = UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_in),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_out, to = UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.LineSearchTask),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.output, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AutomationResponse),\n                         Connection(from = UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.alert, to = UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.ReturnHome))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/architecture\/uav_june_step6__Linux\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage uav_june_step6__Linux\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/inspector\/uav_june_step6__Linux\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/data\/uav_june_step6__Linux\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.Drivers\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi extends BridgeTestSuite[UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver) {\n\n  \/** helper function to set the values of all input ports.\n   * @param recv_data payloads for event data port recv_data.\n   *   ART currently supports single element event data queues so\n   *   only the last element of recv_data will be used\n   * @param MissionCommand payloads for event data port MissionCommand.\n   *   ART currently supports single element event data queues so\n   *   only the last element of MissionCommand will be used\n   *\/\n  def put_concrete_inputs(recv_data : ISZ[Base_Types.Bits],\n                          MissionCommand : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- recv_data){\n      put_recv_data(v)\n    }\n    for(v <- MissionCommand){\n      put_MissionCommand(v)\n    }\n  }\n\n\n  \/** helper function to check UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param send_data method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'send_data'.\n   * @param AirVehicleState_WPM method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AirVehicleState_WPM'.\n   * @param AirVehicleState_UXAS method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AirVehicleState_UXAS'.\n   *\/\n  def check_concrete_output(send_data: ISZ[Base_Types.Bits] => B = send_dataParam => {T},\n                            AirVehicleState_WPM: ISZ[Base_Types.Bits] => B = AirVehicleState_WPMParam => {T},\n                            AirVehicleState_UXAS: ISZ[Base_Types.Bits] => B = AirVehicleState_UXASParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var send_dataValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_send_data().nonEmpty) send_dataValue = send_dataValue :+ get_send_data().get\n    if(!send_data(send_dataValue)) {\n      testFailures = testFailures :+ st\"'send_data' did not match expected: received ${send_dataValue.size} events with the following payloads ${send_dataValue}\"\n    }\n    var AirVehicleState_WPMValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AirVehicleState_WPM().nonEmpty) AirVehicleState_WPMValue = AirVehicleState_WPMValue :+ get_AirVehicleState_WPM().get\n    if(!AirVehicleState_WPM(AirVehicleState_WPMValue)) {\n      testFailures = testFailures :+ st\"'AirVehicleState_WPM' did not match expected: received ${AirVehicleState_WPMValue.size} events with the following payloads ${AirVehicleState_WPMValue}\"\n    }\n    var AirVehicleState_UXASValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AirVehicleState_UXAS().nonEmpty) AirVehicleState_UXASValue = AirVehicleState_UXASValue :+ get_AirVehicleState_UXAS().get\n    if(!AirVehicleState_UXAS(AirVehicleState_UXASValue)) {\n      testFailures = testFailures :+ st\"'AirVehicleState_UXAS' did not match expected: received ${AirVehicleState_UXASValue.size} events with the following payloads ${AirVehicleState_UXASValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_recv_data(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.recv_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_MissionCommand(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.MissionCommand_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_send_data(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_send_data_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port send_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_send_data_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.send_data_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AirVehicleState_WPM(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AirVehicleState_WPM_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AirVehicleState_WPM.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AirVehicleState_WPM_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AirVehicleState_WPM_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AirVehicleState_UXAS(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AirVehicleState_UXAS_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AirVehicleState_UXAS.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AirVehicleState_UXAS_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AirVehicleState_UXAS_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.Drivers\n\nimport org.sireum._\nimport uav_june_step6__Linux.Drivers._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Test extends UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.Drivers\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.Drivers.{UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_data: Port[Base_Types.Bits],\n  MissionCommand: Port[Base_Types.Bits],\n  send_data: Port[Base_Types.Bits],\n  AirVehicleState_WPM: Port[Base_Types.Bits],\n  AirVehicleState_UXAS: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_data,\n              MissionCommand,\n              send_data,\n              AirVehicleState_WPM,\n              AirVehicleState_UXAS),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(recv_data,\n                   MissionCommand),\n\n    eventOuts = ISZ(send_data,\n                    AirVehicleState_WPM,\n                    AirVehicleState_UXAS)\n  )\n\n  val initialization_api : UARTDriver_Impl_Initialization_Api = {\n    val api = UARTDriver_Impl_Initialization_Api(\n      id,\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id\n    )\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : UARTDriver_Impl_Operational_Api = {\n    val api = UARTDriver_Impl_Operational_Api(\n      id,\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id\n    )\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.EntryPoints(\n      id,\n\n      recv_data.id,\n      MissionCommand.id,\n      send_data.id,\n      AirVehicleState_WPM.id,\n      AirVehicleState_UXAS.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge {\n\n  var c_initialization_api: Option[UARTDriver_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[UARTDriver_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_BridgeId : Art.BridgeId,\n\n    recv_data_Id : Art.PortId,\n    MissionCommand_Id : Art.PortId,\n    send_data_Id : Art.PortId,\n    AirVehicleState_WPM_Id : Art.PortId,\n    AirVehicleState_UXAS_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: UARTDriver_Impl_Initialization_Api,\n    operational_api: UARTDriver_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(recv_data_Id,\n                                              MissionCommand_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(send_data_Id,\n                                               AirVehicleState_WPM_Id,\n                                               AirVehicleState_UXAS_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UARTDriver_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: UARTDriver_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/Drivers\/UARTDriver_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.Drivers\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait UARTDriver_Impl_Api {\n  def id: Art.BridgeId\n  def recv_data_Id : Art.PortId\n  def MissionCommand_Id : Art.PortId\n  def send_data_Id : Art.PortId\n  def AirVehicleState_WPM_Id : Art.PortId\n  def AirVehicleState_UXAS_Id : Art.PortId\n\n  def put_send_data(value : Base_Types.Bits) : Unit = {\n    Art.putValue(send_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AirVehicleState_WPM(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AirVehicleState_WPM_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AirVehicleState_UXAS(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AirVehicleState_UXAS_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class UARTDriver_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val AirVehicleState_WPM_Id : Art.PortId,\n  val AirVehicleState_UXAS_Id : Art.PortId) extends UARTDriver_Impl_Api\n\n@datatype class UARTDriver_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val AirVehicleState_WPM_Id : Art.PortId,\n  val AirVehicleState_UXAS_Id : Art.PortId) extends UARTDriver_Impl_Api {\n\n  def get_recv_data() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(recv_data_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port recv_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_MissionCommand() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(MissionCommand_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port MissionCommand.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/Drivers\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.Drivers\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver {\n\n  def initialise(api: UARTDriver_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: UARTDriver_Impl_Operational_Api): Unit = { }\n\n  def activate(api: UARTDriver_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: UARTDriver_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: UARTDriver_Impl_Operational_Api): Unit = { }\n\n  def recover(api: UARTDriver_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[uav_june_step6__Linux.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi extends BridgeTestSuite[RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation) {\n\n  \/** helper function to set the values of all input ports.\n   * @param recv_data payloads for event data port recv_data.\n   *   ART currently supports single element event data queues so\n   *   only the last element of recv_data will be used\n   *\/\n  def put_concrete_inputs(recv_data : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- recv_data){\n      put_recv_data(v)\n    }\n  }\n\n\n  \/** helper function to check RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param send_data method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'send_data'.\n   * @param trusted_ids method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'trusted_ids'.\n   * @param AutomationRequest method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest'.\n   * @param OperatingRegion method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'OperatingRegion'.\n   * @param LineSearchTask method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'LineSearchTask'.\n   *\/\n  def check_concrete_output(send_data: ISZ[Base_Types.Bits] => B = send_dataParam => {T},\n                            trusted_ids: ISZ[Base_Types.Bits] => B = trusted_idsParam => {T},\n                            AutomationRequest: ISZ[Base_Types.Bits] => B = AutomationRequestParam => {T},\n                            OperatingRegion: ISZ[Base_Types.Bits] => B = OperatingRegionParam => {T},\n                            LineSearchTask: ISZ[Base_Types.Bits] => B = LineSearchTaskParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var send_dataValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_send_data().nonEmpty) send_dataValue = send_dataValue :+ get_send_data().get\n    if(!send_data(send_dataValue)) {\n      testFailures = testFailures :+ st\"'send_data' did not match expected: received ${send_dataValue.size} events with the following payloads ${send_dataValue}\"\n    }\n    var trusted_idsValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_trusted_ids().nonEmpty) trusted_idsValue = trusted_idsValue :+ get_trusted_ids().get\n    if(!trusted_ids(trusted_idsValue)) {\n      testFailures = testFailures :+ st\"'trusted_ids' did not match expected: received ${trusted_idsValue.size} events with the following payloads ${trusted_idsValue}\"\n    }\n    var AutomationRequestValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest().nonEmpty) AutomationRequestValue = AutomationRequestValue :+ get_AutomationRequest().get\n    if(!AutomationRequest(AutomationRequestValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest' did not match expected: received ${AutomationRequestValue.size} events with the following payloads ${AutomationRequestValue}\"\n    }\n    var OperatingRegionValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_OperatingRegion().nonEmpty) OperatingRegionValue = OperatingRegionValue :+ get_OperatingRegion().get\n    if(!OperatingRegion(OperatingRegionValue)) {\n      testFailures = testFailures :+ st\"'OperatingRegion' did not match expected: received ${OperatingRegionValue.size} events with the following payloads ${OperatingRegionValue}\"\n    }\n    var LineSearchTaskValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_LineSearchTask().nonEmpty) LineSearchTaskValue = LineSearchTaskValue :+ get_LineSearchTask().get\n    if(!LineSearchTask(LineSearchTaskValue)) {\n      testFailures = testFailures :+ st\"'LineSearchTask' did not match expected: received ${LineSearchTaskValue.size} events with the following payloads ${LineSearchTaskValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_recv_data(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.recv_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_send_data(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_send_data_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port send_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_send_data_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.send_data_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_trusted_ids(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_trusted_ids_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port trusted_ids.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_trusted_ids_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.trusted_ids_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AutomationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AutomationRequest_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_OperatingRegion(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_OperatingRegion_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port OperatingRegion.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_OperatingRegion_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.OperatingRegion_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_LineSearchTask(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_LineSearchTask_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port LineSearchTask.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_LineSearchTask_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.LineSearchTask_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Test extends RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  recv_data: Port[Base_Types.Bits],\n  send_data: Port[Base_Types.Bits],\n  trusted_ids: Port[Base_Types.Bits],\n  AutomationRequest: Port[Base_Types.Bits],\n  OperatingRegion: Port[Base_Types.Bits],\n  LineSearchTask: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(recv_data,\n              send_data,\n              trusted_ids,\n              AutomationRequest,\n              OperatingRegion,\n              LineSearchTask),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(recv_data),\n\n    eventOuts = ISZ(send_data,\n                    trusted_ids,\n                    AutomationRequest,\n                    OperatingRegion,\n                    LineSearchTask)\n  )\n\n  val initialization_api : RadioDriver_Attestation_thr_Impl_Initialization_Api = {\n    val api = RadioDriver_Attestation_thr_Impl_Initialization_Api(\n      id,\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id\n    )\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : RadioDriver_Attestation_thr_Impl_Operational_Api = {\n    val api = RadioDriver_Attestation_thr_Impl_Operational_Api(\n      id,\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id\n    )\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.EntryPoints(\n      id,\n\n      recv_data.id,\n      send_data.id,\n      trusted_ids.id,\n      AutomationRequest.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge {\n\n  var c_initialization_api: Option[RadioDriver_Attestation_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[RadioDriver_Attestation_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_BridgeId : Art.BridgeId,\n\n    recv_data_Id : Art.PortId,\n    send_data_Id : Art.PortId,\n    trusted_ids_Id : Art.PortId,\n    AutomationRequest_Id : Art.PortId,\n    OperatingRegion_Id : Art.PortId,\n    LineSearchTask_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: RadioDriver_Attestation_thr_Impl_Initialization_Api,\n    operational_api: RadioDriver_Attestation_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(recv_data_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(send_data_Id,\n                                               trusted_ids_Id,\n                                               AutomationRequest_Id,\n                                               OperatingRegion_Id,\n                                               LineSearchTask_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: RadioDriver_Attestation_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/RadioDriver_Attestation_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait RadioDriver_Attestation_thr_Impl_Api {\n  def id: Art.BridgeId\n  def recv_data_Id : Art.PortId\n  def send_data_Id : Art.PortId\n  def trusted_ids_Id : Art.PortId\n  def AutomationRequest_Id : Art.PortId\n  def OperatingRegion_Id : Art.PortId\n  def LineSearchTask_Id : Art.PortId\n\n  def put_send_data(value : Base_Types.Bits) : Unit = {\n    Art.putValue(send_data_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_trusted_ids(value : Base_Types.Bits) : Unit = {\n    Art.putValue(trusted_ids_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AutomationRequest(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AutomationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_OperatingRegion(value : Base_Types.Bits) : Unit = {\n    Art.putValue(OperatingRegion_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_LineSearchTask(value : Base_Types.Bits) : Unit = {\n    Art.putValue(LineSearchTask_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class RadioDriver_Attestation_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId) extends RadioDriver_Attestation_thr_Impl_Api\n\n@datatype class RadioDriver_Attestation_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val recv_data_Id : Art.PortId,\n  val send_data_Id : Art.PortId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId) extends RadioDriver_Attestation_thr_Impl_Api {\n\n  def get_recv_data() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(recv_data_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port recv_data.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation {\n\n  def initialise(api: RadioDriver_Attestation_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: RadioDriver_Attestation_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi extends BridgeTestSuite[FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase) {\n\n  \/** helper function to check FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param keep_in_zones method that will be called with the value of the outgoing data\n   *        port 'keep_in_zones'.\n   * @param keep_out_zones method that will be called with the value of the outgoing data\n   *        port 'keep_out_zones'.\n   *\/\n  def check_concrete_output(keep_in_zones: Base_Types.Bits => B = keep_in_zonesParam => {T},\n                            keep_out_zones: Base_Types.Bits => B = keep_out_zonesParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val keep_in_zonesValue: Base_Types.Bits = get_keep_in_zones().get\n    if(!keep_in_zones(keep_in_zonesValue)) {\n      testFailures = testFailures :+ st\"'keep_in_zones' did not match expected: value of the outgoing data port is ${keep_in_zonesValue}\"\n    }\n    val keep_out_zonesValue: Base_Types.Bits = get_keep_out_zones().get\n    if(!keep_out_zones(keep_out_zonesValue)) {\n      testFailures = testFailures :+ st\"'keep_out_zones' did not match expected: value of the outgoing data port is ${keep_out_zonesValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ getter for out DataPort\n  def get_keep_in_zones(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_keep_in_zones_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port keep_in_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_keep_in_zones_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.keep_in_zones_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_keep_out_zones(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_keep_out_zones_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port keep_out_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_keep_out_zones_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.keep_out_zones_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Test extends FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  keep_in_zones: Port[Base_Types.Bits],\n  keep_out_zones: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(keep_in_zones,\n              keep_out_zones),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(keep_in_zones,\n                   keep_out_zones),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : FlyZonesDatabase_thr_Impl_Initialization_Api = {\n    val api = FlyZonesDatabase_thr_Impl_Initialization_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id\n    )\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : FlyZonesDatabase_thr_Impl_Operational_Api = {\n    val api = FlyZonesDatabase_thr_Impl_Operational_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id\n    )\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.EntryPoints(\n      id,\n\n      keep_in_zones.id,\n      keep_out_zones.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge {\n\n  var c_initialization_api: Option[FlyZonesDatabase_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[FlyZonesDatabase_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_BridgeId : Art.BridgeId,\n\n    keep_in_zones_Id : Art.PortId,\n    keep_out_zones_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: FlyZonesDatabase_thr_Impl_Initialization_Api,\n    operational_api: FlyZonesDatabase_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(keep_in_zones_Id,\n                                              keep_out_zones_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: FlyZonesDatabase_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/FlyZonesDatabase_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait FlyZonesDatabase_thr_Impl_Api {\n  def id: Art.BridgeId\n  def keep_in_zones_Id : Art.PortId\n  def keep_out_zones_Id : Art.PortId\n\n  def put_keep_in_zones(value : Base_Types.Bits) : Unit = {\n    Art.putValue(keep_in_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_keep_out_zones(value : Base_Types.Bits) : Unit = {\n    Art.putValue(keep_out_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class FlyZonesDatabase_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId) extends FlyZonesDatabase_thr_Impl_Api\n\n@datatype class FlyZonesDatabase_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId) extends FlyZonesDatabase_thr_Impl_Api {\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase {\n\n  def initialise(api: FlyZonesDatabase_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: FlyZonesDatabase_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi extends BridgeTestSuite[UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS) {\n\n  \/** helper function to set the values of all input ports.\n   * @param AutomationRequest payloads for event data port AutomationRequest.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationRequest will be used\n   * @param AirVehicleState payloads for event data port AirVehicleState.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AirVehicleState will be used\n   * @param OperatingRegion payloads for event data port OperatingRegion.\n   *   ART currently supports single element event data queues so\n   *   only the last element of OperatingRegion will be used\n   * @param LineSearchTask payloads for event data port LineSearchTask.\n   *   ART currently supports single element event data queues so\n   *   only the last element of LineSearchTask will be used\n   *\/\n  def put_concrete_inputs(AutomationRequest : ISZ[Base_Types.Bits],\n                          AirVehicleState : ISZ[Base_Types.Bits],\n                          OperatingRegion : ISZ[Base_Types.Bits],\n                          LineSearchTask : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- AutomationRequest){\n      put_AutomationRequest(v)\n    }\n    for(v <- AirVehicleState){\n      put_AirVehicleState(v)\n    }\n    for(v <- OperatingRegion){\n      put_OperatingRegion(v)\n    }\n    for(v <- LineSearchTask){\n      put_LineSearchTask(v)\n    }\n  }\n\n\n  \/** helper function to check UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AutomationResponse_MON_GEO method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationResponse_MON_GEO'.\n   * @param AutomationResponse_MON_REQ method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationResponse_MON_REQ'.\n   *\/\n  def check_concrete_output(AutomationResponse_MON_GEO: ISZ[Base_Types.Bits] => B = AutomationResponse_MON_GEOParam => {T},\n                            AutomationResponse_MON_REQ: ISZ[Base_Types.Bits] => B = AutomationResponse_MON_REQParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AutomationResponse_MON_GEOValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationResponse_MON_GEO().nonEmpty) AutomationResponse_MON_GEOValue = AutomationResponse_MON_GEOValue :+ get_AutomationResponse_MON_GEO().get\n    if(!AutomationResponse_MON_GEO(AutomationResponse_MON_GEOValue)) {\n      testFailures = testFailures :+ st\"'AutomationResponse_MON_GEO' did not match expected: received ${AutomationResponse_MON_GEOValue.size} events with the following payloads ${AutomationResponse_MON_GEOValue}\"\n    }\n    var AutomationResponse_MON_REQValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationResponse_MON_REQ().nonEmpty) AutomationResponse_MON_REQValue = AutomationResponse_MON_REQValue :+ get_AutomationResponse_MON_REQ().get\n    if(!AutomationResponse_MON_REQ(AutomationResponse_MON_REQValue)) {\n      testFailures = testFailures :+ st\"'AutomationResponse_MON_REQ' did not match expected: received ${AutomationResponse_MON_REQValue.size} events with the following payloads ${AutomationResponse_MON_REQValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationRequest(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AutomationRequest_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AirVehicleState(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AirVehicleState_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_OperatingRegion(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.OperatingRegion_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_LineSearchTask(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.LineSearchTask_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationResponse_MON_GEO(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationResponse_MON_GEO_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AutomationResponse_MON_GEO.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationResponse_MON_GEO_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AutomationResponse_MON_GEO_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationResponse_MON_REQ(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationResponse_MON_REQ_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AutomationResponse_MON_REQ.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationResponse_MON_REQ_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AutomationResponse_MON_REQ_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Test extends UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AutomationRequest: Port[Base_Types.Bits],\n  AirVehicleState: Port[Base_Types.Bits],\n  OperatingRegion: Port[Base_Types.Bits],\n  LineSearchTask: Port[Base_Types.Bits],\n  AutomationResponse_MON_GEO: Port[Base_Types.Bits],\n  AutomationResponse_MON_REQ: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(AutomationRequest,\n              AirVehicleState,\n              OperatingRegion,\n              LineSearchTask,\n              AutomationResponse_MON_GEO,\n              AutomationResponse_MON_REQ),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(AutomationRequest,\n                   AirVehicleState,\n                   OperatingRegion,\n                   LineSearchTask),\n\n    eventOuts = ISZ(AutomationResponse_MON_GEO,\n                    AutomationResponse_MON_REQ)\n  )\n\n  val initialization_api : UxAS_thr_Impl_Initialization_Api = {\n    val api = UxAS_thr_Impl_Initialization_Api(\n      id,\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id\n    )\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : UxAS_thr_Impl_Operational_Api = {\n    val api = UxAS_thr_Impl_Operational_Api(\n      id,\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id\n    )\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.EntryPoints(\n      id,\n\n      AutomationRequest.id,\n      AirVehicleState.id,\n      OperatingRegion.id,\n      LineSearchTask.id,\n      AutomationResponse_MON_GEO.id,\n      AutomationResponse_MON_REQ.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge {\n\n  var c_initialization_api: Option[UxAS_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[UxAS_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_BridgeId : Art.BridgeId,\n\n    AutomationRequest_Id : Art.PortId,\n    AirVehicleState_Id : Art.PortId,\n    OperatingRegion_Id : Art.PortId,\n    LineSearchTask_Id : Art.PortId,\n    AutomationResponse_MON_GEO_Id : Art.PortId,\n    AutomationResponse_MON_REQ_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: UxAS_thr_Impl_Initialization_Api,\n    operational_api: UxAS_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(AutomationRequest_Id,\n                                              AirVehicleState_Id,\n                                              OperatingRegion_Id,\n                                              LineSearchTask_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(AutomationResponse_MON_GEO_Id,\n                                               AutomationResponse_MON_REQ_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: UxAS_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: UxAS_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/UxAS_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait UxAS_thr_Impl_Api {\n  def id: Art.BridgeId\n  def AutomationRequest_Id : Art.PortId\n  def AirVehicleState_Id : Art.PortId\n  def OperatingRegion_Id : Art.PortId\n  def LineSearchTask_Id : Art.PortId\n  def AutomationResponse_MON_GEO_Id : Art.PortId\n  def AutomationResponse_MON_REQ_Id : Art.PortId\n\n  def put_AutomationResponse_MON_GEO(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AutomationResponse_MON_GEO_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AutomationResponse_MON_REQ(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AutomationResponse_MON_REQ_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class UxAS_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AutomationRequest_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId,\n  val AutomationResponse_MON_GEO_Id : Art.PortId,\n  val AutomationResponse_MON_REQ_Id : Art.PortId) extends UxAS_thr_Impl_Api\n\n@datatype class UxAS_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AutomationRequest_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val OperatingRegion_Id : Art.PortId,\n  val LineSearchTask_Id : Art.PortId,\n  val AutomationResponse_MON_GEO_Id : Art.PortId,\n  val AutomationResponse_MON_REQ_Id : Art.PortId) extends UxAS_thr_Impl_Api {\n\n  def get_AutomationRequest() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationRequest_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationRequest.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_AirVehicleState() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AirVehicleState_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AirVehicleState.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_OperatingRegion() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(OperatingRegion_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port OperatingRegion.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_LineSearchTask() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(LineSearchTask_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port LineSearchTask.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS {\n\n  def initialise(api: UxAS_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: UxAS_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi extends BridgeTestSuite[WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService) {\n\n  \/** helper function to set the values of all input ports.\n   * @param AutomationResponse payloads for event data port AutomationResponse.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationResponse will be used\n   * @param AirVehicleState payloads for event data port AirVehicleState.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AirVehicleState will be used\n   * @param ReturnHome the number of events to place in the ReturnHome event port queue.\n   *   ART currently supports single element event queues so at most\n   *   one event will be placed in the queue.\n   *\/\n  def put_concrete_inputs(AutomationResponse : ISZ[Base_Types.Bits],\n                          AirVehicleState : ISZ[Base_Types.Bits],\n                          ReturnHome : Z): Unit = {\n    for(v <- AutomationResponse){\n      put_AutomationResponse(v)\n    }\n    for(v <- AirVehicleState){\n      put_AirVehicleState(v)\n    }\n    for(i <- 0 until ReturnHome) {\n      put_ReturnHome()\n    }\n  }\n\n\n  \/** helper function to check WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param MissionCommand method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'MissionCommand'.\n   *\/\n  def check_concrete_output(MissionCommand: ISZ[Base_Types.Bits] => B = MissionCommandParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var MissionCommandValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_MissionCommand().nonEmpty) MissionCommandValue = MissionCommandValue :+ get_MissionCommand().get\n    if(!MissionCommand(MissionCommandValue)) {\n      testFailures = testFailures :+ st\"'MissionCommand' did not match expected: received ${MissionCommandValue.size} events with the following payloads ${MissionCommandValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationResponse(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AutomationResponse_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AirVehicleState(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AirVehicleState_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventPort\n  def put_ReturnHome(): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.ReturnHome_Id, Empty())\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_MissionCommand(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_MissionCommand_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port MissionCommand.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_MissionCommand_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.MissionCommand_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Test extends WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  AutomationResponse: Port[Base_Types.Bits],\n  AirVehicleState: Port[Base_Types.Bits],\n  MissionCommand: Port[Base_Types.Bits],\n  ReturnHome: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(AutomationResponse,\n              AirVehicleState,\n              MissionCommand,\n              ReturnHome),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(AutomationResponse,\n                   AirVehicleState,\n                   ReturnHome),\n\n    eventOuts = ISZ(MissionCommand)\n  )\n\n  val initialization_api : WaypointPlanManagerService_thr_Impl_Initialization_Api = {\n    val api = WaypointPlanManagerService_thr_Impl_Initialization_Api(\n      id,\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id\n    )\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : WaypointPlanManagerService_thr_Impl_Operational_Api = {\n    val api = WaypointPlanManagerService_thr_Impl_Operational_Api(\n      id,\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id\n    )\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.EntryPoints(\n      id,\n\n      AutomationResponse.id,\n      AirVehicleState.id,\n      MissionCommand.id,\n      ReturnHome.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge {\n\n  var c_initialization_api: Option[WaypointPlanManagerService_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[WaypointPlanManagerService_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_BridgeId : Art.BridgeId,\n\n    AutomationResponse_Id : Art.PortId,\n    AirVehicleState_Id : Art.PortId,\n    MissionCommand_Id : Art.PortId,\n    ReturnHome_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: WaypointPlanManagerService_thr_Impl_Initialization_Api,\n    operational_api: WaypointPlanManagerService_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(AutomationResponse_Id,\n                                              AirVehicleState_Id,\n                                              ReturnHome_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(MissionCommand_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: WaypointPlanManagerService_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/WaypointPlanManagerService_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait WaypointPlanManagerService_thr_Impl_Api {\n  def id: Art.BridgeId\n  def AutomationResponse_Id : Art.PortId\n  def AirVehicleState_Id : Art.PortId\n  def MissionCommand_Id : Art.PortId\n  def ReturnHome_Id : Art.PortId\n\n  def put_MissionCommand(value : Base_Types.Bits) : Unit = {\n    Art.putValue(MissionCommand_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class WaypointPlanManagerService_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val AutomationResponse_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val ReturnHome_Id : Art.PortId) extends WaypointPlanManagerService_thr_Impl_Api\n\n@datatype class WaypointPlanManagerService_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val AutomationResponse_Id : Art.PortId,\n  val AirVehicleState_Id : Art.PortId,\n  val MissionCommand_Id : Art.PortId,\n  val ReturnHome_Id : Art.PortId) extends WaypointPlanManagerService_thr_Impl_Api {\n\n  def get_AutomationResponse() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationResponse_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationResponse.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_AirVehicleState() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AirVehicleState_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AirVehicleState.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_ReturnHome() : Option[art.Empty] = {\n    val value : Option[art.Empty] = Art.getValue(ReturnHome_Id) match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port ReturnHome.  Expecting 'Empty' but received ${v}\")\n        None[art.Empty]()\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService {\n\n  def initialise(api: WaypointPlanManagerService_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: WaypointPlanManagerService_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi extends BridgeTestSuite[CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate) {\n\n  \/** helper function to set the values of all input ports.\n   * @param trusted_ids payloads for event data port trusted_ids.\n   *   ART currently supports single element event data queues so\n   *   only the last element of trusted_ids will be used\n   * @param AutomationRequest_in payloads for event data port AutomationRequest_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of AutomationRequest_in will be used\n   * @param OperatingRegion_in payloads for event data port OperatingRegion_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of OperatingRegion_in will be used\n   * @param LineSearchTask_in payloads for event data port LineSearchTask_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of LineSearchTask_in will be used\n   *\/\n  def put_concrete_inputs(trusted_ids : ISZ[Base_Types.Bits],\n                          AutomationRequest_in : ISZ[Base_Types.Bits],\n                          OperatingRegion_in : ISZ[Base_Types.Bits],\n                          LineSearchTask_in : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- trusted_ids){\n      put_trusted_ids(v)\n    }\n    for(v <- AutomationRequest_in){\n      put_AutomationRequest_in(v)\n    }\n    for(v <- OperatingRegion_in){\n      put_OperatingRegion_in(v)\n    }\n    for(v <- LineSearchTask_in){\n      put_LineSearchTask_in(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param AutomationRequest_out_UXAS method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest_out_UXAS'.\n   * @param AutomationRequest_out_MON_REQ method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'AutomationRequest_out_MON_REQ'.\n   * @param OperatingRegion_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'OperatingRegion_out'.\n   * @param LineSearchTask_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'LineSearchTask_out'.\n   *\/\n  def check_concrete_output(AutomationRequest_out_UXAS: ISZ[Base_Types.Bits] => B = AutomationRequest_out_UXASParam => {T},\n                            AutomationRequest_out_MON_REQ: ISZ[Base_Types.Bits] => B = AutomationRequest_out_MON_REQParam => {T},\n                            OperatingRegion_out: ISZ[Base_Types.Bits] => B = OperatingRegion_outParam => {T},\n                            LineSearchTask_out: ISZ[Base_Types.Bits] => B = LineSearchTask_outParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var AutomationRequest_out_UXASValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest_out_UXAS().nonEmpty) AutomationRequest_out_UXASValue = AutomationRequest_out_UXASValue :+ get_AutomationRequest_out_UXAS().get\n    if(!AutomationRequest_out_UXAS(AutomationRequest_out_UXASValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest_out_UXAS' did not match expected: received ${AutomationRequest_out_UXASValue.size} events with the following payloads ${AutomationRequest_out_UXASValue}\"\n    }\n    var AutomationRequest_out_MON_REQValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_AutomationRequest_out_MON_REQ().nonEmpty) AutomationRequest_out_MON_REQValue = AutomationRequest_out_MON_REQValue :+ get_AutomationRequest_out_MON_REQ().get\n    if(!AutomationRequest_out_MON_REQ(AutomationRequest_out_MON_REQValue)) {\n      testFailures = testFailures :+ st\"'AutomationRequest_out_MON_REQ' did not match expected: received ${AutomationRequest_out_MON_REQValue.size} events with the following payloads ${AutomationRequest_out_MON_REQValue}\"\n    }\n    var OperatingRegion_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_OperatingRegion_out().nonEmpty) OperatingRegion_outValue = OperatingRegion_outValue :+ get_OperatingRegion_out().get\n    if(!OperatingRegion_out(OperatingRegion_outValue)) {\n      testFailures = testFailures :+ st\"'OperatingRegion_out' did not match expected: received ${OperatingRegion_outValue.size} events with the following payloads ${OperatingRegion_outValue}\"\n    }\n    var LineSearchTask_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_LineSearchTask_out().nonEmpty) LineSearchTask_outValue = LineSearchTask_outValue :+ get_LineSearchTask_out().get\n    if(!LineSearchTask_out(LineSearchTask_outValue)) {\n      testFailures = testFailures :+ st\"'LineSearchTask_out' did not match expected: received ${LineSearchTask_outValue.size} events with the following payloads ${LineSearchTask_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_trusted_ids(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.trusted_ids_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_AutomationRequest_in(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.AutomationRequest_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_OperatingRegion_in(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.OperatingRegion_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_LineSearchTask_in(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.LineSearchTask_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest_out_UXAS(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_out_UXAS_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AutomationRequest_out_UXAS.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_out_UXAS_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AutomationRequest_out_UXAS_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_AutomationRequest_out_MON_REQ(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_AutomationRequest_out_MON_REQ_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port AutomationRequest_out_MON_REQ.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_AutomationRequest_out_MON_REQ_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.AutomationRequest_out_MON_REQ_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_OperatingRegion_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_OperatingRegion_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port OperatingRegion_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_OperatingRegion_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.OperatingRegion_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_LineSearchTask_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_LineSearchTask_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port LineSearchTask_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_LineSearchTask_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.LineSearchTask_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Test extends CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  trusted_ids: Port[Base_Types.Bits],\n  AutomationRequest_in: Port[Base_Types.Bits],\n  AutomationRequest_out_UXAS: Port[Base_Types.Bits],\n  AutomationRequest_out_MON_REQ: Port[Base_Types.Bits],\n  OperatingRegion_in: Port[Base_Types.Bits],\n  OperatingRegion_out: Port[Base_Types.Bits],\n  LineSearchTask_in: Port[Base_Types.Bits],\n  LineSearchTask_out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(trusted_ids,\n              AutomationRequest_in,\n              AutomationRequest_out_UXAS,\n              AutomationRequest_out_MON_REQ,\n              OperatingRegion_in,\n              OperatingRegion_out,\n              LineSearchTask_in,\n              LineSearchTask_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(trusted_ids,\n                   AutomationRequest_in,\n                   OperatingRegion_in,\n                   LineSearchTask_in),\n\n    eventOuts = ISZ(AutomationRequest_out_UXAS,\n                    AutomationRequest_out_MON_REQ,\n                    OperatingRegion_out,\n                    LineSearchTask_out)\n  )\n\n  val initialization_api : CASE_AttestationGate_thr_Impl_Initialization_Api = {\n    val api = CASE_AttestationGate_thr_Impl_Initialization_Api(\n      id,\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id\n    )\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_AttestationGate_thr_Impl_Operational_Api = {\n    val api = CASE_AttestationGate_thr_Impl_Operational_Api(\n      id,\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id\n    )\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.EntryPoints(\n      id,\n\n      trusted_ids.id,\n      AutomationRequest_in.id,\n      AutomationRequest_out_UXAS.id,\n      AutomationRequest_out_MON_REQ.id,\n      OperatingRegion_in.id,\n      OperatingRegion_out.id,\n      LineSearchTask_in.id,\n      LineSearchTask_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge {\n\n  var c_initialization_api: Option[CASE_AttestationGate_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_AttestationGate_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_BridgeId : Art.BridgeId,\n\n    trusted_ids_Id : Art.PortId,\n    AutomationRequest_in_Id : Art.PortId,\n    AutomationRequest_out_UXAS_Id : Art.PortId,\n    AutomationRequest_out_MON_REQ_Id : Art.PortId,\n    OperatingRegion_in_Id : Art.PortId,\n    OperatingRegion_out_Id : Art.PortId,\n    LineSearchTask_in_Id : Art.PortId,\n    LineSearchTask_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_AttestationGate_thr_Impl_Initialization_Api,\n    operational_api: CASE_AttestationGate_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(trusted_ids_Id,\n                                              AutomationRequest_in_Id,\n                                              OperatingRegion_in_Id,\n                                              LineSearchTask_in_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(AutomationRequest_out_UXAS_Id,\n                                               AutomationRequest_out_MON_REQ_Id,\n                                               OperatingRegion_out_Id,\n                                               LineSearchTask_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_AttestationGate_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_AttestationGate_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait CASE_AttestationGate_thr_Impl_Api {\n  def id: Art.BridgeId\n  def trusted_ids_Id : Art.PortId\n  def AutomationRequest_in_Id : Art.PortId\n  def AutomationRequest_out_UXAS_Id : Art.PortId\n  def AutomationRequest_out_MON_REQ_Id : Art.PortId\n  def OperatingRegion_in_Id : Art.PortId\n  def OperatingRegion_out_Id : Art.PortId\n  def LineSearchTask_in_Id : Art.PortId\n  def LineSearchTask_out_Id : Art.PortId\n\n  def put_AutomationRequest_out_UXAS(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AutomationRequest_out_UXAS_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_AutomationRequest_out_MON_REQ(value : Base_Types.Bits) : Unit = {\n    Art.putValue(AutomationRequest_out_MON_REQ_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_OperatingRegion_out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(OperatingRegion_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_LineSearchTask_out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(LineSearchTask_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_AttestationGate_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_in_Id : Art.PortId,\n  val AutomationRequest_out_UXAS_Id : Art.PortId,\n  val AutomationRequest_out_MON_REQ_Id : Art.PortId,\n  val OperatingRegion_in_Id : Art.PortId,\n  val OperatingRegion_out_Id : Art.PortId,\n  val LineSearchTask_in_Id : Art.PortId,\n  val LineSearchTask_out_Id : Art.PortId) extends CASE_AttestationGate_thr_Impl_Api\n\n@datatype class CASE_AttestationGate_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val trusted_ids_Id : Art.PortId,\n  val AutomationRequest_in_Id : Art.PortId,\n  val AutomationRequest_out_UXAS_Id : Art.PortId,\n  val AutomationRequest_out_MON_REQ_Id : Art.PortId,\n  val OperatingRegion_in_Id : Art.PortId,\n  val OperatingRegion_out_Id : Art.PortId,\n  val LineSearchTask_in_Id : Art.PortId,\n  val LineSearchTask_out_Id : Art.PortId) extends CASE_AttestationGate_thr_Impl_Api {\n\n  def get_trusted_ids() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(trusted_ids_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port trusted_ids.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_AutomationRequest_in() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(AutomationRequest_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port AutomationRequest_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_OperatingRegion_in() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(OperatingRegion_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port OperatingRegion_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_LineSearchTask_in() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(LineSearchTask_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port LineSearchTask_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate {\n\n  def initialise(api: CASE_AttestationGate_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_AttestationGate_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi extends BridgeTestSuite[CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST) {\n\n  \/** helper function to set the values of all input ports.\n   * @param filter_in payloads for event data port filter_in.\n   *   ART currently supports single element event data queues so\n   *   only the last element of filter_in will be used\n   *\/\n  def put_concrete_inputs(filter_in : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- filter_in){\n      put_filter_in(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param filter_out method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'filter_out'.\n   *\/\n  def check_concrete_output(filter_out: ISZ[Base_Types.Bits] => B = filter_outParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var filter_outValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_filter_out().nonEmpty) filter_outValue = filter_outValue :+ get_filter_out().get\n    if(!filter_out(filter_outValue)) {\n      testFailures = testFailures :+ st\"'filter_out' did not match expected: received ${filter_outValue.size} events with the following payloads ${filter_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_filter_in(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.filter_in_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_filter_out(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_filter_out_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port filter_out.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_filter_out_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.filter_out_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Test extends CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  filter_in: Port[Base_Types.Bits],\n  filter_out: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(filter_in,\n              filter_out),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(filter_in),\n\n    eventOuts = ISZ(filter_out)\n  )\n\n  val initialization_api : CASE_Filter_LST_thr_Impl_Initialization_Api = {\n    val api = CASE_Filter_LST_thr_Impl_Initialization_Api(\n      id,\n      filter_in.id,\n      filter_out.id\n    )\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Filter_LST_thr_Impl_Operational_Api = {\n    val api = CASE_Filter_LST_thr_Impl_Operational_Api(\n      id,\n      filter_in.id,\n      filter_out.id\n    )\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.EntryPoints(\n      id,\n\n      filter_in.id,\n      filter_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge {\n\n  var c_initialization_api: Option[CASE_Filter_LST_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Filter_LST_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_BridgeId : Art.BridgeId,\n\n    filter_in_Id : Art.PortId,\n    filter_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Filter_LST_thr_Impl_Initialization_Api,\n    operational_api: CASE_Filter_LST_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(filter_in_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(filter_out_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Filter_LST_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Filter_LST_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait CASE_Filter_LST_thr_Impl_Api {\n  def id: Art.BridgeId\n  def filter_in_Id : Art.PortId\n  def filter_out_Id : Art.PortId\n\n  def put_filter_out(value : Base_Types.Bits) : Unit = {\n    Art.putValue(filter_out_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Filter_LST_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val filter_in_Id : Art.PortId,\n  val filter_out_Id : Art.PortId) extends CASE_Filter_LST_thr_Impl_Api\n\n@datatype class CASE_Filter_LST_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val filter_in_Id : Art.PortId,\n  val filter_out_Id : Art.PortId) extends CASE_Filter_LST_thr_Impl_Api {\n\n  def get_filter_in() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(filter_in_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port filter_in.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST {\n\n  def initialise(api: CASE_Filter_LST_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Filter_LST_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi extends BridgeTestSuite[CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req) {\n\n  \/** helper function to set the values of all input ports.\n   * @param observed payloads for event data port observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of observed will be used\n   * @param reference_1 payloads for event data port reference_1.\n   *   ART currently supports single element event data queues so\n   *   only the last element of reference_1 will be used\n   *\/\n  def put_concrete_inputs(observed : ISZ[Base_Types.Bits],\n                          reference_1 : ISZ[Base_Types.Bits]): Unit = {\n    for(v <- observed){\n      put_observed(v)\n    }\n    for(v <- reference_1){\n      put_reference_1(v)\n    }\n  }\n\n\n  \/\/ setter for in EventDataPort\n  def put_observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_reference_1(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.reference_1_Id, Base_Types.Bits_Payload(value))\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Test extends CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  observed: Port[Base_Types.Bits],\n  reference_1: Port[Base_Types.Bits]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(observed,\n              reference_1),\n\n    dataIns = ISZ(),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(observed,\n                   reference_1),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : CASE_Monitor_Req_thr_Impl_Initialization_Api = {\n    val api = CASE_Monitor_Req_thr_Impl_Initialization_Api(\n      id,\n      observed.id,\n      reference_1.id\n    )\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor_Req_thr_Impl_Operational_Api = {\n    val api = CASE_Monitor_Req_thr_Impl_Operational_Api(\n      id,\n      observed.id,\n      reference_1.id\n    )\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.EntryPoints(\n      id,\n\n      observed.id,\n      reference_1.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor_Req_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor_Req_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_BridgeId : Art.BridgeId,\n\n    observed_Id : Art.PortId,\n    reference_1_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor_Req_thr_Impl_Initialization_Api,\n    operational_api: CASE_Monitor_Req_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(observed_Id,\n                                              reference_1_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Req_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Req_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait CASE_Monitor_Req_thr_Impl_Api {\n  def id: Art.BridgeId\n  def observed_Id : Art.PortId\n  def reference_1_Id : Art.PortId\n\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor_Req_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val observed_Id : Art.PortId,\n  val reference_1_Id : Art.PortId) extends CASE_Monitor_Req_thr_Impl_Api\n\n@datatype class CASE_Monitor_Req_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val observed_Id : Art.PortId,\n  val reference_1_Id : Art.PortId) extends CASE_Monitor_Req_thr_Impl_Api {\n\n  def get_observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_reference_1() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(reference_1_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port reference_1.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req {\n\n  def initialise(api: CASE_Monitor_Req_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor_Req_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/util\/uav_june_step6__Linux\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport uav_june_step6__Linux._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi extends BridgeTestSuite[CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge](Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo) {\n\n  \/** helper function to set the values of all input ports.\n   * @param keep_in_zones payload for data port keep_in_zones\n   * @param keep_out_zones payload for data port keep_out_zones\n   * @param observed payloads for event data port observed.\n   *   ART currently supports single element event data queues so\n   *   only the last element of observed will be used\n   *\/\n  def put_concrete_inputs(keep_in_zones : Base_Types.Bits,\n                          keep_out_zones : Base_Types.Bits,\n                          observed : ISZ[Base_Types.Bits]): Unit = {\n    put_keep_in_zones(keep_in_zones)\n    put_keep_out_zones(keep_out_zones)\n    for(v <- observed){\n      put_observed(v)\n    }\n  }\n\n\n  \/** helper function to check CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param output method that will be called with the payloads to be sent\n   *        on the outgoing event data port 'output'.\n   * @param alert method that will be called with the number of events to be sent\n   *        on the outgoing event port 'alert'.\n   *\/\n  def check_concrete_output(output: ISZ[Base_Types.Bits] => B = outputParam => {T},\n                            alert: Z => B = alertParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    var outputValue: ISZ[Base_Types.Bits] = ISZ()\n    \/\/ TODO: event data port getter should return all of the events\/payloads\n    \/\/       received on event data ports when queue sizes > 1 support is added\n    \/\/       to ART\n    if(get_output().nonEmpty) outputValue = outputValue :+ get_output().get\n    if(!output(outputValue)) {\n      testFailures = testFailures :+ st\"'output' did not match expected: received ${outputValue.size} events with the following payloads ${outputValue}\"\n    }\n    \/\/ TODO: event port getter should return the number of events in\n    \/\/       the output queue when queue sizes > 1 support is added to ART\n    val alertValue: Z = if(get_alert().nonEmpty) z\"1\" else z\"0\"\n    if(!alert(alertValue)) {\n      testFailures = testFailures :+ st\"'alert' did not match expected: ${alertValue} events were in the outgoing event queue\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_keep_in_zones(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.keep_in_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_keep_out_zones(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.keep_out_zones_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ setter for in EventDataPort\n  def put_observed(value : Base_Types.Bits): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.observed_Id, Base_Types.Bits_Payload(value))\n  }\n\n  \/\/ getter for out EventDataPort\n  def get_output(): Option[Base_Types.Bits] = {\n    val value: Option[Base_Types.Bits] = get_output_payload() match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port output.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventDataPort\n  def get_output_payload(): Option[Base_Types.Bits_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.output_Id).asInstanceOf[Option[Base_Types.Bits_Payload]]\n  }\n\n  \/\/ getter for out EventPort\n  def get_alert(): Option[art.Empty] = {\n    val value: Option[art.Empty] = get_alert_payload() match {\n      case Some(Empty()) => Some(Empty())\n      case Some(v) => fail(s\"Unexpected payload on port alert.  Expecting 'Empty' but received ${v}\")\n      case _ => None[art.Empty]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out EventPort\n  def get_alert_payload(): Option[Empty] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.alert_Id).asInstanceOf[Option[Empty]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/test\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux.SW._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Test extends CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\nimport uav_june_step6__Linux.SW.{CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@datatype class CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  keep_in_zones: Port[Base_Types.Bits],\n  keep_out_zones: Port[Base_Types.Bits],\n  observed: Port[Base_Types.Bits],\n  output: Port[Base_Types.Bits],\n  alert: Port[art.Empty]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(keep_in_zones,\n              keep_out_zones,\n              observed,\n              output,\n              alert),\n\n    dataIns = ISZ(keep_in_zones,\n                  keep_out_zones),\n\n    dataOuts = ISZ(),\n\n    eventIns = ISZ(observed),\n\n    eventOuts = ISZ(output,\n                    alert)\n  )\n\n  val initialization_api : CASE_Monitor_Geo_thr_Impl_Initialization_Api = {\n    val api = CASE_Monitor_Geo_thr_Impl_Initialization_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id\n    )\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : CASE_Monitor_Geo_thr_Impl_Operational_Api = {\n    val api = CASE_Monitor_Geo_thr_Impl_Operational_Api(\n      id,\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id\n    )\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.EntryPoints(\n      id,\n\n      keep_in_zones.id,\n      keep_out_zones.id,\n      observed.id,\n      output.id,\n      alert.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge {\n\n  var c_initialization_api: Option[CASE_Monitor_Geo_thr_Impl_Initialization_Api] = None()\n  var c_operational_api: Option[CASE_Monitor_Geo_thr_Impl_Operational_Api] = None()\n\n  @datatype class EntryPoints(\n    CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_BridgeId : Art.BridgeId,\n\n    keep_in_zones_Id : Art.PortId,\n    keep_out_zones_Id : Art.PortId,\n    observed_Id : Art.PortId,\n    output_Id : Art.PortId,\n    alert_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: CASE_Monitor_Geo_thr_Impl_Initialization_Api,\n    operational_api: CASE_Monitor_Geo_thr_Impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(keep_in_zones_Id,\n                                             keep_out_zones_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ(observed_Id)\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ(output_Id,\n                                               alert_Id)\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n\n      \/\/ implement the following in 'component':  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.timeTriggered(operational_api)\n\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      \/\/ implement the following method in 'component':  def activate(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      \/\/ implement the following method in 'component':  def deactivate(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      \/\/ implement the following method in 'component':  def finalise(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      \/\/ implement the following method in 'component':  def initialise(api: CASE_Monitor_Geo_thr_Impl_Initialization_Api): Unit = {}\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      \/\/ implement the following method in 'component':  def recover(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = {}\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/bridge\/uav_june_step6__Linux\/SW\/CASE_Monitor_Geo_thr_Impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport art._\nimport uav_june_step6__Linux._\n\n@sig trait CASE_Monitor_Geo_thr_Impl_Api {\n  def id: Art.BridgeId\n  def keep_in_zones_Id : Art.PortId\n  def keep_out_zones_Id : Art.PortId\n  def observed_Id : Art.PortId\n  def output_Id : Art.PortId\n  def alert_Id : Art.PortId\n\n  def put_output(value : Base_Types.Bits) : Unit = {\n    Art.putValue(output_Id, Base_Types.Bits_Payload(value))\n  }\n\n  def put_alert() : Unit = {\n    Art.putValue(alert_Id, art.Empty())\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class CASE_Monitor_Geo_thr_Impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId,\n  val observed_Id : Art.PortId,\n  val output_Id : Art.PortId,\n  val alert_Id : Art.PortId) extends CASE_Monitor_Geo_thr_Impl_Api\n\n@datatype class CASE_Monitor_Geo_thr_Impl_Operational_Api (\n  val id: Art.BridgeId,\n  val keep_in_zones_Id : Art.PortId,\n  val keep_out_zones_Id : Art.PortId,\n  val observed_Id : Art.PortId,\n  val output_Id : Art.PortId,\n  val alert_Id : Art.PortId) extends CASE_Monitor_Geo_thr_Impl_Api {\n\n  def get_keep_in_zones() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(keep_in_zones_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port keep_in_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_keep_out_zones() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(keep_out_zones_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port keep_out_zones.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n\n  def get_observed() : Option[Base_Types.Bits] = {\n    val value : Option[Base_Types.Bits] = Art.getValue(observed_Id) match {\n      case Some(Base_Types.Bits_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port observed.  Expecting 'Base_Types.Bits_Payload' but received ${v}\")\n        None[Base_Types.Bits]()\n      case _ => None[Base_Types.Bits]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/SW\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux.SW\n\nimport org.sireum._\nimport uav_june_step6__Linux._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo {\n\n  def initialise(api: CASE_Monitor_Geo_thr_Impl_Initialization_Api): Unit = { }\n\n  def timeTriggered(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n\n  def activate(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n\n  def deactivate(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n\n  def finalise(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n\n  def recover(api: CASE_Monitor_Geo_thr_Impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/component\/uav_june_step6__Linux\/TranspilerToucher.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\n\n\/\/ This file will not be overwritten so is safe to edit\n\nobject TranspilerToucher {\n  def touch(): Unit = {\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.entryPoints\n  val appPortId: Art.PortId = IPCPorts.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val recv_dataPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.recv_data.id\n  val recv_dataPortIdOpt: Option[Art.PortId] = Some(recv_dataPortId)\n  val MissionCommandPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.MissionCommand.id\n  val MissionCommandPortIdOpt: Option[Art.PortId] = Some(MissionCommandPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, recv_dataPortIdOpt)\n    Platform.initialise(seed, MissionCommandPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(recv_dataPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(recv_dataPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port recv_data.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(MissionCommandPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(MissionCommandPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port MissionCommand.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_recv_data()\n      val apiUsage_MissionCommand: Option[Base_Types.Bits] = uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.get_MissionCommand()\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_WPM(Base_Types.Bits_example())\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_initialization_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n      uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge.c_operational_api.get.put_AirVehicleState_UXAS(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_H\n#define UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c",
        {
          "type" : "TestResource",
          "content" : "#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h>\n#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl, numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl);\n  api_put_send_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i);\n  api_put_AirVehicleState_WPM__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i);\n  api_put_AirVehicleState_UXAS__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, t2);\n\n  api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl];\n  size_t t0_numBits;\n  if(api_get_recv_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl, \"numBits received does not match expected\");\n\n    DeclNewString(recv_data_str);\n    String__append(SF (String) &recv_data_str, string(\"Received on recv_data: \"));\n    byte_array_string(SF (String) &recv_data_str, t0, numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl);\n    api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF (String) &recv_data_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_MissionCommand_i];\n  size_t t1_numBits;\n  if(api_get_MissionCommand__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_MissionCommand_i, \"numBits received does not match expected\");\n\n    DeclNewString(MissionCommand_str);\n    String__append(SF (String) &MissionCommand_str, string(\"Received on MissionCommand: \"));\n    byte_array_string(SF (String) &MissionCommand_str, t1, numBytes_uav_june_step6__Linux_CMASI_MissionCommand_i);\n    api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(SF (String) &MissionCommand_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_API_H\n#define UARTDRIVER_IMPL_MCMP_PROC_SW_FC_UART_UARTDRIVER_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_recv_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_MissionCommand__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_send_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AirVehicleState_WPM__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AirVehicleState_UXAS__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.h>\n#include <UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_recv_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_get_recv_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_5125F8 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api(api);\n  Option_5125F8_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api_get_recv_data_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_MissionCommand__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_get_MissionCommand__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_5125F8 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api(api);\n  Option_5125F8_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api_get_MissionCommand_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_send_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_send_data__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_put_send_data_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AirVehicleState_WPM__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_AirVehicleState_WPM__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_put_AirVehicleState_WPM_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AirVehicleState_UXAS__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_put_AirVehicleState_UXAS__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_put_AirVehicleState_UXAS_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"api_logError__uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver\", 0);\n\n  \/\/ Option_279E92 = Option[uav_june_step6__Linux.Drivers.UARTDriver_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api(api);\n  Option_279E92_get_(SF (uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api) &api, uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise\", 0);\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise\", 0);\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_api.c\", \"\", \"uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered\", 0);\n\n  uav_june_step6__Linux_Drivers_UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.entryPoints\n  val appPortId: Art.PortId = IPCPorts.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val recv_dataPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.recv_data.id\n  val recv_dataPortIdOpt: Option[Art.PortId] = Some(recv_dataPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, recv_dataPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(recv_dataPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(recv_dataPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port recv_data.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_recv_data: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.get_recv_data()\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_send_data(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_trusted_ids(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_trusted_ids(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_AutomationRequest(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_AutomationRequest(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_OperatingRegion(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_OperatingRegion(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_initialization_api.get.put_LineSearchTask(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge.c_operational_api.get.put_LineSearchTask(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_H\n#define RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c",
        {
          "type" : "TestResource",
          "content" : "#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h>\n#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl, numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl);\n  api_put_send_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AddressArray_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__Linux_CMASI_AddressArray_i, numBytes_uav_june_step6__Linux_CMASI_AddressArray_i);\n  api_put_trusted_ids__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__Linux_CMASI_AddressArray_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n  api_put_AutomationRequest__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, t2);\n\n  uint8_t t3[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t3, numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n  api_put_OperatingRegion__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, t3);\n\n  uint8_t t4[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  byte_array_default(SF t4, numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n  api_put_LineSearchTask__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, t4);\n\n  api_logInfo__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl];\n  size_t t0_numBits;\n  if(api_get_recv_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl, \"numBits received does not match expected\");\n\n    DeclNewString(recv_data_str);\n    String__append(SF (String) &recv_data_str, string(\"Received on recv_data: \"));\n    byte_array_string(SF (String) &recv_data_str, t0, numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl);\n    api_logInfo__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(SF (String) &recv_data_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_API_H\n#define RADIODRIVER_ATTESTATION_THR_IMPL_MCMP_PROC_SW_RADIO_RADIODRIVER_ATTESTATION_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_recv_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_send_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_trusted_ids__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_OperatingRegion__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_LineSearchTask__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.h>\n#include <RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_recv_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_get_recv_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_5126A3 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Operational_Api(api);\n  Option_5126A3_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Operational_Api_get_recv_data_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_send_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_send_data__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_send_data_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_trusted_ids__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_trusted_ids__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_trusted_ids_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AutomationRequest__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_AutomationRequest__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_AutomationRequest_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_OperatingRegion__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_OperatingRegion__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_OperatingRegion_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_LineSearchTask__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_put_LineSearchTask__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_put_LineSearchTask_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation\", 0);\n\n  \/\/ Option_FF2B86 = Option[uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api(api);\n  Option_FF2B86_get_(SF (uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise\", 0);\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise\", 0);\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_api.c\", \"\", \"uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.entryPoints\n  val appPortId: Art.PortId = IPCPorts.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_in_zones(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_in_zones(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_initialization_api.get.put_keep_out_zones(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge.c_operational_api.get.put_keep_out_zones(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_H\n#define FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c",
        {
          "type" : "TestResource",
          "content" : "#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h>\n#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_Polygon_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_Polygon_i, numBytes_uav_june_step6__Linux_CMASI_Polygon_i);\n  api_put_keep_in_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF numBits_uav_june_step6__Linux_CMASI_Polygon_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_Polygon_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__Linux_CMASI_Polygon_i, numBytes_uav_june_step6__Linux_CMASI_Polygon_i);\n  api_put_keep_out_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF numBits_uav_june_step6__Linux_CMASI_Polygon_i, t1);\n\n  api_logInfo__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_\", 0);\n\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_API_H\n#define FLYZONESDATABASE_THR_IMPL_MCMP_PROC_SW_FLYZONES_FLYZONESDATABASE_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_keep_in_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_keep_out_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.h>\n#include <FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nvoid api_put_keep_in_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_put_keep_in_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_77E588 = Option[uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api(api);\n  Option_77E588_get_(SF (uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_put_keep_in_zones_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_keep_out_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_put_keep_out_zones__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_77E588 = Option[uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api(api);\n  Option_77E588_get_(SF (uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_put_keep_out_zones_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  \/\/ Option_77E588 = Option[uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api(api);\n  Option_77E588_get_(SF (uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  \/\/ Option_77E588 = Option[uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api(api);\n  Option_77E588_get_(SF (uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase\", 0);\n\n  \/\/ Option_77E588 = Option[uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api(api);\n  Option_77E588_get_(SF (uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise\", 0);\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise\", 0);\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_api.c\", \"\", \"uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.entryPoints\n  val appPortId: Art.PortId = IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val AutomationRequestPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationRequest.id\n  val AutomationRequestPortIdOpt: Option[Art.PortId] = Some(AutomationRequestPortId)\n  val AirVehicleStatePortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AirVehicleState.id\n  val AirVehicleStatePortIdOpt: Option[Art.PortId] = Some(AirVehicleStatePortId)\n  val OperatingRegionPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.OperatingRegion.id\n  val OperatingRegionPortIdOpt: Option[Art.PortId] = Some(OperatingRegionPortId)\n  val LineSearchTaskPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.LineSearchTask.id\n  val LineSearchTaskPortIdOpt: Option[Art.PortId] = Some(LineSearchTaskPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, AutomationRequestPortIdOpt)\n    Platform.initialise(seed, AirVehicleStatePortIdOpt)\n    Platform.initialise(seed, OperatingRegionPortIdOpt)\n    Platform.initialise(seed, LineSearchTaskPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AutomationRequestPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AutomationRequestPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AutomationRequest.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AirVehicleStatePortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AirVehicleStatePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AirVehicleState.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(OperatingRegionPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(OperatingRegionPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port OperatingRegion.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(LineSearchTaskPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(LineSearchTaskPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port LineSearchTask.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_AutomationRequest: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AutomationRequest()\n      val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_AirVehicleState()\n      val apiUsage_OperatingRegion: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_OperatingRegion()\n      val apiUsage_LineSearchTask: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.get_LineSearchTask()\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_GEO(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_initialization_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge.c_operational_api.get.put_AutomationResponse_MON_REQ(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_H\n#define UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c",
        {
          "type" : "TestResource",
          "content" : "#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h>\n#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n  api_put_AutomationResponse_MON_GEO__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n  api_put_AutomationResponse_MON_REQ__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, t1);\n\n  api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i];\n  size_t t0_numBits;\n  if(api_get_AutomationRequest__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, \"numBits received does not match expected\");\n\n    DeclNewString(AutomationRequest_str);\n    String__append(SF (String) &AutomationRequest_str, string(\"Received on AutomationRequest: \"));\n    byte_array_string(SF (String) &AutomationRequest_str, t0, numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i);\n    api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &AutomationRequest_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i];\n  size_t t1_numBits;\n  if(api_get_AirVehicleState__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, \"numBits received does not match expected\");\n\n    DeclNewString(AirVehicleState_str);\n    String__append(SF (String) &AirVehicleState_str, string(\"Received on AirVehicleState: \"));\n    byte_array_string(SF (String) &AirVehicleState_str, t1, numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i);\n    api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &AirVehicleState_str);\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_OperatingRegion_i];\n  size_t t2_numBits;\n  if(api_get_OperatingRegion__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_uav_june_step6__Linux_CMASI_OperatingRegion_i, \"numBits received does not match expected\");\n\n    DeclNewString(OperatingRegion_str);\n    String__append(SF (String) &OperatingRegion_str, string(\"Received on OperatingRegion: \"));\n    byte_array_string(SF (String) &OperatingRegion_str, t2, numBytes_uav_june_step6__Linux_CMASI_OperatingRegion_i);\n    api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &OperatingRegion_str);\n  }\n\n  uint8_t t3[numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i];\n  size_t t3_numBits;\n  if(api_get_LineSearchTask__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, \"numBits received does not match expected\");\n\n    DeclNewString(LineSearchTask_str);\n    String__append(SF (String) &LineSearchTask_str, string(\"Received on LineSearchTask: \"));\n    byte_array_string(SF (String) &LineSearchTask_str, t3, numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i);\n    api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(SF (String) &LineSearchTask_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_API_H\n#define UXAS_THR_IMPL_MCMP_PROC_SW_UXAS_UXAS_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_AutomationRequest__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AirVehicleState__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_OperatingRegion__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_LineSearchTask__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationResponse_MON_GEO__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationResponse_MON_REQ__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.h>\n#include <UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_AutomationRequest__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_AutomationRequest__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E4B268 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api(api);\n  Option_E4B268_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api_get_AutomationRequest_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AirVehicleState__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_AirVehicleState__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E4B268 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api(api);\n  Option_E4B268_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api_get_AirVehicleState_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_OperatingRegion__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_OperatingRegion__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E4B268 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api(api);\n  Option_E4B268_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api_get_OperatingRegion_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_LineSearchTask__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_get_LineSearchTask__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_E4B268 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api(api);\n  Option_E4B268_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api_get_LineSearchTask_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_AutomationResponse_MON_GEO__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_put_AutomationResponse_MON_GEO__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_41F874 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api(api);\n  Option_41F874_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api_put_AutomationResponse_MON_GEO_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AutomationResponse_MON_REQ__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_put_AutomationResponse_MON_REQ__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_41F874 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api(api);\n  Option_41F874_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api_put_AutomationResponse_MON_REQ_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_41F874 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api(api);\n  Option_41F874_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_41F874 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api(api);\n  Option_41F874_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS\", 0);\n\n  \/\/ Option_41F874 = Option[uav_june_step6__Linux.SW.UxAS_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api(api);\n  Option_41F874_get_(SF (uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise\", 0);\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise\", 0);\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_api.c\", \"\", \"uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.entryPoints\n  val appPortId: Art.PortId = IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val AutomationResponsePortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AutomationResponse.id\n  val AutomationResponsePortIdOpt: Option[Art.PortId] = Some(AutomationResponsePortId)\n  val AirVehicleStatePortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AirVehicleState.id\n  val AirVehicleStatePortIdOpt: Option[Art.PortId] = Some(AirVehicleStatePortId)\n  val ReturnHomePortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.ReturnHome.id\n  val ReturnHomePortIdOpt: Option[Art.PortId] = Some(ReturnHomePortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, AutomationResponsePortIdOpt)\n    Platform.initialise(seed, AirVehicleStatePortIdOpt)\n    Platform.initialise(seed, ReturnHomePortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AutomationResponsePortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AutomationResponsePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AutomationResponse.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AirVehicleStatePortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AirVehicleStatePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AirVehicleState.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(ReturnHomePortIdOpt, out)\n      out.value2 match {\n        case Some(v: art.Empty) => ArtNix.updateData(ReturnHomePortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port ReturnHome.  Expecting something of type art.Empty but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_AutomationResponse: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AutomationResponse()\n      val apiUsage_AirVehicleState: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_AirVehicleState()\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_initialization_api.get.put_MissionCommand(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.put_MissionCommand(Base_Types.Bits_example())\n      val apiUsage_ReturnHome: Option[art.Empty] = uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge.c_operational_api.get.get_ReturnHome()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_H\n#define WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c",
        {
          "type" : "TestResource",
          "content" : "#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h>\n#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_MissionCommand_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_MissionCommand_i, numBytes_uav_june_step6__Linux_CMASI_MissionCommand_i);\n  api_put_MissionCommand__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF numBits_uav_june_step6__Linux_CMASI_MissionCommand_i, t0);\n\n  api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  size_t t0_numBits;\n  if(api_get_AutomationResponse__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, \"numBits received does not match expected\");\n\n    DeclNewString(AutomationResponse_str);\n    String__append(SF (String) &AutomationResponse_str, string(\"Received on AutomationResponse: \"));\n    byte_array_string(SF (String) &AutomationResponse_str, t0, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF (String) &AutomationResponse_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i];\n  size_t t1_numBits;\n  if(api_get_AirVehicleState__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i, \"numBits received does not match expected\");\n\n    DeclNewString(AirVehicleState_str);\n    String__append(SF (String) &AirVehicleState_str, string(\"Received on AirVehicleState: \"));\n    byte_array_string(SF (String) &AirVehicleState_str, t1, numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i);\n    api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF (String) &AirVehicleState_str);\n  }\n\n  if(api_get_ReturnHome__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF_LAST )){\n    String ReturnHome_str = string(\"Received event on ReturnHome\");\n    api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(SF ReturnHome_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_API_H\n#define WAYPOINTPLANMANAGERSERVICE_THR_IMPL_MCMP_PROC_SW_WPM_WAYPOINTPLANMANAGERSERVICE_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_AutomationResponse__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AirVehicleState__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_MissionCommand__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_ReturnHome__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(STACK_FRAME_ONLY);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.h>\n#include <WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_AutomationResponse__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_AutomationResponse__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A452DC = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api(api);\n  Option_A452DC_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_AutomationResponse_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AirVehicleState__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_AirVehicleState__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_A452DC = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api(api);\n  Option_A452DC_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_AirVehicleState_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_MissionCommand__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_put_MissionCommand__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_17D934 = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api(api);\n  Option_17D934_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_put_MissionCommand_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_ReturnHome__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(STACK_FRAME_ONLY){\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_get_ReturnHome__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_A452DC = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api(api);\n  Option_A452DC_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_operational_api(SF_LAST));\n\n  \/\/ Option_C622DB = Option[art.Empty]\n  \/\/ Some_4782C6 = Some[art.Empty]\n  DeclNewOption_C622DB(t_0);\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api_get_ReturnHome_(\n    SF\n    (Option_C622DB) &t_0,\n    &api);\n\n  if(t_0.type == TSome_4782C6){\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_17D934 = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api(api);\n  Option_17D934_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_17D934 = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api(api);\n  Option_17D934_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService\", 0);\n\n  \/\/ Option_17D934 = Option[uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api(api);\n  Option_17D934_get_(SF (uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise\", 0);\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise\", 0);\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_api.c\", \"\", \"uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val trusted_idsPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.trusted_ids.id\n  val trusted_idsPortIdOpt: Option[Art.PortId] = Some(trusted_idsPortId)\n  val AutomationRequest_inPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_in.id\n  val AutomationRequest_inPortIdOpt: Option[Art.PortId] = Some(AutomationRequest_inPortId)\n  val OperatingRegion_inPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_in.id\n  val OperatingRegion_inPortIdOpt: Option[Art.PortId] = Some(OperatingRegion_inPortId)\n  val LineSearchTask_inPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_in.id\n  val LineSearchTask_inPortIdOpt: Option[Art.PortId] = Some(LineSearchTask_inPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, trusted_idsPortIdOpt)\n    Platform.initialise(seed, AutomationRequest_inPortIdOpt)\n    Platform.initialise(seed, OperatingRegion_inPortIdOpt)\n    Platform.initialise(seed, LineSearchTask_inPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(trusted_idsPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(trusted_idsPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port trusted_ids.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(AutomationRequest_inPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(AutomationRequest_inPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port AutomationRequest_in.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(OperatingRegion_inPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(OperatingRegion_inPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port OperatingRegion_in.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(LineSearchTask_inPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(LineSearchTask_inPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port LineSearchTask_in.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_trusted_ids: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_trusted_ids()\n      val apiUsage_AutomationRequest_in: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_AutomationRequest_in()\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_UXAS(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_AutomationRequest_out_MON_REQ(Base_Types.Bits_example())\n      val apiUsage_OperatingRegion_in: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_OperatingRegion_in()\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_OperatingRegion_out(Base_Types.Bits_example())\n      val apiUsage_LineSearchTask_in: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.get_LineSearchTask_in()\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_initialization_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge.c_operational_api.get.put_LineSearchTask_out(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_H\n#define CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i);\n  api_put_AutomationRequest_out_UXAS__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, t0);\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i];\n  byte_array_default(SF t1, numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i);\n  api_put_AutomationRequest_out_MON_REQ__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, t1);\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_OperatingRegion_i];\n  byte_array_default(SF t2, numBits_uav_june_step6__Linux_CMASI_OperatingRegion_i, numBytes_uav_june_step6__Linux_CMASI_OperatingRegion_i);\n  api_put_OperatingRegion_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__Linux_CMASI_OperatingRegion_i, t2);\n\n  uint8_t t3[numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i];\n  byte_array_default(SF t3, numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i);\n  api_put_LineSearchTask_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, t3);\n\n  api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AddressArray_i];\n  size_t t0_numBits;\n  if(api_get_trusted_ids__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_AddressArray_i, \"numBits received does not match expected\");\n\n    DeclNewString(trusted_ids_str);\n    String__append(SF (String) &trusted_ids_str, string(\"Received on trusted_ids: \"));\n    byte_array_string(SF (String) &trusted_ids_str, t0, numBytes_uav_june_step6__Linux_CMASI_AddressArray_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &trusted_ids_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  size_t t1_numBits;\n  if(api_get_AutomationRequest_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\");\n\n    DeclNewString(AutomationRequest_in_str);\n    String__append(SF (String) &AutomationRequest_in_str, string(\"Received on AutomationRequest_in: \"));\n    byte_array_string(SF (String) &AutomationRequest_in_str, t1, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &AutomationRequest_in_str);\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  size_t t2_numBits;\n  if(api_get_OperatingRegion_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\");\n\n    DeclNewString(OperatingRegion_in_str);\n    String__append(SF (String) &OperatingRegion_in_str, string(\"Received on OperatingRegion_in: \"));\n    byte_array_string(SF (String) &OperatingRegion_in_str, t2, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &OperatingRegion_in_str);\n  }\n\n  uint8_t t3[numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i];\n  size_t t3_numBits;\n  if(api_get_LineSearchTask_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF &t3_numBits, t3)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t3_numBits == numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i, \"numBits received does not match expected\");\n\n    DeclNewString(LineSearchTask_in_str);\n    String__append(SF (String) &LineSearchTask_in_str, string(\"Received on LineSearchTask_in: \"));\n    byte_array_string(SF (String) &LineSearchTask_in_str, t3, numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(SF (String) &LineSearchTask_in_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_API_H\n#define CASE_ATTESTATIONGATE_THR_IMPL_MCMP_PROC_SW_AM_GATE_CASE_ATTESTATIONGATE_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_trusted_ids__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_AutomationRequest_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest_out_UXAS__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_AutomationRequest_out_MON_REQ__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_OperatingRegion_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_OperatingRegion_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nbool api_get_LineSearchTask_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_LineSearchTask_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.h>\n#include <CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_trusted_ids__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_trusted_ids__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_115D1F = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api(api);\n  Option_115D1F_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_trusted_ids_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_AutomationRequest_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_AutomationRequest_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_115D1F = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api(api);\n  Option_115D1F_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_AutomationRequest_in_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_AutomationRequest_out_UXAS__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_AutomationRequest_out_UXAS__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_AutomationRequest_out_UXAS_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_AutomationRequest_out_MON_REQ__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_AutomationRequest_out_MON_REQ__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_AutomationRequest_out_MON_REQ_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_OperatingRegion_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_OperatingRegion_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_115D1F = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api(api);\n  Option_115D1F_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_OperatingRegion_in_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_OperatingRegion_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_OperatingRegion_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_OperatingRegion_out_(\n    SF\n    &api,\n    &t_0);\n}\n\nbool api_get_LineSearchTask_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_get_LineSearchTask_in__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_115D1F = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api(api);\n  Option_115D1F_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api_get_LineSearchTask_in_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_LineSearchTask_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_put_LineSearchTask_out__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_put_LineSearchTask_out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate\", 0);\n\n  \/\/ Option_E4CE95 = Option[uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api(api);\n  Option_E4CE95_get_(SF (uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val filter_inPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_in.id\n  val filter_inPortIdOpt: Option[Art.PortId] = Some(filter_inPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, filter_inPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(filter_inPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(filter_inPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port filter_in.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_filter_in: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.get_filter_in()\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_initialization_api.get.put_filter_out(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge.c_operational_api.get.put_filter_out(Base_Types.Bits_example())\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_H\n#define CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i);\n  api_put_filter_out__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, t0);\n\n  api_logInfo__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i];\n  size_t t0_numBits;\n  if(api_get_filter_in__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i, \"numBits received does not match expected\");\n\n    DeclNewString(filter_in_str);\n    String__append(SF (String) &filter_in_str, string(\"Received on filter_in: \"));\n    byte_array_string(SF (String) &filter_in_str, t0, numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(SF (String) &filter_in_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_API_H\n#define CASE_FILTER_LST_THR_IMPL_MCMP_PROC_SW_FLT_LST_CASE_FILTER_LST_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_filter_in__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_filter_out__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.h>\n#include <CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_filter_in__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_get_filter_in__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_18A83B = Option[uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Operational_Api(api);\n  Option_18A83B_get_(SF (uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Operational_Api_get_filter_in_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_filter_out__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_put_filter_out__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_368700 = Option[uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api(api);\n  Option_368700_get_(SF (uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_put_filter_out_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  \/\/ Option_368700 = Option[uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api(api);\n  Option_368700_get_(SF (uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  \/\/ Option_368700 = Option[uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api(api);\n  Option_368700_get_(SF (uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST\", 0);\n\n  \/\/ Option_368700 = Option[uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api(api);\n  Option_368700_get_(SF (uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val observedPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.observed.id\n  val observedPortIdOpt: Option[Art.PortId] = Some(observedPortId)\n  val reference_1PortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.reference_1.id\n  val reference_1PortIdOpt: Option[Art.PortId] = Some(reference_1PortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, observedPortIdOpt)\n    Platform.initialise(seed, reference_1PortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(observedPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(observedPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port observed.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(reference_1PortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(reference_1PortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port reference_1.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_observed()\n      val apiUsage_reference_1: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge.c_operational_api.get.get_reference_1()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_H\n#define CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h>\n#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  size_t t0_numBits;\n  if(api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, \"numBits received does not match expected\");\n\n    DeclNewString(observed_str);\n    String__append(SF (String) &observed_str, string(\"Received on observed: \"));\n    byte_array_string(SF (String) &observed_str, t0, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF (String) &observed_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i];\n  size_t t1_numBits;\n  if(api_get_reference_1__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i, \"numBits received does not match expected\");\n\n    DeclNewString(reference_1_str);\n    String__append(SF (String) &reference_1_str, string(\"Received on reference_1: \"));\n    byte_array_string(SF (String) &reference_1_str, t1, numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(SF (String) &reference_1_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_API_H\n#define CASE_MONITOR_REQ_THR_IMPL_MCMP_PROC_SW_MON_REQ_CASE_MONITOR_REQ_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_reference_1__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.h>\n#include <CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_5A38A4 = Option[uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api(api);\n  Option_5A38A4_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api_get_observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_reference_1__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_get_reference_1__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_5A38A4 = Option[uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api(api);\n  Option_5A38A4_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api_get_reference_1_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  \/\/ Option_BC2DAD = Option[uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api(api);\n  Option_BC2DAD_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  \/\/ Option_BC2DAD = Option[uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api(api);\n  Option_BC2DAD_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req\", 0);\n\n  \/\/ Option_BC2DAD = Option[uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api(api);\n  Option_BC2DAD_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App extends App {\n\n  val entryPoints: Bridge.EntryPoints = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.entryPoints\n  val appPortId: Art.PortId = IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App\n  val appPortIdOpt: Option[Art.PortId] = Some(appPortId)\n  val keep_in_zonesPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_in_zones.id\n  val keep_in_zonesPortIdOpt: Option[Art.PortId] = Some(keep_in_zonesPortId)\n  val keep_out_zonesPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_out_zones.id\n  val keep_out_zonesPortIdOpt: Option[Art.PortId] = Some(keep_out_zonesPortId)\n  val observedPortId: Art.PortId = Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.observed.id\n  val observedPortIdOpt: Option[Art.PortId] = Some(observedPortId)\n\n  def initialiseArchitecture(seed: Z): Unit = {\n    Platform.initialise(seed, appPortIdOpt)\n    Platform.initialise(seed, keep_in_zonesPortIdOpt)\n    Platform.initialise(seed, keep_out_zonesPortIdOpt)\n    Platform.initialise(seed, observedPortIdOpt)\n\n    Art.run(Arch.ad)\n  }\n\n  def initialise(): Unit = {\n    entryPoints.initialise()\n  }\n\n  def compute(): Unit = {\n\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(keep_in_zonesPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(keep_in_zonesPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port keep_in_zones.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(keep_out_zonesPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(keep_out_zonesPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port keep_out_zones.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(observedPortIdOpt, out)\n      out.value2 match {\n        case Some(v: Base_Types.Bits_Payload) => ArtNix.updateData(observedPortId, v)\n        case Some(v) => halt(s\"Unexpected payload on port observed.  Expecting something of type Base_Types.Bits_Payload but received ${v}\")\n        case None() => \/\/ do nothing\n      }\n    }\n    entryPoints.compute()\n    Process.sleep(500)\n  }\n\n  def finalise(): Unit = {\n    entryPoints.finalise()\n  }\n\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    initialiseArchitecture(seed)\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after setting up component\n\n    initialise()\n\n    Platform.receive(appPortIdOpt, IPCPorts.emptyReceiveOut) \/\/ pause after component init\n\n    println(\"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App starting ...\")\n\n    ArtNix.timeDispatch()\n\n    var terminated = F\n    while (!terminated) {\n      val out = IPCPorts.emptyReceiveAsyncOut\n      Platform.receiveAsync(appPortIdOpt, out)\n      if (out.value2.isEmpty) {\n        compute()\n      } else {\n        terminated = T\n      }\n    }\n    exit()\n\n    touch()\n\n    return 0\n  }\n\n  def touch(): Unit = {\n    if(F) {\n      TranspilerToucher.touch()\n\n      \/\/ touch each payload\/type in case some are only used as a field in a record\n      def printDataContent(a: art.DataContent): Unit = { println(s\"${a}\") }\n\n      printDataContent(Base_Types.Bits_Payload(Base_Types.Bits_example()))\n      printDataContent(art.Empty())\n\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.logError(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logInfo(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logDebug(\"\")\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.logError(\"\")\n      val apiUsage_keep_in_zones: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_in_zones()\n      val apiUsage_keep_out_zones: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_keep_out_zones()\n      val apiUsage_observed: Option[Base_Types.Bits] = uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.get_observed()\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_output(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_output(Base_Types.Bits_example())\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_initialization_api.get.put_alert()\n      uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge.c_operational_api.get.put_alert()\n    }\n  }\n\n  def exit(): Unit = {\n    finalise()\n    Platform.finalise()\n  }\n\n  override def atExit(): Unit = {\n    exit()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_H\n#define CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_H\n\n#include <all.h>\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(STACK_FRAME_ONLY);\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(STACK_FRAME_ONLY);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h>\n#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_\", 0);\n\n  \/\/ examples of api setter and logging usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  byte_array_default(SF t0, numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n  api_put_output__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, t0);\n\n  api_put_alert__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF_LAST);\n\n  api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logInfo\"));\n\n  api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logDebug\"));\n\n  api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF string(\"Example logError\"));\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_\", 0);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_\", 0);\n\n  \/\/ examples of api getter usage\n\n  uint8_t t0[numBytes_uav_june_step6__Linux_CMASI_Polygon_i];\n  size_t t0_numBits;\n  if(api_get_keep_in_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t0_numBits, t0)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t0_numBits == numBits_uav_june_step6__Linux_CMASI_Polygon_i, \"numBits received does not match expected\");\n\n    DeclNewString(keep_in_zones_str);\n    String__append(SF (String) &keep_in_zones_str, string(\"Received on keep_in_zones: \"));\n    byte_array_string(SF (String) &keep_in_zones_str, t0, numBytes_uav_june_step6__Linux_CMASI_Polygon_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &keep_in_zones_str);\n  }\n\n  uint8_t t1[numBytes_uav_june_step6__Linux_CMASI_Polygon_i];\n  size_t t1_numBits;\n  if(api_get_keep_out_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t1_numBits, t1)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t1_numBits == numBits_uav_june_step6__Linux_CMASI_Polygon_i, \"numBits received does not match expected\");\n\n    DeclNewString(keep_out_zones_str);\n    String__append(SF (String) &keep_out_zones_str, string(\"Received on keep_out_zones: \"));\n    byte_array_string(SF (String) &keep_out_zones_str, t1, numBytes_uav_june_step6__Linux_CMASI_Polygon_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &keep_out_zones_str);\n  }\n\n  uint8_t t2[numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i];\n  size_t t2_numBits;\n  if(api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF &t2_numBits, t2)) {\n    \/\/ sanity check\n    sfAssert(SF (Z) t2_numBits == numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i, \"numBits received does not match expected\");\n\n    DeclNewString(observed_str);\n    String__append(SF (String) &observed_str, string(\"Received on observed: \"));\n    byte_array_string(SF (String) &observed_str, t2, numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i);\n    api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(SF (String) &observed_str);\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_API_H\n#define CASE_MONITOR_GEO_THR_IMPL_MCMP_PROC_SW_MON_GEO_CASE_MONITOR_GEO_API_H\n\n#include <all.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_keep_in_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_keep_out_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nbool api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray);\n\nvoid api_put_output__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray);\n\nvoid api_put_alert__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(STACK_FRAME_ONLY);\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str);\n\n#endif\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c",
        {
          "type" : "TestResource",
          "content" : "#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.h>\n#include <CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.h>\n\n\/\/ This file was auto-generated.  Do not edit\n\nbool api_get_keep_in_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_keep_in_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_F16148 = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api(api);\n  Option_F16148_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_keep_in_zones_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_keep_out_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_keep_out_zones__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_F16148 = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api(api);\n  Option_F16148_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_keep_out_zones_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t *numBits,\n  uint8_t *byteArray){\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_get_observed__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_30119F = Option[IS[Z, B]]\n  \/\/ Some_8D03B1 = Some[IS[Z, B]]\n  DeclNewOption_30119F(t_0);\n\n  \/\/ Option_F16148 = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Operational_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api(api);\n  Option_F16148_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_operational_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api_get_observed_(\n    SF\n    (Option_30119F) &t_0,\n    &api);\n\n  if(t_0.type == TSome_8D03B1){\n    *numBits = t_0.Some_8D03B1.value.size;\n    if(*numBits > 0) {\n      size_t numBytes = (*numBits - 1) \/ 8 + 1;\n      memcpy(byteArray, &t_0.Some_8D03B1.value.value, numBytes);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid api_put_output__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  size_t numBits,\n  uint8_t *byteArray) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_put_output__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  sfAssert(SF (Z) numBits >= 0, \"numBits must be non-negative for IS[Z, B].\");\n  sfAssert(SF (Z) numBits <= MaxIS_C4F575, \"numBits too large for IS[Z, B].\");\n\n  DeclNewIS_C4F575(t_0);\n\n  t_0.size = numBits;\n  if(numBits > 0) {\n    size_t numBytes = (numBits - 1) \/ 8 + 1;\n    memcpy(&t_0.value, byteArray, numBytes);\n  }\n\n  \/\/ Option_37D73C = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api(api);\n  Option_37D73C_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_put_output_(\n    SF\n    &api,\n    &t_0);\n}\n\nvoid api_put_alert__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(STACK_FRAME_ONLY) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_put_alert__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_37D73C = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api(api);\n  Option_37D73C_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_put_alert_(\n    SF\n    &api);\n}\n\nvoid api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logInfo__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_37D73C = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api(api);\n  Option_37D73C_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logInfo_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logDebug__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_37D73C = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api(api);\n  Option_37D73C_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logDebug_(\n    SF\n    &api,\n    str);\n}\n\nvoid api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo(\n  STACK_FRAME\n  String str) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"api_logError__uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\", 0);\n\n  \/\/ Option_37D73C = Option[uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_Initialization_Api]\n  DeclNewuav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api(api);\n  Option_37D73C_get_(SF (uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api) &api, uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_Bridge_c_initialization_api(SF_LAST));\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api_logError_(\n    SF\n    &api,\n    str);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Initialization_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_initialise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_finalise_(SF_LAST);\n}\n\nUnit uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered(\n  STACK_FRAME\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_Operational_Api api) {\n  DeclNewStackFrame(caller, \"CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_api.c\", \"\", \"uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered\", 0);\n\n  uav_june_step6__Linux_SW_CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_timeTriggered_(SF_LAST);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/ext.c",
        {
          "type" : "TestResource",
          "content" : "#include <ext.h>\n\n\/\/ This file will not be overwritten so is safe to edit\n\n\/\/ add c extension code here\n\n\/\/ example method that sets the first numBits bits of byteArray to 1\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_default\", 0);\n\n  sfAssert(SF (numBits - 1) \/ 8  + 1 <= numBytes, \"byte_array_default: numBytes * 8 must be at least numBits\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    uint8_t v = 0;\n    for(uint8_t bit = 0; bit < 8; bit++) {\n      if(byte * 8 + bit < numBits) {\n        v |= 1UL << bit;\n      }\n    }\n    byteArray[byte] = v;\n  }\n}\n\n\/\/ example method that places the hex value of the bytes in byteArray into str\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"byte_array_string\", 0);\n\n  sfAssert(SF (str->size + numBytes) <= MaxString, \"byte_array_string: Insufficient maximum for String characters, consider increasing the --max-string-size option\");\n\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    U8_string_(SF str, byteArray[byte]);\n    String__append(SF str, string(\" \"));\n  }\n}\n\n\/\/ example method that directly prints the hex values of the bytes in byte_array\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes) {\n  DeclNewStackFrame(caller, \"ext.c\", \"\", \"hex_dump\", 0);\n\n  printf(\"[ \");\n  for(size_t byte = 0; byte < numBytes; byte++) {\n    if(byte != 0 && byte % 16 == 0) { printf(\"\\n  \"); }\n    printf(\"%02X \", byte_array[byte]);\n  }\n  printf(\"]\\n\");\n}",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/ext-c\/ext.h",
        {
          "type" : "TestResource",
          "content" : "#ifndef EXT_H\n#define EXT_H\n\n\/\/ This file will not be overwritten so is safe to edit\n\n#include <all.h>\n\n\/\/ bit-codec size for uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl\n#define numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl 1024\n#define numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl ((numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_UART_Msg_Impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_MissionCommand_i\n#define numBits_uav_june_step6__Linux_CMASI_MissionCommand_i 16384\n#define numBytes_uav_june_step6__Linux_CMASI_MissionCommand_i ((numBits_uav_june_step6__Linux_CMASI_MissionCommand_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_AirVehicleState_i\n#define numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i 4096\n#define numBytes_uav_june_step6__Linux_CMASI_AirVehicleState_i ((numBits_uav_june_step6__Linux_CMASI_AirVehicleState_i - 1) \/ 8 + 1)\n\nvoid byte_array_default(STACK_FRAME uint8_t* byteArray, size_t numBits, size_t numBytes);\n\nvoid byte_array_string(STACK_FRAME String str, uint8_t* byteArray, size_t numBytes);\n\nvoid hex_dump(STACK_FRAME uint8_t* byte_array, size_t numBytes);\n\n\/\/ bit-codec size for uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl\n#define numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl 1024\n#define numBytes_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl ((numBits_uav_june_step6__Linux_CASE_Model_Transformations_CASE_RF_Msg_Impl - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_AddressArray_i\n#define numBits_uav_june_step6__Linux_CMASI_AddressArray_i 96\n#define numBytes_uav_june_step6__Linux_CMASI_AddressArray_i ((numBits_uav_june_step6__Linux_CMASI_AddressArray_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_AddressAttributedMessage_i\n#define numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i 131072\n#define numBytes_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i ((numBits_uav_june_step6__Linux_CMASI_AddressAttributedMessage_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_Polygon_i\n#define numBits_uav_june_step6__Linux_CMASI_Polygon_i 1024\n#define numBytes_uav_june_step6__Linux_CMASI_Polygon_i ((numBits_uav_june_step6__Linux_CMASI_Polygon_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_AutomationRequest_i\n#define numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i 2048\n#define numBytes_uav_june_step6__Linux_CMASI_AutomationRequest_i ((numBits_uav_june_step6__Linux_CMASI_AutomationRequest_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_OperatingRegion_i\n#define numBits_uav_june_step6__Linux_CMASI_OperatingRegion_i 2048\n#define numBytes_uav_june_step6__Linux_CMASI_OperatingRegion_i ((numBits_uav_june_step6__Linux_CMASI_OperatingRegion_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_LineSearchTask_i\n#define numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i 65536\n#define numBytes_uav_june_step6__Linux_CMASI_LineSearchTask_i ((numBits_uav_june_step6__Linux_CMASI_LineSearchTask_i - 1) \/ 8 + 1)\n\n\/\/ bit-codec size for uav_june_step6__Linux_CMASI_AutomationResponse_i\n#define numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i 262144\n#define numBytes_uav_june_step6__Linux_CMASI_AutomationResponse_i ((numBits_uav_june_step6__Linux_CMASI_AutomationResponse_i - 1) \/ 8 + 1)\n#endif",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/SharedMemory.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object SharedMemory {\n  def create(id: Z): Z = $\n  def get(id: Z): Z = $\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = $\n  def receive(port: Art.PortId, out: MBox2[Art.PortId, DataContent]): Unit = $\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = $\n  def receiveAsync(port: Art.PortId, out: MBox2[Art.PortId, Option[DataContent]]): Unit = $\n  def remove(id: Z): Unit = $\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/SharedMemory_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject SharedMemory_Ext {\n  def create(id: Z): Z = halt(\"stub\")\n  def get(id: Z): Z = halt(\"stub\")\n  def send(id: Z, port: Art.PortId, d: DataContent): Unit = halt(\"stub\")\n  def receive(port: Art.PortId, out: MBox2[Art.PortId, DataContent]): Unit = halt(\"stub\")\n  def sendAsync(id: Z, port: Art.PortId, d: DataContent): B = halt(\"stub\")\n  def receiveAsync(port: Art.PortId, out: MBox2[Art.PortId, Option[DataContent]]): Unit = halt(\"stub\")\n  def remove(id: Z): Unit = halt(\"stub\")\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/IPC.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject IPCPorts {\n  val UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App: Art.PortId = 40\n  val RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App: Art.PortId = 41\n  val FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App: Art.PortId = 42\n  val UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App: Art.PortId = 43\n  val WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App: Art.PortId = 44\n  val CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App: Art.PortId = 45\n  val CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App: Art.PortId = 46\n  val CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App: Art.PortId = 47\n  val CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App: Art.PortId = 48\n  val Main: Art.PortId = 49\n\n  def emptyReceiveOut: MBox2[Art.PortId, DataContent] = {\n    return MBox2(-1, art.Empty())\n  }\n\n  def emptyReceiveAsyncOut: MBox2[Art.PortId, Option[DataContent]] = {\n    return MBox2(-1, None())\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/ArtNix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject ArtNix {\n\n  val maxPortIds: Art.PortId = IPCPorts.Main + 1\n  val timeTriggered: TimeTriggered = TimeTriggered()\n  val noData: Option[DataContent] = None()\n  val data: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  val connection: MS[Art.PortId, ISZ[(Art.PortId, Art.PortId)]] = {\n    val r = MS.create[Art.PortId, ISZ[(Art.PortId, Art.PortId)]](maxPortIds, ISZ())\n\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_WPM.id) = ISZ(\n      (IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AirVehicleState.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.AirVehicleState_UXAS.id) = ISZ(\n      (IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AirVehicleState.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.trusted_ids.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.trusted_ids.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.AutomationRequest.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_in.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.OperatingRegion.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_in.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.LineSearchTask.id) = ISZ(\n      (IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_in.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_in_zones.id) = ISZ(\n      (IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_in_zones.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FlyZones_FlyZonesDatabase.keep_out_zones.id) = ISZ(\n      (IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.keep_out_zones.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_GEO.id) = ISZ(\n      (IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.observed.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationResponse_MON_REQ.id) = ISZ(\n      (IPCPorts.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.observed.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.MissionCommand.id) = ISZ(\n      (IPCPorts.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.MissionCommand.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_UXAS.id) = ISZ(\n      (IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationRequest.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_out_MON_REQ.id) = ISZ(\n      (IPCPorts.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.reference_1.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_out.id) = ISZ(\n      (IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.OperatingRegion.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_out.id) = ISZ(\n      (IPCPorts.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_in.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_out.id) = ISZ(\n      (IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.LineSearchTask.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.output.id) = ISZ(\n      (IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AutomationResponse.id)\n    )\n    r(Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.alert.id) = ISZ(\n      (IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App, Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.ReturnHome.id)\n    )\n\n    r\n  }\n  val eventInPorts: MS[Z, Art.PortId] = MSZ(\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.recv_data.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FC_UART_UARTDriver.MissionCommand.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_RADIO_RadioDriver_Attestation.recv_data.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AutomationRequest.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.AirVehicleState.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.OperatingRegion.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_UXAS_UxAS.LineSearchTask.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AutomationResponse.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.AirVehicleState.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_WPM_WaypointPlanManagerService.ReturnHome.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.trusted_ids.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.AutomationRequest_in.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.OperatingRegion_in.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate.LineSearchTask_in.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST.filter_in.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.observed.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req.reference_1.id,\n    Arch.UAV_Impl_Instance_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo.observed.id\n  )\n  var frozen: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  var outgoing: MS[Art.PortId, Option[DataContent]] = MS.create(maxPortIds, noData)\n  var isTimeDispatch: B = F\n\n  def updateData(port: Art.PortId, d: DataContent): Unit = {\n    data(port) = Some(d)\n  }\n\n  def timeDispatch(): Unit = {\n    isTimeDispatch = T\n  }\n\n  def eventDispatch(): Unit = {\n    isTimeDispatch = F\n  }\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    if (isTimeDispatch) {\n      return timeTriggered\n    } else {\n      var r = ISZ[Art.PortId]()\n      for (i <- eventInPorts if data(i).nonEmpty) {\n        r = r :+ i\n      }\n      return EventTriggered(r)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    frozen = data\n    for (i <- eventPortIds) {\n      data(i) = noData\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    outgoing(portId) = Some(data)\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    return frozen(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (p <- dataPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n\n    for (p <- eventPortIds) {\n      outgoing(p) match {\n        case Some(d) =>\n          outgoing(p) = noData\n          for(e <- connection(p)){\n            Platform.sendAsync(e._1, e._2, d)\n          }\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def logError(title: String, msg: String): Unit = {\n    eprint(title)\n    eprint(\": \")\n    eprintln(msg)\n  }\n\n  def logDebug(title: String, msg: String): Unit = {\n    print(title)\n    print(\": \")\n    println(msg)\n  }\n\n  def run(): Unit = {\n  }\n\n  def time(): Art.Time = {\n    return Process.time()\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/Main.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Main extends App {\n  def main(args: ISZ[String]): Z = {\n\n    val seed: Z = if (args.size == z\"1\") {\n      val n = Z(args(0)).get\n      if (n == z\"0\") 1 else n\n    } else {\n      1\n    }\n\n    Platform.initialise(seed, None())\n\n    val empty = art.Empty()\n\n    Platform.sendAsync(IPCPorts.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App, IPCPorts.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App, empty)\n    Platform.sendAsync(IPCPorts.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App, IPCPorts.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App, empty)\n    Platform.sendAsync(IPCPorts.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App, IPCPorts.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App, empty)\n    Platform.sendAsync(IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, IPCPorts.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App, empty)\n    Platform.sendAsync(IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App, IPCPorts.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, IPCPorts.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App, IPCPorts.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App, IPCPorts.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App, empty)\n    Platform.sendAsync(IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App, IPCPorts.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App, empty)\n\n    Platform.finalise()\n    return 0\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/Platform.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Platform {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = $\n  def receive(portOpt: Option[Art.PortId],  out: MBox2[Art.PortId, DataContent]): Unit = $\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = $\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = $\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = $\n  def finalise(): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/Platform_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Platform_Ext {\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = halt(\"stub\")\n  def receive(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, DataContent]) = halt(\"stub\")\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = halt(\"stub\")\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = halt(\"stub\")\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = halt(\"stub\")\n  def finalise(): Unit = halt(\"stub\")\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/PlatformNix.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject PlatformNix {\n\n  var seed: Z = 0\n  var ids: ISZ[Z] = ISZ()\n\n  def initialise(seed: Z, portOpt: Option[Art.PortId]): Unit = {\n    PlatformNix.seed = seed\n    portOpt match {\n      case Some(port) =>\n        val id = seed + port\n        SharedMemory.create(id)\n        ids = ids :+ id\n      case _ =>\n    }\n  }\n\n  def receive(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, DataContent]): Unit = {\n    portOpt match {\n      case Some(port) =>\n        out.value1 = port\n        SharedMemory.receive(seed + port, out)\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def send(app: Art.PortId, port: Art.PortId, data: DataContent): Unit = {\n    SharedMemory.send(port, seed + port, data)\n  }\n\n  def sendAsync(app: Art.PortId, port: Art.PortId, data: DataContent): B = {\n    val r = SharedMemory.sendAsync(port, seed + port, data)\n    return r\n  }\n\n  def receiveAsync(portOpt: Option[Art.PortId], out: MBox2[Art.PortId, Option[DataContent]]): Unit = {\n    portOpt match {\n      case Some(port) => SharedMemory.receiveAsync(seed + port, out)\n      case _ => halt(\"Unsupported receive operation without port.\")\n    }\n  }\n\n  def finalise(): Unit = {\n    for (id <- ids) {\n      SharedMemory.remove(id)\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/Process.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\npackage uav_june_step6__Linux\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\n@ext object Process {\n  def sleep(n: Z): Unit = $\n\n  def time(): Art.Time = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/nix\/uav_june_step6__Linux\/Process_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package uav_june_step6__Linux\n\nimport org.sireum._\nimport art.Art\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Process_Ext {\n  def sleep(millis: Z): Unit = halt(\"stub\")\n\n  def time(): Art.Time = halt(\"stub\")\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/compile-linux.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd ${SCRIPT_HOME}\nmkdir -p linux-build\nmkdir -p ${SCRIPT_HOME}\/..\/src\/c\/nix\/linux-build\ncd ${SCRIPT_HOME}\/..\/src\/c\/nix\/linux-build\nBOUND_CHECK=${BOUND_CHECK:-OFF}\nNO_PRINT=${NO_PRINT:-OFF}\nRANGE_CHECK=${RANGE_CHECK:-OFF}\nWITH_LOC=${WITH_LOC:-OFF}\ncmake -DBOUND_CHECK=$BOUND_CHECK -DNO_PRINT=$NO_PRINT -DRANGE_CHECK=$RANGE_CHECK -DWITH_LOC=$WITH_LOC -DCMAKE_BUILD_TYPE=Release ..\nmake $MAKE_ARGS\nmv *_App ${SCRIPT_HOME}\/linux-build\/\nmv Main ${SCRIPT_HOME}\/linux-build\/",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/run-linux.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd $SCRIPT_HOME\n\n# Uncomment the following to prevent terminal from closing if app crashes\n#PREVENT_CLOSE=\"; bash -i\"\n\nx-terminal-emulator -T UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App -e sh -c \"linux-build\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App -e sh -c \"linux-build\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App -e sh -c \"linux-build\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App -e sh -c \"linux-build\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App -e sh -c \"linux-build\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App -e sh -c \"linux-build\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App -e sh -c \"linux-build\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App -e sh -c \"linux-build\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App${PREVENT_CLOSE}\" &\nx-terminal-emulator -T CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App -e sh -c \"linux-build\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App${PREVENT_CLOSE}\" &\nread -p \"Press enter to initialise components ...\"\nlinux-build\/Main\nread -p \"Press enter again to start ...\"\nlinux-build\/Main",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/compile-macOS.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd ${SCRIPT_HOME}\nmkdir -p macOS-build\nmkdir -p ${SCRIPT_HOME}\/..\/src\/c\/nix\/macOS-build\ncd ${SCRIPT_HOME}\/..\/src\/c\/nix\/macOS-build\nBOUND_CHECK=${BOUND_CHECK:-OFF}\nNO_PRINT=${NO_PRINT:-OFF}\nRANGE_CHECK=${RANGE_CHECK:-OFF}\nWITH_LOC=${WITH_LOC:-OFF}\ncmake -DBOUND_CHECK=$BOUND_CHECK -DNO_PRINT=$NO_PRINT -DRANGE_CHECK=$RANGE_CHECK -DWITH_LOC=$WITH_LOC -DCMAKE_BUILD_TYPE=Release ..\nmake $MAKE_ARGS\nmv *_App ${SCRIPT_HOME}\/macOS-build\/\nmv Main ${SCRIPT_HOME}\/macOS-build\/",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/run-macOS.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd $SCRIPT_HOME\n\n# Uncomment the following to prevent terminal from closing if app crashes\n#PREVENT_CLOSE=\"; bash -i\"\n\nopen -a Terminal \"macOS-build\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App${PREVENT_CLOSE}\" &\nopen -a Terminal \"macOS-build\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App${PREVENT_CLOSE}\" &\nread -p \"Press enter to initialise components ...\"\nmacOS-build\/Main\nread -p \"Press enter again to start ...\"\nmacOS-build\/Main",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/compile-cygwin.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd ${SCRIPT_HOME}\nmkdir -p cygwin-build\nmkdir -p ${SCRIPT_HOME}\/..\/src\/c\/nix\/cygwin-build\ncd ${SCRIPT_HOME}\/..\/src\/c\/nix\/cygwin-build\nBOUND_CHECK=${BOUND_CHECK:-OFF}\nNO_PRINT=${NO_PRINT:-OFF}\nRANGE_CHECK=${RANGE_CHECK:-OFF}\nWITH_LOC=${WITH_LOC:-OFF}\ncmake -DBOUND_CHECK=$BOUND_CHECK -DNO_PRINT=$NO_PRINT -DRANGE_CHECK=$RANGE_CHECK -DWITH_LOC=$WITH_LOC -DCMAKE_BUILD_TYPE=Release ..\nmake $MAKE_ARGS\nmv *.exe ${SCRIPT_HOME}\/cygwin-build\/",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/run-cygwin.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\nexport SCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\ncd $SCRIPT_HOME\n\n# Uncomment the following to prevent terminal from closing if app crashes\n#PREVENT_CLOSE=\"; bash -i\"\n\ncygstart mintty \/bin\/bash \"cygwin-build\/UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App.exe${PREVENT_CLOSE}\" &\ncygstart mintty \/bin\/bash \"cygwin-build\/CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App.exe${PREVENT_CLOSE}\" &\nread -p \"Press enter to initialise components ...\"\ncygwin-build\/Main.exe\nread -p \"Press enter again to start ...\"\ncygwin-build\/Main.exe",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/stop.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nAPPS=\"UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App\"\nfor APP in ${APPS}; do\n  pkill -f $APP\n  pkill -9 -f $APP\ndone\nME=`whoami`\n\n# message queue\nIPCS_Q=`ipcs -q | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -q $id;\ndone\n\n# shared memory\nIPCS_Q=`ipcs -m | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -m $id;\ndone\n\n# semaphores\nIPCS_Q=`ipcs -s | egrep \"[0-9a-f]+[0-9]+\" | grep $ME | awk '{print $2}'`\nfor id in $IPCS_Q; do\n  ipcrm -s $id;\ndone\n",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/src\/c\/etc\/ipc.c",
        {
          "type" : "TestResource",
          "content" : "#include <all.h>\n#include <sys\/types.h>\n#include <sys\/shm.h>\n#include <sys\/sem.h>\n#include <unistd.h>\n\n\/\/ This file is auto-generated.  Do not edit\n\nstatic inline void sem_op(int sid, short val) {\n    struct sembuf sem_op;\n    sem_op.sem_num = 0;\n    sem_op.sem_op = val;\n    sem_op.sem_flg = 0;\n    semop(sid, &sem_op, 1);\n}\n\nstatic inline void lock(int sid) {\n    sem_op(sid, -1);\n}\n\nstatic inline void unlock(int sid) {\n    sem_op(sid, 1);\n}\n\nstatic inline int create_sem(Z msgid) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n    int sem_set_id = semget((key_t) msgid, 1, mask | permission);\n\n    if (sem_set_id >= 0) {\n        union semun {\n            int val;\n            struct semid_ds *buf;\n            ushort *array;\n        } sem_val;\n        sem_val.val = 1;\n        semctl(sem_set_id, 0, SETVAL, sem_val);\n    }\n    return sem_set_id;\n}\n\nZ uav_june_step6__Linux_SharedMemory_create(STACK_FRAME Z id) {\n    unsigned int permission = 0666;\n    unsigned int mask = IPC_CREAT;\n\n    create_sem(id);\n\n    int shmid = shmget((key_t) id, sizeof(union Option_8E9F45), (int) (permission | mask));\n    void *p = shmat(shmid, (void *) 0, 0);\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    return (Z) shmid;\n}\n\nUnit uav_june_step6__Linux_SharedMemory_receive(STACK_FRAME Z port, MBox2_1CBFC4 out) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type != TSome_D29615) { \/\/ wait until there is a data\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    art_DataContent d = &p->Some_D29615.value;\n    Type_assign(&(out->value2), d, sizeOf((Type) d));\n    memset(p, 0, sizeof(union Option_8E9F45));\n    shmdt(p);\n\n    unlock(sid);\n}\n\nUnit uav_june_step6__Linux_SharedMemory_receiveAsync(STACK_FRAME Z port, MBox2_1029D1 out) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    if (p->type == TSome_D29615) {\n        Type_assign(&(out->value2), p, sizeOf((Type) p));\n        memset(p, 0, sizeof(union Option_8E9F45));\n    } else {\n        out->value2.type = TNone_964667;\n    }\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nUnit uav_june_step6__Linux_SharedMemory_send(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n\n    while (p->type == TSome_D29615) {\n        unlock(sid);\n        usleep((useconds_t) 10 * 1000);\n        lock(sid);\n    }\n\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n}\n\nB uav_june_step6__Linux_SharedMemory_sendAsync(STACK_FRAME Z destid, Z port, art_DataContent d) {\n    int sid = semget((key_t) port, 1, 0666);\n\n    lock(sid);\n\n    int shmid = shmget((key_t) port, sizeof(union Option_8E9F45), 0666);\n\n    Option_8E9F45 p = (Option_8E9F45) shmat(shmid, (void *) 0, 0);\n    p->type = TSome_D29615;\n    Type_assign(&(p->Some_D29615.value), d, sizeOf((Type) d));\n\n    shmdt(p);\n\n    unlock(sid);\n    return T;\n}\n\nUnit uav_june_step6__Linux_SharedMemory_remove(STACK_FRAME Z id) {\n    semctl(semget((key_t) id, 1, 0666), 0, IPC_RMID);\n    shmctl(shmget((key_t) id, sizeof(union Option_8E9F45), 0666), IPC_RMID, NULL);\n}\n\nUnit uav_june_step6__Linux_Process_sleep(STACK_FRAME Z n) {\n    usleep((useconds_t) n * 1000);\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/bin\/transpile.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n#\n# This file is autogenerated.  Do not edit\n#\nset -e\n\nif [ -z \"${SIREUM_HOME}\" ]; then\n  echo \"SIREUM_HOME not set. Refer to https:\/\/github.com\/sireum\/kekinian\/#installing\"\n  exit 1\nfi\n\nPATH_SEP=\":\"\nif [ -n \"$COMSPEC\" -a -x \"$COMSPEC\" ]; then\n  PATH_SEP=\";\"\nfi\n\nSCRIPT_HOME=$( cd \"$( dirname \"$0\" )\" &> \/dev\/null && pwd )\nOUTPUT_DIR=\"${SCRIPT_HOME}\/..\/src\/c\/nix\"\n\n${SIREUM_HOME}\/bin\/sireum slang transpilers c \\\n  --sourcepath \"${SCRIPT_HOME}\/..\/src\/main\" \\\n  --output-dir \"${OUTPUT_DIR}\" \\\n  --name \"main\" \\\n  --apps \"uav_june_step6__Linux.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver_App,uav_june_step6__Linux.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation_App,uav_june_step6__Linux.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase_App,uav_june_step6__Linux.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS_App,uav_june_step6__Linux.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService_App,uav_june_step6__Linux.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate_App,uav_june_step6__Linux.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST_App,uav_june_step6__Linux.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req_App,uav_june_step6__Linux.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo_App,uav_june_step6__Linux.Main\" \\\n  --fingerprint 3 \\\n  --bits 32 \\\n  --string-size 256 \\\n  --sequence-size 50 \\\n  --sequence \"IS[Z,art.Bridge]=9;MS[Z,MOption[art.Bridge]]=9;IS[Z,art.UPort]=8;IS[Z,art.UConnection]=18;IS[Z,B]=262144\" \\\n  --constants \"art.Art.maxComponents=9;art.Art.maxPorts=50\" \\\n  --forward \"art.ArtNative=uav_june_step6__Linux.ArtNix,uav_june_step6__Linux.Platform=uav_june_step6__Linux.PlatformNix\" \\\n  --stack-size \"524288\" \\\n  --stable-type-id \\\n  --exts \"${SCRIPT_HOME}\/..\/src\/c\/ext-c${PATH_SEP}${SCRIPT_HOME}\/..\/src\/c\/etc\" \\\n  --exclude-build \"uav_june_step6__Linux.Drivers.UARTDriver_Impl_MCMP_PROC_SW_FC_UART_UARTDriver,uav_june_step6__Linux.SW.RadioDriver_Attestation_thr_Impl_MCMP_PROC_SW_RADIO_RadioDriver_Attestation,uav_june_step6__Linux.SW.FlyZonesDatabase_thr_Impl_MCMP_PROC_SW_FlyZones_FlyZonesDatabase,uav_june_step6__Linux.SW.UxAS_thr_Impl_MCMP_PROC_SW_UXAS_UxAS,uav_june_step6__Linux.SW.WaypointPlanManagerService_thr_Impl_MCMP_PROC_SW_WPM_WaypointPlanManagerService,uav_june_step6__Linux.SW.CASE_AttestationGate_thr_Impl_MCMP_PROC_SW_AM_Gate_CASE_AttestationGate,uav_june_step6__Linux.SW.CASE_Filter_LST_thr_Impl_MCMP_PROC_SW_FLT_LST_CASE_Filter_LST,uav_june_step6__Linux.SW.CASE_Monitor_Req_thr_Impl_MCMP_PROC_SW_MON_REQ_CASE_Monitor_Req,uav_june_step6__Linux.SW.CASE_Monitor_Geo_thr_Impl_MCMP_PROC_SW_MON_GEO_CASE_Monitor_Geo\"",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    ArtDebug_Ext.start()\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 9\n  val maxPorts: PortId = 50\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@datatype class ArchitectureDescription(components: ISZ[Bridge],\n                                        connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@sig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @sig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\nimport ammonite.ops._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten.\n\/\/\n\/\/ mill can be obtained following instructions at https:\/\/github.com\/sireum\/kekinian#slang-app-example-mill-project\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill uav_june_step6__Linux.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIREUM_HOME\/bin\/mill uav_june_step6__Linux.tests\n\/\/\n\/\/ Sireum IVE:\n\/\/   First cd to the directory containing this file and execute the following:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/sireum tools ivegen -f -m mill -n uav_june_step6--Linux ..\/\n\/\/\n\/\/   Then in IVE select 'File > Open ...' and navigate to the directory\n\/\/   containing this file then click 'OK'.  To have the codebase and its\n\/\/   test suites recompiled upon changes, run:\n\/\/\n\/\/     $SIREUM_HOME\/bin\/mill -w uav_june_step6__Linux.tests.compile\n\/\/\n\/\/ Visual Studio Code:\n\/\/   Follow Sireum Kekinian's instructions for setting up a development\n\/\/   environment using Scala Metals: https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/   Then open the folder containing this file in VS Code and import the\n\/\/   mill build when asked.\n\n\nobject `uav_june_step6__Linux` extends slangEmbeddedProject\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.scala-lang%scala-library%\n  val scalaVer = \"2.13.5\"\n\n  \/\/ versions.properties key: org.scalatest%%scalatest%%\n  val scalaTestVersion = \"3.2.8\"\n\n  \/\/ versions.properties key: org.sireum%%scalac-plugin%\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210422.4fc8eee\n  val sireumScalacVersion = \"4.20210422.4fc8eee\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210427.9cd2a8a\n  val kekinianVersion = \"4.20210427.9cd2a8a\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(\n    ivy\"org.sireum.kekinian::library::${kekinianVersion}\",\n\n    \/\/ Jetbrains UI Designer\n    ivy\"com.intellij:forms_rt:${formsRtVersion}\"\n  )\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories :+ coursier.Repositories.jitpack\n\n  override def mainClass = T { Some(\"uav_june_step6__Linux.Demo\") }\n\n  implicit def osPath2PathRef(p: os.Path): PathRef = PathRef(p)\n}\n\ntrait slangEmbeddedProject extends SlangEmbeddedModule {\n\n  def contributedSources: Seq[PathRef] = Seq(\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n\n  override def sources = T.sources(contributedSources)\n\n  object tests extends Tests {\n\n    final override def millSourcePath = super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources( millSourcePath \/ \"bridge\",\n                                      millSourcePath \/ \"util\" )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\ntrait slangEmbeddedInspectorProject extends slangEmbeddedProject {\n\n  override def mainClass = T { Some(\"uav_june_step6__Linux.InspectorDemo\") }\n\n  override def contributedSources =\n    super.contributedSources :+ millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"inspector\"\n\n  \/\/ FIXME: 2021.01.04 - the following doesn't work due to javafx\/mill resolution issue\n  \/\/        -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767\n  \/\/ override def ivyDeps = Agg(\n  \/\/   ivy\"org.sireum::inspector-capabilities::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-gui::${inspectorVersion}\",\n  \/\/   ivy\"org.sireum::inspector-services-jvm::${inspectorVersion}\"\n\n  \/\/ workaround to #767 -- refer to https:\/\/github.com\/lihaoyi\/mill\/issues\/767#issuecomment-652799588\n  override def unmanagedClasspath = T {\n    import coursier._\n\n    val files = Fetch().addDependencies(\n      dep\"org.sireum:inspector-capabilities:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-gui:0.6-SNAPSHOT\",\n      dep\"org.sireum:inspector-services-jvm:0.6-SNAPSHOT\"\n    ).addRepositories(\n      Repositories.sonatype(\"releases\"),\n      Repositories.jitpack\n    ).run()\n    val pathRefs = files.map(f => PathRef(Path(f)))\n    Agg(pathRefs : _*)\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ Sireum IVE:\n\/\/   In IVE select 'File > Open ...' and navigate to the directory containing\n\/\/   this file then click 'OK'.  To install Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/   To run the demo from within Sireum IVE:\n\/\/     Right click src\/main\/architecture\/uav_june_step6__Linux\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/   To run the unit test cases from within Sireum IVE:\n\/\/     Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/   NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/         run the demo or unit tests.  If this occurs simply delete the directory\n\/\/         named 'target' and retry\n\n\nlazy val UAV_Impl_Instance = slangEmbeddedProject(\"UAV_Impl_Instance\", \".\")\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.scala-lang%scala-library%\nval scalaVer = \"2.13.5\"\n\n\/\/ versions.properties key: org.scalatest%%scalatest%%\nval scalaTestVersion = \"3.2.8\"\n\n\/\/ versions.properties key: org.sireum%%scalac-plugin%\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20210422.4fc8eee\nval sireumScalacVersion = \"4.20210422.4fc8eee\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release: https:\/\/github.com\/sireum\/kekinian\/tree\/4.20210427.9cd2a8a\nval kekinianVersion = \"4.20210427.9cd2a8a\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion,\n\n  mainClass in (Compile, run) := Some(\"uav_june_step6__Linux.Demo\"),\n\n  mainClass in assembly := Some(\"uav_june_step6__Linux.Demo\"),\n  assemblyJarName in assembly := \"UAV_Impl_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources(),\n\n  mainClass in (Compile, run) := Some(\"uav_june_step6__Linux.InspectorDemo\"),\n)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "uav_june_step6--Linux\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ]
    ]
  }
}