{
  "type" : "TestResult",
  "map" : {
    "type" : "Map",
    "entries" : [
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Environment\/Heat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Environment\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Heat {\n  \"Dummy_Head_Enum\"\n}\n\nobject Heat_Payload {\n  def empty(): Heat_Payload = {\n    return Heat_Payload(Isolette_Environment.Heat.byOrdinal(0).get)\n  }\n}\n\n@datatype class Heat_Payload(value: Isolette_Environment.Heat.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Environment\/Interface_Interaction.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Environment\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Interface_Interaction {\n  \"Dummy_Interface_Interaction_Enum\"\n}\n\nobject Interface_Interaction_Payload {\n  def empty(): Interface_Interaction_Payload = {\n    return Interface_Interaction_Payload(Isolette_Environment.Interface_Interaction.byOrdinal(0).get)\n  }\n}\n\n@datatype class Interface_Interaction_Payload(value: Isolette_Environment.Interface_Interaction.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/PhysicalTemp_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject PhysicalTemp_impl {\n  def empty(): Isolette_Data_Model.PhysicalTemp_impl = {\n    return Isolette_Data_Model.PhysicalTemp_impl(Base_Types.Float_32_empty())\n  }\n}\n\n@datatype class PhysicalTemp_impl(\n  value : F32) {\n}\n\nobject PhysicalTemp_impl_Payload {\n  def empty(): PhysicalTemp_impl_Payload = {\n    return PhysicalTemp_impl_Payload(Isolette_Data_Model.PhysicalTemp_impl.empty())\n  }\n}\n\n@datatype class PhysicalTemp_impl_Payload(value: Isolette_Data_Model.PhysicalTemp_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/ValueStatus.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object ValueStatus {\n  \"Valid\"\n  \"Invalid\"\n}\n\nobject ValueStatus_Payload {\n  def empty(): ValueStatus_Payload = {\n    return ValueStatus_Payload(Isolette_Data_Model.ValueStatus.byOrdinal(0).get)\n  }\n}\n\n@datatype class ValueStatus_Payload(value: Isolette_Data_Model.ValueStatus.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/TempWstatus_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject TempWstatus_impl {\n  def empty(): Isolette_Data_Model.TempWstatus_impl = {\n    return Isolette_Data_Model.TempWstatus_impl(Base_Types.Float_32_empty(), Isolette_Data_Model.ValueStatus.byOrdinal(0).get)\n  }\n}\n\n@datatype class TempWstatus_impl(\n  value : F32,\n  status : Isolette_Data_Model.ValueStatus.Type) {\n}\n\nobject TempWstatus_impl_Payload {\n  def empty(): TempWstatus_impl_Payload = {\n    return TempWstatus_impl_Payload(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n}\n\n@datatype class TempWstatus_impl_Payload(value: Isolette_Data_Model.TempWstatus_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/On_Off.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object On_Off {\n  \"Onn\"\n  \"Off\"\n}\n\nobject On_Off_Payload {\n  def empty(): On_Off_Payload = {\n    return On_Off_Payload(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n}\n\n@datatype class On_Off_Payload(value: Isolette_Data_Model.On_Off.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/Status.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Status {\n  \"Init_Status\"\n  \"On_Status\"\n  \"Failed_Status\"\n}\n\nobject Status_Payload {\n  def empty(): Status_Payload = {\n    return Status_Payload(Isolette_Data_Model.Status.byOrdinal(0).get)\n  }\n}\n\n@datatype class Status_Payload(value: Isolette_Data_Model.Status.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/Temp_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Temp_impl {\n  def empty(): Isolette_Data_Model.Temp_impl = {\n    return Isolette_Data_Model.Temp_impl(Base_Types.Float_32_empty())\n  }\n}\n\n@datatype class Temp_impl(\n  value : F32) {\n}\n\nobject Temp_impl_Payload {\n  def empty(): Temp_impl_Payload = {\n    return Temp_impl_Payload(Isolette_Data_Model.Temp_impl.empty())\n  }\n}\n\n@datatype class Temp_impl_Payload(value: Isolette_Data_Model.Temp_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/Regulator_Mode.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Regulator_Mode {\n  \"Init_Regulator_Mode\"\n  \"Normal_Regulator_Mode\"\n  \"Failed_Regulator_Mode\"\n}\n\nobject Regulator_Mode_Payload {\n  def empty(): Regulator_Mode_Payload = {\n    return Regulator_Mode_Payload(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n  }\n}\n\n@datatype class Regulator_Mode_Payload(value: Isolette_Data_Model.Regulator_Mode.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/Failure_Flag_impl.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Failure_Flag_impl {\n  def empty(): Isolette_Data_Model.Failure_Flag_impl = {\n    return Isolette_Data_Model.Failure_Flag_impl(Base_Types.Boolean_empty())\n  }\n}\n\n@datatype class Failure_Flag_impl(\n  value : B) {\n}\n\nobject Failure_Flag_impl_Payload {\n  def empty(): Failure_Flag_impl_Payload = {\n    return Failure_Flag_impl_Payload(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n}\n\n@datatype class Failure_Flag_impl_Payload(value: Isolette_Data_Model.Failure_Flag_impl) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Isolette_Data_Model\/Monitor_Mode.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette_Data_Model\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\n\n@enum object Monitor_Mode {\n  \"Init_Monitor_Mode\"\n  \"Normal_Monitor_Mode\"\n  \"Failed_Monitor_Mode\"\n}\n\nobject Monitor_Mode_Payload {\n  def empty(): Monitor_Mode_Payload = {\n    return Monitor_Mode_Payload(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n  }\n}\n\n@datatype class Monitor_Mode_Payload(value: Isolette_Data_Model.Monitor_Mode.Type) extends art.DataContent\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/Base_Types.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM\n\nimport org.sireum._\nimport org.sireum.S8._\nimport org.sireum.S16._\nimport org.sireum.S32._\nimport org.sireum.S64._\nimport org.sireum.U8._\nimport org.sireum.U16._\nimport org.sireum.U32._\nimport org.sireum.U64._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Base_Types {\n\n  type Boolean = B\n\n  type Integer = Z\n\n  type Integer_8 = S8\n  type Integer_16 = S16\n  type Integer_32 = S32\n  type Integer_64 = S64\n\n  type Unsigned_8 = U8\n  type Unsigned_16 = U16\n  type Unsigned_32 = U32\n  type Unsigned_64 = U64\n\n  \/\/ TODO: Base_Types::Natural\n\n  type Float = R\n  type Float_32 = F32\n  type Float_64 = F64\n\n  type Character = C\n  type String = org.sireum.String\n\n  type Bits = org.sireum.ISZ[B]\n\n  @datatype class Boolean_Payload(value: B) extends art.DataContent\n\n  @datatype class Integer_Payload(value: Z) extends art.DataContent\n\n  @datatype class Integer_8_Payload(value: S8) extends art.DataContent\n  @datatype class Integer_16_Payload(value: S16) extends art.DataContent\n  @datatype class Integer_32_Payload(value: S32) extends art.DataContent\n  @datatype class Integer_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Unsigned_8_Payload(value: U8) extends art.DataContent\n  @datatype class Unsigned_16_Payload(value: U16) extends art.DataContent\n  @datatype class Unsigned_32_Payload(value: U32) extends art.DataContent\n  @datatype class Unsigned_64_Payload(value: U64) extends art.DataContent\n\n  @datatype class Float_Payload(value: R) extends art.DataContent\n  @datatype class Float_32_Payload(value: S32) extends art.DataContent\n  @datatype class Float_64_Payload(value: S64) extends art.DataContent\n\n  @datatype class Character_Payload(value: C) extends art.DataContent\n  @datatype class String_Payload(value: String) extends art.DataContent\n\n  @datatype class Bits_Payload(value: ISZ[B]) extends art.DataContent\n\n  def Boolean_empty(): Boolean = { return F }\n\n  def Integer_empty(): Integer = { return z\"0\" }\n\n  def Integer_8_empty(): Integer_8 = { return s8\"0\" }\n  def Integer_16_empty(): Integer_16 = { return s16\"0\" }\n  def Integer_32_empty(): Integer_32 = { return s32\"0\" }\n  def Integer_64_empty(): Integer_64 = { return s64\"0\" }\n\n  def Unsigned_8_empty(): Unsigned_8 = { return u8\"0\" }\n  def Unsigned_16_empty(): Unsigned_16 = { return u16\"0\" }\n  def Unsigned_32_empty(): Unsigned_32 = { return u32\"0\" }\n  def Unsigned_64_empty(): Unsigned_64 = { return u64\"0\" }\n\n  def Float_empty(): Float = { return r\"0\" }\n  def Float_32_empty(): Float_32 = { return f32\"0\" }\n  def Float_64_empty(): Float_64 = { return f64\"0\" }\n\n  def Character_empty(): Character = { return ' ' }\n  def String_empty(): String = { return \"\" }\n\n  def Bits_empty(): Bits = { return ISZ() }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/architecture\/isolette__JVM\/Arch.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM\n\nimport org.sireum._\nimport art._\nimport art.PortMode._\nimport art.DispatchPropertyProtocol._\n\n\/\/ This file was auto-generated.  Do not edit\n\nobject Arch {\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit : isolette__JVM.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 0, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_current_tempWstatus\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 1, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_tempWstatus\", mode = DataIn)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 2, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_tempWstatus\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 3, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_mode\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 4, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_upper_desired_temp\", mode = DataOut)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 5, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_lower_desired_temp\", mode = DataOut)\n    val displayed_temp = Port[Isolette_Data_Model.Temp_impl] (id = 6, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_displayed_temp\", mode = DataOut)\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 7, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_regulator_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 8, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit_interface_failure\", mode = DataOut)\n\n    isolette__JVM.Regulate.Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge(\n      id = 0,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      regulator_mode = regulator_mode,\n      upper_desired_temp = upper_desired_temp,\n      lower_desired_temp = lower_desired_temp,\n      displayed_temp = displayed_temp,\n      regulator_status = regulator_status,\n      interface_failure = interface_failure\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst : isolette__JVM.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 9, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_current_tempWstatus\", mode = DataIn)\n    val lower_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 10, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_lower_desired_temp\", mode = DataIn)\n    val upper_desired_temp = Port[Isolette_Data_Model.Temp_impl] (id = 11, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_upper_desired_temp\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 12, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_regulator_mode\", mode = DataIn)\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 13, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst_heat_control\", mode = DataOut)\n\n    isolette__JVM.Regulate.Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge(\n      id = 1,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_desired_temp = lower_desired_temp,\n      upper_desired_temp = upper_desired_temp,\n      regulator_mode = regulator_mode,\n      heat_control = heat_control\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt : isolette__JVM.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 14, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 15, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 16, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_internal_failure\", mode = DataIn)\n    val regulator_mode = Port[Isolette_Data_Model.Regulator_Mode.Type] (id = 17, name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt_regulator_mode\", mode = DataOut)\n\n    isolette__JVM.Regulate.Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge(\n      id = 2,\n      name = \"isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      regulator_mode = regulator_mode\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat : isolette__JVM.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 18, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_current_tempWstatus\", mode = DataIn)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 19, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_lower_alarm_temp\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 20, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_upper_alarm_temp\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 21, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_monitor_mode\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 22, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat_alarm_control\", mode = DataOut)\n\n    isolette__JVM.Monitor.Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge(\n      id = 3,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      lower_alarm_temp = lower_alarm_temp,\n      upper_alarm_temp = upper_alarm_temp,\n      monitor_mode = monitor_mode,\n      alarm_control = alarm_control\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit : isolette__JVM.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge = {\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 23, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_tempWstatus\", mode = DataIn)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 24, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_tempWstatus\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 25, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_current_tempWstatus\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 26, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_mode\", mode = DataIn)\n    val upper_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 27, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_upper_alarm_temp\", mode = DataOut)\n    val lower_alarm_temp = Port[Isolette_Data_Model.Temp_impl] (id = 28, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_lower_alarm_temp\", mode = DataOut)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 29, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_monitor_status\", mode = DataOut)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 30, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit_interface_failure\", mode = DataOut)\n\n    isolette__JVM.Monitor.Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge(\n      id = 4,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      current_tempWstatus = current_tempWstatus,\n      monitor_mode = monitor_mode,\n      upper_alarm_temp = upper_alarm_temp,\n      lower_alarm_temp = lower_alarm_temp,\n      monitor_status = monitor_status,\n      interface_failure = interface_failure\n    )\n  }\n  val isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt : isolette__JVM.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge = {\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 31, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_current_tempWstatus\", mode = DataIn)\n    val interface_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 32, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_interface_failure\", mode = DataIn)\n    val internal_failure = Port[Isolette_Data_Model.Failure_Flag_impl] (id = 33, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_internal_failure\", mode = DataIn)\n    val monitor_mode = Port[Isolette_Data_Model.Monitor_Mode.Type] (id = 34, name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt_monitor_mode\", mode = DataOut)\n\n    isolette__JVM.Monitor.Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge(\n      id = 5,\n      name = \"isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      current_tempWstatus = current_tempWstatus,\n      interface_failure = interface_failure,\n      internal_failure = internal_failure,\n      monitor_mode = monitor_mode\n    )\n  }\n  val isolette_single_sensor_Instance_operator_interface_oip_oit : isolette__JVM.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge = {\n    val regulator_status = Port[Isolette_Data_Model.Status.Type] (id = 35, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_regulator_status\", mode = DataIn)\n    val monitor_status = Port[Isolette_Data_Model.Status.Type] (id = 36, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_monitor_status\", mode = DataIn)\n    val display_temperature = Port[Isolette_Data_Model.Temp_impl] (id = 37, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_display_temperature\", mode = DataIn)\n    val alarm_control = Port[Isolette_Data_Model.On_Off.Type] (id = 38, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_alarm_control\", mode = DataIn)\n    val lower_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 39, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_desired_tempWstatus\", mode = DataOut)\n    val upper_desired_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 40, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_desired_tempWstatus\", mode = DataOut)\n    val lower_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 41, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_lower_alarm_tempWstatus\", mode = DataOut)\n    val upper_alarm_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 42, name = \"isolette_single_sensor_Instance_operator_interface_oip_oit_upper_alarm_tempWstatus\", mode = DataOut)\n\n    isolette__JVM.Isolette.operator_interface_thread_impl_operator_interface_oip_oit_Bridge(\n      id = 6,\n      name = \"isolette_single_sensor_Instance_operator_interface_oip_oit\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      regulator_status = regulator_status,\n      monitor_status = monitor_status,\n      display_temperature = display_temperature,\n      alarm_control = alarm_control,\n      lower_desired_tempWstatus = lower_desired_tempWstatus,\n      upper_desired_tempWstatus = upper_desired_tempWstatus,\n      lower_alarm_tempWstatus = lower_alarm_tempWstatus,\n      upper_alarm_tempWstatus = upper_alarm_tempWstatus\n    )\n  }\n  val isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat : isolette__JVM.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge = {\n    val air = Port[Isolette_Data_Model.PhysicalTemp_impl] (id = 43, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_air\", mode = DataIn)\n    val current_tempWstatus = Port[Isolette_Data_Model.TempWstatus_impl] (id = 44, name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat_current_tempWstatus\", mode = DataOut)\n\n    isolette__JVM.Devices.Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge(\n      id = 7,\n      name = \"isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      air = air,\n      current_tempWstatus = current_tempWstatus\n    )\n  }\n  val isolette_single_sensor_Instance_heat_source_cpi_heat_controller : isolette__JVM.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge = {\n    val heat_control = Port[Isolette_Data_Model.On_Off.Type] (id = 45, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_control\", mode = DataIn)\n    val heat_out = Port[Isolette_Environment.Heat.Type] (id = 46, name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller_heat_out\", mode = DataOut)\n\n    isolette__JVM.Devices.Heat_Source_impl_heat_source_cpi_heat_controller_Bridge(\n      id = 8,\n      name = \"isolette_single_sensor_Instance_heat_source_cpi_heat_controller\",\n      dispatchProtocol = Periodic(period = 1000),\n      dispatchTriggers = None(),\n\n      heat_control = heat_control,\n      heat_out = heat_out\n    )\n  }\n\n  val ad : ArchitectureDescription = {\n\n    ArchitectureDescription(\n      components = MSZ (isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit, isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst, isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit, isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt, isolette_single_sensor_Instance_operator_interface_oip_oit, isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat, isolette_single_sensor_Instance_heat_source_cpi_heat_controller),\n\n      connections = ISZ (Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.upper_desired_temp, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.upper_desired_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.lower_desired_temp, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.lower_desired_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.interface_failure, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.interface_failure),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.regulator_mode, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.regulator_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.regulator_mode, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.regulator_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.upper_alarm_temp, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.upper_alarm_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.lower_alarm_temp, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.lower_alarm_temp),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.interface_failure, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.interface_failure),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.monitor_mode, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.monitor_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.monitor_mode, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.monitor_mode),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.displayed_temp, to = isolette_single_sensor_Instance_operator_interface_oip_oit.display_temperature),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.regulator_status, to = isolette_single_sensor_Instance_operator_interface_oip_oit.regulator_status),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.heat_control, to = isolette_single_sensor_Instance_heat_source_cpi_heat_controller.heat_control),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.alarm_control, to = isolette_single_sensor_Instance_operator_interface_oip_oit.alarm_control),\n                         Connection(from = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.monitor_status, to = isolette_single_sensor_Instance_operator_interface_oip_oit.monitor_status),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.lower_desired_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.lower_desired_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_desired_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.upper_desired_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_alarm_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.upper_alarm_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_operator_interface_oip_oit.upper_alarm_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.lower_alarm_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst.current_tempWstatus),\n                         Connection(from = isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat.current_tempWstatus, to = isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt.current_tempWstatus))\n    )\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/architecture\/isolette__JVM\/Demo.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ This file was auto-generated.  Do not edit\npackage isolette__JVM\n\nobject Demo extends App {\n  art.Art.run(Arch.ad)\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/inspector\/isolette__JVM\/InspectorDemo.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM\n\nimport art.{ArchitectureDescription, Bridge, DataContent, UPort}\nimport org.reactivestreams.Publisher\nimport org.sireum.hamr.inspector.common.{Filter, Injection, InspectionBlueprint, Msg, Rule}\nimport org.sireum.hamr.inspector.capabilities.InspectorCapabilitiesLauncher\nimport org.sireum.hamr.inspector.gui.InspectorGUILauncher\nimport org.sireum.hamr.inspector.stream.Flux\n\nobject InspectorDemo extends App {\n\n  {\n    InspectorCapabilitiesLauncher.run(Blueprint)\n\n    val filters: Set[Filter] = Set(NoFilter, EvensOnly)\n    val rules: Set[Rule] = Set(Require100OrMore)\n    val injections: Set[Injection] = Set()\n\n    InspectorGUILauncher.run(Blueprint, filters, rules, injections, args)\n  }\n\n  object Blueprint extends InspectionBlueprint {\n    override def ad(): ArchitectureDescription = Arch.ad\n    override def serializer(): DataContent => String = JSON.from_artDataContent(_, true).value\n    override def deserializer(): String => DataContent = JSON.to_artDataContent(_).left\n  }\n\n  object NoFilter extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in\n  }\n\n  object EvensOnly extends Filter {\n    override def filter(in: Flux[Msg]): Publisher[Msg] = in.filter(_.sequence % 2 == 0)\n  }\n\n  object Require100OrMore extends Rule {\n    override def rule(in: Flux[Msg]): Publisher[_] = in.skip(99).next().single()\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/data\/isolette__JVM\/sergen.sh",
        {
          "type" : "TestResource",
          "content" : "#!\/usr\/bin\/env bash\n\n# Creates serializers and deserializers for all types in the data folder of a HAMR project.\n#\n# This script should be placed in the \"<project name>\/src\/main\/data\/<your>\/<package>\/\" folder of a Sireum HAMR project.\n#\n# When run, it will create serializers and deserializers (JSON.scala and MsgPack.scala) for all user-defined types.\n# JSON.scala must exist for any HAMR-project jar that is pointed to by the Inspector-GUI.\n\n# check for conflicting files\nif [ -f 'JSON.scala' ]; then\n  echo 'Deleting stale JSON.scala'\n  rm JSON.scala\nfi\nif [ -f 'MsgPack.scala' ]; then\n  echo 'Deleting stale MsgPack.scala'\n  rm MsgPack.scala\nfi\n\n# determine OS\n# credit: https:\/\/stackoverflow.com\/questions\/394230\/how-to-detect-the-os-from-a-bash-script\/18434831\nif [[ $OSTYPE == 'linux-gnu' ]]; then\n        platform='linux'\nelif [[ $OSTYPE == 'darwin'* ]]; then\n        platform='mac'\nelif [[ $OSTYPE == 'msys' ]]; then\n        platform='win'\nelif [[ $OSTYPE == 'win32' ]]; then\n        platform='win'\nelse\n        echo 'ERROR: invalid OS'\n        exit 1\nfi\n\necho \"detected platform: '$platform' based on OS: '$OSTYPE'\"\n\ninitialDirectory=$PWD # allows script to get back to initial directory after crawling up\npathToData='' # a path to get to the data folder, which is made up of repeating '..\/'\npackage='' # the package name, which is from the child of 'data' to (and including) the initialDirectory\nuppermostDirectoryFound='' # name of the uppermost directory found, if it is not data then we cancel the script\n\n# determine package\nwhile [[ $PWD != '\/' && ${PWD##*\/} != 'data' ]]; do\n  # \"if\" check on package prevents trailing period character\n  if [[ $package == '' ]]; then package=${PWD##*\/}; else package=${PWD##*\/}.${package}; fi;\n  pathToData=..\/${pathToData};\n  cd ..;\n  uppermostDirectoryFound=${PWD##*\/}\ndone\n\n# check that data folder was found\nif [[ $uppermostDirectoryFound != 'data' ]]; then\n  echo 'ERROR: script directory is not a descendent of data\/<full_project_package>\/';\n  exit 1\nfi\n\n# check that src\/main\/data\/ path holds\ncd ..\nif [[ ${PWD##*\/} != 'main' ]]; then\n  echo \"ERROR: expected main\/ to be direct parent of data\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\ncd ..\nif [[ ${PWD##*\/} != 'src' ]]; then\n  echo \"ERROR: expected src\/ to be direct parent of main\/ but ${PWD##*\/} was found.\";\n  exit 1\nfi\n\n# check that main\/art\/DataContent.scala exists (from the current folder src)\n\nif [ ! -f 'main\/art\/DataContent.scala' ]; then\n  echo 'ERROR: project must contain art\/DataContent under src\/main\/ but it was not found.';\n  exit 1\nfi\n\ncd ${initialDirectory}\n\n# add -L option to find if symlinks need to be followed: files=$(find -L . -regex '.*\/[^\/]*.scala')\nfiles=$(find . -regex '.*\/[^\/]*.scala')\n\necho \"package: $package\"\necho \"files:\"\necho \"$files\"\n\nsergen=\"$SIREUM_HOME\/bin\/${platform}\/java\/bin\/java -jar $SIREUM_HOME\/bin\/sireum.jar tools sergen\"\n\neval $sergen -p $package -m \"json,msgpack\" $files ${pathToData}..\/art\/DataContent.scala",
          "overwrite" : true,
          "makeExecutable" : true
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi extends BridgeTestSuite[Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_interface_mrit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_desired_tempWstatus payload for data port lower_desired_tempWstatus\n   * @param upper_desired_tempWstatus payload for data port upper_desired_tempWstatus\n   * @param regulator_mode payload for data port regulator_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_desired_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          upper_desired_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          regulator_mode : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_desired_tempWstatus(lower_desired_tempWstatus)\n    put_upper_desired_tempWstatus(upper_desired_tempWstatus)\n    put_regulator_mode(regulator_mode)\n  }\n\n\n  \/** helper function to check Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param upper_desired_temp method that will be called with the value of the outgoing data\n   *        port 'upper_desired_temp'.\n   * @param lower_desired_temp method that will be called with the value of the outgoing data\n   *        port 'lower_desired_temp'.\n   * @param displayed_temp method that will be called with the value of the outgoing data\n   *        port 'displayed_temp'.\n   * @param regulator_status method that will be called with the value of the outgoing data\n   *        port 'regulator_status'.\n   * @param interface_failure method that will be called with the value of the outgoing data\n   *        port 'interface_failure'.\n   *\/\n  def check_concrete_output(upper_desired_temp: Isolette_Data_Model.Temp_impl => B = upper_desired_tempParam => {T},\n                            lower_desired_temp: Isolette_Data_Model.Temp_impl => B = lower_desired_tempParam => {T},\n                            displayed_temp: Isolette_Data_Model.Temp_impl => B = displayed_tempParam => {T},\n                            regulator_status: Isolette_Data_Model.Status.Type => B = regulator_statusParam => {T},\n                            interface_failure: Isolette_Data_Model.Failure_Flag_impl => B = interface_failureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val upper_desired_tempValue: Isolette_Data_Model.Temp_impl = get_upper_desired_temp().get\n    if(!upper_desired_temp(upper_desired_tempValue)) {\n      testFailures = testFailures :+ st\"'upper_desired_temp' did not match expected: value of the outgoing data port is ${upper_desired_tempValue}\"\n    }\n    val lower_desired_tempValue: Isolette_Data_Model.Temp_impl = get_lower_desired_temp().get\n    if(!lower_desired_temp(lower_desired_tempValue)) {\n      testFailures = testFailures :+ st\"'lower_desired_temp' did not match expected: value of the outgoing data port is ${lower_desired_tempValue}\"\n    }\n    val displayed_tempValue: Isolette_Data_Model.Temp_impl = get_displayed_temp().get\n    if(!displayed_temp(displayed_tempValue)) {\n      testFailures = testFailures :+ st\"'displayed_temp' did not match expected: value of the outgoing data port is ${displayed_tempValue}\"\n    }\n    val regulator_statusValue: Isolette_Data_Model.Status.Type = get_regulator_status().get\n    if(!regulator_status(regulator_statusValue)) {\n      testFailures = testFailures :+ st\"'regulator_status' did not match expected: value of the outgoing data port is ${regulator_statusValue}\"\n    }\n    val interface_failureValue: Isolette_Data_Model.Failure_Flag_impl = get_interface_failure().get\n    if(!interface_failure(interface_failureValue)) {\n      testFailures = testFailures :+ st\"'interface_failure' did not match expected: value of the outgoing data port is ${interface_failureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_regulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_desired_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_upper_desired_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_desired_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_desired_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_desired_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_lower_desired_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_desired_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_desired_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_displayed_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_displayed_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port displayed_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_displayed_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.displayed_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_regulator_status(): Option[Isolette_Data_Model.Status.Type] = {\n    val value: Option[Isolette_Data_Model.Status.Type] = get_regulator_status_payload() match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port regulator_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_regulator_status_payload(): Option[Isolette_Data_Model.Status_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.regulator_status_Id).asInstanceOf[Option[Isolette_Data_Model.Status_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_interface_failure(): Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value: Option[Isolette_Data_Model.Failure_Flag_impl] = get_interface_failure_payload() match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_interface_failure_payload(): Option[Isolette_Data_Model.Failure_Flag_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.interface_failure_Id).asInstanceOf[Option[Isolette_Data_Model.Failure_Flag_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Test extends Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Regulate.{Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type],\n  upper_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  lower_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  displayed_temp: Port[Isolette_Data_Model.Temp_impl],\n  regulator_status: Port[Isolette_Data_Model.Status.Type],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_desired_tempWstatus,\n              upper_desired_tempWstatus,\n              regulator_mode,\n              upper_desired_temp,\n              lower_desired_temp,\n              displayed_temp,\n              regulator_status,\n              interface_failure),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_desired_tempWstatus,\n                  upper_desired_tempWstatus,\n                  regulator_mode),\n\n    dataOuts = ISZ(upper_desired_temp,\n                   lower_desired_temp,\n                   displayed_temp,\n                   regulator_status,\n                   interface_failure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Regulator_Interface_impl_Initialization_Api = {\n    val api = Manage_Regulator_Interface_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id\n    )\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Regulator_Interface_impl_Operational_Api = {\n    val api = Manage_Regulator_Interface_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id\n    )\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      regulator_mode.id,\n      upper_desired_temp.id,\n      lower_desired_temp.id,\n      displayed_temp.id,\n      regulator_status.id,\n      interface_failure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_Bridge {\n\n  var c_initialization_api: Option[Manage_Regulator_Interface_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Regulator_Interface_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_desired_tempWstatus_Id : Art.PortId,\n    upper_desired_tempWstatus_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n    upper_desired_temp_Id : Art.PortId,\n    lower_desired_temp_Id : Art.PortId,\n    displayed_temp_Id : Art.PortId,\n    regulator_status_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Regulator_Interface_impl_Initialization_Api,\n    operational_api: Manage_Regulator_Interface_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_desired_tempWstatus_Id,\n                                             upper_desired_tempWstatus_Id,\n                                             regulator_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(upper_desired_temp_Id,\n                                              lower_desired_temp_Id,\n                                              displayed_temp_Id,\n                                              regulator_status_Id,\n                                              interface_failure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Interface_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Regulator_Interface_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_desired_tempWstatus_Id : Art.PortId\n  def upper_desired_tempWstatus_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n  def upper_desired_temp_Id : Art.PortId\n  def lower_desired_temp_Id : Art.PortId\n  def displayed_temp_Id : Art.PortId\n  def regulator_status_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n\n  def setupper_desired_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(upper_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setlower_desired_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(lower_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setdisplayed_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(displayed_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setregulator_status(value : Isolette_Data_Model.Status.Type) : Unit = {\n    Art.putValue(regulator_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  def setinterface_failure(value : Isolette_Data_Model.Failure_Flag_impl) : Unit = {\n    Art.putValue(interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Regulator_Interface_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val displayed_temp_Id : Art.PortId,\n  val regulator_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Regulator_Interface_impl_Api\n\n@datatype class Manage_Regulator_Interface_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val displayed_temp_Id : Art.PortId,\n  val regulator_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Regulator_Interface_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_desired_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(lower_desired_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getupper_desired_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(upper_desired_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getregulator_mode() : Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Regulator_Mode.Type] = Art.getValue(regulator_mode_Id) match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Regulator_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Regulate\/Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Regulator_Interface_impl_thermostat_regulate_temperature_manage_regulator_interface_mrit {\n\n  def initialise(api: Manage_Regulator_Interface_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setupper_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setlower_desired_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setdisplayed_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setregulator_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n    api.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n\n  def timeTriggered(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getlower_desired_tempWstatus()\n    api.logInfo(s\"Received on lower_desired_tempWstatus: ${apiUsage_lower_desired_tempWstatus}\")\n    val apiUsage_upper_desired_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getupper_desired_tempWstatus()\n    api.logInfo(s\"Received on upper_desired_tempWstatus: ${apiUsage_upper_desired_tempWstatus}\")\n    val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = api.getregulator_mode()\n    api.logInfo(s\"Received on regulator_mode: ${apiUsage_regulator_mode}\")\n  }\n\n  def activate(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Regulator_Interface_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/BridgeTestSuite.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM\n\nimport art.{Art, Bridge}\nimport org.scalatest.{BeforeAndAfterEach, OneInstancePerTest}\nimport org.scalatest.funsuite.AnyFunSuite\n\n\/**\n * A test suite that provides the following functionality for unit tests:\n *  - Clears all registers bridges and ports before each test\n *  - Initializes the selected bridge and ports before each test\n *  - Finalizes the bridge after each test\n *  - Creates a new instance of the test suite class for each test\n *    -> NOTE: this is NOT the same as having a separate JVM per-test (or suite), but is useful for test-local variables\n *\n *  If automatic calls to initTest() or finalizeTest() are not desired, simply override beforeEach() or afterEach()\n *  methods to change the desired behavior.\n *\n * @param bridge the bridge being tested, see [[isolette__JVM.Arch]] for potential values.\n * @tparam T the type of the bridge being tested\n *\/\n\n\/\/ This file was auto-generated.  Do no edit\n\nclass BridgeTestSuite[+T <: Bridge](val bridge: T) extends AnyFunSuite with OneInstancePerTest with BeforeAndAfterEach {\n\n  \/**\n   * Automatically called before each test. Currently calls Art.initTest for the given bridge. Override as needed.\n   *\/\n  override protected def beforeEach(): Unit = {\n    Art.initTest(bridge)\n  }\n\n  \/**\n   * Automatically called after each test. Currently calls Art.finalizeTest for the given bridge. Override as needed.\n   *\/\n  override protected def afterEach(): Unit = {\n    Art.finalizeTest(bridge)\n  }\n\n  \/**\n   * Invokes testCompute() once per registered bridge.\n   *\n   * IMPORTANT: This method also clears all bridge output BEFORE each call. This will have no effect the first time it's\n   * invoked (because all output will be empty), but it does ensure that output doesn't \"leak\" across multiple\n   * invocations.\n   *\n   *\/\n  def executeTest(): Unit = {\n    Art.manuallyClearOutput()\n    Art.executeTest(bridge)\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi extends BridgeTestSuite[Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_heat_source_mhst) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_desired_temp payload for data port lower_desired_temp\n   * @param upper_desired_temp payload for data port upper_desired_temp\n   * @param regulator_mode payload for data port regulator_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_desired_temp : Isolette_Data_Model.Temp_impl,\n                          upper_desired_temp : Isolette_Data_Model.Temp_impl,\n                          regulator_mode : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_desired_temp(lower_desired_temp)\n    put_upper_desired_temp(upper_desired_temp)\n    put_regulator_mode(regulator_mode)\n  }\n\n\n  \/** helper function to check Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param heat_control method that will be called with the value of the outgoing data\n   *        port 'heat_control'.\n   *\/\n  def check_concrete_output(heat_control: Isolette_Data_Model.On_Off.Type => B = heat_controlParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val heat_controlValue: Isolette_Data_Model.On_Off.Type = get_heat_control().get\n    if(!heat_control(heat_controlValue)) {\n      testFailures = testFailures :+ st\"'heat_control' did not match expected: value of the outgoing data port is ${heat_controlValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_desired_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_desired_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_desired_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_regulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_heat_control(): Option[Isolette_Data_Model.On_Off.Type] = {\n    val value: Option[Isolette_Data_Model.On_Off.Type] = get_heat_control_payload() match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port heat_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_heat_control_payload(): Option[Isolette_Data_Model.On_Off_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.heat_control_Id).asInstanceOf[Option[Isolette_Data_Model.On_Off_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Test extends Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Regulate.{Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  upper_desired_temp: Port[Isolette_Data_Model.Temp_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type],\n  heat_control: Port[Isolette_Data_Model.On_Off.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_desired_temp,\n              upper_desired_temp,\n              regulator_mode,\n              heat_control),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_desired_temp,\n                  upper_desired_temp,\n                  regulator_mode),\n\n    dataOuts = ISZ(heat_control),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Heat_Source_impl_Initialization_Api = {\n    val api = Manage_Heat_Source_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id\n    )\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Heat_Source_impl_Operational_Api = {\n    val api = Manage_Heat_Source_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id\n    )\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_desired_temp.id,\n      upper_desired_temp.id,\n      regulator_mode.id,\n      heat_control.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_Bridge {\n\n  var c_initialization_api: Option[Manage_Heat_Source_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Heat_Source_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_desired_temp_Id : Art.PortId,\n    upper_desired_temp_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n    heat_control_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Heat_Source_impl_Initialization_Api,\n    operational_api: Manage_Heat_Source_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_desired_temp_Id,\n                                             upper_desired_temp_Id,\n                                             regulator_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(heat_control_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Heat_Source_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Heat_Source_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_desired_temp_Id : Art.PortId\n  def upper_desired_temp_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n  def heat_control_Id : Art.PortId\n\n  def setheat_control(value : Isolette_Data_Model.On_Off.Type) : Unit = {\n    Art.putValue(heat_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Heat_Source_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val heat_control_Id : Art.PortId) extends Manage_Heat_Source_impl_Api\n\n@datatype class Manage_Heat_Source_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_desired_temp_Id : Art.PortId,\n  val upper_desired_temp_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId,\n  val heat_control_Id : Art.PortId) extends Manage_Heat_Source_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_desired_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(lower_desired_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getupper_desired_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(upper_desired_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_desired_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getregulator_mode() : Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Regulator_Mode.Type] = Art.getValue(regulator_mode_Id) match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Regulator_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Regulate\/Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Heat_Source_impl_thermostat_regulate_temperature_manage_heat_source_mhst {\n\n  def initialise(api: Manage_Heat_Source_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setheat_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Heat_Source_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_desired_temp: Option[Isolette_Data_Model.Temp_impl] = api.getlower_desired_temp()\n    api.logInfo(s\"Received on lower_desired_temp: ${apiUsage_lower_desired_temp}\")\n    val apiUsage_upper_desired_temp: Option[Isolette_Data_Model.Temp_impl] = api.getupper_desired_temp()\n    api.logInfo(s\"Received on upper_desired_temp: ${apiUsage_upper_desired_temp}\")\n    val apiUsage_regulator_mode: Option[Isolette_Data_Model.Regulator_Mode.Type] = api.getregulator_mode()\n    api.logInfo(s\"Received on regulator_mode: ${apiUsage_regulator_mode}\")\n  }\n\n  def activate(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Heat_Source_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi extends BridgeTestSuite[Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge](Arch.isolette_single_sensor_Instance_thermostat_regulate_temperature_manage_regulator_mode_mrmt) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param interface_failure payload for data port interface_failure\n   * @param internal_failure payload for data port internal_failure\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          interface_failure : Isolette_Data_Model.Failure_Flag_impl,\n                          internal_failure : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_interface_failure(interface_failure)\n    put_internal_failure(internal_failure)\n  }\n\n\n  \/** helper function to check Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param regulator_mode method that will be called with the value of the outgoing data\n   *        port 'regulator_mode'.\n   *\/\n  def check_concrete_output(regulator_mode: Isolette_Data_Model.Regulator_Mode.Type => B = regulator_modeParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val regulator_modeValue: Isolette_Data_Model.Regulator_Mode.Type = get_regulator_mode().get\n    if(!regulator_mode(regulator_modeValue)) {\n      testFailures = testFailures :+ st\"'regulator_mode' did not match expected: value of the outgoing data port is ${regulator_modeValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_interface_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_internal_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.internal_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_regulator_mode(): Option[Isolette_Data_Model.Regulator_Mode.Type] = {\n    val value: Option[Isolette_Data_Model.Regulator_Mode.Type] = get_regulator_mode_payload() match {\n      case Some(Isolette_Data_Model.Regulator_Mode_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port regulator_mode.  Expecting 'Isolette_Data_Model.Regulator_Mode_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Regulator_Mode.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_regulator_mode_payload(): Option[Isolette_Data_Model.Regulator_Mode_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.regulator_mode_Id).asInstanceOf[Option[Isolette_Data_Model.Regulator_Mode_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM.Regulate._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Test extends Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Regulate.{Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  internal_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  regulator_mode: Port[Isolette_Data_Model.Regulator_Mode.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              interface_failure,\n              internal_failure,\n              regulator_mode),\n\n    dataIns = ISZ(current_tempWstatus,\n                  interface_failure,\n                  internal_failure),\n\n    dataOuts = ISZ(regulator_mode),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Regulator_Mode_impl_Initialization_Api = {\n    val api = Manage_Regulator_Mode_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id\n    )\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Regulator_Mode_impl_Operational_Api = {\n    val api = Manage_Regulator_Mode_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id\n    )\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      regulator_mode.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_Bridge {\n\n  var c_initialization_api: Option[Manage_Regulator_Mode_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Regulator_Mode_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n    internal_failure_Id : Art.PortId,\n    regulator_mode_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Regulator_Mode_impl_Initialization_Api,\n    operational_api: Manage_Regulator_Mode_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             interface_failure_Id,\n                                             internal_failure_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(regulator_mode_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Regulate\/Manage_Regulator_Mode_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Regulator_Mode_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n  def internal_failure_Id : Art.PortId\n  def regulator_mode_Id : Art.PortId\n\n  def setregulator_mode(value : Isolette_Data_Model.Regulator_Mode.Type) : Unit = {\n    Art.putValue(regulator_mode_Id, Isolette_Data_Model.Regulator_Mode_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Regulator_Mode_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId) extends Manage_Regulator_Mode_impl_Api\n\n@datatype class Manage_Regulator_Mode_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val regulator_mode_Id : Art.PortId) extends Manage_Regulator_Mode_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getinterface_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(interface_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  def getinternal_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(internal_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port internal_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Regulate\/Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Regulate\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Regulator_Mode_impl_thermostat_regulate_temperature_manage_regulator_mode_mrmt {\n\n  def initialise(api: Manage_Regulator_Mode_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setregulator_mode(Isolette_Data_Model.Regulator_Mode.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinterface_failure()\n    api.logInfo(s\"Received on interface_failure: ${apiUsage_interface_failure}\")\n    val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinternal_failure()\n    api.logInfo(s\"Received on internal_failure: ${apiUsage_internal_failure}\")\n  }\n\n  def activate(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Regulator_Mode_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi extends BridgeTestSuite[Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_alarm_mat) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param lower_alarm_temp payload for data port lower_alarm_temp\n   * @param upper_alarm_temp payload for data port upper_alarm_temp\n   * @param monitor_mode payload for data port monitor_mode\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_alarm_temp : Isolette_Data_Model.Temp_impl,\n                          upper_alarm_temp : Isolette_Data_Model.Temp_impl,\n                          monitor_mode : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_lower_alarm_temp(lower_alarm_temp)\n    put_upper_alarm_temp(upper_alarm_temp)\n    put_monitor_mode(monitor_mode)\n  }\n\n\n  \/** helper function to check Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param alarm_control method that will be called with the value of the outgoing data\n   *        port 'alarm_control'.\n   *\/\n  def check_concrete_output(alarm_control: Isolette_Data_Model.On_Off.Type => B = alarm_controlParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val alarm_controlValue: Isolette_Data_Model.On_Off.Type = get_alarm_control().get\n    if(!alarm_control(alarm_controlValue)) {\n      testFailures = testFailures :+ st\"'alarm_control' did not match expected: value of the outgoing data port is ${alarm_controlValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_alarm_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_upper_alarm_temp(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_alarm_control(): Option[Isolette_Data_Model.On_Off.Type] = {\n    val value: Option[Isolette_Data_Model.On_Off.Type] = get_alarm_control_payload() match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port alarm_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_alarm_control_payload(): Option[Isolette_Data_Model.On_Off_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.alarm_control_Id).asInstanceOf[Option[Isolette_Data_Model.On_Off_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Test extends Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Monitor.{Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  upper_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type],\n  alarm_control: Port[Isolette_Data_Model.On_Off.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              lower_alarm_temp,\n              upper_alarm_temp,\n              monitor_mode,\n              alarm_control),\n\n    dataIns = ISZ(current_tempWstatus,\n                  lower_alarm_temp,\n                  upper_alarm_temp,\n                  monitor_mode),\n\n    dataOuts = ISZ(alarm_control),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Alarm_impl_Initialization_Api = {\n    val api = Manage_Alarm_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id\n    )\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Alarm_impl_Operational_Api = {\n    val api = Manage_Alarm_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id\n    )\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      lower_alarm_temp.id,\n      upper_alarm_temp.id,\n      monitor_mode.id,\n      alarm_control.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_Bridge {\n\n  var c_initialization_api: Option[Manage_Alarm_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Alarm_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    lower_alarm_temp_Id : Art.PortId,\n    upper_alarm_temp_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n    alarm_control_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Alarm_impl_Initialization_Api,\n    operational_api: Manage_Alarm_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             lower_alarm_temp_Id,\n                                             upper_alarm_temp_Id,\n                                             monitor_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(alarm_control_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Alarm_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Alarm_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def lower_alarm_temp_Id : Art.PortId\n  def upper_alarm_temp_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n  def alarm_control_Id : Art.PortId\n\n  def setalarm_control(value : Isolette_Data_Model.On_Off.Type) : Unit = {\n    Art.putValue(alarm_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Alarm_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId) extends Manage_Alarm_impl_Api\n\n@datatype class Manage_Alarm_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId) extends Manage_Alarm_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_alarm_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(lower_alarm_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getupper_alarm_temp() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(upper_alarm_temp_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getmonitor_mode() : Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Monitor_Mode.Type] = Art.getValue(monitor_mode_Id) match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Monitor_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Monitor\/Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Alarm_impl_thermostat_monitor_temperature_manage_alarm_mat {\n\n  def initialise(api: Manage_Alarm_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setalarm_control(Isolette_Data_Model.On_Off.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Alarm_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_lower_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = api.getlower_alarm_temp()\n    api.logInfo(s\"Received on lower_alarm_temp: ${apiUsage_lower_alarm_temp}\")\n    val apiUsage_upper_alarm_temp: Option[Isolette_Data_Model.Temp_impl] = api.getupper_alarm_temp()\n    api.logInfo(s\"Received on upper_alarm_temp: ${apiUsage_upper_alarm_temp}\")\n    val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = api.getmonitor_mode()\n    api.logInfo(s\"Received on monitor_mode: ${apiUsage_monitor_mode}\")\n  }\n\n  def activate(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Alarm_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi extends BridgeTestSuite[Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_interface_mmit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param upper_alarm_tempWstatus payload for data port upper_alarm_tempWstatus\n   * @param lower_alarm_tempWstatus payload for data port lower_alarm_tempWstatus\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param monitor_mode payload for data port monitor_mode\n   *\/\n  def put_concrete_inputs(upper_alarm_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          lower_alarm_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          monitor_mode : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    put_upper_alarm_tempWstatus(upper_alarm_tempWstatus)\n    put_lower_alarm_tempWstatus(lower_alarm_tempWstatus)\n    put_current_tempWstatus(current_tempWstatus)\n    put_monitor_mode(monitor_mode)\n  }\n\n\n  \/** helper function to check Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param upper_alarm_temp method that will be called with the value of the outgoing data\n   *        port 'upper_alarm_temp'.\n   * @param lower_alarm_temp method that will be called with the value of the outgoing data\n   *        port 'lower_alarm_temp'.\n   * @param monitor_status method that will be called with the value of the outgoing data\n   *        port 'monitor_status'.\n   * @param interface_failure method that will be called with the value of the outgoing data\n   *        port 'interface_failure'.\n   *\/\n  def check_concrete_output(upper_alarm_temp: Isolette_Data_Model.Temp_impl => B = upper_alarm_tempParam => {T},\n                            lower_alarm_temp: Isolette_Data_Model.Temp_impl => B = lower_alarm_tempParam => {T},\n                            monitor_status: Isolette_Data_Model.Status.Type => B = monitor_statusParam => {T},\n                            interface_failure: Isolette_Data_Model.Failure_Flag_impl => B = interface_failureParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val upper_alarm_tempValue: Isolette_Data_Model.Temp_impl = get_upper_alarm_temp().get\n    if(!upper_alarm_temp(upper_alarm_tempValue)) {\n      testFailures = testFailures :+ st\"'upper_alarm_temp' did not match expected: value of the outgoing data port is ${upper_alarm_tempValue}\"\n    }\n    val lower_alarm_tempValue: Isolette_Data_Model.Temp_impl = get_lower_alarm_temp().get\n    if(!lower_alarm_temp(lower_alarm_tempValue)) {\n      testFailures = testFailures :+ st\"'lower_alarm_temp' did not match expected: value of the outgoing data port is ${lower_alarm_tempValue}\"\n    }\n    val monitor_statusValue: Isolette_Data_Model.Status.Type = get_monitor_status().get\n    if(!monitor_status(monitor_statusValue)) {\n      testFailures = testFailures :+ st\"'monitor_status' did not match expected: value of the outgoing data port is ${monitor_statusValue}\"\n    }\n    val interface_failureValue: Isolette_Data_Model.Failure_Flag_impl = get_interface_failure().get\n    if(!interface_failure(interface_failureValue)) {\n      testFailures = testFailures :+ st\"'interface_failure' did not match expected: value of the outgoing data port is ${interface_failureValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_upper_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.upper_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_lower_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.lower_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_alarm_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_upper_alarm_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_alarm_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_alarm_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_alarm_temp(): Option[Isolette_Data_Model.Temp_impl] = {\n    val value: Option[Isolette_Data_Model.Temp_impl] = get_lower_alarm_temp_payload() match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_alarm_temp.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_alarm_temp_payload(): Option[Isolette_Data_Model.Temp_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_alarm_temp_Id).asInstanceOf[Option[Isolette_Data_Model.Temp_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_monitor_status(): Option[Isolette_Data_Model.Status.Type] = {\n    val value: Option[Isolette_Data_Model.Status.Type] = get_monitor_status_payload() match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port monitor_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_monitor_status_payload(): Option[Isolette_Data_Model.Status_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.monitor_status_Id).asInstanceOf[Option[Isolette_Data_Model.Status_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_interface_failure(): Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value: Option[Isolette_Data_Model.Failure_Flag_impl] = get_interface_failure_payload() match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_interface_failure_payload(): Option[Isolette_Data_Model.Failure_Flag_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.interface_failure_Id).asInstanceOf[Option[Isolette_Data_Model.Failure_Flag_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Test extends Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Monitor.{Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  upper_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type],\n  upper_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  lower_alarm_temp: Port[Isolette_Data_Model.Temp_impl],\n  monitor_status: Port[Isolette_Data_Model.Status.Type],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(upper_alarm_tempWstatus,\n              lower_alarm_tempWstatus,\n              current_tempWstatus,\n              monitor_mode,\n              upper_alarm_temp,\n              lower_alarm_temp,\n              monitor_status,\n              interface_failure),\n\n    dataIns = ISZ(upper_alarm_tempWstatus,\n                  lower_alarm_tempWstatus,\n                  current_tempWstatus,\n                  monitor_mode),\n\n    dataOuts = ISZ(upper_alarm_temp,\n                   lower_alarm_temp,\n                   monitor_status,\n                   interface_failure),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Monitor_Interface_impl_Initialization_Api = {\n    val api = Manage_Monitor_Interface_impl_Initialization_Api(\n      id,\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id\n    )\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Monitor_Interface_impl_Operational_Api = {\n    val api = Manage_Monitor_Interface_impl_Operational_Api(\n      id,\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id\n    )\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge.EntryPoints(\n      id,\n\n      upper_alarm_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      current_tempWstatus.id,\n      monitor_mode.id,\n      upper_alarm_temp.id,\n      lower_alarm_temp.id,\n      monitor_status.id,\n      interface_failure.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_Bridge {\n\n  var c_initialization_api: Option[Manage_Monitor_Interface_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Monitor_Interface_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit_BridgeId : Art.BridgeId,\n\n    upper_alarm_tempWstatus_Id : Art.PortId,\n    lower_alarm_tempWstatus_Id : Art.PortId,\n    current_tempWstatus_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n    upper_alarm_temp_Id : Art.PortId,\n    lower_alarm_temp_Id : Art.PortId,\n    monitor_status_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Monitor_Interface_impl_Initialization_Api,\n    operational_api: Manage_Monitor_Interface_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(upper_alarm_tempWstatus_Id,\n                                             lower_alarm_tempWstatus_Id,\n                                             current_tempWstatus_Id,\n                                             monitor_mode_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(upper_alarm_temp_Id,\n                                              lower_alarm_temp_Id,\n                                              monitor_status_Id,\n                                              interface_failure_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Interface_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Monitor_Interface_impl_Api {\n  def id: Art.BridgeId\n  def upper_alarm_tempWstatus_Id : Art.PortId\n  def lower_alarm_tempWstatus_Id : Art.PortId\n  def current_tempWstatus_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n  def upper_alarm_temp_Id : Art.PortId\n  def lower_alarm_temp_Id : Art.PortId\n  def monitor_status_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n\n  def setupper_alarm_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(upper_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setlower_alarm_temp(value : Isolette_Data_Model.Temp_impl) : Unit = {\n    Art.putValue(lower_alarm_temp_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  def setmonitor_status(value : Isolette_Data_Model.Status.Type) : Unit = {\n    Art.putValue(monitor_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  def setinterface_failure(value : Isolette_Data_Model.Failure_Flag_impl) : Unit = {\n    Art.putValue(interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Monitor_Interface_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val upper_alarm_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Monitor_Interface_impl_Api\n\n@datatype class Manage_Monitor_Interface_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val upper_alarm_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId,\n  val upper_alarm_temp_Id : Art.PortId,\n  val lower_alarm_temp_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId) extends Manage_Monitor_Interface_impl_Api {\n\n  def getupper_alarm_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(upper_alarm_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port upper_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getlower_alarm_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(lower_alarm_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port lower_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getmonitor_mode() : Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value : Option[Isolette_Data_Model.Monitor_Mode.Type] = Art.getValue(monitor_mode_Id) match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Monitor_Mode.Type]()\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Monitor\/Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Monitor_Interface_impl_thermostat_monitor_temperature_manage_monitor_interface_mmit {\n\n  def initialise(api: Manage_Monitor_Interface_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setupper_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setlower_alarm_temp(Isolette_Data_Model.Temp_impl.empty())\n    api.setmonitor_status(Isolette_Data_Model.Status.byOrdinal(0).get)\n    api.setinterface_failure(Isolette_Data_Model.Failure_Flag_impl.empty())\n  }\n\n  def timeTriggered(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_upper_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getupper_alarm_tempWstatus()\n    api.logInfo(s\"Received on upper_alarm_tempWstatus: ${apiUsage_upper_alarm_tempWstatus}\")\n    val apiUsage_lower_alarm_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getlower_alarm_tempWstatus()\n    api.logInfo(s\"Received on lower_alarm_tempWstatus: ${apiUsage_lower_alarm_tempWstatus}\")\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_monitor_mode: Option[Isolette_Data_Model.Monitor_Mode.Type] = api.getmonitor_mode()\n    api.logInfo(s\"Received on monitor_mode: ${apiUsage_monitor_mode}\")\n  }\n\n  def activate(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Monitor_Interface_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi extends BridgeTestSuite[Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge](Arch.isolette_single_sensor_Instance_thermostat_monitor_temperature_manage_monitor_mode_mmmt) {\n\n  \/** helper function to set the values of all input ports.\n   * @param current_tempWstatus payload for data port current_tempWstatus\n   * @param interface_failure payload for data port interface_failure\n   * @param internal_failure payload for data port internal_failure\n   *\/\n  def put_concrete_inputs(current_tempWstatus : Isolette_Data_Model.TempWstatus_impl,\n                          interface_failure : Isolette_Data_Model.Failure_Flag_impl,\n                          internal_failure : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    put_current_tempWstatus(current_tempWstatus)\n    put_interface_failure(interface_failure)\n    put_internal_failure(internal_failure)\n  }\n\n\n  \/** helper function to check Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param monitor_mode method that will be called with the value of the outgoing data\n   *        port 'monitor_mode'.\n   *\/\n  def check_concrete_output(monitor_mode: Isolette_Data_Model.Monitor_Mode.Type => B = monitor_modeParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val monitor_modeValue: Isolette_Data_Model.Monitor_Mode.Type = get_monitor_mode().get\n    if(!monitor_mode(monitor_modeValue)) {\n      testFailures = testFailures :+ st\"'monitor_mode' did not match expected: value of the outgoing data port is ${monitor_modeValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_current_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_interface_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.interface_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_internal_failure(value : Isolette_Data_Model.Failure_Flag_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.internal_failure_Id, Isolette_Data_Model.Failure_Flag_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_monitor_mode(): Option[Isolette_Data_Model.Monitor_Mode.Type] = {\n    val value: Option[Isolette_Data_Model.Monitor_Mode.Type] = get_monitor_mode_payload() match {\n      case Some(Isolette_Data_Model.Monitor_Mode_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port monitor_mode.  Expecting 'Isolette_Data_Model.Monitor_Mode_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.Monitor_Mode.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_monitor_mode_payload(): Option[Isolette_Data_Model.Monitor_Mode_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.monitor_mode_Id).asInstanceOf[Option[Isolette_Data_Model.Monitor_Mode_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM.Monitor._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Test extends Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Monitor.{Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  interface_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  internal_failure: Port[Isolette_Data_Model.Failure_Flag_impl],\n  monitor_mode: Port[Isolette_Data_Model.Monitor_Mode.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(current_tempWstatus,\n              interface_failure,\n              internal_failure,\n              monitor_mode),\n\n    dataIns = ISZ(current_tempWstatus,\n                  interface_failure,\n                  internal_failure),\n\n    dataOuts = ISZ(monitor_mode),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Manage_Monitor_Mode_impl_Initialization_Api = {\n    val api = Manage_Monitor_Mode_impl_Initialization_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id\n    )\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Manage_Monitor_Mode_impl_Operational_Api = {\n    val api = Manage_Monitor_Mode_impl_Operational_Api(\n      id,\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id\n    )\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge.EntryPoints(\n      id,\n\n      current_tempWstatus.id,\n      interface_failure.id,\n      internal_failure.id,\n      monitor_mode.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_Bridge {\n\n  var c_initialization_api: Option[Manage_Monitor_Mode_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Manage_Monitor_Mode_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt_BridgeId : Art.BridgeId,\n\n    current_tempWstatus_Id : Art.PortId,\n    interface_failure_Id : Art.PortId,\n    internal_failure_Id : Art.PortId,\n    monitor_mode_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Manage_Monitor_Mode_impl_Initialization_Api,\n    operational_api: Manage_Monitor_Mode_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id,\n                                             interface_failure_Id,\n                                             internal_failure_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(monitor_mode_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Monitor\/Manage_Monitor_Mode_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Manage_Monitor_Mode_impl_Api {\n  def id: Art.BridgeId\n  def current_tempWstatus_Id : Art.PortId\n  def interface_failure_Id : Art.PortId\n  def internal_failure_Id : Art.PortId\n  def monitor_mode_Id : Art.PortId\n\n  def setmonitor_mode(value : Isolette_Data_Model.Monitor_Mode.Type) : Unit = {\n    Art.putValue(monitor_mode_Id, Isolette_Data_Model.Monitor_Mode_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Manage_Monitor_Mode_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId) extends Manage_Monitor_Mode_impl_Api\n\n@datatype class Manage_Monitor_Mode_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val current_tempWstatus_Id : Art.PortId,\n  val interface_failure_Id : Art.PortId,\n  val internal_failure_Id : Art.PortId,\n  val monitor_mode_Id : Art.PortId) extends Manage_Monitor_Mode_impl_Api {\n\n  def getcurrent_tempWstatus() : Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value : Option[Isolette_Data_Model.TempWstatus_impl] = Art.getValue(current_tempWstatus_Id) match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.TempWstatus_impl]()\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  def getinterface_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(interface_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port interface_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n\n  def getinternal_failure() : Option[Isolette_Data_Model.Failure_Flag_impl] = {\n    val value : Option[Isolette_Data_Model.Failure_Flag_impl] = Art.getValue(internal_failure_Id) match {\n      case Some(Isolette_Data_Model.Failure_Flag_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port internal_failure.  Expecting 'Isolette_Data_Model.Failure_Flag_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Failure_Flag_impl]()\n      case _ => None[Isolette_Data_Model.Failure_Flag_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Monitor\/Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Monitor\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Manage_Monitor_Mode_impl_thermostat_monitor_temperature_manage_monitor_mode_mmmt {\n\n  def initialise(api: Manage_Monitor_Mode_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setmonitor_mode(Isolette_Data_Model.Monitor_Mode.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_current_tempWstatus: Option[Isolette_Data_Model.TempWstatus_impl] = api.getcurrent_tempWstatus()\n    api.logInfo(s\"Received on current_tempWstatus: ${apiUsage_current_tempWstatus}\")\n    val apiUsage_interface_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinterface_failure()\n    api.logInfo(s\"Received on interface_failure: ${apiUsage_interface_failure}\")\n    val apiUsage_internal_failure: Option[Isolette_Data_Model.Failure_Flag_impl] = api.getinternal_failure()\n    api.logInfo(s\"Received on internal_failure: ${apiUsage_internal_failure}\")\n  }\n\n  def activate(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n\n  def recover(api: Manage_Monitor_Mode_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Isolette\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class operator_interface_thread_impl_operator_interface_oip_oit_TestApi extends BridgeTestSuite[operator_interface_thread_impl_operator_interface_oip_oit_Bridge](Arch.isolette_single_sensor_Instance_operator_interface_oip_oit) {\n\n  \/** helper function to set the values of all input ports.\n   * @param regulator_status payload for data port regulator_status\n   * @param monitor_status payload for data port monitor_status\n   * @param display_temperature payload for data port display_temperature\n   * @param alarm_control payload for data port alarm_control\n   *\/\n  def put_concrete_inputs(regulator_status : Isolette_Data_Model.Status.Type,\n                          monitor_status : Isolette_Data_Model.Status.Type,\n                          display_temperature : Isolette_Data_Model.Temp_impl,\n                          alarm_control : Isolette_Data_Model.On_Off.Type): Unit = {\n    put_regulator_status(regulator_status)\n    put_monitor_status(monitor_status)\n    put_display_temperature(display_temperature)\n    put_alarm_control(alarm_control)\n  }\n\n\n  \/** helper function to check operator_interface_thread_impl_operator_interface_oip_oit's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param lower_desired_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'lower_desired_tempWstatus'.\n   * @param upper_desired_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'upper_desired_tempWstatus'.\n   * @param lower_alarm_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'lower_alarm_tempWstatus'.\n   * @param upper_alarm_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'upper_alarm_tempWstatus'.\n   *\/\n  def check_concrete_output(lower_desired_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = lower_desired_tempWstatusParam => {T},\n                            upper_desired_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = upper_desired_tempWstatusParam => {T},\n                            lower_alarm_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = lower_alarm_tempWstatusParam => {T},\n                            upper_alarm_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = upper_alarm_tempWstatusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val lower_desired_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_lower_desired_tempWstatus().get\n    if(!lower_desired_tempWstatus(lower_desired_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'lower_desired_tempWstatus' did not match expected: value of the outgoing data port is ${lower_desired_tempWstatusValue}\"\n    }\n    val upper_desired_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_upper_desired_tempWstatus().get\n    if(!upper_desired_tempWstatus(upper_desired_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'upper_desired_tempWstatus' did not match expected: value of the outgoing data port is ${upper_desired_tempWstatusValue}\"\n    }\n    val lower_alarm_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_lower_alarm_tempWstatus().get\n    if(!lower_alarm_tempWstatus(lower_alarm_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'lower_alarm_tempWstatus' did not match expected: value of the outgoing data port is ${lower_alarm_tempWstatusValue}\"\n    }\n    val upper_alarm_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_upper_alarm_tempWstatus().get\n    if(!upper_alarm_tempWstatus(upper_alarm_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'upper_alarm_tempWstatus' did not match expected: value of the outgoing data port is ${upper_alarm_tempWstatusValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_regulator_status(value : Isolette_Data_Model.Status.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.regulator_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_monitor_status(value : Isolette_Data_Model.Status.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.monitor_status_Id, Isolette_Data_Model.Status_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_display_temperature(value : Isolette_Data_Model.Temp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.display_temperature_Id, Isolette_Data_Model.Temp_impl_Payload(value))\n  }\n\n  \/\/ setter for in DataPort\n  def put_alarm_control(value : Isolette_Data_Model.On_Off.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.alarm_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_desired_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_lower_desired_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_desired_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_desired_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_desired_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_upper_desired_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_desired_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_desired_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_desired_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_lower_alarm_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_lower_alarm_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port lower_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_lower_alarm_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.lower_alarm_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n  \/\/ getter for out DataPort\n  def get_upper_alarm_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_upper_alarm_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port upper_alarm_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_upper_alarm_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.upper_alarm_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Isolette\n\nimport org.sireum._\nimport isolette__JVM.Isolette._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass operator_interface_thread_impl_operator_interface_oip_oit_Test extends operator_interface_thread_impl_operator_interface_oip_oit_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Isolette.{operator_interface_thread_impl_operator_interface_oip_oit => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class operator_interface_thread_impl_operator_interface_oip_oit_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  regulator_status: Port[Isolette_Data_Model.Status.Type],\n  monitor_status: Port[Isolette_Data_Model.Status.Type],\n  display_temperature: Port[Isolette_Data_Model.Temp_impl],\n  alarm_control: Port[Isolette_Data_Model.On_Off.Type],\n  lower_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_desired_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  lower_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl],\n  upper_alarm_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(regulator_status,\n              monitor_status,\n              display_temperature,\n              alarm_control,\n              lower_desired_tempWstatus,\n              upper_desired_tempWstatus,\n              lower_alarm_tempWstatus,\n              upper_alarm_tempWstatus),\n\n    dataIns = ISZ(regulator_status,\n                  monitor_status,\n                  display_temperature,\n                  alarm_control),\n\n    dataOuts = ISZ(lower_desired_tempWstatus,\n                   upper_desired_tempWstatus,\n                   lower_alarm_tempWstatus,\n                   upper_alarm_tempWstatus),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : operator_interface_thread_impl_Initialization_Api = {\n    val api = operator_interface_thread_impl_Initialization_Api(\n      id,\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id\n    )\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : operator_interface_thread_impl_Operational_Api = {\n    val api = operator_interface_thread_impl_Operational_Api(\n      id,\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id\n    )\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    operator_interface_thread_impl_operator_interface_oip_oit_Bridge.EntryPoints(\n      id,\n\n      regulator_status.id,\n      monitor_status.id,\n      display_temperature.id,\n      alarm_control.id,\n      lower_desired_tempWstatus.id,\n      upper_desired_tempWstatus.id,\n      lower_alarm_tempWstatus.id,\n      upper_alarm_tempWstatus.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject operator_interface_thread_impl_operator_interface_oip_oit_Bridge {\n\n  var c_initialization_api: Option[operator_interface_thread_impl_Initialization_Api] = None()\n  var c_operational_api: Option[operator_interface_thread_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    operator_interface_thread_impl_operator_interface_oip_oit_BridgeId : Art.BridgeId,\n\n    regulator_status_Id : Art.PortId,\n    monitor_status_Id : Art.PortId,\n    display_temperature_Id : Art.PortId,\n    alarm_control_Id : Art.PortId,\n    lower_desired_tempWstatus_Id : Art.PortId,\n    upper_desired_tempWstatus_Id : Art.PortId,\n    lower_alarm_tempWstatus_Id : Art.PortId,\n    upper_alarm_tempWstatus_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: operator_interface_thread_impl_Initialization_Api,\n    operational_api: operator_interface_thread_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(regulator_status_Id,\n                                             monitor_status_Id,\n                                             display_temperature_Id,\n                                             alarm_control_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(lower_desired_tempWstatus_Id,\n                                              upper_desired_tempWstatus_Id,\n                                              lower_alarm_tempWstatus_Id,\n                                              upper_alarm_tempWstatus_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Isolette\/operator_interface_thread_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait operator_interface_thread_impl_Api {\n  def id: Art.BridgeId\n  def regulator_status_Id : Art.PortId\n  def monitor_status_Id : Art.PortId\n  def display_temperature_Id : Art.PortId\n  def alarm_control_Id : Art.PortId\n  def lower_desired_tempWstatus_Id : Art.PortId\n  def upper_desired_tempWstatus_Id : Art.PortId\n  def lower_alarm_tempWstatus_Id : Art.PortId\n  def upper_alarm_tempWstatus_Id : Art.PortId\n\n  def setlower_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(lower_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setupper_desired_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(upper_desired_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setlower_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(lower_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def setupper_alarm_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(upper_alarm_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class operator_interface_thread_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val regulator_status_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val display_temperature_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val upper_alarm_tempWstatus_Id : Art.PortId) extends operator_interface_thread_impl_Api\n\n@datatype class operator_interface_thread_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val regulator_status_Id : Art.PortId,\n  val monitor_status_Id : Art.PortId,\n  val display_temperature_Id : Art.PortId,\n  val alarm_control_Id : Art.PortId,\n  val lower_desired_tempWstatus_Id : Art.PortId,\n  val upper_desired_tempWstatus_Id : Art.PortId,\n  val lower_alarm_tempWstatus_Id : Art.PortId,\n  val upper_alarm_tempWstatus_Id : Art.PortId) extends operator_interface_thread_impl_Api {\n\n  def getregulator_status() : Option[Isolette_Data_Model.Status.Type] = {\n    val value : Option[Isolette_Data_Model.Status.Type] = Art.getValue(regulator_status_Id) match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port regulator_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Status.Type]()\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  def getmonitor_status() : Option[Isolette_Data_Model.Status.Type] = {\n    val value : Option[Isolette_Data_Model.Status.Type] = Art.getValue(monitor_status_Id) match {\n      case Some(Isolette_Data_Model.Status_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port monitor_status.  Expecting 'Isolette_Data_Model.Status_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Status.Type]()\n      case _ => None[Isolette_Data_Model.Status.Type]()\n    }\n    return value\n  }\n\n  def getdisplay_temperature() : Option[Isolette_Data_Model.Temp_impl] = {\n    val value : Option[Isolette_Data_Model.Temp_impl] = Art.getValue(display_temperature_Id) match {\n      case Some(Isolette_Data_Model.Temp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port display_temperature.  Expecting 'Isolette_Data_Model.Temp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.Temp_impl]()\n      case _ => None[Isolette_Data_Model.Temp_impl]()\n    }\n    return value\n  }\n\n  def getalarm_control() : Option[Isolette_Data_Model.On_Off.Type] = {\n    val value : Option[Isolette_Data_Model.On_Off.Type] = Art.getValue(alarm_control_Id) match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port alarm_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n        None[Isolette_Data_Model.On_Off.Type]()\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Isolette\/operator_interface_thread_impl_operator_interface_oip_oit.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Isolette\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject operator_interface_thread_impl_operator_interface_oip_oit {\n\n  def initialise(api: operator_interface_thread_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setlower_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setupper_desired_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setlower_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n    api.setupper_alarm_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n\n  def timeTriggered(api: operator_interface_thread_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_regulator_status: Option[Isolette_Data_Model.Status.Type] = api.getregulator_status()\n    api.logInfo(s\"Received on regulator_status: ${apiUsage_regulator_status}\")\n    val apiUsage_monitor_status: Option[Isolette_Data_Model.Status.Type] = api.getmonitor_status()\n    api.logInfo(s\"Received on monitor_status: ${apiUsage_monitor_status}\")\n    val apiUsage_display_temperature: Option[Isolette_Data_Model.Temp_impl] = api.getdisplay_temperature()\n    api.logInfo(s\"Received on display_temperature: ${apiUsage_display_temperature}\")\n    val apiUsage_alarm_control: Option[Isolette_Data_Model.On_Off.Type] = api.getalarm_control()\n    api.logInfo(s\"Received on alarm_control: ${apiUsage_alarm_control}\")\n  }\n\n  def activate(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def finalise(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n\n  def recover(api: operator_interface_thread_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Devices\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi extends BridgeTestSuite[Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge](Arch.isolette_single_sensor_Instance_temperature_sensor_cpi_thermostat) {\n\n  \/** helper function to set the values of all input ports.\n   * @param air payload for data port air\n   *\/\n  def put_concrete_inputs(air : Isolette_Data_Model.PhysicalTemp_impl): Unit = {\n    put_air(air)\n  }\n\n\n  \/** helper function to check Temperature_Sensor_impl_temperature_sensor_cpi_thermostat's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param current_tempWstatus method that will be called with the value of the outgoing data\n   *        port 'current_tempWstatus'.\n   *\/\n  def check_concrete_output(current_tempWstatus: Isolette_Data_Model.TempWstatus_impl => B = current_tempWstatusParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val current_tempWstatusValue: Isolette_Data_Model.TempWstatus_impl = get_current_tempWstatus().get\n    if(!current_tempWstatus(current_tempWstatusValue)) {\n      testFailures = testFailures :+ st\"'current_tempWstatus' did not match expected: value of the outgoing data port is ${current_tempWstatusValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_air(value : Isolette_Data_Model.PhysicalTemp_impl): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.air_Id, Isolette_Data_Model.PhysicalTemp_impl_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_current_tempWstatus(): Option[Isolette_Data_Model.TempWstatus_impl] = {\n    val value: Option[Isolette_Data_Model.TempWstatus_impl] = get_current_tempWstatus_payload() match {\n      case Some(Isolette_Data_Model.TempWstatus_impl_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port current_tempWstatus.  Expecting 'Isolette_Data_Model.TempWstatus_impl_Payload' but received ${v}\")\n      case _ => None[Isolette_Data_Model.TempWstatus_impl]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_current_tempWstatus_payload(): Option[Isolette_Data_Model.TempWstatus_impl_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.current_tempWstatus_Id).asInstanceOf[Option[Isolette_Data_Model.TempWstatus_impl_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Devices\n\nimport org.sireum._\nimport isolette__JVM.Devices._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Test extends Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Devices.{Temperature_Sensor_impl_temperature_sensor_cpi_thermostat => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  air: Port[Isolette_Data_Model.PhysicalTemp_impl],\n  current_tempWstatus: Port[Isolette_Data_Model.TempWstatus_impl]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(air,\n              current_tempWstatus),\n\n    dataIns = ISZ(air),\n\n    dataOuts = ISZ(current_tempWstatus),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Temperature_Sensor_impl_Initialization_Api = {\n    val api = Temperature_Sensor_impl_Initialization_Api(\n      id,\n      air.id,\n      current_tempWstatus.id\n    )\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Temperature_Sensor_impl_Operational_Api = {\n    val api = Temperature_Sensor_impl_Operational_Api(\n      id,\n      air.id,\n      current_tempWstatus.id\n    )\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge.EntryPoints(\n      id,\n\n      air.id,\n      current_tempWstatus.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_Bridge {\n\n  var c_initialization_api: Option[Temperature_Sensor_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Temperature_Sensor_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Temperature_Sensor_impl_temperature_sensor_cpi_thermostat_BridgeId : Art.BridgeId,\n\n    air_Id : Art.PortId,\n    current_tempWstatus_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Temperature_Sensor_impl_Initialization_Api,\n    operational_api: Temperature_Sensor_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(air_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(current_tempWstatus_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Devices\/Temperature_Sensor_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Temperature_Sensor_impl_Api {\n  def id: Art.BridgeId\n  def air_Id : Art.PortId\n  def current_tempWstatus_Id : Art.PortId\n\n  def setcurrent_tempWstatus(value : Isolette_Data_Model.TempWstatus_impl) : Unit = {\n    Art.putValue(current_tempWstatus_Id, Isolette_Data_Model.TempWstatus_impl_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Temperature_Sensor_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val air_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId) extends Temperature_Sensor_impl_Api\n\n@datatype class Temperature_Sensor_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val air_Id : Art.PortId,\n  val current_tempWstatus_Id : Art.PortId) extends Temperature_Sensor_impl_Api {\n\n  def getair() : Option[Isolette_Data_Model.PhysicalTemp_impl] = {\n    val value : Option[Isolette_Data_Model.PhysicalTemp_impl] = Art.getValue(air_Id) match {\n      case Some(Isolette_Data_Model.PhysicalTemp_impl_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port air.  Expecting 'Isolette_Data_Model.PhysicalTemp_impl_Payload' but received ${v}\")\n        None[Isolette_Data_Model.PhysicalTemp_impl]()\n      case _ => None[Isolette_Data_Model.PhysicalTemp_impl]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Devices\/Temperature_Sensor_impl_temperature_sensor_cpi_thermostat.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Temperature_Sensor_impl_temperature_sensor_cpi_thermostat {\n\n  def initialise(api: Temperature_Sensor_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setcurrent_tempWstatus(Isolette_Data_Model.TempWstatus_impl.empty())\n  }\n\n  def timeTriggered(api: Temperature_Sensor_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_air: Option[Isolette_Data_Model.PhysicalTemp_impl] = api.getair()\n    api.logInfo(s\"Received on air: ${apiUsage_air}\")\n  }\n\n  def activate(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n\n  def recover(api: Temperature_Sensor_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/util\/isolette__JVM\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_TestApi.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Devices\n\nimport org.sireum._\nimport art.{ArtNative_Ext, Empty}\nimport isolette__JVM._\n\n\/\/ This file was auto-generated.  Do not edit\nabstract class Heat_Source_impl_heat_source_cpi_heat_controller_TestApi extends BridgeTestSuite[Heat_Source_impl_heat_source_cpi_heat_controller_Bridge](Arch.isolette_single_sensor_Instance_heat_source_cpi_heat_controller) {\n\n  \/** helper function to set the values of all input ports.\n   * @param heat_control payload for data port heat_control\n   *\/\n  def put_concrete_inputs(heat_control : Isolette_Data_Model.On_Off.Type): Unit = {\n    put_heat_control(heat_control)\n  }\n\n\n  \/** helper function to check Heat_Source_impl_heat_source_cpi_heat_controller's\n   * output ports.  Use named arguments to check subsets of the output ports.\n   * @param heat_out method that will be called with the value of the outgoing data\n   *        port 'heat_out'.\n   *\/\n  def check_concrete_output(heat_out: Isolette_Environment.Heat.Type => B = heat_outParam => {T}): Unit = {\n    var testFailures: ISZ[ST] = ISZ()\n\n    val heat_outValue: Isolette_Environment.Heat.Type = get_heat_out().get\n    if(!heat_out(heat_outValue)) {\n      testFailures = testFailures :+ st\"'heat_out' did not match expected: value of the outgoing data port is ${heat_outValue}\"\n    }\n\n    assert(testFailures.isEmpty, st\"${(testFailures, \"\\n\")}\".render)\n  }\n\n\n  \/\/ setter for in DataPort\n  def put_heat_control(value : Isolette_Data_Model.On_Off.Type): Unit = {\n    ArtNative_Ext.insertInPortValue(bridge.operational_api.heat_control_Id, Isolette_Data_Model.On_Off_Payload(value))\n  }\n\n  \/\/ getter for out DataPort\n  def get_heat_out(): Option[Isolette_Environment.Heat.Type] = {\n    val value: Option[Isolette_Environment.Heat.Type] = get_heat_out_payload() match {\n      case Some(Isolette_Environment.Heat_Payload(v)) => Some(v)\n      case Some(v) => fail(s\"Unexpected payload on port heat_out.  Expecting 'Isolette_Environment.Heat_Payload' but received ${v}\")\n      case _ => None[Isolette_Environment.Heat.Type]()\n    }\n    return value\n  }\n\n  \/\/ payload getter for out DataPort\n  def get_heat_out_payload(): Option[Isolette_Environment.Heat_Payload] = {\n    return ArtNative_Ext.observeOutPortValue(bridge.initialization_api.heat_out_Id).asInstanceOf[Option[Isolette_Environment.Heat_Payload]]\n  }\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/test\/bridge\/isolette__JVM\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_Test.scala",
        {
          "type" : "TestResource",
          "content" : "package isolette__JVM.Devices\n\nimport org.sireum._\nimport isolette__JVM.Devices._\n\n\/\/ This file will not be overwritten so is safe to edit\nclass Heat_Source_impl_heat_source_cpi_heat_controller_Test extends Heat_Source_impl_heat_source_cpi_heat_controller_TestApi {\n\n  test(\"Example Unit Test\"){\n    executeTest()\n  }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\nimport isolette__JVM.Devices.{Heat_Source_impl_heat_source_cpi_heat_controller => component}\n\n\/\/ This file was auto-generated.  Do not edit\n\n@record class Heat_Source_impl_heat_source_cpi_heat_controller_Bridge(\n  val id: Art.BridgeId,\n  val name: String,\n  val dispatchProtocol: DispatchPropertyProtocol,\n  val dispatchTriggers: Option[ISZ[Art.PortId]],\n\n  heat_control: Port[Isolette_Data_Model.On_Off.Type],\n  heat_out: Port[Isolette_Environment.Heat.Type]\n  ) extends Bridge {\n\n  val ports : Bridge.Ports = Bridge.Ports(\n    all = ISZ(heat_control,\n              heat_out),\n\n    dataIns = ISZ(heat_control),\n\n    dataOuts = ISZ(heat_out),\n\n    eventIns = ISZ(),\n\n    eventOuts = ISZ()\n  )\n\n  val initialization_api : Heat_Source_impl_Initialization_Api = {\n    val api = Heat_Source_impl_Initialization_Api(\n      id,\n      heat_control.id,\n      heat_out.id\n    )\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_initialization_api = Some(api)\n    api\n  }\n\n  val operational_api : Heat_Source_impl_Operational_Api = {\n    val api = Heat_Source_impl_Operational_Api(\n      id,\n      heat_control.id,\n      heat_out.id\n    )\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.c_operational_api = Some(api)\n    api\n  }\n\n  val entryPoints : Bridge.EntryPoints =\n    Heat_Source_impl_heat_source_cpi_heat_controller_Bridge.EntryPoints(\n      id,\n\n      heat_control.id,\n      heat_out.id,\n\n      dispatchTriggers,\n\n      initialization_api,\n      operational_api)\n}\n\nobject Heat_Source_impl_heat_source_cpi_heat_controller_Bridge {\n\n  var c_initialization_api: Option[Heat_Source_impl_Initialization_Api] = None()\n  var c_operational_api: Option[Heat_Source_impl_Operational_Api] = None()\n\n  @record class EntryPoints(\n    Heat_Source_impl_heat_source_cpi_heat_controller_BridgeId : Art.BridgeId,\n\n    heat_control_Id : Art.PortId,\n    heat_out_Id : Art.PortId,\n\n    dispatchTriggers : Option[ISZ[Art.PortId]],\n\n    initialization_api: Heat_Source_impl_Initialization_Api,\n    operational_api: Heat_Source_impl_Operational_Api) extends Bridge.EntryPoints {\n\n    val dataInPortIds: ISZ[Art.PortId] = ISZ(heat_control_Id)\n\n    val eventInPortIds: ISZ[Art.PortId] = ISZ()\n\n    val dataOutPortIds: ISZ[Art.PortId] = ISZ(heat_out_Id)\n\n    val eventOutPortIds: ISZ[Art.PortId] = ISZ()\n\n    def compute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    override\n    def testCompute(): Unit = {\n      Art.receiveInput(eventInPortIds, dataInPortIds)\n      component.timeTriggered(operational_api)\n      Art.releaseOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def activate(): Unit = {\n      component.activate(operational_api)\n    }\n\n    def deactivate(): Unit = {\n      component.deactivate(operational_api)\n    }\n\n    def finalise(): Unit = {\n      component.finalise(operational_api)\n    }\n\n    def initialise(): Unit = {\n      component.initialise(initialization_api)\n      Art.sendOutput(eventOutPortIds, dataOutPortIds)\n    }\n\n    def recover(): Unit = {\n      component.recover(operational_api)\n    }\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/bridge\/isolette__JVM\/Devices\/Heat_Source_impl_Api.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport art._\nimport isolette__JVM._\n\n@sig trait Heat_Source_impl_Api {\n  def id: Art.BridgeId\n  def heat_control_Id : Art.PortId\n  def heat_out_Id : Art.PortId\n\n  def setheat_out(value : Isolette_Environment.Heat.Type) : Unit = {\n    Art.putValue(heat_out_Id, Isolette_Environment.Heat_Payload(value))\n  }\n\n  def logInfo(msg: String): Unit = {\n    Art.logInfo(id, msg)\n  }\n\n  def logDebug(msg: String): Unit = {\n    Art.logDebug(id, msg)\n  }\n\n  def logError(msg: String): Unit = {\n    Art.logError(id, msg)\n  }\n}\n\n@datatype class Heat_Source_impl_Initialization_Api (\n  val id: Art.BridgeId,\n  val heat_control_Id : Art.PortId,\n  val heat_out_Id : Art.PortId) extends Heat_Source_impl_Api\n\n@datatype class Heat_Source_impl_Operational_Api (\n  val id: Art.BridgeId,\n  val heat_control_Id : Art.PortId,\n  val heat_out_Id : Art.PortId) extends Heat_Source_impl_Api {\n\n  def getheat_control() : Option[Isolette_Data_Model.On_Off.Type] = {\n    val value : Option[Isolette_Data_Model.On_Off.Type] = Art.getValue(heat_control_Id) match {\n      case Some(Isolette_Data_Model.On_Off_Payload(v)) => Some(v)\n      case Some(v) =>\n        Art.logError(id, s\"Unexpected payload on port heat_control.  Expecting 'Isolette_Data_Model.On_Off_Payload' but received ${v}\")\n        None[Isolette_Data_Model.On_Off.Type]()\n      case _ => None[Isolette_Data_Model.On_Off.Type]()\n    }\n    return value\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/component\/isolette__JVM\/Devices\/Heat_Source_impl_heat_source_cpi_heat_controller.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage isolette__JVM.Devices\n\nimport org.sireum._\nimport isolette__JVM._\n\n\/\/ This file will not be overwritten so is safe to edit\nobject Heat_Source_impl_heat_source_cpi_heat_controller {\n\n  def initialise(api: Heat_Source_impl_Initialization_Api): Unit = {\n    \/\/ example api usage\n\n    api.logInfo(\"Example info logging\")\n    api.logDebug(\"Example debug logging\")\n    api.logError(\"Example error logging\")\n\n    api.setheat_out(Isolette_Environment.Heat.byOrdinal(0).get)\n  }\n\n  def timeTriggered(api: Heat_Source_impl_Operational_Api): Unit = {\n    \/\/ example api usage\n\n    val apiUsage_heat_control: Option[Isolette_Data_Model.On_Off.Type] = api.getheat_control()\n    api.logInfo(s\"Received on heat_control: ${apiUsage_heat_control}\")\n  }\n\n  def activate(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def deactivate(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def finalise(api: Heat_Source_impl_Operational_Api): Unit = { }\n\n  def recover(api: Heat_Source_impl_Operational_Api): Unit = { }\n}\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtTimer_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum.{B, F, ISZ, String, T}\nimport art.Art.{BridgeId, Time}\n\nimport scala.collection.mutable.{Map => MMap}\nimport java.util.concurrent.atomic.AtomicBoolean\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\n\nobject ArtTimer_Ext {\n\n  val m: MMap[String, AtomicBoolean] = ArtNative_Ext.concMap()\n  val executor = Executors.newSingleThreadScheduledExecutor()\n\n  def finalise(): Unit = {\n    executor.shutdownNow()\n    ArtNative.logInfo(Art.logTitle, \"Finalized ArtTimer\")\n  }\n\n  def clearTimeout(eventId: String): Unit = {\n    m.get(eventId) match {\n      case Some(b) =>\n        b.set(false)\n        m.remove(eventId)\n        ArtNative.logInfo(Art.logTitle, s\"timeout cleared for $eventId\")\n      case _ =>\n    }\n  }\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = {\n    if(m.get(eventId).nonEmpty) {\n      art.Art.logError(bridgeId, s\"callback already set for $eventId\")\n      return\n    }\n\n    if(wait < 0) {\n      art.Art.logError(bridgeId, s\"Invalid wait time: ${wait}.  Value must be non-negative.\")\n      return\n    }\n\n    var b = new AtomicBoolean(true)\n\n    val bridge = Art.bridge(bridgeId)\n    val eventOuts = bridge.ports.eventOuts.map(_.id)\n    val dataOuts = bridge.ports.dataOuts.map(_.id)\n\n    val task = new Runnable {\n      override def run(): Unit = {\n        if (b.get()) {\n          bridge.synchronized {\n            callback()\n            Art.sendOutput(eventOuts, dataOuts)\n            if(autoClear) {\n              clearTimeout(eventId)\n            }\n          }\n        }\n      }\n    }\n\n    m.put(eventId, b)\n\n    val adjusted = wait.toMP.toLong * ArtNative_Ext.slowdown.toMP.toLong\n    executor.schedule(task, adjusted, TimeUnit.MILLISECONDS)\n\n    art.Art.logInfo(bridgeId, s\"callback set for $eventId\")\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArchitectureDescription.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n\n@record class ArchitectureDescription(components: MSZ[Bridge],\n                                      connections: ISZ[UConnection]) {\n  @spec val allPorts: ISZ[UPort] = $\n\n  @spec def allPortsSpec(i: Z): ISZ[UPort] = $\n  \/*\n    l\"\"\"\n    = base:  ISZ[UPort](), if i == 0\n    = rec:   components(i).ports.all ++ allPorts(i - 1), if 0 < i \u2227 i < components.size\n  \"\"\"\n\n  l\"\"\" invariant\n\n         AllPorts:\n           allPorts \u2261 allPortsSpec(components.size - 1)\n\n         ComponentIdUnique:\n           \u2200i: [0, components.size)\n             \u2200j: [0, components.size)\n               i \u2260 j \u2192 components(i).id \u2260 components(j).id\n\n         PortIdUnique:\n           \u2200i: [0, allPorts.size)\n             \u2200j: [0, allPorts.size)\n               i \u2260 j \u2192 allPorts(i).id \u2260 allPorts(j).id\n   \"\"\"\n  *\/\n}\n\n@datatype trait UConnection {\n  \/*\n  l\"\"\" invariant\n         FromPortOut:   from.mode \u2261 PortMode.DataOut \u2228 from.mode \u2261 PortMode.EventOut\n         DataPort:    (from.mode \u2261 PortMode.DataOut) \u2261 (to.mode \u2261 PortMode.DataIn)\n         EventPort:  (from.mode \u2261 PortMode.EventOut) \u2261 (to.mode \u2261 PortMode.EventIn)  \"\"\"\n  *\/\n\n  def from: UPort\n\n  def to: UPort\n}\n\n@datatype class Connection(val from: UPort, val to: UPort)\n  extends UConnection\n\n\n@enum object PortMode {\n  'DataIn\n  'DataOut\n  'EventIn\n  'EventOut\n}\n\n@datatype trait UPort {\n  def id: Art.PortId\n\n  def name: String\n\n  def mode: PortMode.Type\n}\n\n@datatype class Port[T](val id: Art.PortId,\n                        val name: String,\n                        val mode: PortMode.Type)\n  extends UPort\n\n@datatype class UrgentPort[T](val id: Art.PortId,\n                              val name: String,\n                              val mode: PortMode.Type,\n                              val urgency: Z)\n  extends UPort\n\n@msig trait Bridge {\n  def id: Art.BridgeId\n\n  def name: String\n\n  def ports: Bridge.Ports\n\n  def entryPoints: Bridge.EntryPoints\n\n  def dispatchProtocol: DispatchPropertyProtocol\n}\n\n\nobject Bridge {\n\n  \/\/ initialise()  ( compute() | activate() deactivate() | recover() )* finalise()\n  @msig trait EntryPoints {\n\n    def initialise(): Unit\n\n    def activate(): Unit\n\n    def deactivate(): Unit\n\n    def compute(): Unit\n\n    def recover(): Unit\n\n    def finalise(): Unit\n\n    def testCompute(): Unit = { println(\"Default testCompute\") }\n  }\n\n  @datatype class Ports(all: ISZ[UPort],\n                        dataIns: ISZ[UPort],\n                        dataOuts: ISZ[UPort],\n                        eventIns: ISZ[UPort],\n                        eventOuts: ISZ[UPort])\n\n}\n\n\n@datatype trait DispatchPropertyProtocol\n\nobject DispatchPropertyProtocol {\n\n  @datatype class Periodic(period: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Aperiodic() extends DispatchPropertyProtocol\n\n  @datatype class Sporadic(min: Z) extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Timed() extends DispatchPropertyProtocol\n\n  \/\/ @datatype class Hybrid() extends DispatchPropertyProtocol\n}\n\n@datatype trait DispatchStatus\n\n@datatype class TimeTriggered() extends DispatchStatus\n\n@datatype class EventTriggered(portIds: ISZ[Art.PortId]) extends DispatchStatus",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/Art.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\nobject Art {\n  type PortId = Z\n  type BridgeId = Z\n  type Time = Z\n\n  val z16max: PortId = org.sireum.conversions.Z16.toZ(Z16.Max) \/\/ 32,767\n\n  val maxComponents: BridgeId = 9\n  val maxPorts: PortId = 47\n\n  val logTitle: String = \"Art\"\n  val bridges: MS[BridgeId, MOption[Bridge]] = MS.create[BridgeId, MOption[Bridge]](maxComponents, MNone[Bridge]())\n  val connections: MS[PortId, ISZ[PortId]] = MS.create[PortId, ISZ[PortId]](maxPorts, ISZ())\n  val ports: MS[PortId, Option[UPort]] = MS.create[PortId, Option[UPort]](maxPorts, None[UPort]())\n\n  def bridge(bridgeId: BridgeId): Bridge = {\n    val MSome(r) = bridges(bridgeId)\n    return r\n  }\n\n  def port(p: PortId) : UPort = {\n    val Some(r) = ports(p)\n    return r\n  }\n\n  def register(bridge: Bridge): Unit = {\n    bridges(bridge.id) = MSome(bridge)\n    bridge.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(period) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (periodic: $period)\")\n      case DispatchPropertyProtocol.Sporadic(min) =>\n        ArtNative.logInfo(logTitle, s\"Registered component: ${bridge.name} (sporadic: $min)\")\n    }\n    for (port <- bridge.ports.all) {\n      ports(port.id) = Some(port)\n      port.mode match {\n        case PortMode.DataIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data in)\")\n        case PortMode.DataOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (data out)\")\n        case PortMode.EventIn => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event in)\")\n        case PortMode.EventOut => ArtNative.logInfo(logTitle, s\"- Registered port: ${port.name} (event out)\")\n      }\n    }\n  }\n\n  \/\/ can't find definition in the standard ??\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = { \/\/ DISPATCH_STATUS\n    return ArtNative.dispatchStatus(bridgeId)\n  }\n\n  def receiveInput(eventPortIds: ISZ[PortId], dataPortIds: ISZ[PortId]): Unit = { \/\/ RECEIVE_INPUT\n    ArtNative.receiveInput(eventPortIds, dataPortIds)\n  }\n\n  def putValue(portId: PortId, data: DataContent): Unit = { \/\/ PUT_VALUE\n    ArtNative.putValue(portId, data)\n  }\n\n  def getValue(portId: PortId): Option[DataContent] = { \/\/ GET_VALUE\n    return ArtNative.getValue(portId)\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    ArtNative.sendOutput(eventPortIds, dataPortIds)\n  }\n\n  def logInfo(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logInfo(bridge(bridgeId).name, msg)\n  }\n\n  def logError(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logError(bridge(bridgeId).name, msg)\n  }\n\n  def logDebug(bridgeId: Art.BridgeId, msg: String): Unit = {\n    ArtNative.logDebug(bridge(bridgeId).name, msg)\n  }\n\n  def connect(from: UPort, to: UPort): Unit = {\n    connections(from.id) = connections(from.id) :+ to.id\n    ArtNative.logInfo(logTitle, s\"Connected ports: ${from.name} -> ${to.name}\")\n  }\n\n  def run(system: ArchitectureDescription): Unit = {\n\n    for (component <- system.components) {\n      register(component)\n    }\n\n    for (connection <- system.connections) {\n      connect(connection.from, connection.to)\n    }\n\n    ArtNative.run()\n  }\n\n  def time(): Time = {\n    return ArtNative.time()\n  }\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Clears any existing ports and bridges, then sets up ports\/bridges for the next test.\n   *\n   * Automatically called by BridgeTestSuite before each test.\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ remove all bridges\n    for (i <- bridges.indices) {\n      bridges(i) = MNone()\n    }\n\n    \/\/ remove all ports\n    for (i <- ports.indices) {\n      ports(i) = None()\n    }\n\n    \/\/ register bridge passed to this method\n    register(bridge)\n\n    \/\/ let ArtNative reset itself as well\n    ArtNative.initTest(bridge)\n  }\n\n  def executeTest(bridge: Bridge): Unit = {\n    ArtNative.executeTest(bridge)\n  }\n\n  def finalizeTest(bridge: Bridge): Unit = {\n    ArtNative.finalizeTest(bridge)\n  }\n\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    ArtNative.releaseOutput(eventPortIds, dataPortIds)\n  }\n\n  def manuallyClearOutput(): Unit = {\n    ArtNative.manuallyClearOutput()\n  }\n\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    ArtNative.insertInPortValue(dstPortId, data)\n  }\n\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    ArtNative.observeOutPortValue(portId)\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtNative_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\n\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicBoolean\n\n\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtMessage {\n  val UNSET: Z = -1\n}\n\ncase class ArtMessage (data: DataContent,\n\n                       var srcPortId: Art.PortId = ArtMessage.UNSET,\n                       var dstPortId: Art.PortId = ArtMessage.UNSET,\n\n                       \/\/ when putValue was called by producer\n                       var putValueTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when sendOutput transferred message from out port var of producer \n                       var sendOutputTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when message arrived via transport layer\n                       var dstArrivalTimestamp: Z = ArtMessage.UNSET,\n\n                       \/\/ when receiveInput transferred message to in port vars of consumer\n                       var receiveInputTimestamp: Z = ArtMessage.UNSET\n                      )\n\nobject ArtNative_Ext {\n  val noTime: Art.Time = 0\n\n  val slowdown: Z = 1\n\n  val lastSporadic: MMap[Art.BridgeId, Art.Time] = concMap()\n  val eventPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val dataPortVariables: MMap[Art.PortId, ArtMessage] = concMap()\n  val receivedPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n  val sentPortValues: MMap[Art.PortId, ArtMessage] = concMap()\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = {\n    val portIds = ISZ[Art.PortId](Art.bridge(bridgeId).ports.eventIns.elements.map(_.id).filter(eventPortVariables.get(_).nonEmpty): _*)\n    if (portIds.isEmpty) {\n      TimeTriggered()\n    } else {\n      val urgentFifo = ops.ISZOps(portIds.map(Art.port(_))).sortWith { \/\/ reverse sort\n        case (p1: UrgentPort[_], p2: UrgentPort[_]) =>\n          if(p1.urgency < p2.urgency) F\n          else if(p1.urgency > p2.urgency) T\n          else eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n        case (_: UrgentPort[_], _: Port[_]) => T \/\/ urgent ports take precedence\n        case (_: Port[_], _: UrgentPort[_]) => F \/\/ urgent ports take precedence\n        case (p1: Port[_], p2: Port[_]) =>\n          eventPortVariables(p1.id).dstArrivalTimestamp < eventPortVariables(p2.id).dstArrivalTimestamp\n      }.map(_.id)\n      EventTriggered(urgentFifo)\n    }\n  }\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = {\n    for (portId <- eventPortIds) {\n      receivedPortValues -= portId \/\/ remove stale events from previous dispatch\n      eventPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          eventPortVariables -= portId\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n    for (portId <- dataPortIds) {\n      dataPortVariables.get(portId) match {\n        case scala.Some(data) =>\n          receivedPortValues(portId) = data\n        case _ =>\n      }\n    }\n  }\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = {\n    sentPortValues(portId) = ArtMessage(data = data, srcPortId = portId, putValueTimestamp = Art.time())\n  }\n\n  def getValue(portId: Art.PortId): Option[DataContent] = {\n    val data = receivedPortValues.get(portId) match {\n      case scala.Some(v) => org.sireum.Some(v.data)\n      case _ => org.sireum.None[DataContent]()\n    }\n    return data\n  }\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ SEND_OUTPUT\n    for (srcPortId <- eventPortIds ++ dataPortIds) {\n      sentPortValues.get(srcPortId) match {\n        case scala.Some(msg) =>\n          \/\/ todo send on emission as well as receive\n          for(dstPortId <- Art.connections(srcPortId).elements) {\n\n            \/\/ simulate sending msg via transport middleware\n\n            val _msg = msg.copy(dstPortId = dstPortId, sendOutputTimestamp = Art.time())\n\n            Art.port(dstPortId).mode match {\n              case PortMode.DataIn | PortMode.DataOut =>\n                dataPortVariables(dstPortId) = _msg\n              case PortMode.EventIn | PortMode.EventOut =>\n                eventPortVariables(dstPortId) = _msg\n            }\n\n            _msg.dstArrivalTimestamp = Art.time()\n\n            ArtDebug_Ext.outputCallback(srcPortId, dstPortId, _msg.data, _msg.dstArrivalTimestamp)\n          }\n          sentPortValues -= srcPortId\n        case _ =>\n      }\n    }\n  }\n\n  def logInfo(title: String, msg: String): Unit = log(\"info\", title, msg)\n\n  def logError(title: String, msg: String): Unit = log(\"error\", title, msg)\n\n  def logDebug(title: String, msg: String): Unit = log(\"debug\", title, msg)\n\n  def time(): Art.Time = toZ(System.currentTimeMillis())\n\n  def shouldDispatch(bridgeId: Art.BridgeId): B = {\n    val b = Art.bridge(bridgeId)\n    b.dispatchProtocol match {\n      case DispatchPropertyProtocol.Periodic(_) => return T\n      case DispatchPropertyProtocol.Sporadic(minRate) =>\n        val ls = lastSporadic.getOrElse(bridgeId, noTime)\n        if (time() - ls < minRate) {\n          return F\n        } else {\n          return b.ports.eventIns.elements.exists(port => eventPortVariables.contains(port.id))\n        }\n    }\n  }\n\n  def run(): Unit = {\n    \/\/require(Art.bridges.elements.forall(_.nonEmpty))\n\n    ArtDebug_Ext.start()\n\n    val bridges = {\n      var r = Vector[Bridge]()\n      for (e <- Art.bridges.elements) e match {\n        case MSome(b) => r :+= b\n        case _ =>\n      }\n      r\n    }\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.initialise()\n      logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n    }\n\n    val terminated = new AtomicBoolean()\n    val numTerminated = new CountDownLatch(bridges.size)\n\n    for (bridge <- bridges) {\n      val rate = bridge.dispatchProtocol match {\n        case DispatchPropertyProtocol.Periodic(period) => period\n        case DispatchPropertyProtocol.Sporadic(min) => min\n      }\n\n      new Thread(() => {\n        logInfo(Art.logTitle, s\"Thread for ${bridge.name} instantiated.\")\n        ArtNative_Ext.synchronized {\n          ArtNative_Ext.wait()\n        }\n        while (!terminated.get()) {\n          Thread.sleep((rate * slowdown).toMP.toLong)\n          if (shouldDispatch(bridge.id))\n            try {\n              bridge.synchronized {\n                bridge.entryPoints.compute()\n              }\n            }\n            catch {\n              case x : Throwable =>\n                x.printStackTrace()\n                terminated.set(true)\n            }\n        }\n        numTerminated.countDown()\n      }).start()\n    }\n\n    Thread.sleep(1000)\n\n    logInfo(Art.logTitle, s\"Start execution (press Enter twice to terminate) ...\")\n\n    ArtNative_Ext.synchronized {\n      ArtNative_Ext.notifyAll()\n    }\n\n    Console.in.readLine()\n    terminated.set(true)\n    numTerminated.await()\n    logInfo(Art.logTitle, s\"End execution...\")\n\n    for (bridge <- bridges) {\n      bridge.entryPoints.finalise()\n      logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n    }\n\n    ArtTimer_Ext.finalise()\n    ArtDebug_Ext.stop()\n  }\n\n  def log(kind: String, title: String, msg: String): Unit = {\n    Console.out.println(s\"\"\"{ \"log\" : \"$kind\", \"title\" : ${escape(title)}, \"msg\" : ${escape(msg)}, \"time\" : \"${time()}\" }\"\"\")\n    Console.out.flush()\n  }\n\n  def escape(raw: String): String = {\n    import scala.reflect.runtime.universe._\n    Literal(Constant(raw.value)).toString\n  }\n\n  def toZ(value: Long): Z = Z(value)\n\n  def concMap[K, V](): MMap[K, V] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    new java.util.concurrent.ConcurrentHashMap[K, V].asInstanceOf[java.util.Map[K, V]].asScala\n  }\n\n\n\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges AND resets all inputs and outputs for all ports.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = {\n    \/\/ note that all ports and bridges were deleted by Art's initTest\n\n    \/\/ delete ALL port values as well as lastSporadic tracker\n    lastSporadic.clear()\n    eventPortVariables.clear()\n    dataPortVariables.clear()\n    receivedPortValues.clear()\n    sentPortValues.clear()\n\n    \/\/ clear pending ArtTimer events (also done after a test completes)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n\n    bridge.entryPoints.initialise()\n    logInfo(Art.logTitle, s\"Initialized bridge: ${bridge.name}\")\n  }\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.testCompute()\n  }\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = {\n    bridge.entryPoints.finalise()\n    logInfo(Art.logTitle, s\"Finalized bridge: ${bridge.name}\")\n\n    \/\/ clear pending ArtTimer events (also done before a test begins)\n    ArtTimer_Ext.m.keys.foreach(ArtTimer_Ext.clearTimeout)\n  }\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = { \/\/ testing SEND_OUTPUT\n    \/\/ note: sendOutput is usually accessed via: Art.sendOutput -> ArtNative.sendOutput -> ArtNative_Ext.sendOutput\n    \/\/ NO OP\n  }\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = {\n    sentPortValues.clear()\n  }\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    val artMessage = ArtMessage(data = data, dstPortId = dstPortId, dstArrivalTimestamp = Art.time())\n    Art.port(dstPortId).mode match {\n      case PortMode.DataIn | PortMode.DataOut =>\n        dataPortVariables(dstPortId) = artMessage\n      case PortMode.EventIn | PortMode.EventOut =>\n        eventPortVariables(dstPortId) = artMessage\n    }\n  }\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = {\n    \/\/ note: that could would be changed when we refactor to support event queues of size > 1\n    sentPortValues.get(portId) match {\n      case scala.Some(value: ArtMessage) => org.sireum.Some[DataContent](value.data)\n      case scala.None => org.sireum.None[DataContent]()\n    }\n  }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/DataContent.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@sig trait DataContent\n\n@datatype class Empty extends art.DataContent",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtTimer.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\nimport art.Art.BridgeId\n\n@ext object ArtTimer {\n\n  def setTimeout(bridgeId: BridgeId, eventId: String, wait: Art.Time, autoClear: B, callback: () => Unit): Unit = $\n\n  def clearTimeout(eventId: String): Unit = $\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtDebug.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtDebug {\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = $\n\n  def registerListener(listener: ArtListener): Unit = $\n\n  def setDebugObject[T](key: String, o: T): Unit = $\n\n  def getDebugObject[T](key: String): Option[T] = $\n}\n\n@msig trait ArtListener {\n\n  \/\/ lifecycle information\n  def start(time: Art.Time): Unit\n  def stop(time: Art.Time): Unit\n\n  \/\/ communication information\n  def output(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Art.Time): Unit\n\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtDebug_Ext.scala",
        {
          "type" : "TestResource",
          "content" : "package art\n\nimport org.sireum._\nimport art.Art.Time\nimport scala.collection.mutable.{Map => MMap, Set => MSet}\n\nobject ArtDebug_Ext {\n  private val debugObjects: MMap[String, Any] = ArtNative_Ext.concMap()\n  private val listeners: MSet[ArtListener] = concSet()\n\n  protected[art] def start(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.start(time))\n  }\n\n  protected[art] def stop(): Unit = {\n    val time = Art.time()\n    listeners.foreach((listener: ArtListener) => listener.stop(time))\n  }\n\n  protected[art] def outputCallback(src: Art.PortId, dst: Art.PortId, data: DataContent, time: Time): Unit = {\n    listeners.foreach((listener: ArtListener) => listener.output(src, dst, data, time))\n  }\n\n  def setDebugObject[T](key: String, o: T): Unit = {\n    ArtNative.logDebug(Art.logTitle, s\"Set debug object for $key\")\n    debugObjects(key) = o\n  }\n\n  def getDebugObject[T](key: String): Option[T] = {\n    debugObjects.get(key) match {\n      case scala.Some(o) => Some(o.asInstanceOf[T])\n      case _ => None[T]()\n    }\n  }\n\n  def injectPort(bridgeId: Art.BridgeId, port: Art.PortId, data: DataContent): Unit = {\n    assert(z\"0\" <= bridgeId && bridgeId < Art.maxComponents && Art.bridges(bridgeId).nonEmpty)\n\n    val bridge = Art.bridges(bridgeId).get\n    assert(bridge.ports.all.elements.map(_.id).contains(port))\n\n    if(bridge.ports.dataOuts.elements.map(_.id).contains(port) ||\n      bridge.ports.eventOuts.elements.map(_.id).contains(port)) {\n\n      ArtNative.logDebug(Art.logTitle, s\"Injecting from port ${Art.ports(port).get.name}\")\n\n      ArtNative.putValue(port, data)\n      ArtNative.sendOutput(bridge.ports.eventOuts.map(_.id), bridge.ports.dataOuts.map(_.id))\n    } else {\n      ArtNative.logDebug(Art.logTitle, s\"Injecting to port ${Art.ports(port).get.name}\")\n\n      if(bridge.ports.dataIns.elements.map(_.id).contains(port)) {\n        ArtNative_Ext.dataPortVariables(port) = ArtMessage(data)\n      } else {\n        ArtNative_Ext.eventPortVariables(port) = ArtMessage(data)\n      }\n    }\n  }\n\n  def registerListener(listener: ArtListener): Unit = {\n    listeners.add(listener)\n  }\n\n  def concSet[K](): MSet[K] = {\n    import org.sireum.$internal.CollectionCompat.Converters._\n    val m: java.util.Set[K] = java.util.concurrent.ConcurrentHashMap.newKeySet()\n    m.asScala\n  }\n}",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/src\/main\/art\/ArtNative.scala",
        {
          "type" : "TestResource",
          "content" : "\/\/ #Sireum\n\npackage art\n\nimport org.sireum._\n\n@ext object ArtNative {\n\n  def dispatchStatus(bridgeId: Art.BridgeId): DispatchStatus = $\n\n  def receiveInput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def putValue(portId: Art.PortId, data: DataContent): Unit = $\n\n  def getValue(portId: Art.PortId): Option[DataContent] = $\n\n  def sendOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  def logInfo(title: String, msg: String): Unit = $\n\n  def logError(title: String, msg: String): Unit = $\n\n  def logDebug(title: String, msg: String): Unit = $\n\n  def run(): Unit = $\n\n  def time(): Art.Time = $\n\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n  \/\/ TESTING \/\/\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/**\n   * Calls the initialize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method before each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def initTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Precondition: executeInit() has been called prior.\n   *\n   * Executes the testCompute() method one time for each registered bridge.\n   *\n   * Unlike [[Art.run()]], this method does NOT wrap compute calls in a try-catch block.\n   * This is to ensure no exceptions are overlooked during testing.\n   *\/\n  def executeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * Calls the finalize entry points on all registered bridges.\n   * Testers should NOT call this method because BridgeTestSuite will automatically call this method after each test.\n   *\n   * (note: BridgeTestSuite exists only in the test scope)\n   *\/\n  def finalizeTest(bridge: Bridge): Unit = $\n\n  \/**\n   * A method that replaces bridge.compute()'s calls to [[Art.sendOutput()]] in its equivalent testCompute() method.\n   *\n   * This method is currently a NO-OP, but may gain functionality later.\n   *\n   * @param eventPortIds the event ports to be \"copied and cleared\" (but currently nothing happens)\n   * @param dataPortIds the data ports to be \"copied and cleared\" (but currently nothing happens)\n   *\/\n  def releaseOutput(eventPortIds: ISZ[Art.PortId], dataPortIds: ISZ[Art.PortId]): Unit = $\n\n  \/**\n   * Because a bridge's testCompute() doesn't clear outputs, this method can be used by users to manually\n   * clear the output if desired. This is useful for tests involving multiple dispatches.\n   *\/\n  def manuallyClearOutput(): Unit = $\n\n  \/**\n   * Inserts a value into an \"infrastructure in\" port. For testing only, normally this is handled by Art.\n   *\n   * @param dstPortId the portId to place the passed [[DataContent]] into\n   * @param data the [[DataContent]] which will be placed in the dstPort\n   *\/\n  def insertInPortValue(dstPortId: Art.PortId, data: DataContent): Unit = $\n\n  \/**\n   * Returns the value of an out port.\n   *\n   * @param portId the id of the OUTPUT port to return a value from\n   * @return If the port is non-empty, a [[Some]] of [[DataContent]]. Otherwise [[None]].\n   *\/\n  def observeOutPortValue(portId: Art.PortId): Option[DataContent] = $\n\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/build.sc",
        {
          "type" : "TestResource",
          "content" : "import mill._\nimport scalalib._\n\n\/\/ Example mill build -- the contents of this file will not be overwritten\n\/\/\n\/\/ mill is included with Sireum Kekinian: https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/ To open the following project in VSCode, first follow Sireum Kekinian's\n\/\/ instructions for setting up a development environment using Scala Metals:\n\/\/ https:\/\/github.com\/sireum\/kekinian#scala-metals\n\/\/\n\/\/ Then open the folder containing this file in VSCode and import the\n\/\/ mill build when asked.\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   $SIREUM_HOME\/bin\/mill isolette__JVM.run\n\/\/\n\/\/ To run the example unit tests:\n\/\/   $SIRUEM_HOME\/bin\/mill isolette__JVM.test\n\ntrait SlangEmbeddedModule extends ScalaModule {\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n  \/\/ to get the most recent versions of the following dependencies\n\n  \/\/ versions.properties key: org.sireum.version.scala\n  val scalaVer = \"2.13.3\"\n\n  \/\/ versions.properties key: org.sireum.version.scalatest\n  val scalaTestVersion = \"3.2.3\"\n\n  \/\/ versions.properties key: org.sireum.version.scalac-plugin\n  \/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20201221.73c7e64\n  val sireumScalacVersion = \"4.20201221.73c7e64\"\n\n\n  \/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n  \/\/ Sireum Kekinian release\n  \/\/ https:\/\/github.com\/sireum\/kekinian\/tree\/4.20201221.b159c6f\n  val kekinianVersion = \"4.20201221.b159c6f\"\n\n\n  val inspectorVersion = \"0.6-SNAPSHOT\"\n\n  val formsRtVersion = \"7.0.3\"\n\n\n\n  def scalaVersion = scalaVer\n\n  override def javacOptions = T { Seq(\"-source\", \"1.8\", \"-target\", \"1.8\", \"-encoding\", \"utf8\") }\n\n  override def scalacOptions = T { Seq(\n    \"-target:jvm-1.8\",\n    \"-deprecation\",\n    \"-Yrangepos\",\n    \"-Ydelambdafy:method\",\n    \"-feature\",\n    \"-unchecked\",\n    \"-Xfatal-warnings\",\n    \"-language:postfixOps\"\n  ) }\n\n  override def ivyDeps = Agg(ivy\"org.sireum.kekinian::library::${kekinianVersion}\")\n\n  override def scalacPluginIvyDeps = Agg(ivy\"org.sireum::scalac-plugin::${sireumScalacVersion}\")\n\n  override def repositories = super.repositories ++ Seq(\n    coursier.maven.MavenRepository(\"https:\/\/jitpack.io\/\"),\n  )\n}\n\ntrait AadlModule extends SlangEmbeddedModule {\n  override def sources = T.sources (\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"architecture\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"art\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"bridge\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"component\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"data\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"nix\",\n    millSourcePath \/ os.up \/ \"src\" \/ \"main\" \/ \"seL4Nix\"\n  )\n}\n\ntrait AadlTestModule extends AadlModule {\n  object test extends Tests {\n\n    final override def millSourcePath =\n      super.millSourcePath \/ os.up \/ os.up \/ \"src\" \/ \"test\"\n\n    override def sources = T.sources(\n      millSourcePath \/ \"bridge\",\n      millSourcePath \/ \"util\"\n    )\n\n    override def ivyDeps = Agg(ivy\"org.scalatest::scalatest::${scalaTestVersion}\")\n\n    override def testFrameworks = T { Seq(\"org.scalatest.tools.Framework\") }\n  }\n}\n\nobject `isolette__JVM` extends AadlTestModule {\n  override def mainClass = T { Some(\"isolette__JVM.Demo\") }\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/build.sbt",
        {
          "type" : "TestResource",
          "content" : "\/\/ Example sbt build definitions -- the contents of this file will not be overwritten\n\/\/\n\/\/ To open the following project in Sireum IVE select 'File > Open ...' and\n\/\/ navigate to the directory containing this file then click 'OK'.  To install\n\/\/ Sireum IVE see https:\/\/github.com\/sireum\/kekinian#installing\n\/\/\n\/\/ To run the demo from within Sireum IVE:\n\/\/   Right click src\/main\/architecture\/isolette__JVM\/Demo.scala and choose \"Run 'Demo'\"\n\/\/\n\/\/ To run the unit test cases from within Sireum IVE:\n\/\/   Right click the src\/test\/bridge directory and choose \"Run ScalaTests in bridge\"\n\/\/\n\/\/ NOTE: A ClassNotFoundException may be raised the first time you try to\n\/\/       run the demo or unit tests.  If this occurs simply delete the directory\n\/\/       named 'target' and retry\n\/\/\n\/\/ To run the demo from the command line:\n\/\/   sbt run\n\/\/\n\/\/ To run the example unit tests from the command line:\n\/\/   sbt test\n\/\/\n\/\/ To build a runnable\/executable jar:\n\/\/   sbt assembly\n\/\/\n\/\/ To skip running the unit tests while building the executable jar:\n\/\/   sbt 'set test in assembly := {}' assembly\n\/\/ on Linux\/Mac, or\n\/\/   sbt \"set test in assembly := {}\" assembly\n\/\/ on Windows\n\/\/\n\/\/ sbt can be obtained from https:\/\/www.scala-sbt.org\/download.html\n\nlazy val isolette_single_sensor_Instance = slangEmbeddedTestProject(\"isolette_single_sensor_Instance\", \".\")\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/blob\/master\/versions.properties\n\/\/ to get the most recent versions of the following dependencies\n\n\/\/ versions.properties key: org.sireum.version.scala\nval scalaVer = \"2.13.3\"\n\n\/\/ versions.properties key: org.sireum.version.scalatest\nval scalaTestVersion = \"3.2.3\"\n\n\/\/ versions.properties key: org.sireum.version.scalac-plugin\n\/\/ https:\/\/github.com\/sireum\/scalac-plugin\/tree\/4.20201221.73c7e64\nval sireumScalacVersion = \"4.20201221.73c7e64\"\n\n\n\/\/ refer to https:\/\/github.com\/sireum\/kekinian\/releases to get the latest\n\/\/ Sireum Kekinian release\n\/\/ https:\/\/github.com\/sireum\/kekinian\/tree\/4.20201221.b159c6f\nval kekinianVersion = \"4.20201221.b159c6f\"\n\n\nval inspectorVersion = \"0.6-SNAPSHOT\"\n\nval formsRtVersion = \"7.0.3\"\n\n\n\nval commonSettings = Seq(\n  organization := \"org.sireum\",\n  incOptions := incOptions.value.withLogRecompileOnMacro(false),\n  scalaVersion := scalaVer,\n  scalacOptions := Seq(\"-target:jvm-1.8\", \"-deprecation\",\n    \"-Ydelambdafy:method\", \"-feature\", \"-unchecked\", \"-Xfatal-warnings\"),\n  Test \/ parallelExecution := true,\n  resolvers ++= Seq(Resolver.sonatypeRepo(\"public\"), \"jitpack\" at \"https:\/\/jitpack.io\"),\n  addCompilerPlugin(\"org.sireum\" %% \"scalac-plugin\" % sireumScalacVersion),\n  libraryDependencies ++= Seq(\n    \"org.sireum.kekinian\" %% \"library\" % kekinianVersion withSources() withJavadoc()\n  )\n)\n\nimport sbtassembly.AssemblyPlugin.defaultUniversalScript\nval slangEmbeddedSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/art\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/architecture\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/bridge\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/component\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/data\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/nix\",\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/seL4Nix\",\n\n  mainClass in (Compile, run) := Some(\"isolette__JVM.Demo\"),\n\n  mainClass in assembly := Some(\"isolette__JVM.Demo\"),\n  assemblyJarName in assembly := \"isolette_single_sensor_Instance.jar\",\n  assemblyOption in assembly := (assemblyOption in assembly).value.copy(prependShellScript = Some(defaultUniversalScript(shebang = false))),\n\n  assemblyMergeStrategy in assembly := {\n    case PathList(\"META-INF\", xs @ _*) => MergeStrategy.discard\n    case x => MergeStrategy.first\n  }\n)\n\nval slangEmbeddedTestSettings = Seq(\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/bridge\",\n  Compile \/ unmanagedSourceDirectories in Test += baseDirectory.value \/ \"src\/test\/util\",\n\n  libraryDependencies += \"org.scalatest\" %% \"scalatest\" % scalaTestVersion % \"test\",\n\n  \/\/ Jetbrains UI Designer\n  libraryDependencies += \"com.intellij\" % \"forms_rt\" % formsRtVersion withSources() withJavadoc(),\n)\n\nval slangEmbeddedInspectorSettings = Seq(\n  Compile \/ unmanagedSourceDirectories += baseDirectory.value \/ \"src\/main\/inspector\",\n\n  libraryDependencies += \"org.sireum\" % \"inspector-capabilities\" % inspectorVersion withSources() withJavadoc(),\n  libraryDependencies += \"org.sireum\" % \"inspector-gui\" % inspectorVersion withSources() withJavadoc(),\n  libraryDependencies += \"org.sireum\" % \"inspector-services-jvm\" % inspectorVersion withSources() withJavadoc()\n)\n\ndef standardProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).settings(commonSettings)\n\ndef slangEmbeddedProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings)\n\ndef slangEmbeddedTestProject(projId: String, projectDirectory: String) =\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedTestSettings)\n\ndef slangEmbeddedInspectorProject(projId: String, projectDirectory: String) = {\n  Project(id = projId, base = file(projectDirectory)).\n    settings(commonSettings ++ slangEmbeddedSettings ++ slangEmbeddedTestSettings ++ slangEmbeddedInspectorSettings)\n}\n",
          "overwrite" : true,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/project\/build.properties",
        {
          "type" : "TestResource",
          "content" : "sbt.version=1.3.3\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ],
      [
        "isolette--JVM\/project\/plugins.sbt",
        {
          "type" : "TestResource",
          "content" : "addSbtPlugin(\"com.eed3si9n\" % \"sbt-assembly\" % \"0.15.0\")\n",
          "overwrite" : false,
          "makeExecutable" : false
        }
      ]
    ]
  }
}